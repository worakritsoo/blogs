var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* read(parts) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else {
      yield part;
    }
  }
}
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    if (error2 instanceof FetchBaseError) {
      throw error2;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = dataUriToBuffer$1(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error2) {
                reject(error2);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error2) => {
        reject(error2);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), (error2) => {
          reject(error2);
        });
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error2) => {
          reject(error2);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), (error2) => {
              reject(error2);
            });
          } else {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), (error2) => {
              reject(error2);
            });
          }
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), (error2) => {
          reject(error2);
        });
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
var import_http, import_https, import_zlib, import_stream, import_util, import_crypto, import_url, src, dataUriToBuffer$1, Readable, wm, Blob, fetchBlob, Blob$1, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_http = __toModule(require("http"));
    import_https = __toModule(require("https"));
    import_zlib = __toModule(require("zlib"));
    import_stream = __toModule(require("stream"));
    import_util = __toModule(require("util"));
    import_crypto = __toModule(require("crypto"));
    import_url = __toModule(require("url"));
    src = dataUriToBuffer;
    dataUriToBuffer$1 = src;
    ({ Readable } = import_stream.default);
    wm = new WeakMap();
    Blob = class {
      constructor(blobParts = [], options2 = {}) {
        let size = 0;
        const parts = blobParts.map((element) => {
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element;
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length || buffer.size || 0;
          return buffer;
        });
        const type = options2.type === void 0 ? "" : String(options2.type).toLowerCase();
        wm.set(this, {
          type: /[^\u0020-\u007E]/.test(type) ? "" : type,
          size,
          parts
        });
      }
      get size() {
        return wm.get(this).size;
      }
      get type() {
        return wm.get(this).type;
      }
      async text() {
        return Buffer.from(await this.arrayBuffer()).toString();
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of this.stream()) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        return Readable.from(read(wm.get(this).parts));
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = wm.get(this).parts.values();
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
            blobParts.push(chunk);
            added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
            relativeStart = 0;
            if (added >= span) {
              break;
            }
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        Object.assign(wm.get(blob), { size: span, parts: blobParts });
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    fetchBlob = Blob;
    Blob$1 = fetchBlob;
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && object[NAME] === "AbortSignal";
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_stream.default)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = import_stream.default.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_stream.default) {
          body.on("error", (err) => {
            const error2 = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_stream.PassThrough({ highWaterMark });
        p2 = new import_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof import_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw err;
      }
    };
    validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const err = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" });
        throw err;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback) {
        for (const name of this.keys()) {
          callback(this.get(name), name);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status || 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal !== null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-vercel/files/shims.js
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-vercel/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/mongoose/lib/driver.js
var require_driver = __commonJS({
  "node_modules/mongoose/lib/driver.js"(exports2, module2) {
    init_shims();
    "use strict";
    var driver = null;
    module2.exports.get = function() {
      return driver;
    };
    module2.exports.set = function(v) {
      driver = v;
    };
  }
});

// node_modules/bson/lib/bson/map.js
var require_map = __commonJS({
  "node_modules/bson/lib/bson/map.js"(exports2, module2) {
    init_shims();
    "use strict";
    if (typeof global.Map !== "undefined") {
      module2.exports = global.Map;
      module2.exports.Map = global.Map;
    } else {
      Map2 = function(array) {
        this._keys = [];
        this._values = {};
        for (var i = 0; i < array.length; i++) {
          if (array[i] == null)
            continue;
          var entry = array[i];
          var key = entry[0];
          var value = entry[1];
          this._keys.push(key);
          this._values[key] = { v: value, i: this._keys.length - 1 };
        }
      };
      Map2.prototype.clear = function() {
        this._keys = [];
        this._values = {};
      };
      Map2.prototype.delete = function(key) {
        var value = this._values[key];
        if (value == null)
          return false;
        delete this._values[key];
        this._keys.splice(value.i, 1);
        return true;
      };
      Map2.prototype.entries = function() {
        var self2 = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self2._keys[index2++];
            return {
              value: key !== void 0 ? [key, self2._values[key].v] : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.forEach = function(callback, self2) {
        self2 = self2 || this;
        for (var i = 0; i < this._keys.length; i++) {
          var key = this._keys[i];
          callback.call(self2, this._values[key].v, key, self2);
        }
      };
      Map2.prototype.get = function(key) {
        return this._values[key] ? this._values[key].v : void 0;
      };
      Map2.prototype.has = function(key) {
        return this._values[key] != null;
      };
      Map2.prototype.keys = function() {
        var self2 = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self2._keys[index2++];
            return {
              value: key !== void 0 ? key : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.set = function(key, value) {
        if (this._values[key]) {
          this._values[key].v = value;
          return this;
        }
        this._keys.push(key);
        this._values[key] = { v: value, i: this._keys.length - 1 };
        return this;
      };
      Map2.prototype.values = function() {
        var self2 = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self2._keys[index2++];
            return {
              value: key !== void 0 ? self2._values[key].v : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Object.defineProperty(Map2.prototype, "size", {
        enumerable: true,
        get: function() {
          return this._keys.length;
        }
      });
      module2.exports = Map2;
      module2.exports.Map = Map2;
    }
    var Map2;
  }
});

// node_modules/bson/lib/bson/long.js
var require_long = __commonJS({
  "node_modules/bson/lib/bson/long.js"(exports2, module2) {
    init_shims();
    function Long2(low, high) {
      if (!(this instanceof Long2))
        return new Long2(low, high);
      this._bsontype = "Long";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Long2.prototype.toInt = function() {
      return this.low_;
    };
    Long2.prototype.toNumber = function() {
      return this.high_ * Long2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Long2.prototype.toBigInt = function() {
      return BigInt(this.toString());
    };
    Long2.prototype.toJSON = function() {
      return this.toString();
    };
    Long2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          var radixLong = Long2.fromNumber(radix);
          var div = this.div(radixLong);
          var rem = div.multiply(radixLong).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Long2.prototype.getHighBits = function() {
      return this.high_;
    };
    Long2.prototype.getLowBits = function() {
      return this.low_;
    };
    Long2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Long2.TWO_PWR_32_DBL_ + this.low_;
    };
    Long2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Long2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Long2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Long2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Long2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Long2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Long2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Long2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Long2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Long2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Long2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Long2.prototype.negate = function() {
      if (this.equals(Long2.MIN_VALUE)) {
        return Long2.MIN_VALUE;
      } else {
        return this.not().add(Long2.ONE);
      }
    };
    Long2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Long2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Long2.ZERO;
      } else if (other.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        return other.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      } else if (other.equals(Long2.MIN_VALUE)) {
        return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Long2.TWO_PWR_24_) && other.lessThan(Long2.TWO_PWR_24_)) {
        return Long2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        if (other.equals(Long2.ONE) || other.equals(Long2.NEG_ONE)) {
          return Long2.MIN_VALUE;
        } else if (other.equals(Long2.MIN_VALUE)) {
          return Long2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Long2.ZERO)) {
            return other.isNegative() ? Long2.ONE : Long2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Long2.MIN_VALUE)) {
        return Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Long2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Long2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Long2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Long2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Long2.prototype.not = function() {
      return Long2.fromBits(~this.low_, ~this.high_);
    };
    Long2.prototype.and = function(other) {
      return Long2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Long2.prototype.or = function(other) {
      return Long2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Long2.prototype.xor = function(other) {
      return Long2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Long2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Long2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Long2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Long2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Long2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Long2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Long2.fromBits(high, 0);
        } else {
          return Long2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Long2.fromInt = function(value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Long2.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Long2(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Long2.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Long2.fromNumber = function(value) {
      if (isNaN(value) || !isFinite(value)) {
        return Long2.ZERO;
      } else if (value <= -Long2.TWO_PWR_63_DBL_) {
        return Long2.MIN_VALUE;
      } else if (value + 1 >= Long2.TWO_PWR_63_DBL_) {
        return Long2.MAX_VALUE;
      } else if (value < 0) {
        return Long2.fromNumber(-value).negate();
      } else {
        return new Long2(value % Long2.TWO_PWR_32_DBL_ | 0, value / Long2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Long2.fromBigInt = function(value) {
      return Long2.fromString(value.toString(10), 10);
    };
    Long2.fromBits = function(lowBits, highBits) {
      return new Long2(lowBits, highBits);
    };
    Long2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Long2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
      var result = Long2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Long2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Long2.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Long2.fromNumber(value));
        }
      }
      return result;
    };
    Long2.INT_CACHE_ = {};
    Long2.TWO_PWR_16_DBL_ = 1 << 16;
    Long2.TWO_PWR_24_DBL_ = 1 << 24;
    Long2.TWO_PWR_32_DBL_ = Long2.TWO_PWR_16_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_31_DBL_ = Long2.TWO_PWR_32_DBL_ / 2;
    Long2.TWO_PWR_48_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_64_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_32_DBL_;
    Long2.TWO_PWR_63_DBL_ = Long2.TWO_PWR_64_DBL_ / 2;
    Long2.ZERO = Long2.fromInt(0);
    Long2.ONE = Long2.fromInt(1);
    Long2.NEG_ONE = Long2.fromInt(-1);
    Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0);
    Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0);
    Long2.TWO_PWR_24_ = Long2.fromInt(1 << 24);
    module2.exports = Long2;
    module2.exports.Long = Long2;
  }
});

// node_modules/bson/lib/bson/double.js
var require_double = __commonJS({
  "node_modules/bson/lib/bson/double.js"(exports2, module2) {
    init_shims();
    function Double2(value) {
      if (!(this instanceof Double2))
        return new Double2(value);
      this._bsontype = "Double";
      this.value = value;
    }
    Double2.prototype.valueOf = function() {
      return this.value;
    };
    Double2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Double2;
    module2.exports.Double = Double2;
  }
});

// node_modules/bson/lib/bson/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/bson/lib/bson/timestamp.js"(exports2, module2) {
    init_shims();
    function Timestamp2(low, high) {
      if (!(this instanceof Timestamp2))
        return new Timestamp2(low, high);
      this._bsontype = "Timestamp";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Timestamp2.prototype.toInt = function() {
      return this.low_;
    };
    Timestamp2.prototype.toNumber = function() {
      return this.high_ * Timestamp2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Timestamp2.prototype.toJSON = function() {
      return this.toString();
    };
    Timestamp2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          var radixTimestamp = Timestamp2.fromNumber(radix);
          var div = this.div(radixTimestamp);
          var rem = div.multiply(radixTimestamp).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Timestamp2.prototype.getHighBits = function() {
      return this.high_;
    };
    Timestamp2.prototype.getLowBits = function() {
      return this.low_;
    };
    Timestamp2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Timestamp2.TWO_PWR_32_DBL_ + this.low_;
    };
    Timestamp2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Timestamp2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Timestamp2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Timestamp2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Timestamp2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Timestamp2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Timestamp2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Timestamp2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Timestamp2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Timestamp2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Timestamp2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Timestamp2.prototype.negate = function() {
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.MIN_VALUE;
      } else {
        return this.not().add(Timestamp2.ONE);
      }
    };
    Timestamp2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Timestamp2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Timestamp2.ZERO;
      } else if (other.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return other.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return this.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Timestamp2.TWO_PWR_24_) && other.lessThan(Timestamp2.TWO_PWR_24_)) {
        return Timestamp2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        if (other.equals(Timestamp2.ONE) || other.equals(Timestamp2.NEG_ONE)) {
          return Timestamp2.MIN_VALUE;
        } else if (other.equals(Timestamp2.MIN_VALUE)) {
          return Timestamp2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Timestamp2.ZERO)) {
            return other.isNegative() ? Timestamp2.ONE : Timestamp2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Timestamp2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Timestamp2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Timestamp2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Timestamp2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Timestamp2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Timestamp2.prototype.not = function() {
      return Timestamp2.fromBits(~this.low_, ~this.high_);
    };
    Timestamp2.prototype.and = function(other) {
      return Timestamp2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Timestamp2.prototype.or = function(other) {
      return Timestamp2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Timestamp2.prototype.xor = function(other) {
      return Timestamp2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Timestamp2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Timestamp2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Timestamp2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Timestamp2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Timestamp2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Timestamp2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Timestamp2.fromBits(high, 0);
        } else {
          return Timestamp2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Timestamp2.fromInt = function(value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Timestamp2.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Timestamp2(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Timestamp2.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Timestamp2.fromNumber = function(value) {
      if (isNaN(value) || !isFinite(value)) {
        return Timestamp2.ZERO;
      } else if (value <= -Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MIN_VALUE;
      } else if (value + 1 >= Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MAX_VALUE;
      } else if (value < 0) {
        return Timestamp2.fromNumber(-value).negate();
      } else {
        return new Timestamp2(value % Timestamp2.TWO_PWR_32_DBL_ | 0, value / Timestamp2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Timestamp2.fromBits = function(lowBits, highBits) {
      return new Timestamp2(lowBits, highBits);
    };
    Timestamp2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Timestamp2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 8));
      var result = Timestamp2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Timestamp2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Timestamp2.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Timestamp2.fromNumber(value));
        }
      }
      return result;
    };
    Timestamp2.INT_CACHE_ = {};
    Timestamp2.TWO_PWR_16_DBL_ = 1 << 16;
    Timestamp2.TWO_PWR_24_DBL_ = 1 << 24;
    Timestamp2.TWO_PWR_32_DBL_ = Timestamp2.TWO_PWR_16_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_31_DBL_ = Timestamp2.TWO_PWR_32_DBL_ / 2;
    Timestamp2.TWO_PWR_48_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_64_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_32_DBL_;
    Timestamp2.TWO_PWR_63_DBL_ = Timestamp2.TWO_PWR_64_DBL_ / 2;
    Timestamp2.ZERO = Timestamp2.fromInt(0);
    Timestamp2.ONE = Timestamp2.fromInt(1);
    Timestamp2.NEG_ONE = Timestamp2.fromInt(-1);
    Timestamp2.MAX_VALUE = Timestamp2.fromBits(4294967295 | 0, 2147483647 | 0);
    Timestamp2.MIN_VALUE = Timestamp2.fromBits(0, 2147483648 | 0);
    Timestamp2.TWO_PWR_24_ = Timestamp2.fromInt(1 << 24);
    module2.exports = Timestamp2;
    module2.exports.Timestamp = Timestamp2;
  }
});

// node_modules/bson/lib/bson/parser/utils.js
var require_utils = __commonJS({
  "node_modules/bson/lib/bson/parser/utils.js"(exports2, module2) {
    init_shims();
    "use strict";
    function normalizedFunctionString(fn) {
      return fn.toString().replace(/function *\(/, "function (");
    }
    function newBuffer(item, encoding) {
      return new Buffer(item, encoding);
    }
    function allocBuffer() {
      return Buffer.alloc.apply(Buffer, arguments);
    }
    function toBuffer() {
      return Buffer.from.apply(Buffer, arguments);
    }
    module2.exports = {
      normalizedFunctionString,
      allocBuffer: typeof Buffer.alloc === "function" ? allocBuffer : newBuffer,
      toBuffer: typeof Buffer.from === "function" ? toBuffer : newBuffer
    };
  }
});

// node_modules/bson/lib/bson/objectid.js
var require_objectid = __commonJS({
  "node_modules/bson/lib/bson/objectid.js"(exports2, module2) {
    init_shims();
    var inspect = "inspect";
    var utils2 = require_utils();
    var MACHINE_ID = parseInt(Math.random() * 16777215, 10);
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    try {
      if (Buffer && Buffer.from) {
        hasBufferType = true;
        inspect = require("util").inspect.custom || "inspect";
      }
    } catch (err) {
      hasBufferType = false;
    }
    var hasBufferType;
    var ObjectID2 = function ObjectID3(id) {
      if (id instanceof ObjectID3)
        return id;
      if (!(this instanceof ObjectID3))
        return new ObjectID3(id);
      this._bsontype = "ObjectID";
      if (id == null || typeof id === "number") {
        this.id = this.generate(id);
        if (ObjectID3.cacheHexString)
          this.__id = this.toString("hex");
        return;
      }
      var valid = ObjectID3.isValid(id);
      if (!valid && id != null) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      } else if (valid && typeof id === "string" && id.length === 24 && hasBufferType) {
        return new ObjectID3(utils2.toBuffer(id, "hex"));
      } else if (valid && typeof id === "string" && id.length === 24) {
        return ObjectID3.createFromHexString(id);
      } else if (id != null && id.length === 12) {
        this.id = id;
      } else if (id != null && typeof id.toHexString === "function") {
        return id;
      } else {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (ObjectID3.cacheHexString)
        this.__id = this.toString("hex");
    };
    var hexTable = [];
    for (i = 0; i < 256; i++) {
      hexTable[i] = (i <= 15 ? "0" : "") + i.toString(16);
    }
    var i;
    ObjectID2.prototype.toHexString = function() {
      if (ObjectID2.cacheHexString && this.__id)
        return this.__id;
      var hexString = "";
      if (!this.id || !this.id.length) {
        throw new Error("invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]");
      }
      if (this.id instanceof _Buffer) {
        hexString = convertToHex(this.id);
        if (ObjectID2.cacheHexString)
          this.__id = hexString;
        return hexString;
      }
      for (var i2 = 0; i2 < this.id.length; i2++) {
        hexString += hexTable[this.id.charCodeAt(i2)];
      }
      if (ObjectID2.cacheHexString)
        this.__id = hexString;
      return hexString;
    };
    ObjectID2.prototype.get_inc = function() {
      return ObjectID2.index = (ObjectID2.index + 1) % 16777215;
    };
    ObjectID2.prototype.getInc = function() {
      return this.get_inc();
    };
    ObjectID2.prototype.generate = function(time) {
      if (typeof time !== "number") {
        time = ~~(Date.now() / 1e3);
      }
      var pid = (typeof process === "undefined" || process.pid === 1 ? Math.floor(Math.random() * 1e5) : process.pid) % 65535;
      var inc = this.get_inc();
      var buffer = utils2.allocBuffer(12);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      buffer[6] = MACHINE_ID & 255;
      buffer[5] = MACHINE_ID >> 8 & 255;
      buffer[4] = MACHINE_ID >> 16 & 255;
      buffer[8] = pid & 255;
      buffer[7] = pid >> 8 & 255;
      buffer[11] = inc & 255;
      buffer[10] = inc >> 8 & 255;
      buffer[9] = inc >> 16 & 255;
      return buffer;
    };
    ObjectID2.prototype.toString = function(format2) {
      if (this.id && this.id.copy) {
        return this.id.toString(typeof format2 === "string" ? format2 : "hex");
      }
      return this.toHexString();
    };
    ObjectID2.prototype[inspect] = ObjectID2.prototype.toString;
    ObjectID2.prototype.toJSON = function() {
      return this.toHexString();
    };
    ObjectID2.prototype.equals = function equals(otherId) {
      if (otherId instanceof ObjectID2) {
        return this.toString() === otherId.toString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {
        return otherId === this.id.toString("binary");
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 24) {
        return otherId.toLowerCase() === this.toHexString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12) {
        return otherId === this.id;
      } else if (otherId != null && (otherId instanceof ObjectID2 || otherId.toHexString)) {
        return otherId.toHexString() === this.toHexString();
      } else {
        return false;
      }
    };
    ObjectID2.prototype.getTimestamp = function() {
      var timestamp = new Date();
      var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      timestamp.setTime(Math.floor(time) * 1e3);
      return timestamp;
    };
    ObjectID2.index = ~~(Math.random() * 16777215);
    ObjectID2.createPk = function createPk() {
      return new ObjectID2();
    };
    ObjectID2.createFromTime = function createFromTime(time) {
      var buffer = utils2.toBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      buffer[3] = time & 255;
      buffer[2] = time >> 8 & 255;
      buffer[1] = time >> 16 & 255;
      buffer[0] = time >> 24 & 255;
      return new ObjectID2(buffer);
    };
    var decodeLookup = [];
    i = 0;
    while (i < 10)
      decodeLookup[48 + i] = i++;
    while (i < 16)
      decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
    var _Buffer = Buffer;
    var convertToHex = function(bytes) {
      return bytes.toString("hex");
    };
    ObjectID2.createFromHexString = function createFromHexString(string) {
      if (typeof string === "undefined" || string != null && string.length !== 24) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (hasBufferType)
        return new ObjectID2(utils2.toBuffer(string, "hex"));
      var array = new _Buffer(12);
      var n = 0;
      var i2 = 0;
      while (i2 < 24) {
        array[n++] = decodeLookup[string.charCodeAt(i2++)] << 4 | decodeLookup[string.charCodeAt(i2++)];
      }
      return new ObjectID2(array);
    };
    ObjectID2.isValid = function isValid(id) {
      if (id == null)
        return false;
      if (typeof id === "number") {
        return true;
      }
      if (typeof id === "string") {
        return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
      }
      if (id instanceof ObjectID2) {
        return true;
      }
      if (id instanceof _Buffer) {
        return true;
      }
      if (typeof id.toHexString === "function" && (id.id instanceof _Buffer || typeof id.id === "string")) {
        return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
      }
      return false;
    };
    Object.defineProperty(ObjectID2.prototype, "generationTime", {
      enumerable: true,
      get: function() {
        return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      },
      set: function(value) {
        this.id[3] = value & 255;
        this.id[2] = value >> 8 & 255;
        this.id[1] = value >> 16 & 255;
        this.id[0] = value >> 24 & 255;
      }
    });
    module2.exports = ObjectID2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.ObjectId = ObjectID2;
  }
});

// node_modules/bson/lib/bson/regexp.js
var require_regexp = __commonJS({
  "node_modules/bson/lib/bson/regexp.js"(exports2, module2) {
    init_shims();
    function BSONRegExp2(pattern, options2) {
      if (!(this instanceof BSONRegExp2))
        return new BSONRegExp2();
      this._bsontype = "BSONRegExp";
      this.pattern = pattern || "";
      this.options = options2 || "";
      for (var i = 0; i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new Error("the regular expression options [" + this.options[i] + "] is not supported");
        }
      }
    }
    module2.exports = BSONRegExp2;
    module2.exports.BSONRegExp = BSONRegExp2;
  }
});

// node_modules/bson/lib/bson/symbol.js
var require_symbol = __commonJS({
  "node_modules/bson/lib/bson/symbol.js"(exports2, module2) {
    init_shims();
    var inspect = Buffer ? require("util").inspect.custom || "inspect" : "inspect";
    function Symbol2(value) {
      if (!(this instanceof Symbol2))
        return new Symbol2(value);
      this._bsontype = "Symbol";
      this.value = value;
    }
    Symbol2.prototype.valueOf = function() {
      return this.value;
    };
    Symbol2.prototype.toString = function() {
      return this.value;
    };
    Symbol2.prototype[inspect] = function() {
      return this.value;
    };
    Symbol2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Symbol2;
    module2.exports.Symbol = Symbol2;
  }
});

// node_modules/bson/lib/bson/int_32.js
var require_int_32 = __commonJS({
  "node_modules/bson/lib/bson/int_32.js"(exports2, module2) {
    init_shims();
    var Int322 = function(value) {
      if (!(this instanceof Int322))
        return new Int322(value);
      this._bsontype = "Int32";
      this.value = value;
    };
    Int322.prototype.valueOf = function() {
      return this.value;
    };
    Int322.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Int322;
    module2.exports.Int32 = Int322;
  }
});

// node_modules/bson/lib/bson/code.js
var require_code = __commonJS({
  "node_modules/bson/lib/bson/code.js"(exports2, module2) {
    init_shims();
    var Code2 = function Code3(code, scope) {
      if (!(this instanceof Code3))
        return new Code3(code, scope);
      this._bsontype = "Code";
      this.code = code;
      this.scope = scope;
    };
    Code2.prototype.toJSON = function() {
      return { scope: this.scope, code: this.code };
    };
    module2.exports = Code2;
    module2.exports.Code = Code2;
  }
});

// node_modules/bson/lib/bson/decimal128.js
var require_decimal128 = __commonJS({
  "node_modules/bson/lib/bson/decimal128.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Long2 = require_long();
    var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = [
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_NEGATIVE_BUFFER = [
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_POSITIVE_BUFFER = [
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    var utils2 = require_utils();
    var isDigit = function(value) {
      return !isNaN(parseInt(value, 10));
    };
    var divideu128 = function(value) {
      var DIVISOR = Long2.fromNumber(1e3 * 1e3 * 1e3);
      var _rem = Long2.fromNumber(0);
      var i = 0;
      if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
        return { quotient: value, rem: _rem };
      }
      for (i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new Long2(value.parts[i], 0));
        value.parts[i] = _rem.div(DIVISOR).low_;
        _rem = _rem.modulo(DIVISOR);
      }
      return { quotient: value, rem: _rem };
    };
    var multiply64x2 = function(left, right) {
      if (!left && !right) {
        return { high: Long2.fromNumber(0), low: Long2.fromNumber(0) };
      }
      var leftHigh = left.shiftRightUnsigned(32);
      var leftLow = new Long2(left.getLowBits(), 0);
      var rightHigh = right.shiftRightUnsigned(32);
      var rightLow = new Long2(right.getLowBits(), 0);
      var productHigh = leftHigh.multiply(rightHigh);
      var productMid = leftHigh.multiply(rightLow);
      var productMid2 = leftLow.multiply(rightHigh);
      var productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new Long2(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new Long2(productLow.getLowBits(), 0));
      return { high: productHigh, low: productLow };
    };
    var lessThan = function(left, right) {
      var uhleft = left.high_ >>> 0;
      var uhright = right.high_ >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft === uhright) {
        var ulleft = left.low_ >>> 0;
        var ulright = right.low_ >>> 0;
        if (ulleft < ulright)
          return true;
      }
      return false;
    };
    var Decimal1282 = function(bytes) {
      this._bsontype = "Decimal128";
      this.bytes = bytes;
    };
    Decimal1282.fromString = function(string) {
      var isNegative = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var firstDigit = 0;
      var lastDigit = 0;
      var exponent = 0;
      var i = 0;
      var significandHigh = [0, 0];
      var significandLow = [0, 0];
      var biasedExponent = 0;
      var index2 = 0;
      string = string.trim();
      if (string.length >= 7e3) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      var stringMatch = string.match(PARSE_STRING_REGEXP);
      var infMatch = string.match(PARSE_INF_REGEXP);
      var nanMatch = string.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || string.length === 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (stringMatch && stringMatch[4] && stringMatch[2] === void 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index2] === "+" || string[index2] === "-") {
        isNegative = string[index2++] === "-";
      }
      if (!isDigit(string[index2]) && string[index2] !== ".") {
        if (string[index2] === "i" || string[index2] === "I") {
          return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        } else if (string[index2] === "N") {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
      }
      while (isDigit(string[index2]) || string[index2] === ".") {
        if (string[index2] === ".") {
          if (sawRadix) {
            return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
          }
          sawRadix = true;
          index2 = index2 + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (string[index2] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(string[index2], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero) {
          nDigits = nDigits + 1;
        }
        if (sawRadix) {
          radixPosition = radixPosition + 1;
        }
        nDigitsRead = nDigitsRead + 1;
        index2 = index2 + 1;
      }
      if (sawRadix && !nDigitsRead) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index2] === "e" || string[index2] === "E") {
        var match = string.substr(++index2).match(EXPONENT_REGEX);
        if (!match || !match[2]) {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
        exponent = parseInt(match[0], 10);
        index2 = index2 + match[0].length;
      }
      if (string[index2]) {
        return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
      }
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (exponent !== 0 && significantDigits !== 1) {
          while (string[firstNonZero + significantDigits - 1] === "0") {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          var digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits && string[significantDigits] !== "0") {
        var endOfString = nDigitsRead;
        if (sawRadix && exponent === EXPONENT_MIN) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        var roundDigit = parseInt(string[firstNonZero + lastDigit + 1], 10);
        var roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1;
            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
              if (parseInt(string[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          var dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
                }
              }
            } else {
              break;
            }
          }
        }
      }
      significandHigh = Long2.fromNumber(0);
      significandLow = Long2.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long2.fromNumber(0);
        significandLow = Long2.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        dIdx = firstDigit;
        significandLow = Long2.fromNumber(digits[dIdx++]);
        significandHigh = new Long2(0, 0);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      } else {
        dIdx = firstDigit;
        significandHigh = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long2.fromNumber(10));
          significandHigh = significandHigh.add(Long2.fromNumber(digits[dIdx]));
        }
        significandLow = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      }
      var significand = multiply64x2(significandHigh, Long2.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long2.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      var dec = { low: Long2.fromNumber(0), high: Long2.fromNumber(0) };
      if (significand.high.shiftRightUnsigned(49).and(Long2.fromNumber(1)).equals(Long2.fromNumber)) {
        dec.high = dec.high.or(Long2.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(Long2.fromNumber(biasedExponent).and(Long2.fromNumber(16383).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long2.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long2.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long2.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long2.fromString("9223372036854775808"));
      }
      var buffer = utils2.allocBuffer(16);
      index2 = 0;
      buffer[index2++] = dec.low.low_ & 255;
      buffer[index2++] = dec.low.low_ >> 8 & 255;
      buffer[index2++] = dec.low.low_ >> 16 & 255;
      buffer[index2++] = dec.low.low_ >> 24 & 255;
      buffer[index2++] = dec.low.high_ & 255;
      buffer[index2++] = dec.low.high_ >> 8 & 255;
      buffer[index2++] = dec.low.high_ >> 16 & 255;
      buffer[index2++] = dec.low.high_ >> 24 & 255;
      buffer[index2++] = dec.high.low_ & 255;
      buffer[index2++] = dec.high.low_ >> 8 & 255;
      buffer[index2++] = dec.high.low_ >> 16 & 255;
      buffer[index2++] = dec.high.low_ >> 24 & 255;
      buffer[index2++] = dec.high.high_ & 255;
      buffer[index2++] = dec.high.high_ >> 8 & 255;
      buffer[index2++] = dec.high.high_ >> 16 & 255;
      buffer[index2++] = dec.high.high_ >> 24 & 255;
      return new Decimal1282(buffer);
    };
    var COMBINATION_MASK = 31;
    var EXPONENT_MASK = 16383;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    EXPONENT_BIAS = 6176;
    Decimal1282.prototype.toString = function() {
      var high;
      var midh;
      var midl;
      var low;
      var combination;
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++)
        significand[i] = 0;
      var index2 = 0;
      var exponent;
      var scientific_exponent;
      var is_zero = false;
      var significand_msb;
      var significand128 = { parts: new Array(4) };
      i;
      var j, k;
      var string = [];
      index2 = 0;
      var buffer = this.bytes;
      low = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      midl = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      midh = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      high = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      index2 = 0;
      var dec = {
        low: new Long2(low, midl),
        high: new Long2(midh, high)
      };
      if (dec.high.lessThan(Long2.ZERO)) {
        string.push("-");
      }
      combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3; k >= 0; k--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low_;
          if (!least_digits)
            continue;
          for (j = 8; j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index2] = 0;
      } else {
        significand_digits = 36;
        i = 0;
        while (!significand[index2]) {
          i++;
          significand_digits = significand_digits - 1;
          index2 = index2 + 1;
        }
      }
      scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        string.push(significand[index2++]);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push(".");
        }
        for (i = 0; i < significand_digits; i++) {
          string.push(significand[index2++]);
        }
        string.push("E");
        if (scientific_exponent > 0) {
          string.push("+" + scientific_exponent);
        } else {
          string.push(scientific_exponent);
        }
      } else {
        if (exponent >= 0) {
          for (i = 0; i < significand_digits; i++) {
            string.push(significand[index2++]);
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (i = 0; i < radix_position; i++) {
              string.push(significand[index2++]);
            }
          } else {
            string.push("0");
          }
          string.push(".");
          while (radix_position++ < 0) {
            string.push("0");
          }
          for (i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push(significand[index2++]);
          }
        }
      }
      return string.join("");
    };
    Decimal1282.prototype.toJSON = function() {
      return { $numberDecimal: this.toString() };
    };
    module2.exports = Decimal1282;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/lib/bson/min_key.js
var require_min_key = __commonJS({
  "node_modules/bson/lib/bson/min_key.js"(exports2, module2) {
    init_shims();
    function MinKey2() {
      if (!(this instanceof MinKey2))
        return new MinKey2();
      this._bsontype = "MinKey";
    }
    module2.exports = MinKey2;
    module2.exports.MinKey = MinKey2;
  }
});

// node_modules/bson/lib/bson/max_key.js
var require_max_key = __commonJS({
  "node_modules/bson/lib/bson/max_key.js"(exports2, module2) {
    init_shims();
    function MaxKey2() {
      if (!(this instanceof MaxKey2))
        return new MaxKey2();
      this._bsontype = "MaxKey";
    }
    module2.exports = MaxKey2;
    module2.exports.MaxKey = MaxKey2;
  }
});

// node_modules/bson/lib/bson/db_ref.js
var require_db_ref = __commonJS({
  "node_modules/bson/lib/bson/db_ref.js"(exports2, module2) {
    init_shims();
    function DBRef2(namespace, oid, db) {
      if (!(this instanceof DBRef2))
        return new DBRef2(namespace, oid, db);
      this._bsontype = "DBRef";
      this.namespace = namespace;
      this.oid = oid;
      this.db = db;
    }
    DBRef2.prototype.toJSON = function() {
      return {
        $ref: this.namespace,
        $id: this.oid,
        $db: this.db == null ? "" : this.db
      };
    };
    module2.exports = DBRef2;
    module2.exports.DBRef = DBRef2;
  }
});

// node_modules/bson/lib/bson/binary.js
var require_binary = __commonJS({
  "node_modules/bson/lib/bson/binary.js"(exports2, module2) {
    init_shims();
    if (typeof global !== "undefined") {
      Buffer2 = require("buffer").Buffer;
    }
    var Buffer2;
    var utils2 = require_utils();
    function Binary2(buffer, subType) {
      if (!(this instanceof Binary2))
        return new Binary2(buffer, subType);
      if (buffer != null && !(typeof buffer === "string") && !Buffer2.isBuffer(buffer) && !(buffer instanceof Uint8Array) && !Array.isArray(buffer)) {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
      this._bsontype = "Binary";
      if (buffer instanceof Number) {
        this.sub_type = buffer;
        this.position = 0;
      } else {
        this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
        this.position = 0;
      }
      if (buffer != null && !(buffer instanceof Number)) {
        if (typeof buffer === "string") {
          if (typeof Buffer2 !== "undefined") {
            this.buffer = utils2.toBuffer(buffer);
          } else if (typeof Uint8Array !== "undefined" || Object.prototype.toString.call(buffer) === "[object Array]") {
            this.buffer = writeStringToArray(buffer);
          } else {
            throw new Error("only String, Buffer, Uint8Array or Array accepted");
          }
        } else {
          this.buffer = buffer;
        }
        this.position = buffer.length;
      } else {
        if (typeof Buffer2 !== "undefined") {
          this.buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE);
        } else if (typeof Uint8Array !== "undefined") {
          this.buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE));
        } else {
          this.buffer = new Array(Binary2.BUFFER_SIZE);
        }
        this.position = 0;
      }
    }
    Binary2.prototype.put = function put(byte_value) {
      if (byte_value["length"] != null && typeof byte_value !== "number" && byte_value.length !== 1)
        throw new Error("only accepts single character String, Uint8Array or Array");
      if (typeof byte_value !== "number" && byte_value < 0 || byte_value > 255)
        throw new Error("only accepts number in a valid unsigned byte range 0-255");
      var decoded_byte = null;
      if (typeof byte_value === "string") {
        decoded_byte = byte_value.charCodeAt(0);
      } else if (byte_value["length"] != null) {
        decoded_byte = byte_value[0];
      } else {
        decoded_byte = byte_value;
      }
      if (this.buffer.length > this.position) {
        this.buffer[this.position++] = decoded_byte;
      } else {
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          var buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE + this.buffer.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        } else {
          buffer = null;
          if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
            buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE + this.buffer.length));
          } else {
            buffer = new Array(Binary2.BUFFER_SIZE + this.buffer.length);
          }
          for (var i = 0; i < this.buffer.length; i++) {
            buffer[i] = this.buffer[i];
          }
          this.buffer = buffer;
          this.buffer[this.position++] = decoded_byte;
        }
      }
    };
    Binary2.prototype.write = function write(string, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.length < offset + string.length) {
        var buffer = null;
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          buffer = utils2.allocBuffer(this.buffer.length + string.length);
          this.buffer.copy(buffer, 0, 0, this.buffer.length);
        } else if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
          buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));
          for (var i = 0; i < this.position; i++) {
            buffer[i] = this.buffer[i];
          }
        }
        this.buffer = buffer;
      }
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(string) && Buffer2.isBuffer(this.buffer)) {
        string.copy(this.buffer, offset, 0, string.length);
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (typeof Buffer2 !== "undefined" && typeof string === "string" && Buffer2.isBuffer(this.buffer)) {
        this.buffer.write(string, offset, "binary");
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (Object.prototype.toString.call(string) === "[object Uint8Array]" || Object.prototype.toString.call(string) === "[object Array]" && typeof string !== "string") {
        for (i = 0; i < string.length; i++) {
          this.buffer[offset++] = string[i];
        }
        this.position = offset > this.position ? offset : this.position;
      } else if (typeof string === "string") {
        for (i = 0; i < string.length; i++) {
          this.buffer[offset++] = string.charCodeAt(i);
        }
        this.position = offset > this.position ? offset : this.position;
      }
    };
    Binary2.prototype.read = function read2(position, length) {
      length = length && length > 0 ? length : this.position;
      if (this.buffer["slice"]) {
        return this.buffer.slice(position, position + length);
      } else {
        var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
        for (var i = 0; i < length; i++) {
          buffer[i] = this.buffer[position++];
        }
      }
      return buffer;
    };
    Binary2.prototype.value = function value(asRaw) {
      asRaw = asRaw == null ? false : asRaw;
      if (asRaw && typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer) && this.buffer.length === this.position)
        return this.buffer;
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
        return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString("binary", 0, this.position);
      } else {
        if (asRaw) {
          if (this.buffer["slice"] != null) {
            return this.buffer.slice(0, this.position);
          } else {
            var newBuffer = Object.prototype.toString.call(this.buffer) === "[object Uint8Array]" ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
            for (var i = 0; i < this.position; i++) {
              newBuffer[i] = this.buffer[i];
            }
            return newBuffer;
          }
        } else {
          return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
        }
      }
    };
    Binary2.prototype.length = function length() {
      return this.position;
    };
    Binary2.prototype.toJSON = function() {
      return this.buffer != null ? this.buffer.toString("base64") : "";
    };
    Binary2.prototype.toString = function(format2) {
      return this.buffer != null ? this.buffer.slice(0, this.position).toString(format2) : "";
    };
    var BSON_BINARY_SUBTYPE_DEFAULT = 0;
    var writeStringToArray = function(data) {
      var buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        buffer[i] = data.charCodeAt(i);
      }
      return buffer;
    };
    var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
      var result = "";
      for (var i = startIndex; i < endIndex; i++) {
        result = result + String.fromCharCode(byteArray[i]);
      }
      return result;
    };
    Binary2.BUFFER_SIZE = 256;
    Binary2.SUBTYPE_DEFAULT = 0;
    Binary2.SUBTYPE_FUNCTION = 1;
    Binary2.SUBTYPE_BYTE_ARRAY = 2;
    Binary2.SUBTYPE_UUID_OLD = 3;
    Binary2.SUBTYPE_UUID = 4;
    Binary2.SUBTYPE_MD5 = 5;
    Binary2.SUBTYPE_USER_DEFINED = 128;
    module2.exports = Binary2;
    module2.exports.Binary = Binary2;
  }
});

// node_modules/bson/lib/bson/parser/deserializer.js
var require_deserializer = __commonJS({
  "node_modules/bson/lib/bson/parser/deserializer.js"(exports, module) {
    init_shims();
    "use strict";
    var Long = require_long().Long;
    var Double = require_double().Double;
    var Timestamp = require_timestamp().Timestamp;
    var ObjectID = require_objectid().ObjectID;
    var Symbol = require_symbol().Symbol;
    var Code = require_code().Code;
    var MinKey = require_min_key().MinKey;
    var MaxKey = require_max_key().MaxKey;
    var Decimal128 = require_decimal128();
    var Int32 = require_int_32();
    var DBRef = require_db_ref().DBRef;
    var BSONRegExp = require_regexp().BSONRegExp;
    var Binary = require_binary().Binary;
    var utils = require_utils();
    var deserialize = function(buffer, options2, isArray) {
      options2 = options2 == null ? {} : options2;
      var index2 = options2 && options2.index ? options2.index : 0;
      var size = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
      if (size < 5 || buffer.length < size || size + index2 > buffer.length) {
        throw new Error("corrupt bson message");
      }
      if (buffer[index2 + size - 1] !== 0) {
        throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer, index2, options2, isArray);
    };
    var deserializeObject = function(buffer, index2, options2, isArray) {
      var evalFunctions = options2["evalFunctions"] == null ? false : options2["evalFunctions"];
      var cacheFunctions = options2["cacheFunctions"] == null ? false : options2["cacheFunctions"];
      var cacheFunctionsCrc32 = options2["cacheFunctionsCrc32"] == null ? false : options2["cacheFunctionsCrc32"];
      if (!cacheFunctionsCrc32)
        var crc32 = null;
      var fieldsAsRaw = options2["fieldsAsRaw"] == null ? null : options2["fieldsAsRaw"];
      var raw = options2["raw"] == null ? false : options2["raw"];
      var bsonRegExp = typeof options2["bsonRegExp"] === "boolean" ? options2["bsonRegExp"] : false;
      var promoteBuffers = options2["promoteBuffers"] == null ? false : options2["promoteBuffers"];
      var promoteLongs = options2["promoteLongs"] == null ? true : options2["promoteLongs"];
      var promoteValues = options2["promoteValues"] == null ? true : options2["promoteValues"];
      var startIndex = index2;
      if (buffer.length < 5)
        throw new Error("corrupt bson message < 5 bytes long");
      var size = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
      if (size < 5 || size > buffer.length)
        throw new Error("corrupt bson message");
      var object = isArray ? [] : {};
      var arrayIndex = 0;
      var done = false;
      while (!done) {
        var elementType = buffer[index2++];
        if (elementType === 0)
          break;
        var i = index2;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error("Bad BSON Document: illegal CString");
        var name = isArray ? arrayIndex++ : buffer.toString("utf8", index2, i);
        index2 = i + 1;
        if (elementType === BSON.BSON_DATA_STRING) {
          var stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object[name] = buffer.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_OID) {
          var oid = utils.allocBuffer(12);
          buffer.copy(oid, 0, index2, index2 + 12);
          object[name] = new ObjectID(oid);
          index2 = index2 + 12;
        } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {
          object[name] = new Int32(buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24);
        } else if (elementType === BSON.BSON_DATA_INT) {
          object[name] = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
        } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {
          object[name] = new Double(buffer.readDoubleLE(index2));
          index2 = index2 + 8;
        } else if (elementType === BSON.BSON_DATA_NUMBER) {
          object[name] = buffer.readDoubleLE(index2);
          index2 = index2 + 8;
        } else if (elementType === BSON.BSON_DATA_DATE) {
          var lowBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          var highBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          object[name] = new Date(new Long(lowBits, highBits).toNumber());
        } else if (elementType === BSON.BSON_DATA_BOOLEAN) {
          if (buffer[index2] !== 0 && buffer[index2] !== 1)
            throw new Error("illegal boolean type value");
          object[name] = buffer[index2++] === 1;
        } else if (elementType === BSON.BSON_DATA_OBJECT) {
          var _index = index2;
          var objectSize = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
          if (objectSize <= 0 || objectSize > buffer.length - index2)
            throw new Error("bad embedded document length in bson");
          if (raw) {
            object[name] = buffer.slice(index2, index2 + objectSize);
          } else {
            object[name] = deserializeObject(buffer, _index, options2, false);
          }
          index2 = index2 + objectSize;
        } else if (elementType === BSON.BSON_DATA_ARRAY) {
          _index = index2;
          objectSize = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
          var arrayOptions = options2;
          var stopIndex = index2 + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name]) {
            arrayOptions = {};
            for (var n in options2)
              arrayOptions[n] = options2[n];
            arrayOptions["raw"] = true;
          }
          object[name] = deserializeObject(buffer, _index, arrayOptions, true);
          index2 = index2 + objectSize;
          if (buffer[index2 - 1] !== 0)
            throw new Error("invalid array terminator byte");
          if (index2 !== stopIndex)
            throw new Error("corrupted array bson");
        } else if (elementType === BSON.BSON_DATA_UNDEFINED) {
          object[name] = void 0;
        } else if (elementType === BSON.BSON_DATA_NULL) {
          object[name] = null;
        } else if (elementType === BSON.BSON_DATA_LONG) {
          lowBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          highBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          var long = new Long(lowBits, highBits);
          if (promoteLongs && promoteValues === true) {
            object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            object[name] = long;
          }
        } else if (elementType === BSON.BSON_DATA_DECIMAL128) {
          var bytes = utils.allocBuffer(16);
          buffer.copy(bytes, 0, index2, index2 + 16);
          index2 = index2 + 16;
          var decimal128 = new Decimal128(bytes);
          object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;
        } else if (elementType === BSON.BSON_DATA_BINARY) {
          var binarySize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          var totalBinarySize = binarySize;
          var subType = buffer[index2++];
          if (binarySize < 0)
            throw new Error("Negative binary type element size found");
          if (binarySize > buffer.length)
            throw new Error("Binary type size larger than document size");
          if (buffer["slice"] != null) {
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            if (promoteBuffers && promoteValues) {
              object[name] = buffer.slice(index2, index2 + binarySize);
            } else {
              object[name] = new Binary(buffer.slice(index2, index2 + binarySize), subType);
            }
          } else {
            var _buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            for (i = 0; i < binarySize; i++) {
              _buffer[i] = buffer[index2 + i];
            }
            if (promoteBuffers && promoteValues) {
              object[name] = _buffer;
            } else {
              object[name] = new Binary(_buffer, subType);
            }
          }
          index2 = index2 + binarySize;
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          var source = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          var regExpOptions = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          var optionsArray = new Array(regExpOptions.length);
          for (i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case "m":
                optionsArray[i] = "m";
                break;
              case "s":
                optionsArray[i] = "g";
                break;
              case "i":
                optionsArray[i] = "i";
                break;
            }
          }
          object[name] = new RegExp(source, optionsArray.join(""));
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          source = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          i = index2;
          while (buffer[i] !== 0 && i < buffer.length) {
            i++;
          }
          if (i >= buffer.length)
            throw new Error("Bad BSON Document: illegal CString");
          regExpOptions = buffer.toString("utf8", index2, i);
          index2 = i + 1;
          object[name] = new BSONRegExp(source, regExpOptions);
        } else if (elementType === BSON.BSON_DATA_SYMBOL) {
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object[name] = new Symbol(buffer.toString("utf8", index2, index2 + stringSize - 1));
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {
          lowBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          highBits = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          object[name] = new Timestamp(lowBits, highBits);
        } else if (elementType === BSON.BSON_DATA_MIN_KEY) {
          object[name] = new MinKey();
        } else if (elementType === BSON.BSON_DATA_MAX_KEY) {
          object[name] = new MaxKey();
        } else if (elementType === BSON.BSON_DATA_CODE) {
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var functionString = buffer.toString("utf8", index2, index2 + stringSize - 1);
          if (evalFunctions) {
            if (cacheFunctions) {
              var hash2 = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name] = isolateEvalWithHash(functionCache, hash2, functionString, object);
            } else {
              object[name] = isolateEval(functionString);
            }
          } else {
            object[name] = new Code(functionString);
          }
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {
          var totalSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new Error("code_w_scope total size shorter minimum expected length");
          }
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          functionString = buffer.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
          _index = index2;
          objectSize = buffer[index2] | buffer[index2 + 1] << 8 | buffer[index2 + 2] << 16 | buffer[index2 + 3] << 24;
          var scopeObject = deserializeObject(buffer, _index, options2, false);
          index2 = index2 + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to short, truncating scope");
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to long, clips outer document");
          }
          if (evalFunctions) {
            if (cacheFunctions) {
              hash2 = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name] = isolateEvalWithHash(functionCache, hash2, functionString, object);
            } else {
              object[name] = isolateEval(functionString);
            }
            object[name].scope = scopeObject;
          } else {
            object[name] = new Code(functionString, scopeObject);
          }
        } else if (elementType === BSON.BSON_DATA_DBPOINTER) {
          stringSize = buffer[index2++] | buffer[index2++] << 8 | buffer[index2++] << 16 | buffer[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer.length - index2 || buffer[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var namespace = buffer.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
          var oidBuffer = utils.allocBuffer(12);
          buffer.copy(oidBuffer, 0, index2, index2 + 12);
          oid = new ObjectID(oidBuffer);
          index2 = index2 + 12;
          var parts = namespace.split(".");
          var db = parts.shift();
          var collection = parts.join(".");
          object[name] = new DBRef(collection, oid, db);
        } else {
          throw new Error("Detected unknown BSON type " + elementType.toString(16) + ' for fieldname "' + name + '", are you using the latest BSON parser');
        }
      }
      if (size !== index2 - startIndex) {
        if (isArray)
          throw new Error("corrupt array bson");
        throw new Error("corrupt object bson");
      }
      if (object["$id"] != null)
        object = new DBRef(object["$ref"], object["$id"], object["$db"]);
      return object;
    };
    var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
      var value = null;
      if (functionCache[hash] == null) {
        eval("value = " + functionString);
        functionCache[hash] = value;
      }
      return functionCache[hash].bind(object);
    };
    var isolateEval = function(functionString) {
      var value = null;
      eval("value = " + functionString);
      return value;
    };
    var BSON = {};
    var functionCache = BSON.functionCache = {};
    BSON.BSON_DATA_NUMBER = 1;
    BSON.BSON_DATA_STRING = 2;
    BSON.BSON_DATA_OBJECT = 3;
    BSON.BSON_DATA_ARRAY = 4;
    BSON.BSON_DATA_BINARY = 5;
    BSON.BSON_DATA_UNDEFINED = 6;
    BSON.BSON_DATA_OID = 7;
    BSON.BSON_DATA_BOOLEAN = 8;
    BSON.BSON_DATA_DATE = 9;
    BSON.BSON_DATA_NULL = 10;
    BSON.BSON_DATA_REGEXP = 11;
    BSON.BSON_DATA_DBPOINTER = 12;
    BSON.BSON_DATA_CODE = 13;
    BSON.BSON_DATA_SYMBOL = 14;
    BSON.BSON_DATA_CODE_W_SCOPE = 15;
    BSON.BSON_DATA_INT = 16;
    BSON.BSON_DATA_TIMESTAMP = 17;
    BSON.BSON_DATA_LONG = 18;
    BSON.BSON_DATA_DECIMAL128 = 19;
    BSON.BSON_DATA_MIN_KEY = 255;
    BSON.BSON_DATA_MAX_KEY = 127;
    BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON.BSON_INT32_MAX = 2147483647;
    BSON.BSON_INT32_MIN = -2147483648;
    BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON.JS_INT_MAX = 9007199254740992;
    BSON.JS_INT_MIN = -9007199254740992;
    var JS_INT_MAX_LONG = Long.fromNumber(9007199254740992);
    var JS_INT_MIN_LONG = Long.fromNumber(-9007199254740992);
    module.exports = deserialize;
  }
});

// node_modules/bson/lib/bson/float_parser.js
var require_float_parser = __commonJS({
  "node_modules/bson/lib/bson/float_parser.js"(exports2) {
    init_shims();
    var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
      var e, m, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = bBE ? 0 : nBytes - 1, d2 = bBE ? 1 : -1, s2 = buffer[offset + i];
      i += d2;
      e = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d2, nBits -= 8)
        ;
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d2, nBits -= 8)
        ;
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
      var e, m, c, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = bBE ? nBytes - 1 : 0, d2 = bBE ? -1 : 1, s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d2, m /= 256, mLen -= 8)
        ;
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8)
        ;
      buffer[offset + i - d2] |= s2 * 128;
    };
    exports2.readIEEE754 = readIEEE754;
    exports2.writeIEEE754 = writeIEEE754;
  }
});

// node_modules/bson/lib/bson/parser/serializer.js
var require_serializer = __commonJS({
  "node_modules/bson/lib/bson/parser/serializer.js"(exports2, module2) {
    init_shims();
    "use strict";
    var writeIEEE754 = require_float_parser().writeIEEE754;
    var Long2 = require_long().Long;
    var Map2 = require_map();
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils().normalizedFunctionString;
    var regexp = /\x00/;
    var ignoreKeys = ["$db", "$ref", "$id", "$clusterTime"];
    var isDate = function isDate2(d2) {
      return typeof d2 === "object" && Object.prototype.toString.call(d2) === "[object Date]";
    };
    var isRegExp = function isRegExp2(d2) {
      return Object.prototype.toString.call(d2) === "[object RegExp]";
    };
    var serializeString = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_STRING;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes + 1;
      buffer[index2 - 1] = 0;
      var size = buffer.write(value, index2 + 4, "utf8");
      buffer[index2 + 3] = size + 1 >> 24 & 255;
      buffer[index2 + 2] = size + 1 >> 16 & 255;
      buffer[index2 + 1] = size + 1 >> 8 & 255;
      buffer[index2] = size + 1 & 255;
      index2 = index2 + 4 + size;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeNumber = function(buffer, key, value, index2, isArray) {
      if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
        if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
          buffer[index2++] = BSON2.BSON_DATA_INT;
          var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer[index2++] = 0;
          buffer[index2++] = value & 255;
          buffer[index2++] = value >> 8 & 255;
          buffer[index2++] = value >> 16 & 255;
          buffer[index2++] = value >> 24 & 255;
        } else if (value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
          buffer[index2++] = BSON2.BSON_DATA_NUMBER;
          numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer[index2++] = 0;
          writeIEEE754(buffer, value, index2, "little", 52, 8);
          index2 = index2 + 8;
        } else {
          buffer[index2++] = BSON2.BSON_DATA_LONG;
          numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer[index2++] = 0;
          var longVal = Long2.fromNumber(value);
          var lowBits = longVal.getLowBits();
          var highBits = longVal.getHighBits();
          buffer[index2++] = lowBits & 255;
          buffer[index2++] = lowBits >> 8 & 255;
          buffer[index2++] = lowBits >> 16 & 255;
          buffer[index2++] = lowBits >> 24 & 255;
          buffer[index2++] = highBits & 255;
          buffer[index2++] = highBits >> 8 & 255;
          buffer[index2++] = highBits >> 16 & 255;
          buffer[index2++] = highBits >> 24 & 255;
        }
      } else {
        buffer[index2++] = BSON2.BSON_DATA_NUMBER;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer[index2++] = 0;
        writeIEEE754(buffer, value, index2, "little", 52, 8);
        index2 = index2 + 8;
      }
      return index2;
    };
    var serializeNull = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_NULL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeBoolean = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_BOOLEAN;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      buffer[index2++] = value ? 1 : 0;
      return index2;
    };
    var serializeDate = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_DATE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var dateInMilis = Long2.fromNumber(value.getTime());
      var lowBits = dateInMilis.getLowBits();
      var highBits = dateInMilis.getHighBits();
      buffer[index2++] = lowBits & 255;
      buffer[index2++] = lowBits >> 8 & 255;
      buffer[index2++] = lowBits >> 16 & 255;
      buffer[index2++] = lowBits >> 24 & 255;
      buffer[index2++] = highBits & 255;
      buffer[index2++] = highBits >> 8 & 255;
      buffer[index2++] = highBits >> 16 & 255;
      buffer[index2++] = highBits >> 24 & 255;
      return index2;
    };
    var serializeRegExp = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      if (value.source && value.source.match(regexp) != null) {
        throw Error("value " + value.source + " must not contain null bytes");
      }
      index2 = index2 + buffer.write(value.source, index2, "utf8");
      buffer[index2++] = 0;
      if (value.global)
        buffer[index2++] = 115;
      if (value.ignoreCase)
        buffer[index2++] = 105;
      if (value.multiline)
        buffer[index2++] = 109;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeBSONRegExp = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      if (value.pattern.match(regexp) != null) {
        throw Error("pattern " + value.pattern + " must not contain null bytes");
      }
      index2 = index2 + buffer.write(value.pattern, index2, "utf8");
      buffer[index2++] = 0;
      index2 = index2 + buffer.write(value.options.split("").sort().join(""), index2, "utf8");
      buffer[index2++] = 0;
      return index2;
    };
    var serializeMinMax = function(buffer, key, value, index2, isArray) {
      if (value === null) {
        buffer[index2++] = BSON2.BSON_DATA_NULL;
      } else if (value._bsontype === "MinKey") {
        buffer[index2++] = BSON2.BSON_DATA_MIN_KEY;
      } else {
        buffer[index2++] = BSON2.BSON_DATA_MAX_KEY;
      }
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeObjectId = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_OID;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      if (typeof value.id === "string") {
        buffer.write(value.id, index2, "binary");
      } else if (value.id && value.id.copy) {
        value.id.copy(buffer, index2, 0, 12);
      } else {
        throw new Error("object [" + JSON.stringify(value) + "] is not a valid ObjectId");
      }
      return index2 + 12;
    };
    var serializeBuffer = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var size = value.length;
      buffer[index2++] = size & 255;
      buffer[index2++] = size >> 8 & 255;
      buffer[index2++] = size >> 16 & 255;
      buffer[index2++] = size >> 24 & 255;
      buffer[index2++] = BSON2.BSON_BINARY_SUBTYPE_DEFAULT;
      value.copy(buffer, index2, 0, size);
      index2 = index2 + size;
      return index2;
    };
    var serializeObject = function(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === value)
          throw new Error("cyclic dependency detected");
      }
      path.push(value);
      buffer[index2++] = Array.isArray(value) ? BSON2.BSON_DATA_ARRAY : BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var endIndex = serializeInto(buffer, value, checkKeys, index2, depth + 1, serializeFunctions, ignoreUndefined, path);
      path.pop();
      return endIndex;
    };
    var serializeDecimal128 = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_DECIMAL128;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      value.bytes.copy(buffer, index2, 0, 16);
      return index2 + 16;
    };
    var serializeLong = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = value._bsontype === "Long" ? BSON2.BSON_DATA_LONG : BSON2.BSON_DATA_TIMESTAMP;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var lowBits = value.getLowBits();
      var highBits = value.getHighBits();
      buffer[index2++] = lowBits & 255;
      buffer[index2++] = lowBits >> 8 & 255;
      buffer[index2++] = lowBits >> 16 & 255;
      buffer[index2++] = lowBits >> 24 & 255;
      buffer[index2++] = highBits & 255;
      buffer[index2++] = highBits >> 8 & 255;
      buffer[index2++] = highBits >> 16 & 255;
      buffer[index2++] = highBits >> 24 & 255;
      return index2;
    };
    var serializeInt32 = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_INT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      buffer[index2++] = value & 255;
      buffer[index2++] = value >> 8 & 255;
      buffer[index2++] = value >> 16 & 255;
      buffer[index2++] = value >> 24 & 255;
      return index2;
    };
    var serializeDouble = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_NUMBER;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      writeIEEE754(buffer, value, index2, "little", 52, 8);
      index2 = index2 + 8;
      return index2;
    };
    var serializeFunction = function(buffer, key, value, index2, checkKeys, depth, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_CODE;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var functionString = normalizedFunctionString(value);
      var size = buffer.write(functionString, index2 + 4, "utf8") + 1;
      buffer[index2] = size & 255;
      buffer[index2 + 1] = size >> 8 & 255;
      buffer[index2 + 2] = size >> 16 & 255;
      buffer[index2 + 3] = size >> 24 & 255;
      index2 = index2 + 4 + size - 1;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeCode = function(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
      if (value.scope && typeof value.scope === "object") {
        buffer[index2++] = BSON2.BSON_DATA_CODE_W_SCOPE;
        var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer[index2++] = 0;
        var startIndex = index2;
        var functionString = typeof value.code === "string" ? value.code : value.code.toString();
        index2 = index2 + 4;
        var codeSize = buffer.write(functionString, index2 + 4, "utf8") + 1;
        buffer[index2] = codeSize & 255;
        buffer[index2 + 1] = codeSize >> 8 & 255;
        buffer[index2 + 2] = codeSize >> 16 & 255;
        buffer[index2 + 3] = codeSize >> 24 & 255;
        buffer[index2 + 4 + codeSize - 1] = 0;
        index2 = index2 + codeSize + 4;
        var endIndex = serializeInto(buffer, value.scope, checkKeys, index2, depth + 1, serializeFunctions, ignoreUndefined);
        index2 = endIndex - 1;
        var totalSize = endIndex - startIndex;
        buffer[startIndex++] = totalSize & 255;
        buffer[startIndex++] = totalSize >> 8 & 255;
        buffer[startIndex++] = totalSize >> 16 & 255;
        buffer[startIndex++] = totalSize >> 24 & 255;
        buffer[index2++] = 0;
      } else {
        buffer[index2++] = BSON2.BSON_DATA_CODE;
        numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer[index2++] = 0;
        functionString = value.code.toString();
        var size = buffer.write(functionString, index2 + 4, "utf8") + 1;
        buffer[index2] = size & 255;
        buffer[index2 + 1] = size >> 8 & 255;
        buffer[index2 + 2] = size >> 16 & 255;
        buffer[index2 + 3] = size >> 24 & 255;
        index2 = index2 + 4 + size - 1;
        buffer[index2++] = 0;
      }
      return index2;
    };
    var serializeBinary = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var data = value.value(true);
      var size = value.position;
      if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY)
        size = size + 4;
      buffer[index2++] = size & 255;
      buffer[index2++] = size >> 8 & 255;
      buffer[index2++] = size >> 16 & 255;
      buffer[index2++] = size >> 24 & 255;
      buffer[index2++] = value.sub_type;
      if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        buffer[index2++] = size & 255;
        buffer[index2++] = size >> 8 & 255;
        buffer[index2++] = size >> 16 & 255;
        buffer[index2++] = size >> 24 & 255;
      }
      data.copy(buffer, index2, 0, value.position);
      index2 = index2 + value.position;
      return index2;
    };
    var serializeSymbol = function(buffer, key, value, index2, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_SYMBOL;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var size = buffer.write(value.value, index2 + 4, "utf8") + 1;
      buffer[index2] = size & 255;
      buffer[index2 + 1] = size >> 8 & 255;
      buffer[index2 + 2] = size >> 16 & 255;
      buffer[index2 + 3] = size >> 24 & 255;
      index2 = index2 + 4 + size - 1;
      buffer[index2++] = 0;
      return index2;
    };
    var serializeDBRef = function(buffer, key, value, index2, depth, serializeFunctions, isArray) {
      buffer[index2++] = BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer.write(key, index2, "utf8") : buffer.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer[index2++] = 0;
      var startIndex = index2;
      var endIndex;
      if (value.db != null) {
        endIndex = serializeInto(buffer, {
          $ref: value.namespace,
          $id: value.oid,
          $db: value.db
        }, false, index2, depth + 1, serializeFunctions);
      } else {
        endIndex = serializeInto(buffer, {
          $ref: value.namespace,
          $id: value.oid
        }, false, index2, depth + 1, serializeFunctions);
      }
      var size = endIndex - startIndex;
      buffer[startIndex++] = size & 255;
      buffer[startIndex++] = size >> 8 & 255;
      buffer[startIndex++] = size >> 16 & 255;
      buffer[startIndex++] = size >> 24 & 255;
      return endIndex;
    };
    var serializeInto = function serializeInto2(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
      startingIndex = startingIndex || 0;
      path = path || [];
      path.push(object);
      var index2 = startingIndex + 4;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          var key = "" + i;
          var value = object[i];
          if (value && value.toBSON) {
            if (typeof value.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          var type = typeof value;
          if (type === "string") {
            index2 = serializeString(buffer, key, value, index2, true);
          } else if (type === "number") {
            index2 = serializeNumber(buffer, key, value, index2, true);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer, key, value, index2, true);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer, key, value, index2, true);
          } else if (value === void 0) {
            index2 = serializeNull(buffer, key, value, index2, true);
          } else if (value === null) {
            index2 = serializeNull(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer, key, value, index2, true);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer, key, value, index2, true);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer, key, value, index2, true);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer, key, value, index2, true);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer, key, value, index2, checkKeys, depth, serializeFunctions, true);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer, key, value, index2, depth, serializeFunctions, true);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer, key, value, index2, true);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer, key, value, index2, true);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      } else if (object instanceof Map2) {
        var iterator = object.entries();
        var done = false;
        while (!done) {
          var entry = iterator.next();
          done = entry.done;
          if (done)
            continue;
          key = entry.value[0];
          value = entry.value[1];
          type = typeof value;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if (key[0] === "$") {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index2 = serializeString(buffer, key, value, index2);
          } else if (type === "number") {
            index2 = serializeNumber(buffer, key, value, index2);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer, key, value, index2);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer, key, value, index2);
          } else if (value === null || value === void 0 && ignoreUndefined === false) {
            index2 = serializeNull(buffer, key, value, index2);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer, key, value, index2);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer, key, value, index2);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer, key, value, index2);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer, key, value, index2, checkKeys, depth, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer, key, value, index2);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer, key, value, index2, depth, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer, key, value, index2);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer, key, value, index2);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      } else {
        if (object.toBSON) {
          if (typeof object.toBSON !== "function")
            throw new Error("toBSON is not a function");
          object = object.toBSON();
          if (object != null && typeof object !== "object")
            throw new Error("toBSON function did not return an object");
        }
        for (key in object) {
          value = object[key];
          if (value && value.toBSON) {
            if (typeof value.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          type = typeof value;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if (key[0] === "$") {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index2 = serializeString(buffer, key, value, index2);
          } else if (type === "number") {
            index2 = serializeNumber(buffer, key, value, index2);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer, key, value, index2);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer, key, value, index2);
          } else if (value === void 0) {
            if (ignoreUndefined === false)
              index2 = serializeNull(buffer, key, value, index2);
          } else if (value === null) {
            index2 = serializeNull(buffer, key, value, index2);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer, key, value, index2);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer, key, value, index2);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer, key, value, index2);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer, key, value, index2, checkKeys, depth, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer, key, value, index2);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer, key, value, index2, depth, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer, key, value, index2);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer, key, value, index2);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer, key, value, index2);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      }
      path.pop();
      buffer[index2++] = 0;
      var size = index2 - startingIndex;
      buffer[startingIndex++] = size & 255;
      buffer[startingIndex++] = size >> 8 & 255;
      buffer[startingIndex++] = size >> 16 & 255;
      buffer[startingIndex++] = size >> 24 & 255;
      return index2;
    };
    var BSON2 = {};
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_UNDEFINED = 6;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_DECIMAL128 = 19;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = serializeInto;
  }
});

// node_modules/bson/lib/bson/parser/calculate_size.js
var require_calculate_size = __commonJS({
  "node_modules/bson/lib/bson/parser/calculate_size.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Long2 = require_long().Long;
    var Double2 = require_double().Double;
    var Timestamp2 = require_timestamp().Timestamp;
    var ObjectID2 = require_objectid().ObjectID;
    var Symbol2 = require_symbol().Symbol;
    var BSONRegExp2 = require_regexp().BSONRegExp;
    var Code2 = require_code().Code;
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key().MinKey;
    var MaxKey2 = require_max_key().MaxKey;
    var DBRef2 = require_db_ref().DBRef;
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils().normalizedFunctionString;
    var isDate = function isDate2(d2) {
      return typeof d2 === "object" && Object.prototype.toString.call(d2) === "[object Date]";
    };
    var calculateObjectSize = function calculateObjectSize2(object, serializeFunctions, ignoreUndefined) {
      var totalLength = 4 + 1;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
        }
      } else {
        if (object.toBSON) {
          object = object.toBSON();
        }
        for (var key in object) {
          totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    };
    function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
      if (value && value.toBSON) {
        value = value.toBSON();
      }
      switch (typeof value) {
        case "string":
          return 1 + Buffer.byteLength(name, "utf8") + 1 + 4 + Buffer.byteLength(value, "utf8") + 1;
        case "number":
          if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
            if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (4 + 1);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
            }
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          }
        case "undefined":
          if (isArray || !ignoreUndefined)
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
          return 0;
        case "boolean":
          return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 1);
        case "object":
          if (value == null || value instanceof MinKey2 || value instanceof MaxKey2 || value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1;
          } else if (value instanceof ObjectID2 || value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (12 + 1);
          } else if (value instanceof Date || isDate(value)) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(value)) {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (1 + 4 + 1) + value.length;
          } else if (value instanceof Long2 || value instanceof Double2 || value instanceof Timestamp2 || value["_bsontype"] === "Long" || value["_bsontype"] === "Double" || value["_bsontype"] === "Timestamp") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (8 + 1);
          } else if (value instanceof Decimal1282 || value["_bsontype"] === "Decimal128") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (16 + 1);
          } else if (value instanceof Code2 || value["_bsontype"] === "Code") {
            if (value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1;
            }
          } else if (value instanceof Binary2 || value["_bsontype"] === "Binary") {
            if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1 + 4);
            } else {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1);
            }
          } else if (value instanceof Symbol2 || value["_bsontype"] === "Symbol") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + Buffer.byteLength(value.value, "utf8") + 4 + 1 + 1;
          } else if (value instanceof DBRef2 || value["_bsontype"] === "DBRef") {
            var ordered_values = {
              $ref: value.namespace,
              $id: value.oid
            };
            if (value.db != null) {
              ordered_values["$db"] = value.db;
            }
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else if (value instanceof BSONRegExp2 || value["_bsontype"] === "BSONRegExp") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.pattern, "utf8") + 1 + Buffer.byteLength(value.options, "utf8") + 1;
          } else {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
          }
        case "function":
          if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]" || String.call(value) === "[object RegExp]") {
            return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else {
            if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else if (serializeFunctions) {
              return (name != null ? Buffer.byteLength(name, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1;
            }
          }
      }
      return 0;
    }
    var BSON2 = {};
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = calculateObjectSize;
  }
});

// node_modules/bson/lib/bson/bson.js
var require_bson = __commonJS({
  "node_modules/bson/lib/bson/bson.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Map2 = require_map();
    var Long2 = require_long();
    var Double2 = require_double();
    var Timestamp2 = require_timestamp();
    var ObjectID2 = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Int322 = require_int_32();
    var Code2 = require_code();
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key();
    var MaxKey2 = require_max_key();
    var DBRef2 = require_db_ref();
    var Binary2 = require_binary();
    var deserialize2 = require_deserializer();
    var serializer = require_serializer();
    var calculateObjectSize = require_calculate_size();
    var utils2 = require_utils();
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer = utils2.allocBuffer(MAXSIZE);
    var BSON2 = function() {
    };
    BSON2.prototype.serialize = function serialize(object, options2) {
      options2 = options2 || {};
      var checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      var minInternalBufferSize = typeof options2.minInternalBufferSize === "number" ? options2.minInternalBufferSize : MAXSIZE;
      if (buffer.length < minInternalBufferSize) {
        buffer = utils2.allocBuffer(minInternalBufferSize);
      }
      var serializationIndex = serializer(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
      var finishedBuffer = utils2.allocBuffer(serializationIndex);
      buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
      return finishedBuffer;
    };
    BSON2.prototype.serializeWithBufferAndIndex = function(object, finalBuffer, options2) {
      options2 = options2 || {};
      var checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      var startIndex = typeof options2.index === "number" ? options2.index : 0;
      var serializationIndex = serializer(finalBuffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
      return serializationIndex - 1;
    };
    BSON2.prototype.deserialize = function(buffer2, options2) {
      return deserialize2(buffer2, options2);
    };
    BSON2.prototype.calculateObjectSize = function(object, options2) {
      options2 = options2 || {};
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
    };
    BSON2.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options2) {
      options2 = options2 != null ? options2 : {};
      var index2 = startIndex;
      for (var i = 0; i < numberOfDocuments; i++) {
        var size = data[index2] | data[index2 + 1] << 8 | data[index2 + 2] << 16 | data[index2 + 3] << 24;
        options2["index"] = index2;
        documents[docStartIndex + i] = this.deserialize(data, options2);
        index2 = index2 + size;
      }
      return index2;
    };
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    module2.exports = BSON2;
    module2.exports.Code = Code2;
    module2.exports.Map = Map2;
    module2.exports.Symbol = Symbol2;
    module2.exports.BSON = BSON2;
    module2.exports.DBRef = DBRef2;
    module2.exports.Binary = Binary2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.Long = Long2;
    module2.exports.Timestamp = Timestamp2;
    module2.exports.Double = Double2;
    module2.exports.Int32 = Int322;
    module2.exports.MinKey = MinKey2;
    module2.exports.MaxKey = MaxKey2;
    module2.exports.BSONRegExp = BSONRegExp2;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/index.js
var require_bson2 = __commonJS({
  "node_modules/bson/index.js"(exports2, module2) {
    init_shims();
    var BSON2 = require_bson();
    var Binary2 = require_binary();
    var Code2 = require_code();
    var DBRef2 = require_db_ref();
    var Decimal1282 = require_decimal128();
    var Double2 = require_double();
    var Int322 = require_int_32();
    var Long2 = require_long();
    var Map2 = require_map();
    var MaxKey2 = require_max_key();
    var MinKey2 = require_min_key();
    var ObjectId2 = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Timestamp2 = require_timestamp();
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.Binary = Binary2;
    BSON2.Code = Code2;
    BSON2.DBRef = DBRef2;
    BSON2.Decimal128 = Decimal1282;
    BSON2.Double = Double2;
    BSON2.Int32 = Int322;
    BSON2.Long = Long2;
    BSON2.Map = Map2;
    BSON2.MaxKey = MaxKey2;
    BSON2.MinKey = MinKey2;
    BSON2.ObjectId = ObjectId2;
    BSON2.ObjectID = ObjectId2;
    BSON2.BSONRegExp = BSONRegExp2;
    BSON2.Symbol = Symbol2;
    BSON2.Timestamp = Timestamp2;
    module2.exports = BSON2;
  }
});

// node_modules/optional-require/index.js
var require_optional_require = __commonJS({
  "node_modules/optional-require/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var assert = require("assert");
    function findModuleNotFound(err, name) {
      const msg = err.message.split("\n")[0];
      return msg && (msg.includes(`'${name}'`) || msg.includes(` ${name} `) || msg.includes(` ${name}. `) || msg.includes(` ${name}, `));
    }
    function _optionalRequire(callerRequire, resolve2, path, message) {
      let opts;
      if (typeof message === "object") {
        opts = message;
        assert(!(opts.hasOwnProperty("notFound") && opts.hasOwnProperty("default")), "optionalRequire: options set with both `notFound` and `default`");
      } else {
        opts = { message };
      }
      try {
        return resolve2 ? callerRequire.resolve(path) : callerRequire(path);
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" || !findModuleNotFound(e, path)) {
          if (typeof opts.fail === "function") {
            return opts.fail(e);
          }
          throw e;
        }
        if (opts.message) {
          const message2 = typeof opts.message === "string" ? `${opts.message} - ` : "";
          const r = resolve2 ? "resolved" : "found";
          optionalRequire.log(`${message2}optional module not ${r}`, path);
        }
        if (typeof opts.notFound === "function") {
          return opts.notFound(e);
        }
        return opts.default;
      }
    }
    var tryRequire = (callerRequire, path, message) => _optionalRequire(callerRequire, false, path, message);
    var tryResolve = (callerRequire, path, message) => _optionalRequire(callerRequire, true, path, message);
    function optionalRequire(callerRequire) {
      const x = (path, message) => tryRequire(callerRequire, path, message);
      x.resolve = (path, message) => tryResolve(callerRequire, path, message);
      return x;
    }
    optionalRequire.try = tryRequire;
    optionalRequire.tryResolve = tryResolve;
    optionalRequire.resolve = tryResolve;
    optionalRequire.log = (message, path) => console.log(`Just FYI: ${message}; Path "${path}"`);
    module2.exports = optionalRequire;
  }
});

// node_modules/mongodb/package.json
var require_package = __commonJS({
  "node_modules/mongodb/package.json"(exports2, module2) {
    module2.exports = {
      name: "mongodb",
      version: "3.6.10",
      description: "The official MongoDB driver for Node.js",
      main: "index.js",
      files: [
        "index.js",
        "lib"
      ],
      repository: {
        type: "git",
        url: "git@github.com:mongodb/node-mongodb-native.git"
      },
      keywords: [
        "mongodb",
        "driver",
        "official"
      ],
      peerDependenciesMeta: {
        kerberos: {
          optional: true
        },
        "mongodb-client-encryption": {
          optional: true
        },
        "mongodb-extjson": {
          optional: true
        },
        snappy: {
          optional: true
        },
        "bson-ext": {
          optional: true
        },
        aws4: {
          optional: true
        }
      },
      dependencies: {
        bl: "^2.2.1",
        bson: "^1.1.4",
        denque: "^1.4.1",
        "optional-require": "^1.0.3",
        "safe-buffer": "^5.1.2"
      },
      devDependencies: {
        "@types/chai": "^4.2.16",
        "@types/mocha": "^8.2.2",
        "@types/node": "^14.14.37",
        "array-includes": "^3.1.3",
        chai: "^4.1.1",
        "chai-subset": "^1.6.0",
        chalk: "^2.4.2",
        co: "4.6.0",
        eslint: "^7.10.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-es": "^3.0.1",
        "eslint-plugin-prettier": "^3.1.3",
        jsdoc: "^3.5.5",
        "lodash.camelcase": "^4.3.0",
        mocha: "5.2.0",
        "mocha-sinon": "^2.1.0",
        "mongodb-extjson": "^2.1.1",
        "mongodb-mock-server": "^1.0.1",
        nyc: "^15.1.0",
        "object.entries": "^1.1.3",
        prettier: "^1.19.1",
        semver: "^5.5.0",
        sinon: "^4.3.0",
        "sinon-chai": "^3.2.0",
        snappy: "^6.3.4",
        "spec-xunit-file": "0.0.1-3",
        "standard-version": "^9.2.0",
        tslib: "^2.2.0",
        typescript: "^4.2.4",
        "util.promisify": "^1.0.1",
        "worker-farm": "^1.5.0",
        wtfnode: "^0.8.0",
        yargs: "^14.2.0"
      },
      license: "Apache-2.0",
      engines: {
        node: ">=4"
      },
      bugs: {
        url: "https://github.com/mongodb/node-mongodb-native/issues"
      },
      scripts: {
        "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
        "build:unified": "tsc -p test/functional/unified-spec-runner/tsconfig.unified.json",
        "check:atlas": "mocha --opts '{}' ./test/manual/atlas_connectivity.test.js",
        "check:bench": "node test/benchmarks/driverBench/",
        "check:coverage": "nyc npm run check:test",
        "check:kerberos": "mocha --opts '{}' -t 60000 test/manual/kerberos.test.js",
        "check:ldap": "mocha --opts '{}' test/manual/ldap.test.js",
        "check:lint": "eslint -v && eslint lib test",
        "check:test": "mocha --recursive test/functional test/unit",
        "check:tls": "mocha --opts '{}' test/manual/tls_support.test.js",
        format: "npm run check:lint -- --fix",
        release: "standard-version -i HISTORY.md",
        test: "npm run lint && mocha --recursive test/functional test/unit"
      },
      homepage: "https://github.com/mongodb/node-mongodb-native",
      optionalDependencies: {
        saslprep: "^1.0.0"
      }
    };
  }
});

// node_modules/mongodb/lib/core/utils.js
var require_utils2 = __commonJS({
  "node_modules/mongodb/lib/core/utils.js"(exports2, module2) {
    init_shims();
    "use strict";
    var os = require("os");
    var crypto = require("crypto");
    var requireOptional = require_optional_require()(require);
    var uuidV4 = () => {
      const result = crypto.randomBytes(16);
      result[6] = result[6] & 15 | 64;
      result[8] = result[8] & 63 | 128;
      return result;
    };
    function relayEvents(listener, emitter, events) {
      events.forEach((eventName) => listener.on(eventName, (event) => emitter.emit(eventName, event)));
    }
    function retrieveKerberos() {
      let kerberos;
      try {
        kerberos = requireOptional("kerberos");
      } catch (err) {
        if (err.code === "MODULE_NOT_FOUND") {
          throw new Error("The `kerberos` module was not found. Please install it and try again.");
        }
        throw err;
      }
      return kerberos;
    }
    var noEJSONError = function() {
      throw new Error("The `mongodb-extjson` module was not found. Please install it and try again.");
    };
    function retrieveEJSON() {
      let EJSON = requireOptional("mongodb-extjson");
      if (!EJSON) {
        EJSON = {
          parse: noEJSONError,
          deserialize: noEJSONError,
          serialize: noEJSONError,
          stringify: noEJSONError,
          setBSONModule: noEJSONError,
          BSON: noEJSONError
        };
      }
      return EJSON;
    }
    function maxWireVersion(topologyOrServer) {
      if (topologyOrServer) {
        if (topologyOrServer.ismaster) {
          return topologyOrServer.ismaster.maxWireVersion;
        }
        if (typeof topologyOrServer.lastIsMaster === "function") {
          const lastIsMaster = topologyOrServer.lastIsMaster();
          if (lastIsMaster) {
            return lastIsMaster.maxWireVersion;
          }
        }
        if (topologyOrServer.description) {
          return topologyOrServer.description.maxWireVersion;
        }
      }
      return 0;
    }
    function collationNotSupported(server, cmd) {
      return cmd && cmd.collation && maxWireVersion(server) < 5;
    }
    function isPromiseLike(maybePromise) {
      return maybePromise && typeof maybePromise.then === "function";
    }
    function eachAsync(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = 0;
      for (idx = 0; idx < arr.length; ++idx) {
        awaiting++;
        eachFn(arr[idx], eachCallback);
      }
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
        }
      }
    }
    function eachAsyncSeries(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = arr.length;
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        idx++;
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
          return;
        }
        eachFn(arr[idx], eachCallback);
      }
      eachFn(arr[idx], eachCallback);
    }
    function isUnifiedTopology(topology) {
      return topology.description != null;
    }
    function arrayStrictEqual(arr, arr2) {
      if (!Array.isArray(arr) || !Array.isArray(arr2)) {
        return false;
      }
      return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
    }
    function tagsStrictEqual(tags, tags2) {
      const tagsKeys = Object.keys(tags);
      const tags2Keys = Object.keys(tags2);
      return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
    }
    function errorStrictEqual(lhs, rhs) {
      if (lhs === rhs) {
        return true;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (lhs.constructor.name !== rhs.constructor.name) {
        return false;
      }
      if (lhs.message !== rhs.message) {
        return false;
      }
      return true;
    }
    function makeStateMachine(stateTable) {
      return function stateTransition(target, newState) {
        const legalStates = stateTable[target.s.state];
        if (legalStates && legalStates.indexOf(newState) < 0) {
          throw new TypeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
        }
        target.emit("stateChanged", target.s.state, newState);
        target.s.state = newState;
      };
    }
    function makeClientMetadata(options2) {
      options2 = options2 || {};
      const metadata = {
        driver: {
          name: "nodejs",
          version: require_package().version
        },
        os: {
          type: os.type(),
          name: process.platform,
          architecture: process.arch,
          version: os.release()
        },
        platform: `'Node.js ${process.version}, ${os.endianness} (${options2.useUnifiedTopology ? "unified" : "legacy"})`
      };
      if (options2.driverInfo) {
        if (options2.driverInfo.name) {
          metadata.driver.name = `${metadata.driver.name}|${options2.driverInfo.name}`;
        }
        if (options2.driverInfo.version) {
          metadata.version = `${metadata.driver.version}|${options2.driverInfo.version}`;
        }
        if (options2.driverInfo.platform) {
          metadata.platform = `${metadata.platform}|${options2.driverInfo.platform}`;
        }
      }
      if (options2.appname) {
        const buffer = Buffer.from(options2.appname);
        metadata.application = {
          name: buffer.length > 128 ? buffer.slice(0, 128).toString("utf8") : options2.appname
        };
      }
      return metadata;
    }
    var noop3 = () => {
    };
    module2.exports = {
      uuidV4,
      relayEvents,
      collationNotSupported,
      retrieveEJSON,
      retrieveKerberos,
      maxWireVersion,
      isPromiseLike,
      eachAsync,
      eachAsyncSeries,
      isUnifiedTopology,
      arrayStrictEqual,
      tagsStrictEqual,
      errorStrictEqual,
      makeStateMachine,
      makeClientMetadata,
      noop: noop3
    };
  }
});

// node_modules/mongodb/lib/core/error.js
var require_error = __commonJS({
  "node_modules/mongodb/lib/core/error.js"(exports2, module2) {
    init_shims();
    "use strict";
    var kErrorLabels = Symbol("errorLabels");
    var MongoError = class extends Error {
      constructor(message) {
        if (message instanceof Error) {
          super(message.message);
          this.stack = message.stack;
        } else {
          if (typeof message === "string") {
            super(message);
          } else {
            super(message.message || message.errmsg || message.$err || "n/a");
            if (message.errorLabels) {
              this[kErrorLabels] = new Set(message.errorLabels);
            }
            for (var name in message) {
              if (name === "errorLabels" || name === "errmsg") {
                continue;
              }
              this[name] = message[name];
            }
          }
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "MongoError";
      }
      get errmsg() {
        return this.message;
      }
      static create(options2) {
        return new MongoError(options2);
      }
      hasErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          return false;
        }
        return this[kErrorLabels].has(label);
      }
      addErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          this[kErrorLabels] = new Set();
        }
        this[kErrorLabels].add(label);
      }
      get errorLabels() {
        return this[kErrorLabels] ? Array.from(this[kErrorLabels]) : [];
      }
    };
    var kBeforeHandshake = Symbol("beforeHandshake");
    function isNetworkErrorBeforeHandshake(err) {
      return err[kBeforeHandshake] === true;
    }
    var MongoNetworkError = class extends MongoError {
      constructor(message, options2) {
        super(message);
        this.name = "MongoNetworkError";
        if (options2 && typeof options2.beforeHandshake === "boolean") {
          this[kBeforeHandshake] = options2.beforeHandshake;
        }
      }
    };
    var MongoNetworkTimeoutError = class extends MongoNetworkError {
      constructor(message, options2) {
        super(message, options2);
        this.name = "MongoNetworkTimeoutError";
      }
    };
    var MongoParseError = class extends MongoError {
      constructor(message) {
        super(message);
        this.name = "MongoParseError";
      }
    };
    var MongoTimeoutError = class extends MongoError {
      constructor(message, reason) {
        if (reason && reason.error) {
          super(reason.error.message || reason.error);
        } else {
          super(message);
        }
        this.name = "MongoTimeoutError";
        if (reason) {
          this.reason = reason;
        }
      }
    };
    var MongoServerSelectionError = class extends MongoTimeoutError {
      constructor(message, reason) {
        super(message, reason);
        this.name = "MongoServerSelectionError";
      }
    };
    function makeWriteConcernResultObject(input) {
      const output = Object.assign({}, input);
      if (output.ok === 0) {
        output.ok = 1;
        delete output.errmsg;
        delete output.code;
        delete output.codeName;
      }
      return output;
    }
    var MongoWriteConcernError = class extends MongoError {
      constructor(message, result) {
        super(message);
        this.name = "MongoWriteConcernError";
        if (result && Array.isArray(result.errorLabels)) {
          this[kErrorLabels] = new Set(result.errorLabels);
        }
        if (result != null) {
          this.result = makeWriteConcernResultObject(result);
        }
      }
    };
    var RETRYABLE_ERROR_CODES = new Set([
      6,
      7,
      89,
      91,
      189,
      9001,
      10107,
      11600,
      11602,
      13435,
      13436
    ]);
    var RETRYABLE_WRITE_ERROR_CODES = new Set([
      11600,
      11602,
      10107,
      13435,
      13436,
      189,
      91,
      7,
      6,
      89,
      9001,
      262
    ]);
    function isRetryableWriteError(error2) {
      if (error2 instanceof MongoWriteConcernError) {
        return RETRYABLE_WRITE_ERROR_CODES.has(error2.code) || RETRYABLE_WRITE_ERROR_CODES.has(error2.result.code);
      }
      return RETRYABLE_WRITE_ERROR_CODES.has(error2.code);
    }
    function isRetryableError(error2) {
      return RETRYABLE_ERROR_CODES.has(error2.code) || error2 instanceof MongoNetworkError || error2.message.match(/not master/) || error2.message.match(/node is recovering/);
    }
    var SDAM_RECOVERING_CODES = new Set([
      91,
      189,
      11600,
      11602,
      13436
    ]);
    var SDAM_NOTMASTER_CODES = new Set([
      10107,
      13435
    ]);
    var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
      11600,
      91
    ]);
    function isRecoveringError(err) {
      if (err.code && SDAM_RECOVERING_CODES.has(err.code)) {
        return true;
      }
      return err.message.match(/not master or secondary/) || err.message.match(/node is recovering/);
    }
    function isNotMasterError(err) {
      if (err.code && SDAM_NOTMASTER_CODES.has(err.code)) {
        return true;
      }
      if (isRecoveringError(err)) {
        return false;
      }
      return err.message.match(/not master/);
    }
    function isNodeShuttingDownError(err) {
      return err.code && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code);
    }
    function isSDAMUnrecoverableError(error2) {
      if (error2 instanceof MongoParseError || error2 == null) {
        return true;
      }
      if (isRecoveringError(error2) || isNotMasterError(error2)) {
        return true;
      }
      return false;
    }
    module2.exports = {
      MongoError,
      MongoNetworkError,
      MongoNetworkTimeoutError,
      MongoParseError,
      MongoTimeoutError,
      MongoServerSelectionError,
      MongoWriteConcernError,
      isRetryableError,
      isSDAMUnrecoverableError,
      isNodeShuttingDownError,
      isRetryableWriteError,
      isNetworkErrorBeforeHandshake
    };
  }
});

// node_modules/mongodb/lib/core/connection/utils.js
var require_utils3 = __commonJS({
  "node_modules/mongodb/lib/core/connection/utils.js"(exports2, module2) {
    init_shims();
    "use strict";
    var require_optional = require_optional_require()(require);
    function debugOptions(debugFields, options2) {
      const finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options2[n];
      });
      return finaloptions;
    }
    function retrieveBSON() {
      const BSON2 = require_bson2();
      BSON2.native = false;
      const optionalBSON = require_optional("bson-ext");
      if (optionalBSON) {
        optionalBSON.native = true;
        return optionalBSON;
      }
      return BSON2;
    }
    function noSnappyWarning() {
      throw new Error("Attempted to use Snappy compression, but Snappy is not installed. Install or disable Snappy compression and try again.");
    }
    function retrieveSnappy() {
      let snappy = require_optional("snappy");
      if (!snappy) {
        snappy = {
          compress: noSnappyWarning,
          uncompress: noSnappyWarning,
          compressSync: noSnappyWarning,
          uncompressSync: noSnappyWarning
        };
      }
      return snappy;
    }
    module2.exports = {
      debugOptions,
      retrieveBSON,
      retrieveSnappy
    };
  }
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS({
  "node_modules/mongodb/lib/write_concern.js"(exports2, module2) {
    init_shims();
    "use strict";
    var kWriteConcernKeys = new Set(["w", "wtimeout", "j", "journal", "fsync"]);
    var utils2;
    var WriteConcern = class {
      constructor(w, wtimeout, j, fsync) {
        if (w != null) {
          this.w = w;
        }
        if (wtimeout != null) {
          this.wtimeout = wtimeout;
        }
        if (j != null) {
          this.j = j;
        }
        if (fsync != null) {
          this.fsync = fsync;
        }
      }
      static fromOptions(options2) {
        if (options2 == null || options2.writeConcern == null && options2.w == null && options2.wtimeout == null && options2.j == null && options2.journal == null && options2.fsync == null) {
          return;
        }
        if (options2.writeConcern) {
          if (typeof options2.writeConcern === "string") {
            return new WriteConcern(options2.writeConcern);
          }
          if (!Object.keys(options2.writeConcern).some((key) => kWriteConcernKeys.has(key))) {
            return;
          }
          return new WriteConcern(options2.writeConcern.w, options2.writeConcern.wtimeout, options2.writeConcern.j || options2.writeConcern.journal, options2.writeConcern.fsync);
        }
        if (!utils2)
          utils2 = require_utils4();
        utils2.emitWarningOnce(`Top-level use of w, wtimeout, j, and fsync is deprecated. Use writeConcern instead.`);
        return new WriteConcern(options2.w, options2.wtimeout, options2.j || options2.journal, options2.fsync);
      }
    };
    module2.exports = WriteConcern;
  }
});

// node_modules/mongodb/lib/async/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/mongodb/lib/async/async_iterator.js"(exports2) {
    init_shims();
    "use strict";
    function asyncIterator() {
      const cursor = this;
      return {
        next: function() {
          return Promise.resolve().then(() => cursor.next()).then((value) => {
            if (!value) {
              return cursor.close().then(() => ({ value, done: true }));
            }
            return { value, done: false };
          });
        }
      };
    }
    exports2.asyncIterator = asyncIterator;
  }
});

// node_modules/mongodb/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/mongodb/lib/utils.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_error().MongoError;
    var WriteConcern = require_write_concern();
    var shallowClone = function(obj) {
      var copy = {};
      for (var name in obj)
        copy[name] = obj[name];
      return copy;
    };
    var getSingleProperty = function(obj, name, value) {
      Object.defineProperty(obj, name, {
        enumerable: true,
        get: function() {
          return value;
        }
      });
    };
    var formatSortValue = exports2.formatSortValue = function(sortDirection) {
      var value = ("" + sortDirection).toLowerCase();
      switch (value) {
        case "ascending":
        case "asc":
        case "1":
          return 1;
        case "descending":
        case "desc":
        case "-1":
          return -1;
        default:
          throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
    };
    var formattedOrderClause = exports2.formattedOrderClause = function(sortValue) {
      var orderBy = new Map();
      if (sortValue == null)
        return null;
      if (Array.isArray(sortValue)) {
        if (sortValue.length === 0) {
          return null;
        }
        for (var i = 0; i < sortValue.length; i++) {
          if (sortValue[i].constructor === String) {
            orderBy.set(`${sortValue[i]}`, 1);
          } else {
            orderBy.set(`${sortValue[i][0]}`, formatSortValue(sortValue[i][1]));
          }
        }
      } else if (sortValue != null && typeof sortValue === "object") {
        if (sortValue instanceof Map) {
          orderBy = sortValue;
        } else {
          var sortKeys = Object.keys(sortValue);
          for (var k of sortKeys) {
            orderBy.set(k, sortValue[k]);
          }
        }
      } else if (typeof sortValue === "string") {
        orderBy.set(`${sortValue}`, 1);
      } else {
        throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
      return orderBy;
    };
    var checkCollectionName = function checkCollectionName2(collectionName) {
      if (typeof collectionName !== "string") {
        throw new MongoError("collection name must be a String");
      }
      if (!collectionName || collectionName.indexOf("..") !== -1) {
        throw new MongoError("collection names cannot be empty");
      }
      if (collectionName.indexOf("$") !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
        throw new MongoError("collection names must not contain '$'");
      }
      if (collectionName.match(/^\.|\.$/) != null) {
        throw new MongoError("collection names must not start or end with '.'");
      }
      if (collectionName.indexOf("\0") !== -1) {
        throw new MongoError("collection names cannot contain a null character");
      }
    };
    var handleCallback = function(callback, err, value1, value2) {
      try {
        if (callback == null)
          return;
        if (callback) {
          return value2 ? callback(err, value1, value2) : callback(err, value1);
        }
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
        return false;
      }
      return true;
    };
    var toError = function(error2) {
      if (error2 instanceof Error)
        return error2;
      var msg = error2.err || error2.errmsg || error2.errMessage || error2;
      var e = MongoError.create({ message: msg, driver: true });
      var keys = typeof error2 === "object" ? Object.keys(error2) : [];
      for (var i = 0; i < keys.length; i++) {
        try {
          e[keys[i]] = error2[keys[i]];
        } catch (err) {
        }
      }
      return e;
    };
    var normalizeHintField = function normalizeHintField2(hint) {
      var finalHint = null;
      if (typeof hint === "string") {
        finalHint = hint;
      } else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach(function(param) {
          finalHint[param] = 1;
        });
      } else if (hint != null && typeof hint === "object") {
        finalHint = {};
        for (var name in hint) {
          finalHint[name] = hint[name];
        }
      }
      return finalHint;
    };
    var parseIndexOptions = function(fieldOrSpec) {
      var fieldHash = {};
      var indexes = [];
      var keys;
      if (typeof fieldOrSpec === "string") {
        indexes.push(fieldOrSpec + "_" + 1);
        fieldHash[fieldOrSpec] = 1;
      } else if (Array.isArray(fieldOrSpec)) {
        fieldOrSpec.forEach(function(f) {
          if (typeof f === "string") {
            indexes.push(f + "_" + 1);
            fieldHash[f] = 1;
          } else if (Array.isArray(f)) {
            indexes.push(f[0] + "_" + (f[1] || 1));
            fieldHash[f[0]] = f[1] || 1;
          } else if (isObject2(f)) {
            keys = Object.keys(f);
            keys.forEach(function(k) {
              indexes.push(k + "_" + f[k]);
              fieldHash[k] = f[k];
            });
          } else {
          }
        });
      } else if (isObject2(fieldOrSpec)) {
        keys = Object.keys(fieldOrSpec);
        keys.forEach(function(key) {
          indexes.push(key + "_" + fieldOrSpec[key]);
          fieldHash[key] = fieldOrSpec[key];
        });
      }
      return {
        name: indexes.join("_"),
        keys,
        fieldHash
      };
    };
    var isObject2 = exports2.isObject = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Object]";
    };
    var debugOptions = function(debugFields, options2) {
      var finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options2[n];
      });
      return finaloptions;
    };
    var decorateCommand = function(command, options2, exclude) {
      for (var name in options2) {
        if (exclude.indexOf(name) === -1)
          command[name] = options2[name];
      }
      return command;
    };
    var mergeOptions = function(target, source) {
      for (var name in source) {
        target[name] = source[name];
      }
      return target;
    };
    var translateOptions = function(target, source) {
      var translations = {
        sslCA: "ca",
        sslCRL: "crl",
        sslValidate: "rejectUnauthorized",
        sslKey: "key",
        sslCert: "cert",
        sslPass: "passphrase",
        socketTimeoutMS: "socketTimeout",
        connectTimeoutMS: "connectionTimeout",
        replicaSet: "setName",
        rs_name: "setName",
        secondaryAcceptableLatencyMS: "acceptableLatency",
        connectWithNoPrimary: "secondaryOnlyConnectionAllowed",
        acceptableLatencyMS: "localThresholdMS"
      };
      for (var name in source) {
        if (translations[name]) {
          target[translations[name]] = source[name];
        } else {
          target[name] = source[name];
        }
      }
      return target;
    };
    var filterOptions = function(options2, names) {
      var filterOptions2 = {};
      for (var name in options2) {
        if (names.indexOf(name) !== -1)
          filterOptions2[name] = options2[name];
      }
      return filterOptions2;
    };
    var WRITE_CONCERN_KEYS = ["w", "j", "wtimeout", "fsync", "writeConcern"];
    function conditionallyMergeWriteConcern(target, source) {
      let found = false;
      for (const wcKey of WRITE_CONCERN_KEYS) {
        if (wcKey in target) {
          found = true;
          break;
        }
      }
      if (!found) {
        for (const wcKey of WRITE_CONCERN_KEYS) {
          if (source[wcKey]) {
            if (!("writeConcern" in target)) {
              target.writeConcern = {};
            }
            target.writeConcern[wcKey] = source[wcKey];
          }
        }
      }
      return target;
    }
    var executeLegacyOperation = (topology, operation, args, options2) => {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!Array.isArray(args)) {
        throw new TypeError("This method requires an array of arguments to apply");
      }
      options2 = options2 || {};
      const Promise2 = topology.s.promiseLibrary;
      let callback = args[args.length - 1];
      let session, opOptions, owner;
      if (!options2.skipSessions && topology.hasSessionSupport()) {
        opOptions = args[args.length - 2];
        if (opOptions == null || opOptions.session == null) {
          owner = Symbol();
          session = topology.startSession({ owner });
          const optionsIndex = args.length - 2;
          args[optionsIndex] = Object.assign({}, args[optionsIndex], { session });
        } else if (opOptions.session && opOptions.session.hasEnded) {
          throw new MongoError("Use of expired sessions is not permitted");
        }
      }
      const makeExecuteCallback = (resolve2, reject) => function executeCallback(err, result) {
        if (session && session.owner === owner && !options2.returnsCursor) {
          session.endSession(() => {
            delete opOptions.session;
            if (err)
              return reject(err);
            resolve2(result);
          });
        } else {
          if (err)
            return reject(err);
          resolve2(result);
        }
      };
      if (typeof callback === "function") {
        callback = args.pop();
        const handler = makeExecuteCallback((result) => callback(null, result), (err) => callback(err, null));
        args.push(handler);
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler(e);
          throw e;
        }
      }
      if (args[args.length - 1] != null) {
        throw new TypeError("final argument to `executeLegacyOperation` must be a callback");
      }
      return new Promise2(function(resolve2, reject) {
        const handler = makeExecuteCallback(resolve2, reject);
        args[args.length - 1] = handler;
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler(e);
        }
      });
    };
    function applyRetryableWrites(target, db) {
      if (db && db.s.options.retryWrites) {
        target.retryWrites = true;
      }
      return target;
    }
    function applyWriteConcern(target, sources, options2) {
      options2 = options2 || {};
      const db = sources.db;
      const coll = sources.collection;
      if (options2.session && options2.session.inTransaction()) {
        if (target.writeConcern) {
          delete target.writeConcern;
        }
        return target;
      }
      const writeConcern = WriteConcern.fromOptions(options2);
      if (writeConcern) {
        return Object.assign(target, { writeConcern });
      }
      if (coll && coll.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });
      }
      if (db && db.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });
      }
      return target;
    }
    function isPromiseLike(maybePromise2) {
      return maybePromise2 && typeof maybePromise2.then === "function";
    }
    function decorateWithCollation(command, target, options2) {
      const topology = target.s && target.s.topology || target.topology;
      if (!topology) {
        throw new TypeError('parameter "target" is missing a topology');
      }
      const capabilities = topology.capabilities();
      if (options2.collation && typeof options2.collation === "object") {
        if (capabilities && capabilities.commandsTakeCollation) {
          command.collation = options2.collation;
        } else {
          throw new MongoError(`Current topology does not support collation`);
        }
      }
    }
    function decorateWithReadConcern(command, coll, options2) {
      if (options2 && options2.session && options2.session.inTransaction()) {
        return;
      }
      let readConcern = Object.assign({}, command.readConcern || {});
      if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
      }
      if (Object.keys(readConcern).length > 0) {
        Object.assign(command, { readConcern });
      }
    }
    function decorateWithExplain(command, explain) {
      if (command.explain) {
        return command;
      }
      return { explain: command, verbosity: explain.verbosity };
    }
    var nodejsMajorVersion = +process.version.split(".")[0].substring(1);
    var emitProcessWarning = (msg) => nodejsMajorVersion <= 6 ? process.emitWarning(msg, "DeprecationWarning", MONGODB_WARNING_CODE) : process.emitWarning(msg, { type: "DeprecationWarning", code: MONGODB_WARNING_CODE });
    var emitConsoleWarning = (msg) => console.error(msg);
    var emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;
    function defaultMsgHandler(name, option) {
      return `${name} option [${option}] is deprecated and will be removed in a later version.`;
    }
    function deprecateOptions(config, fn) {
      if (process.noDeprecation === true) {
        return fn;
      }
      const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;
      const optionsWarned = new Set();
      function deprecated() {
        const options2 = arguments[config.optionsIndex];
        if (!isObject2(options2) || Object.keys(options2).length === 0) {
          return fn.apply(this, arguments);
        }
        config.deprecatedOptions.forEach((deprecatedOption) => {
          if (Object.prototype.hasOwnProperty.call(options2, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {
            optionsWarned.add(deprecatedOption);
            const msg = msgHandler(config.name, deprecatedOption);
            emitDeprecationWarning(msg);
            if (this && this.getLogger) {
              const logger = this.getLogger();
              if (logger) {
                logger.warn(msg);
              }
            }
          }
        });
        return fn.apply(this, arguments);
      }
      Object.setPrototypeOf(deprecated, fn);
      if (fn.prototype) {
        deprecated.prototype = fn.prototype;
      }
      return deprecated;
    }
    var SUPPORTS = {};
    try {
      require_async_iterator();
      SUPPORTS.ASYNC_ITERATOR = true;
    } catch (e) {
      SUPPORTS.ASYNC_ITERATOR = false;
    }
    var MongoDBNamespace = class {
      constructor(db, collection) {
        this.db = db;
        this.collection = collection;
      }
      toString() {
        return this.collection ? `${this.db}.${this.collection}` : this.db;
      }
      withCollection(collection) {
        return new MongoDBNamespace(this.db, collection);
      }
      static fromString(namespace) {
        if (!namespace) {
          throw new Error(`Cannot parse namespace from "${namespace}"`);
        }
        const index2 = namespace.indexOf(".");
        return new MongoDBNamespace(namespace.substring(0, index2), namespace.substring(index2 + 1));
      }
    };
    function* makeCounter(seed) {
      let count = seed || 0;
      while (true) {
        const newCount = count;
        count += 1;
        yield newCount;
      }
    }
    function maybePromise(parent, callback, fn) {
      const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;
      let result;
      if (typeof callback !== "function") {
        result = new PromiseLibrary((resolve2, reject) => {
          callback = (err, res) => {
            if (err)
              return reject(err);
            resolve2(res);
          };
        });
      }
      fn(function(err, res) {
        if (err != null) {
          try {
            callback(err);
          } catch (error2) {
            return process.nextTick(() => {
              throw error2;
            });
          }
          return;
        }
        callback(err, res);
      });
      return result;
    }
    function now() {
      const hrtime = process.hrtime();
      return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
    }
    function calculateDurationInMs(started) {
      if (typeof started !== "number") {
        throw TypeError("numeric value required to calculate duration");
      }
      const elapsed = now() - started;
      return elapsed < 0 ? 0 : elapsed;
    }
    function makeInterruptableAsyncInterval(fn, options2) {
      let timerId;
      let lastCallTime;
      let lastWakeTime;
      let stopped = false;
      options2 = options2 || {};
      const interval = options2.interval || 1e3;
      const minInterval = options2.minInterval || 500;
      const immediate = typeof options2.immediate === "boolean" ? options2.immediate : false;
      const clock = typeof options2.clock === "function" ? options2.clock : now;
      function wake() {
        const currentTime = clock();
        const timeSinceLastWake = currentTime - lastWakeTime;
        const timeSinceLastCall = currentTime - lastCallTime;
        const timeUntilNextCall = interval - timeSinceLastCall;
        lastWakeTime = currentTime;
        if (timeSinceLastWake < minInterval) {
          return;
        }
        if (timeUntilNextCall > minInterval) {
          reschedule(minInterval);
        }
        if (timeUntilNextCall < 0) {
          executeAndReschedule();
        }
      }
      function stop() {
        stopped = true;
        if (timerId) {
          clearTimeout(timerId);
          timerId = null;
        }
        lastCallTime = 0;
        lastWakeTime = 0;
      }
      function reschedule(ms) {
        if (stopped)
          return;
        clearTimeout(timerId);
        timerId = setTimeout(executeAndReschedule, ms || interval);
      }
      function executeAndReschedule() {
        lastWakeTime = 0;
        lastCallTime = clock();
        fn((err) => {
          if (err)
            throw err;
          reschedule(interval);
        });
      }
      if (immediate) {
        executeAndReschedule();
      } else {
        lastCallTime = clock();
        reschedule();
      }
      return { wake, stop };
    }
    function hasAtomicOperators(doc) {
      if (Array.isArray(doc)) {
        return doc.reduce((err, u) => err || hasAtomicOperators(u), null);
      }
      return Object.keys(typeof doc.toBSON !== "function" ? doc : doc.toBSON()).map((k) => k[0]).indexOf("$") >= 0;
    }
    var MONGODB_WARNING_CODE = "MONGODB DRIVER";
    function emitWarning(message) {
      if (process.emitWarning) {
        return nodejsMajorVersion <= 6 ? process.emitWarning(message, void 0, MONGODB_WARNING_CODE) : process.emitWarning(message, { code: MONGODB_WARNING_CODE });
      } else {
        return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);
      }
    }
    var emittedWarnings = new Set();
    function emitWarningOnce(message) {
      if (!emittedWarnings.has(message)) {
        emittedWarnings.add(message);
        return emitWarning(message);
      }
    }
    function isSuperset(set, subset) {
      set = Array.isArray(set) ? new Set(set) : set;
      subset = Array.isArray(subset) ? new Set(subset) : subset;
      for (const elem of subset) {
        if (!set.has(elem)) {
          return false;
        }
      }
      return true;
    }
    function isRecord(value, requiredKeys) {
      const toString = Object.prototype.toString;
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      const isObject3 = (v) => toString.call(v) === "[object Object]";
      if (!isObject3(value)) {
        return false;
      }
      const ctor = value.constructor;
      if (ctor && ctor.prototype) {
        if (!isObject3(ctor.prototype)) {
          return false;
        }
        if (!hasOwnProperty.call(ctor.prototype, "isPrototypeOf")) {
          return false;
        }
      }
      if (requiredKeys) {
        const keys = Object.keys(value);
        return isSuperset(keys, requiredKeys);
      }
      return true;
    }
    function deepCopy(value) {
      if (value == null) {
        return value;
      } else if (Array.isArray(value)) {
        return value.map((item) => deepCopy(item));
      } else if (isRecord(value)) {
        const res = {};
        for (const key in value) {
          res[key] = deepCopy(value[key]);
        }
        return res;
      }
      const ctor = value.constructor;
      if (ctor) {
        switch (ctor.name.toLowerCase()) {
          case "date":
            return new ctor(Number(value));
          case "map":
            return new Map(value);
          case "set":
            return new Set(value);
          case "buffer":
            return Buffer.from(value);
        }
      }
      return value;
    }
    module2.exports = {
      filterOptions,
      mergeOptions,
      translateOptions,
      shallowClone,
      getSingleProperty,
      checkCollectionName,
      toError,
      formattedOrderClause,
      parseIndexOptions,
      normalizeHintField,
      handleCallback,
      decorateCommand,
      isObject: isObject2,
      debugOptions,
      MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,
      conditionallyMergeWriteConcern,
      executeLegacyOperation,
      applyRetryableWrites,
      applyWriteConcern,
      isPromiseLike,
      decorateWithCollation,
      decorateWithReadConcern,
      decorateWithExplain,
      deprecateOptions,
      SUPPORTS,
      MongoDBNamespace,
      emitDeprecationWarning,
      makeCounter,
      maybePromise,
      now,
      calculateDurationInMs,
      makeInterruptableAsyncInterval,
      hasAtomicOperators,
      MONGODB_WARNING_CODE,
      emitWarning,
      emitWarningOnce,
      deepCopy
    };
  }
});

// node_modules/mongodb/lib/core/topologies/read_preference.js
var require_read_preference = __commonJS({
  "node_modules/mongodb/lib/core/topologies/read_preference.js"(exports2, module2) {
    init_shims();
    "use strict";
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var ReadPreference = function(mode, tags, options2) {
      if (!ReadPreference.isValid(mode)) {
        throw new TypeError(`Invalid read preference mode ${mode}`);
      }
      if (tags && !Array.isArray(tags)) {
        emitWarningOnce("ReadPreference tags must be an array, this will change in the next major version");
        const tagsHasMaxStalenessSeconds = typeof tags.maxStalenessSeconds !== "undefined";
        const tagsHasHedge = typeof tags.hedge !== "undefined";
        const tagsHasOptions = tagsHasMaxStalenessSeconds || tagsHasHedge;
        if (tagsHasOptions) {
          options2 = tags;
          tags = void 0;
        } else {
          tags = [tags];
        }
      }
      this.mode = mode;
      this.tags = tags;
      this.hedge = options2 && options2.hedge;
      options2 = options2 || {};
      if (options2.maxStalenessSeconds != null) {
        if (options2.maxStalenessSeconds <= 0) {
          throw new TypeError("maxStalenessSeconds must be a positive integer");
        }
        this.maxStalenessSeconds = options2.maxStalenessSeconds;
        this.minWireVersion = 5;
      }
      if (this.mode === ReadPreference.PRIMARY) {
        if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
          throw new TypeError("Primary read preference cannot be combined with tags");
        }
        if (this.maxStalenessSeconds) {
          throw new TypeError("Primary read preference cannot be combined with maxStalenessSeconds");
        }
        if (this.hedge) {
          throw new TypeError("Primary read preference cannot be combined with hedge");
        }
      }
    };
    Object.defineProperty(ReadPreference.prototype, "preference", {
      enumerable: true,
      get: function() {
        return this.mode;
      }
    });
    ReadPreference.PRIMARY = "primary";
    ReadPreference.PRIMARY_PREFERRED = "primaryPreferred";
    ReadPreference.SECONDARY = "secondary";
    ReadPreference.SECONDARY_PREFERRED = "secondaryPreferred";
    ReadPreference.NEAREST = "nearest";
    var VALID_MODES = [
      ReadPreference.PRIMARY,
      ReadPreference.PRIMARY_PREFERRED,
      ReadPreference.SECONDARY,
      ReadPreference.SECONDARY_PREFERRED,
      ReadPreference.NEAREST,
      null
    ];
    ReadPreference.fromOptions = function(options2) {
      if (!options2)
        return null;
      const readPreference = options2.readPreference;
      if (!readPreference)
        return null;
      const readPreferenceTags = options2.readPreferenceTags;
      const maxStalenessSeconds = options2.maxStalenessSeconds;
      if (typeof readPreference === "string") {
        return new ReadPreference(readPreference, readPreferenceTags);
      } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
        const mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode === "string") {
          return new ReadPreference(mode, readPreference.tags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds || maxStalenessSeconds,
            hedge: readPreference.hedge
          });
        }
      }
      return readPreference;
    };
    ReadPreference.resolve = function(parent, options2) {
      options2 = options2 || {};
      const session = options2.session;
      const inheritedReadPreference = parent && parent.readPreference;
      let readPreference;
      if (options2.readPreference) {
        readPreference = ReadPreference.fromOptions(options2);
      } else if (session && session.inTransaction() && session.transaction.options.readPreference) {
        readPreference = session.transaction.options.readPreference;
      } else if (inheritedReadPreference != null) {
        readPreference = inheritedReadPreference;
      } else {
        readPreference = ReadPreference.primary;
      }
      return typeof readPreference === "string" ? new ReadPreference(readPreference) : readPreference;
    };
    ReadPreference.translate = function(options2) {
      if (options2.readPreference == null)
        return options2;
      const r = options2.readPreference;
      if (typeof r === "string") {
        options2.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
        const mode = r.mode || r.preference;
        if (mode && typeof mode === "string") {
          options2.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new TypeError("Invalid read preference: " + r);
      }
      return options2;
    };
    ReadPreference.isValid = function(mode) {
      return VALID_MODES.indexOf(mode) !== -1;
    };
    ReadPreference.prototype.isValid = function(mode) {
      return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
    };
    var needSlaveOk = ["primaryPreferred", "secondary", "secondaryPreferred", "nearest"];
    ReadPreference.prototype.slaveOk = function() {
      return needSlaveOk.indexOf(this.mode) !== -1;
    };
    ReadPreference.prototype.equals = function(readPreference) {
      return readPreference.mode === this.mode;
    };
    ReadPreference.prototype.toJSON = function() {
      const readPreference = { mode: this.mode };
      if (Array.isArray(this.tags))
        readPreference.tags = this.tags;
      if (this.maxStalenessSeconds)
        readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge)
        readPreference.hedge = this.hedge;
      return readPreference;
    };
    ReadPreference.primary = new ReadPreference("primary");
    ReadPreference.primaryPreferred = new ReadPreference("primaryPreferred");
    ReadPreference.secondary = new ReadPreference("secondary");
    ReadPreference.secondaryPreferred = new ReadPreference("secondaryPreferred");
    ReadPreference.nearest = new ReadPreference("nearest");
    module2.exports = ReadPreference;
  }
});

// node_modules/mongodb/lib/core/sdam/common.js
var require_common = __commonJS({
  "node_modules/mongodb/lib/core/sdam/common.js"(exports2, module2) {
    init_shims();
    "use strict";
    var STATE_CLOSING = "closing";
    var STATE_CLOSED = "closed";
    var STATE_CONNECTING = "connecting";
    var STATE_CONNECTED = "connected";
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    function serverType(server) {
      let description = server.s.description || server.s.serverDescription;
      if (description.topologyType === TopologyType.Single)
        return description.servers[0].type;
      return description.type;
    }
    var TOPOLOGY_DEFAULTS = {
      useUnifiedTopology: true,
      localThresholdMS: 15,
      serverSelectionTimeoutMS: 3e4,
      heartbeatFrequencyMS: 1e4,
      minHeartbeatFrequencyMS: 500
    };
    function drainTimerQueue(queue) {
      queue.forEach(clearTimeout);
      queue.clear();
    }
    function clearAndRemoveTimerFrom(timer, timers) {
      clearTimeout(timer);
      return timers.delete(timer);
    }
    module2.exports = {
      STATE_CLOSING,
      STATE_CLOSED,
      STATE_CONNECTING,
      STATE_CONNECTED,
      TOPOLOGY_DEFAULTS,
      TopologyType,
      ServerType,
      serverType,
      drainTimerQueue,
      clearAndRemoveTimerFrom
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server_description.js
var require_server_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_description.js"(exports2, module2) {
    init_shims();
    "use strict";
    var arrayStrictEqual = require_utils2().arrayStrictEqual;
    var tagsStrictEqual = require_utils2().tagsStrictEqual;
    var errorStrictEqual = require_utils2().errorStrictEqual;
    var ServerType = require_common().ServerType;
    var now = require_utils4().now;
    var WRITABLE_SERVER_TYPES = new Set([
      ServerType.RSPrimary,
      ServerType.Standalone,
      ServerType.Mongos
    ]);
    var DATA_BEARING_SERVER_TYPES = new Set([
      ServerType.RSPrimary,
      ServerType.RSSecondary,
      ServerType.Mongos,
      ServerType.Standalone
    ]);
    var ISMASTER_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "compression",
      "me",
      "hosts",
      "passives",
      "arbiters",
      "tags",
      "setName",
      "setVersion",
      "electionId",
      "primary",
      "logicalSessionTimeoutMinutes",
      "saslSupportedMechs",
      "__nodejs_mock_server__",
      "$clusterTime"
    ];
    var ServerDescription = class {
      constructor(address, ismaster, options2) {
        options2 = options2 || {};
        ismaster = Object.assign({
          minWireVersion: 0,
          maxWireVersion: 0,
          hosts: [],
          passives: [],
          arbiters: [],
          tags: []
        }, ismaster);
        this.address = address;
        this.error = options2.error;
        this.roundTripTime = options2.roundTripTime || -1;
        this.lastUpdateTime = now();
        this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;
        this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;
        this.type = parseServerType(ismaster);
        this.topologyVersion = options2.topologyVersion || ismaster.topologyVersion;
        ISMASTER_FIELDS.forEach((field) => {
          if (typeof ismaster[field] !== "undefined")
            this[field] = ismaster[field];
        });
        if (this.me)
          this.me = this.me.toLowerCase();
        this.hosts = this.hosts.map((host) => host.toLowerCase());
        this.passives = this.passives.map((host) => host.toLowerCase());
        this.arbiters = this.arbiters.map((host) => host.toLowerCase());
      }
      get allHosts() {
        return this.hosts.concat(this.arbiters).concat(this.passives);
      }
      get isReadable() {
        return this.type === ServerType.RSSecondary || this.isWritable;
      }
      get isDataBearing() {
        return DATA_BEARING_SERVER_TYPES.has(this.type);
      }
      get isWritable() {
        return WRITABLE_SERVER_TYPES.has(this.type);
      }
      get host() {
        const chopLength = `:${this.port}`.length;
        return this.address.slice(0, -chopLength);
      }
      get port() {
        const port = this.address.split(":").pop();
        return port ? Number.parseInt(port, 10) : port;
      }
      equals(other) {
        const topologyVersionsEqual = this.topologyVersion === other.topologyVersion || compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;
        return other != null && errorStrictEqual(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && this.me === other.me && arrayStrictEqual(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && (this.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId) && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
      }
    };
    function parseServerType(ismaster) {
      if (!ismaster || !ismaster.ok) {
        return ServerType.Unknown;
      }
      if (ismaster.isreplicaset) {
        return ServerType.RSGhost;
      }
      if (ismaster.msg && ismaster.msg === "isdbgrid") {
        return ServerType.Mongos;
      }
      if (ismaster.setName) {
        if (ismaster.hidden) {
          return ServerType.RSOther;
        } else if (ismaster.ismaster) {
          return ServerType.RSPrimary;
        } else if (ismaster.secondary) {
          return ServerType.RSSecondary;
        } else if (ismaster.arbiterOnly) {
          return ServerType.RSArbiter;
        } else {
          return ServerType.RSOther;
        }
      }
      return ServerType.Standalone;
    }
    function compareTopologyVersion(lhs, rhs) {
      if (lhs == null || rhs == null) {
        return -1;
      }
      if (lhs.processId.equals(rhs.processId)) {
        if (lhs.counter === rhs.counter) {
          return 0;
        } else if (lhs.counter < rhs.counter) {
          return -1;
        }
        return 1;
      }
      return -1;
    }
    module2.exports = {
      ServerDescription,
      parseServerType,
      compareTopologyVersion
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/constants.js
var require_constants = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/constants.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MIN_SUPPORTED_SERVER_VERSION = "2.6";
    var MAX_SUPPORTED_SERVER_VERSION = "5.0";
    var MIN_SUPPORTED_WIRE_VERSION = 2;
    var MAX_SUPPORTED_WIRE_VERSION = 13;
    module2.exports = {
      MIN_SUPPORTED_SERVER_VERSION,
      MAX_SUPPORTED_SERVER_VERSION,
      MIN_SUPPORTED_WIRE_VERSION,
      MAX_SUPPORTED_WIRE_VERSION
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology_description.js
var require_topology_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology_description.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ServerType = require_common().ServerType;
    var ServerDescription = require_server_description().ServerDescription;
    var WIRE_CONSTANTS = require_constants();
    var TopologyType = require_common().TopologyType;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var TopologyDescription = class {
      constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options2) {
        options2 = options2 || {};
        this.type = topologyType || TopologyType.Unknown;
        this.setName = setName || null;
        this.maxSetVersion = maxSetVersion || null;
        this.maxElectionId = maxElectionId || null;
        this.servers = serverDescriptions || new Map();
        this.stale = false;
        this.compatible = true;
        this.compatibilityError = null;
        this.logicalSessionTimeoutMinutes = null;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 0;
        this.localThresholdMS = options2.localThresholdMS || 0;
        this.commonWireVersion = commonWireVersion || null;
        Object.defineProperty(this, "options", { value: options2, enumberable: false });
        for (const serverDescription of this.servers.values()) {
          if (serverDescription.type === ServerType.Unknown)
            continue;
          if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
          }
          if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
            break;
          }
        }
        this.logicalSessionTimeoutMinutes = null;
        for (const addressServerTuple of this.servers) {
          const server = addressServerTuple[1];
          if (server.isReadable) {
            if (server.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = null;
              break;
            }
            if (this.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
              continue;
            }
            this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
          }
        }
      }
      updateFromSrvPollingEvent(ev) {
        const newAddresses = ev.addresses();
        const serverDescriptions = new Map(this.servers);
        for (const server of this.servers) {
          if (newAddresses.has(server[0])) {
            newAddresses.delete(server[0]);
          } else {
            serverDescriptions.delete(server[0]);
          }
        }
        if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {
          return this;
        }
        for (const address of newAddresses) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
        return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);
      }
      update(serverDescription) {
        const address = serverDescription.address;
        let topologyType = this.type;
        let setName = this.setName;
        let maxSetVersion = this.maxSetVersion;
        let maxElectionId = this.maxElectionId;
        let commonWireVersion = this.commonWireVersion;
        if (serverDescription.setName && setName && serverDescription.setName !== setName) {
          serverDescription = new ServerDescription(address, null);
        }
        const serverType = serverDescription.type;
        let serverDescriptions = new Map(this.servers);
        if (serverDescription.maxWireVersion !== 0) {
          if (commonWireVersion == null) {
            commonWireVersion = serverDescription.maxWireVersion;
          } else {
            commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
          }
        }
        serverDescriptions.set(address, serverDescription);
        if (topologyType === TopologyType.Single) {
          return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
        }
        if (topologyType === TopologyType.Unknown) {
          if (serverType === ServerType.Standalone && this.servers.size !== 1) {
            serverDescriptions.delete(address);
          } else {
            topologyType = topologyTypeForServerType(serverType);
          }
        }
        if (topologyType === TopologyType.Sharded) {
          if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {
            serverDescriptions.delete(address);
          }
        }
        if (topologyType === TopologyType.ReplicaSetNoPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
          }
          if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);
            topologyType = result[0], setName = result[1];
          }
        }
        if (topologyType === TopologyType.ReplicaSetWithPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
            topologyType = checkHasPrimary(serverDescriptions);
          } else if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);
          } else {
            topologyType = checkHasPrimary(serverDescriptions);
          }
        }
        return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
      }
      get error() {
        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
        if (descriptionsWithError.length > 0) {
          return descriptionsWithError[0].error;
        }
        return void 0;
      }
      get hasKnownServers() {
        return Array.from(this.servers.values()).some((sd) => sd.type !== ServerType.Unknown);
      }
      get hasDataBearingServers() {
        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
      }
      hasServer(address) {
        return this.servers.has(address);
      }
    };
    function topologyTypeForServerType(serverType) {
      if (serverType === ServerType.Standalone) {
        return TopologyType.Single;
      }
      if (serverType === ServerType.Mongos) {
        return TopologyType.Sharded;
      }
      if (serverType === ServerType.RSPrimary) {
        return TopologyType.ReplicaSetWithPrimary;
      }
      if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function compareObjectId(oid1, oid2) {
      if (oid1 == null) {
        return -1;
      }
      if (oid2 == null) {
        return 1;
      }
      if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {
        const oid1Buffer = oid1.id;
        const oid2Buffer = oid2.id;
        return oid1Buffer.compare(oid2Buffer);
      }
      const oid1String = oid1.toString();
      const oid2String = oid2.toString();
      return oid1String.localeCompare(oid2String);
    }
    function updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
      const electionId = serverDescription.electionId ? serverDescription.electionId : null;
      if (serverDescription.setVersion && electionId) {
        if (maxSetVersion && maxElectionId) {
          if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {
            serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
          }
        }
        maxElectionId = serverDescription.electionId;
      }
      if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
        maxSetVersion = serverDescription.setVersion;
      }
      for (const address of serverDescriptions.keys()) {
        const server = serverDescriptions.get(address);
        if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {
          serverDescriptions.set(address, new ServerDescription(server.address));
          break;
        }
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      const currentAddresses = Array.from(serverDescriptions.keys());
      const responseAddresses = serverDescription.allHosts;
      currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
        serverDescriptions.delete(address);
      });
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    function updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      if (setName == null) {
        throw new TypeError("setName is required");
      }
      if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return checkHasPrimary(serverDescriptions);
    }
    function updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      let topologyType = TopologyType.ReplicaSetNoPrimary;
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [topologyType, setName];
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      if (serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return [topologyType, setName];
    }
    function checkHasPrimary(serverDescriptions) {
      for (const addr of serverDescriptions.keys()) {
        if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {
          return TopologyType.ReplicaSetWithPrimary;
        }
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    module2.exports = {
      TopologyDescription
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/shared.js
var require_shared = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/shared.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var MESSAGE_HEADER_SIZE = 16;
    var COMPRESSION_DETAILS_SIZE = 9;
    var opcodes = {
      OP_REPLY: 1,
      OP_UPDATE: 2001,
      OP_INSERT: 2002,
      OP_QUERY: 2004,
      OP_GETMORE: 2005,
      OP_DELETE: 2006,
      OP_KILL_CURSORS: 2007,
      OP_COMPRESSED: 2012,
      OP_MSG: 2013
    };
    var getReadPreference = function(cmd, options2) {
      var readPreference = cmd.readPreference || new ReadPreference("primary");
      if (options2.readPreference) {
        readPreference = options2.readPreference;
      }
      if (typeof readPreference === "string") {
        readPreference = new ReadPreference(readPreference);
      }
      if (!(readPreference instanceof ReadPreference)) {
        throw new MongoError("read preference must be a ReadPreference instance");
      }
      return readPreference;
    };
    var parseHeader = function(message) {
      return {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
    };
    function applyCommonQueryOptions(queryOptions, options2) {
      Object.assign(queryOptions, {
        raw: typeof options2.raw === "boolean" ? options2.raw : false,
        promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
        promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
        promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false,
        bsonRegExp: typeof options2.bsonRegExp === "boolean" ? options2.bsonRegExp : false,
        monitoring: typeof options2.monitoring === "boolean" ? options2.monitoring : false,
        fullResult: typeof options2.fullResult === "boolean" ? options2.fullResult : false
      });
      if (typeof options2.socketTimeout === "number") {
        queryOptions.socketTimeout = options2.socketTimeout;
      }
      if (options2.session) {
        queryOptions.session = options2.session;
      }
      if (typeof options2.documentsReturnedIn === "string") {
        queryOptions.documentsReturnedIn = options2.documentsReturnedIn;
      }
      return queryOptions;
    }
    function isSharded(topologyOrServer) {
      if (topologyOrServer.type === "mongos")
        return true;
      if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {
        return true;
      }
      if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {
        const servers = Array.from(topologyOrServer.description.servers.values());
        return servers.some((server) => server.type === ServerType.Mongos);
      }
      return false;
    }
    function databaseNamespace(ns) {
      return ns.split(".")[0];
    }
    function collectionNamespace(ns) {
      return ns.split(".").slice(1).join(".");
    }
    module2.exports = {
      getReadPreference,
      MESSAGE_HEADER_SIZE,
      COMPRESSION_DETAILS_SIZE,
      opcodes,
      parseHeader,
      applyCommonQueryOptions,
      isSharded,
      databaseNamespace,
      collectionNamespace
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/compression.js
var require_compression = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/compression.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Snappy = require_utils3().retrieveSnappy();
    var zlib2 = require("zlib");
    var compressorIDs = {
      snappy: 1,
      zlib: 2
    };
    var uncompressibleCommands = new Set([
      "ismaster",
      "saslStart",
      "saslContinue",
      "getnonce",
      "authenticate",
      "createUser",
      "updateUser",
      "copydbSaslStart",
      "copydbgetnonce",
      "copydb"
    ]);
    function compress(self2, dataToBeCompressed, callback) {
      switch (self2.options.agreedCompressor) {
        case "snappy":
          Snappy.compress(dataToBeCompressed, callback);
          break;
        case "zlib":
          var zlibOptions = {};
          if (self2.options.zlibCompressionLevel) {
            zlibOptions.level = self2.options.zlibCompressionLevel;
          }
          zlib2.deflate(dataToBeCompressed, zlibOptions, callback);
          break;
        default:
          throw new Error('Attempt to compress message using unknown compressor "' + self2.options.agreedCompressor + '".');
      }
    }
    function decompress(compressorID, compressedData, callback) {
      if (compressorID < 0 || compressorID > compressorIDs.length) {
        throw new Error("Server sent message compressed using an unsupported compressor. (Received compressor ID " + compressorID + ")");
      }
      switch (compressorID) {
        case compressorIDs.snappy:
          Snappy.uncompress(compressedData, callback);
          break;
        case compressorIDs.zlib:
          zlib2.inflate(compressedData, callback);
          break;
        default:
          callback(null, compressedData);
      }
    }
    module2.exports = {
      compressorIDs,
      uncompressibleCommands,
      compress,
      decompress
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    init_shims();
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/mongodb/lib/core/connection/commands.js
var require_commands = __commonJS({
  "node_modules/mongodb/lib/core/connection/commands.js"(exports2, module2) {
    init_shims();
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var Buffer2 = require_safe_buffer().Buffer;
    var _requestId = 0;
    var opcodes = require_shared().opcodes;
    var OPTS_TAILABLE_CURSOR = 2;
    var OPTS_SLAVE = 4;
    var OPTS_OPLOG_REPLAY = 8;
    var OPTS_NO_CURSOR_TIMEOUT = 16;
    var OPTS_AWAIT_DATA = 32;
    var OPTS_EXHAUST = 64;
    var OPTS_PARTIAL = 128;
    var CURSOR_NOT_FOUND = 1;
    var QUERY_FAILURE = 2;
    var SHARD_CONFIG_STALE = 4;
    var AWAIT_CAPABLE = 8;
    var Query = function(bson, ns, query, options2) {
      var self2 = this;
      if (ns == null)
        throw new Error("ns must be specified for query");
      if (query == null)
        throw new Error("query must be specified for query");
      if (ns.indexOf("\0") !== -1) {
        throw new Error("namespace cannot contain a null character");
      }
      this.bson = bson;
      this.ns = ns;
      this.query = query;
      this.numberToSkip = options2.numberToSkip || 0;
      this.numberToReturn = options2.numberToReturn || 0;
      this.returnFieldSelector = options2.returnFieldSelector || null;
      this.requestId = Query.getRequestId();
      this.pre32Limit = options2.pre32Limit;
      this.serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      this.ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
      this.maxBsonSize = options2.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : true;
      this.batchSize = self2.numberToReturn;
      this.tailable = false;
      this.slaveOk = typeof options2.slaveOk === "boolean" ? options2.slaveOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    };
    Query.prototype.incRequestId = function() {
      this.requestId = _requestId++;
    };
    Query.nextRequestId = function() {
      return _requestId + 1;
    };
    Query.prototype.toBin = function() {
      var self2 = this;
      var buffers = [];
      var projection = null;
      var flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.slaveOk) {
        flags |= OPTS_SLAVE;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (self2.batchSize !== self2.numberToReturn)
        self2.numberToReturn = self2.batchSize;
      var header = Buffer2.alloc(4 * 4 + 4 + Buffer2.byteLength(self2.ns) + 1 + 4 + 4);
      buffers.push(header);
      var query = self2.bson.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(query);
      if (self2.returnFieldSelector && Object.keys(self2.returnFieldSelector).length > 0) {
        projection = self2.bson.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(projection);
      }
      var totalLength = header.length + query.length + (projection ? projection.length : 0);
      var index2 = 4;
      header[3] = totalLength >> 24 & 255;
      header[2] = totalLength >> 16 & 255;
      header[1] = totalLength >> 8 & 255;
      header[0] = totalLength & 255;
      header[index2 + 3] = this.requestId >> 24 & 255;
      header[index2 + 2] = this.requestId >> 16 & 255;
      header[index2 + 1] = this.requestId >> 8 & 255;
      header[index2] = this.requestId & 255;
      index2 = index2 + 4;
      header[index2 + 3] = 0 >> 24 & 255;
      header[index2 + 2] = 0 >> 16 & 255;
      header[index2 + 1] = 0 >> 8 & 255;
      header[index2] = 0 & 255;
      index2 = index2 + 4;
      header[index2 + 3] = opcodes.OP_QUERY >> 24 & 255;
      header[index2 + 2] = opcodes.OP_QUERY >> 16 & 255;
      header[index2 + 1] = opcodes.OP_QUERY >> 8 & 255;
      header[index2] = opcodes.OP_QUERY & 255;
      index2 = index2 + 4;
      header[index2 + 3] = flags >> 24 & 255;
      header[index2 + 2] = flags >> 16 & 255;
      header[index2 + 1] = flags >> 8 & 255;
      header[index2] = flags & 255;
      index2 = index2 + 4;
      index2 = index2 + header.write(this.ns, index2, "utf8") + 1;
      header[index2 - 1] = 0;
      header[index2 + 3] = this.numberToSkip >> 24 & 255;
      header[index2 + 2] = this.numberToSkip >> 16 & 255;
      header[index2 + 1] = this.numberToSkip >> 8 & 255;
      header[index2] = this.numberToSkip & 255;
      index2 = index2 + 4;
      header[index2 + 3] = this.numberToReturn >> 24 & 255;
      header[index2 + 2] = this.numberToReturn >> 16 & 255;
      header[index2 + 1] = this.numberToReturn >> 8 & 255;
      header[index2] = this.numberToReturn & 255;
      index2 = index2 + 4;
      return buffers;
    };
    Query.getRequestId = function() {
      return ++_requestId;
    };
    var GetMore = function(bson, ns, cursorId, opts) {
      opts = opts || {};
      this.numberToReturn = opts.numberToReturn || 0;
      this.requestId = _requestId++;
      this.bson = bson;
      this.ns = ns;
      this.cursorId = cursorId;
    };
    GetMore.prototype.toBin = function() {
      var length = 4 + Buffer2.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4;
      var index2 = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index2 + 3] = length >> 24 & 255;
      _buffer[index2 + 2] = length >> 16 & 255;
      _buffer[index2 + 1] = length >> 8 & 255;
      _buffer[index2] = length & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.requestId >> 24 & 255;
      _buffer[index2 + 2] = this.requestId >> 16 & 255;
      _buffer[index2 + 1] = this.requestId >> 8 & 255;
      _buffer[index2] = this.requestId & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = opcodes.OP_GETMORE >> 24 & 255;
      _buffer[index2 + 2] = opcodes.OP_GETMORE >> 16 & 255;
      _buffer[index2 + 1] = opcodes.OP_GETMORE >> 8 & 255;
      _buffer[index2] = opcodes.OP_GETMORE & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      index2 = index2 + _buffer.write(this.ns, index2, "utf8") + 1;
      _buffer[index2 - 1] = 0;
      _buffer[index2 + 3] = this.numberToReturn >> 24 & 255;
      _buffer[index2 + 2] = this.numberToReturn >> 16 & 255;
      _buffer[index2 + 1] = this.numberToReturn >> 8 & 255;
      _buffer[index2] = this.numberToReturn & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorId.getLowBits() >> 24 & 255;
      _buffer[index2 + 2] = this.cursorId.getLowBits() >> 16 & 255;
      _buffer[index2 + 1] = this.cursorId.getLowBits() >> 8 & 255;
      _buffer[index2] = this.cursorId.getLowBits() & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorId.getHighBits() >> 24 & 255;
      _buffer[index2 + 2] = this.cursorId.getHighBits() >> 16 & 255;
      _buffer[index2 + 1] = this.cursorId.getHighBits() >> 8 & 255;
      _buffer[index2] = this.cursorId.getHighBits() & 255;
      index2 = index2 + 4;
      return _buffer;
    };
    var KillCursor = function(bson, ns, cursorIds) {
      this.ns = ns;
      this.requestId = _requestId++;
      this.cursorIds = cursorIds;
    };
    KillCursor.prototype.toBin = function() {
      var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8;
      var index2 = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index2 + 3] = length >> 24 & 255;
      _buffer[index2 + 2] = length >> 16 & 255;
      _buffer[index2 + 1] = length >> 8 & 255;
      _buffer[index2] = length & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.requestId >> 24 & 255;
      _buffer[index2 + 2] = this.requestId >> 16 & 255;
      _buffer[index2 + 1] = this.requestId >> 8 & 255;
      _buffer[index2] = this.requestId & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = opcodes.OP_KILL_CURSORS >> 24 & 255;
      _buffer[index2 + 2] = opcodes.OP_KILL_CURSORS >> 16 & 255;
      _buffer[index2 + 1] = opcodes.OP_KILL_CURSORS >> 8 & 255;
      _buffer[index2] = opcodes.OP_KILL_CURSORS & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorIds.length >> 24 & 255;
      _buffer[index2 + 2] = this.cursorIds.length >> 16 & 255;
      _buffer[index2 + 1] = this.cursorIds.length >> 8 & 255;
      _buffer[index2] = this.cursorIds.length & 255;
      index2 = index2 + 4;
      for (var i = 0; i < this.cursorIds.length; i++) {
        _buffer[index2 + 3] = this.cursorIds[i].getLowBits() >> 24 & 255;
        _buffer[index2 + 2] = this.cursorIds[i].getLowBits() >> 16 & 255;
        _buffer[index2 + 1] = this.cursorIds[i].getLowBits() >> 8 & 255;
        _buffer[index2] = this.cursorIds[i].getLowBits() & 255;
        index2 = index2 + 4;
        _buffer[index2 + 3] = this.cursorIds[i].getHighBits() >> 24 & 255;
        _buffer[index2 + 2] = this.cursorIds[i].getHighBits() >> 16 & 255;
        _buffer[index2 + 1] = this.cursorIds[i].getHighBits() >> 8 & 255;
        _buffer[index2] = this.cursorIds[i].getHighBits() & 255;
        index2 = index2 + 4;
      }
      return _buffer;
    };
    var Response2 = function(bson, message, msgHeader, msgBody, opts) {
      opts = opts || {
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.bson = bson;
      this.opts = opts;
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.cursorId = new Long2(msgBody.readInt32LE(4), msgBody.readInt32LE(8));
      this.startingFrom = msgBody.readInt32LE(12);
      this.numberReturned = msgBody.readInt32LE(16);
      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
      this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
      this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
      this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
      this.bsonRegExp = typeof opts.bsonRegExp === "boolean" ? opts.bsonRegExp : false;
    };
    Response2.prototype.isParsed = function() {
      return this.parsed;
    };
    Response2.prototype.parse = function(options2) {
      if (this.parsed)
        return;
      options2 = options2 || {};
      var raw = options2.raw || false;
      var documentsReturnedIn = options2.documentsReturnedIn || null;
      var promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : this.opts.promoteLongs;
      var promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : this.opts.promoteValues;
      var promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : this.opts.promoteBuffers;
      var bsonRegExp = typeof options2.bsonRegExp === "boolean" ? options2.bsonRegExp : this.opts.bsonRegExp;
      var bsonSize, _options;
      _options = {
        promoteLongs,
        promoteValues,
        promoteBuffers,
        bsonRegExp
      };
      this.index = 20;
      for (var i = 0; i < this.numberReturned; i++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        if (raw) {
          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
        }
        this.index = this.index + bsonSize;
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        const doc = this.bson.deserialize(this.documents[0], _options);
        this.documents = [doc];
      }
      this.parsed = true;
    };
    module2.exports = {
      Query,
      GetMore,
      Response: Response2,
      KillCursor
    };
  }
});

// node_modules/mongodb/lib/core/connection/msg.js
var require_msg = __commonJS({
  "node_modules/mongodb/lib/core/connection/msg.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var opcodes = require_shared().opcodes;
    var databaseNamespace = require_shared().databaseNamespace;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var _requestId = 0;
    var OPTS_CHECKSUM_PRESENT = 1;
    var OPTS_MORE_TO_COME = 2;
    var OPTS_EXHAUST_ALLOWED = 1 << 16;
    var Msg = class {
      constructor(bson, ns, command, options2) {
        if (command == null)
          throw new Error("query must be specified for query");
        this.bson = bson;
        this.ns = ns;
        this.command = command;
        this.command.$db = databaseNamespace(ns);
        if (options2.readPreference && options2.readPreference.mode !== ReadPreference.PRIMARY) {
          this.command.$readPreference = options2.readPreference.toJSON();
        }
        this.options = options2 || {};
        this.requestId = options2.requestId ? options2.requestId : Msg.getRequestId();
        this.serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
        this.ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
        this.checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
        this.maxBsonSize = options2.maxBsonSize || 1024 * 1024 * 16;
        this.checksumPresent = false;
        this.moreToCome = options2.moreToCome || false;
        this.exhaustAllowed = typeof options2.exhaustAllowed === "boolean" ? options2.exhaustAllowed : false;
      }
      toBin() {
        const buffers = [];
        let flags = 0;
        if (this.checksumPresent) {
          flags |= OPTS_CHECKSUM_PRESENT;
        }
        if (this.moreToCome) {
          flags |= OPTS_MORE_TO_COME;
        }
        if (this.exhaustAllowed) {
          flags |= OPTS_EXHAUST_ALLOWED;
        }
        const header = Buffer2.alloc(4 * 4 + 4);
        buffers.push(header);
        let totalLength = header.length;
        const command = this.command;
        totalLength += this.makeDocumentSegment(buffers, command);
        header.writeInt32LE(totalLength, 0);
        header.writeInt32LE(this.requestId, 4);
        header.writeInt32LE(0, 8);
        header.writeInt32LE(opcodes.OP_MSG, 12);
        header.writeUInt32LE(flags, 16);
        return buffers;
      }
      makeDocumentSegment(buffers, document2) {
        const payloadTypeBuffer = Buffer2.alloc(1);
        payloadTypeBuffer[0] = 0;
        const documentBuffer = this.serializeBson(document2);
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        return payloadTypeBuffer.length + documentBuffer.length;
      }
      serializeBson(document2) {
        return this.bson.serialize(document2, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
      }
    };
    Msg.getRequestId = function() {
      _requestId = _requestId + 1 & 2147483647;
      return _requestId;
    };
    var BinMsg = class {
      constructor(bson, message, msgHeader, msgBody, opts) {
        opts = opts || {
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: false,
          bsonRegExp: false
        };
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.bson = bson;
        this.opts = opts;
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.responseFlags = msgBody.readInt32LE(0);
        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
        this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
        this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
        this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
        this.bsonRegExp = typeof opts.bsonRegExp === "boolean" ? opts.bsonRegExp : false;
        this.documents = [];
      }
      isParsed() {
        return this.parsed;
      }
      parse(options2) {
        if (this.parsed)
          return;
        options2 = options2 || {};
        this.index = 4;
        const raw = options2.raw || false;
        const documentsReturnedIn = options2.documentsReturnedIn || null;
        const promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : this.opts.promoteLongs;
        const promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : this.opts.promoteValues;
        const promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : this.opts.promoteBuffers;
        const bsonRegExp = typeof options2.bsonRegExp === "boolean" ? options2.bsonRegExp : this.opts.bsonRegExp;
        const _options = {
          promoteLongs,
          promoteValues,
          promoteBuffers,
          bsonRegExp
        };
        while (this.index < this.data.length) {
          const payloadType = this.data.readUInt8(this.index++);
          if (payloadType === 1) {
            throw new MongoError("OP_MSG Payload Type 1 detected unsupported protocol");
          } else if (payloadType === 0) {
            const bsonSize = this.data.readUInt32LE(this.index);
            const bin = this.data.slice(this.index, this.index + bsonSize);
            this.documents.push(raw ? bin : this.bson.deserialize(bin, _options));
            this.index += bsonSize;
          }
        }
        if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
          const fieldsAsRaw = {};
          fieldsAsRaw[documentsReturnedIn] = true;
          _options.fieldsAsRaw = fieldsAsRaw;
          const doc = this.bson.deserialize(this.documents[0], _options);
          this.documents = [doc];
        }
        this.parsed = true;
      }
    };
    module2.exports = { Msg, BinMsg };
  }
});

// node_modules/mongodb/lib/core/connection/logger.js
var require_logger = __commonJS({
  "node_modules/mongodb/lib/core/connection/logger.js"(exports2, module2) {
    init_shims();
    "use strict";
    var f = require("util").format;
    var MongoError = require_error().MongoError;
    var classFilters = {};
    var filteredClasses = {};
    var level = null;
    var pid = process.pid;
    var currentLogger = null;
    var Logger = function(className, options2) {
      if (!(this instanceof Logger))
        return new Logger(className, options2);
      options2 = options2 || {};
      this.className = className;
      if (options2.logger) {
        currentLogger = options2.logger;
      } else if (currentLogger == null) {
        currentLogger = console.log;
      }
      if (options2.loggerLevel) {
        level = options2.loggerLevel || "error";
      }
      if (filteredClasses[this.className] == null)
        classFilters[this.className] = true;
    };
    Logger.prototype.debug = function(message, object) {
      if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "DEBUG", this.className, pid, dateTime, message);
        var state = {
          type: "debug",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    };
    Logger.prototype.warn = function(message, object) {
      if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "WARN", this.className, pid, dateTime, message);
        var state = {
          type: "warn",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.info = function(message, object) {
      if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "INFO", this.className, pid, dateTime, message);
        var state = {
          type: "info",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.error = function(message, object) {
      if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "ERROR", this.className, pid, dateTime, message);
        var state = {
          type: "error",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.isInfo = function() {
      return level === "info" || level === "debug";
    }, Logger.prototype.isError = function() {
      return level === "error" || level === "info" || level === "debug";
    }, Logger.prototype.isWarn = function() {
      return level === "error" || level === "warn" || level === "info" || level === "debug";
    }, Logger.prototype.isDebug = function() {
      return level === "debug";
    };
    Logger.reset = function() {
      level = "error";
      filteredClasses = {};
    };
    Logger.currentLogger = function() {
      return currentLogger;
    };
    Logger.setCurrentLogger = function(logger) {
      if (typeof logger !== "function")
        throw new MongoError("current logger must be a function");
      currentLogger = logger;
    };
    Logger.filter = function(type, values) {
      if (type === "class" && Array.isArray(values)) {
        filteredClasses = {};
        values.forEach(function(x) {
          filteredClasses[x] = true;
        });
      }
    };
    Logger.setLevel = function(_level) {
      if (_level !== "info" && _level !== "error" && _level !== "debug" && _level !== "warn") {
        throw new Error(f("%s is an illegal logging level", _level));
      }
      level = _level;
    };
    module2.exports = Logger;
  }
});

// node_modules/mongodb/lib/core/connection/command_result.js
var require_command_result = __commonJS({
  "node_modules/mongodb/lib/core/connection/command_result.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandResult = function(result, connection, message) {
      this.result = result;
      this.connection = connection;
      this.message = message;
    };
    CommandResult.prototype.toJSON = function() {
      let result = Object.assign({}, this, this.result);
      delete result.message;
      return result;
    };
    CommandResult.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    module2.exports = CommandResult;
  }
});

// node_modules/mongodb/lib/core/connection/connection.js
var require_connection = __commonJS({
  "node_modules/mongodb/lib/core/connection/connection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var crypto = require("crypto");
    var debugOptions = require_utils3().debugOptions;
    var parseHeader = require_shared().parseHeader;
    var decompress = require_compression().decompress;
    var Response2 = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoError = require_error().MongoError;
    var Logger = require_logger();
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var Buffer2 = require_safe_buffer().Buffer;
    var Query = require_commands().Query;
    var CommandResult = require_command_result();
    var _id = 0;
    var DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;
    var DEBUG_FIELDS = [
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "checkServerIdentity"
    ];
    var connectionAccountingSpy = void 0;
    var connectionAccounting = false;
    var connections = {};
    var Connection = class extends EventEmitter {
      constructor(socket, options2) {
        super();
        options2 = options2 || {};
        if (!options2.bson) {
          throw new TypeError("must pass in valid bson parser");
        }
        this.id = _id++;
        this.options = options2;
        this.logger = Logger("Connection", options2);
        this.bson = options2.bson;
        this.tag = options2.tag;
        this.maxBsonMessageSize = options2.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;
        this.port = options2.port || 27017;
        this.host = options2.host || "localhost";
        this.socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        this.keepAlive = typeof options2.keepAlive === "boolean" ? options2.keepAlive : true;
        this.keepAliveInitialDelay = typeof options2.keepAliveInitialDelay === "number" ? options2.keepAliveInitialDelay : 12e4;
        this.connectionTimeout = typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : 3e4;
        if (this.keepAliveInitialDelay > this.socketTimeout) {
          this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);
        }
        if (this.logger.isDebug()) {
          this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options2))}]`);
        }
        this.responseOptions = {
          promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
          promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
          promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false,
          bsonRegExp: typeof options2.bsonRegExp === "boolean" ? options2.bsonRegExp : false
        };
        this.flushing = false;
        this.queue = [];
        this.writeStream = null;
        this.destroyed = false;
        this.timedOut = false;
        const hash2 = crypto.createHash("sha1");
        hash2.update(this.address);
        this.hashedName = hash2.digest("hex");
        this.workItems = [];
        this.socket = socket;
        this.socket.once("error", errorHandler(this));
        this.socket.once("timeout", timeoutHandler(this));
        this.socket.once("close", closeHandler(this));
        this.socket.on("data", dataHandler(this));
        if (connectionAccounting) {
          addConnection(this.id, this);
        }
      }
      setSocketTimeout(value) {
        if (this.socket) {
          this.socket.setTimeout(value);
        }
      }
      resetSocketTimeout() {
        if (this.socket) {
          this.socket.setTimeout(this.socketTimeout);
        }
      }
      static enableConnectionAccounting(spy) {
        if (spy) {
          connectionAccountingSpy = spy;
        }
        connectionAccounting = true;
        connections = {};
      }
      static disableConnectionAccounting() {
        connectionAccounting = false;
        connectionAccountingSpy = void 0;
      }
      static connections() {
        return connections;
      }
      get address() {
        return `${this.host}:${this.port}`;
      }
      unref() {
        if (this.socket == null) {
          this.once("connect", () => this.socket.unref());
          return;
        }
        this.socket.unref();
      }
      flush(err) {
        while (this.workItems.length > 0) {
          const workItem = this.workItems.shift();
          if (workItem.cb) {
            workItem.cb(err);
          }
        }
      }
      destroy(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = Object.assign({ force: false }, options2);
        if (connectionAccounting) {
          deleteConnection(this.id);
        }
        if (this.socket == null) {
          this.destroyed = true;
          return;
        }
        if (options2.force || this.timedOut) {
          this.socket.destroy();
          this.destroyed = true;
          if (typeof callback === "function")
            callback(null, null);
          return;
        }
        this.socket.end((err) => {
          this.destroyed = true;
          if (typeof callback === "function")
            callback(err, null);
        });
      }
      write(buffer) {
        if (this.logger.isDebug()) {
          if (!Array.isArray(buffer)) {
            this.logger.debug(`writing buffer [ ${buffer.length} ] to ${this.address}`);
          } else {
            for (let i = 0; i < buffer.length; i++)
              this.logger.debug(`writing buffer [ ${buffer[i].length} ] to ${this.address}`);
          }
        }
        if (this.socket.destroyed === false) {
          if (!Array.isArray(buffer)) {
            this.socket.write(buffer, "binary");
            return true;
          }
          for (let i = 0; i < buffer.length; i++) {
            this.socket.write(buffer[i], "binary");
          }
          return true;
        }
        return false;
      }
      toString() {
        return "" + this.id;
      }
      toJSON() {
        return { id: this.id, host: this.host, port: this.port };
      }
      isConnected() {
        if (this.destroyed)
          return false;
        return !this.socket.destroyed && this.socket.writable;
      }
      command(ns, command, options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        const conn = this;
        const socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        const bson = conn.options.bson;
        const query = new Query(bson, ns, command, {
          numberToSkip: 0,
          numberToReturn: 1
        });
        const noop3 = () => {
        };
        function _callback(err, result) {
          callback(err, result);
          callback = noop3;
        }
        function errorHandler2(err) {
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          if (err == null) {
            err = new MongoError(`runCommand failed for connection to '${conn.address}'`);
          }
          conn.on("error", noop3);
          _callback(err);
        }
        function messageHandler(msg) {
          if (msg.responseTo !== query.requestId) {
            return;
          }
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          msg.parse({ promoteValues: true });
          const response = msg.documents[0];
          if (response.ok === 0 || response.$err || response.errmsg || response.code) {
            _callback(new MongoError(response));
            return;
          }
          _callback(void 0, new CommandResult(response, this, msg));
        }
        conn.setSocketTimeout(socketTimeout);
        CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.once(eventName, errorHandler2));
        conn.on("message", messageHandler);
        conn.write(query.toBin());
      }
    };
    var CONNECTION_ERROR_EVENTS = ["error", "close", "timeout", "parseError"];
    function deleteConnection(id) {
      delete connections[id];
      if (connectionAccountingSpy) {
        connectionAccountingSpy.deleteConnection(id);
      }
    }
    function addConnection(id, connection) {
      connections[id] = connection;
      if (connectionAccountingSpy) {
        connectionAccountingSpy.addConnection(id, connection);
      }
    }
    function errorHandler(conn) {
      return function(err) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);
        }
        conn.emit("error", new MongoNetworkError(err), conn);
      };
    }
    function timeoutHandler(conn) {
      return function() {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);
        }
        conn.timedOut = true;
        conn.emit("timeout", new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {
          beforeHandshake: conn.ismaster == null
        }), conn);
      };
    }
    function closeHandler(conn) {
      return function(hadError) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);
        }
        if (!hadError) {
          conn.emit("close", new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);
        }
      };
    }
    function processMessage(conn, message) {
      const msgHeader = parseHeader(message);
      if (msgHeader.opCode !== OP_COMPRESSED) {
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response2;
        conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);
        return;
      }
      msgHeader.fromCompressed = true;
      let index2 = MESSAGE_HEADER_SIZE;
      msgHeader.opCode = message.readInt32LE(index2);
      index2 += 4;
      msgHeader.length = message.readInt32LE(index2);
      index2 += 4;
      const compressorID = message[index2];
      index2++;
      decompress(compressorID, message.slice(index2), (err, decompressedMsgBody) => {
        if (err) {
          conn.emit("error", err);
          return;
        }
        if (decompressedMsgBody.length !== msgHeader.length) {
          conn.emit("error", new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
          return;
        }
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response2;
        conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);
      });
    }
    function dataHandler(conn) {
      return function(data) {
        while (data.length > 0) {
          if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {
            const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;
            if (remainingBytesToRead > data.length) {
              data.copy(conn.buffer, conn.bytesRead);
              conn.bytesRead = conn.bytesRead + data.length;
              data = Buffer2.alloc(0);
            } else {
              data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);
              data = data.slice(remainingBytesToRead);
              const emitBuffer = conn.buffer;
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
              processMessage(conn, emitBuffer);
            }
          } else {
            if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {
              if (conn.stubBuffer.length + data.length > 4) {
                const newData = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newData, 0);
                data.copy(newData, conn.stubBuffer.length);
                data = newData;
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
              } else {
                const newStubBuffer = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newStubBuffer, 0);
                data.copy(newStubBuffer, conn.stubBuffer.length);
                data = Buffer2.alloc(0);
              }
            } else {
              if (data.length > 4) {
                const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
                if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: "",
                    bin: conn.buffer,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: conn.bytesRead,
                      stubBuffer: conn.stubBuffer
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  return;
                }
                if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {
                  conn.buffer = Buffer2.alloc(sizeOfMessage);
                  data.copy(conn.buffer, 0);
                  conn.bytesRead = data.length;
                  conn.sizeOfMessage = sizeOfMessage;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {
                  const emitBuffer = data;
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                  processMessage(conn, emitBuffer);
                } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: null,
                    bin: data,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: 0,
                      buffer: null,
                      stubBuffer: null
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else {
                  const emitBuffer = data.slice(0, sizeOfMessage);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = data.slice(sizeOfMessage);
                  processMessage(conn, emitBuffer);
                }
              } else {
                conn.stubBuffer = Buffer2.alloc(data.length);
                data.copy(conn.stubBuffer, 0);
                data = Buffer2.alloc(0);
              }
            }
          }
        }
      };
    }
    module2.exports = Connection;
  }
});

// node_modules/mongodb/lib/command_utils.js
var require_command_utils = __commonJS({
  "node_modules/mongodb/lib/command_utils.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Msg = require_msg().Msg;
    var KillCursor = require_commands().KillCursor;
    var GetMore = require_commands().GetMore;
    var deepCopy = require_utils4().deepCopy;
    var SENSITIVE_COMMANDS = new Set([
      "authenticate",
      "saslStart",
      "saslContinue",
      "getnonce",
      "createUser",
      "updateUser",
      "copydbgetnonce",
      "copydbsaslstart",
      "copydb"
    ]);
    var HELLO_COMMANDS = new Set(["hello", "ismaster", "isMaster"]);
    var LEGACY_FIND_QUERY_MAP = {
      $query: "filter",
      $orderby: "sort",
      $hint: "hint",
      $comment: "comment",
      $maxScan: "maxScan",
      $max: "max",
      $min: "min",
      $returnKey: "returnKey",
      $showDiskLoc: "showRecordId",
      $maxTimeMS: "maxTimeMS",
      $snapshot: "snapshot"
    };
    var LEGACY_FIND_OPTIONS_MAP = {
      numberToSkip: "skip",
      numberToReturn: "batchSize",
      returnFieldsSelector: "projection"
    };
    var OP_QUERY_KEYS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "partial",
      "exhaust"
    ];
    var collectionName = (command) => command.ns.split(".")[1];
    var shouldRedactCommand = (commandName, cmd) => SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && !!cmd.speculativeAuthenticate;
    var extractCommand = (command) => {
      let extractedCommand;
      if (command instanceof GetMore) {
        extractedCommand = {
          getMore: deepCopy(command.cursorId),
          collection: collectionName(command),
          batchSize: command.numberToReturn
        };
      } else if (command instanceof KillCursor) {
        extractedCommand = {
          killCursors: collectionName(command),
          cursors: deepCopy(command.cursorIds)
        };
      } else if (command instanceof Msg) {
        extractedCommand = deepCopy(command.command);
      } else if (command.query && command.query.$query) {
        let result;
        if (command.ns === "admin.$cmd") {
          result = Object.assign({}, command.query.$query);
        } else {
          result = { find: collectionName(command) };
          Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
            if (typeof command.query[key] !== "undefined")
              result[LEGACY_FIND_QUERY_MAP[key]] = deepCopy(command.query[key]);
          });
        }
        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
          if (typeof command[key] !== "undefined")
            result[LEGACY_FIND_OPTIONS_MAP[key]] = deepCopy(command[key]);
        });
        OP_QUERY_KEYS.forEach((key) => {
          if (command[key])
            result[key] = command[key];
        });
        if (typeof command.pre32Limit !== "undefined") {
          result.limit = command.pre32Limit;
        }
        if (command.query.$explain) {
          extractedCommand = { explain: result };
        } else {
          extractedCommand = result;
        }
      } else {
        extractedCommand = deepCopy(command.query || command);
      }
      const commandName = Object.keys(extractedCommand)[0];
      return {
        cmd: extractedCommand,
        name: commandName,
        shouldRedact: shouldRedactCommand(commandName, extractedCommand)
      };
    };
    module2.exports = {
      extractCommand
    };
  }
});

// node_modules/mongodb/lib/core/connection/apm.js
var require_apm = __commonJS({
  "node_modules/mongodb/lib/core/connection/apm.js"(exports2, module2) {
    init_shims();
    "use strict";
    var KillCursor = require_commands().KillCursor;
    var GetMore = require_commands().GetMore;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var extractCommand = require_command_utils().extractCommand;
    var namespace = (command) => command.ns;
    var databaseName = (command) => command.ns.split(".")[0];
    var generateConnectionId = (pool) => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;
    var isLegacyPool = (pool) => pool.s && pool.queue;
    var extractReply = (command, reply) => {
      if (command instanceof GetMore) {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command),
            nextBatch: reply.message.documents
          }
        };
      }
      if (command instanceof KillCursor) {
        return {
          ok: 1,
          cursorsUnknown: command.cursorIds
        };
      }
      if (command.query && typeof command.query.$query !== "undefined") {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command),
            firstBatch: reply.message.documents
          }
        };
      }
      return reply && reply.result ? reply.result : reply;
    };
    var extractConnectionDetails = (pool) => {
      if (isLegacyPool(pool)) {
        return {
          connectionId: generateConnectionId(pool)
        };
      }
      const connection = pool;
      return {
        address: connection.address,
        connectionId: connection.id
      };
    };
    var CommandStartedEvent = class {
      constructor(pool, command) {
        const extractedCommand = extractCommand(command);
        const commandName = extractedCommand.name;
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          databaseName: databaseName(command),
          commandName,
          command: extractedCommand.shouldRedact ? {} : extractedCommand.cmd
        });
      }
    };
    var CommandSucceededEvent = class {
      constructor(pool, command, reply, started) {
        const extractedCommand = extractCommand(command);
        const commandName = extractedCommand.name;
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          reply: extractedCommand.shouldRedact ? {} : extractReply(command, reply)
        });
      }
    };
    var CommandFailedEvent = class {
      constructor(pool, command, error2, started) {
        const extractedCommand = extractCommand(command);
        const commandName = extractedCommand.name;
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          failure: extractedCommand.shouldRedact ? {} : error2
        });
      }
    };
    module2.exports = {
      CommandStartedEvent,
      CommandSucceededEvent,
      CommandFailedEvent
    };
  }
});

// node_modules/mongodb/lib/core/auth/auth_provider.js
var require_auth_provider = __commonJS({
  "node_modules/mongodb/lib/core/auth/auth_provider.js"(exports2, module2) {
    init_shims();
    "use strict";
    var AuthContext = class {
      constructor(connection, credentials, options2) {
        this.connection = connection;
        this.credentials = credentials;
        this.options = options2;
      }
    };
    var AuthProvider = class {
      constructor(bson) {
        this.bson = bson;
      }
      prepare(handshakeDoc, context, callback) {
        callback(void 0, handshakeDoc);
      }
      auth(context, callback) {
        callback(new TypeError("`auth` method must be overridden by subclass"));
      }
    };
    module2.exports = { AuthContext, AuthProvider };
  }
});

// node_modules/mongodb/lib/core/auth/mongocr.js
var require_mongocr = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongocr.js"(exports2, module2) {
    init_shims();
    "use strict";
    var crypto = require("crypto");
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCR = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const source = credentials.source;
        connection.command(`${source}.$cmd`, { getnonce: 1 }, (err, result) => {
          let nonce = null;
          let key = null;
          if (err == null) {
            const r = result.result;
            nonce = r.nonce;
            let md5 = crypto.createHash("md5");
            md5.update(username + ":mongo:" + password, "utf8");
            const hash_password = md5.digest("hex");
            md5 = crypto.createHash("md5");
            md5.update(nonce + username + hash_password, "utf8");
            key = md5.digest("hex");
          }
          const authenticateCommand = {
            authenticate: 1,
            user: username,
            nonce,
            key
          };
          connection.command(`${source}.$cmd`, authenticateCommand, callback);
        });
      }
    };
    module2.exports = MongoCR;
  }
});

// node_modules/mongodb/lib/core/auth/x509.js
var require_x509 = __commonJS({
  "node_modules/mongodb/lib/core/auth/x509.js"(exports2, module2) {
    init_shims();
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var X509 = class extends AuthProvider {
      prepare(handshakeDoc, authContext, callback) {
        const credentials = authContext.credentials;
        Object.assign(handshakeDoc, {
          speculativeAuthenticate: x509AuthenticateCommand(credentials)
        });
        callback(void 0, handshakeDoc);
      }
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const response = authContext.response;
        if (response.speculativeAuthenticate) {
          return callback();
        }
        connection.command("$external.$cmd", x509AuthenticateCommand(credentials), callback);
      }
    };
    function x509AuthenticateCommand(credentials) {
      const command = { authenticate: 1, mechanism: "MONGODB-X509" };
      if (credentials.username) {
        Object.assign(command, { user: credentials.username });
      }
      return command;
    }
    module2.exports = X509;
  }
});

// node_modules/mongodb/lib/core/auth/plain.js
var require_plain = __commonJS({
  "node_modules/mongodb/lib/core/auth/plain.js"(exports2, module2) {
    init_shims();
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var AuthProvider = require_auth_provider().AuthProvider;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var Plain = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const payload = new Binary2(`\0${username}\0${password}`);
        const command = {
          saslStart: 1,
          mechanism: "PLAIN",
          payload,
          autoAuthorize: 1
        };
        connection.command("$external.$cmd", command, callback);
      }
    };
    module2.exports = Plain;
  }
});

// node_modules/mongodb/lib/core/auth/gssapi.js
var require_gssapi = __commonJS({
  "node_modules/mongodb/lib/core/auth/gssapi.js"(exports2, module2) {
    init_shims();
    "use strict";
    var dns = require("dns");
    var AuthProvider = require_auth_provider().AuthProvider;
    var retrieveKerberos = require_utils2().retrieveKerberos;
    var MongoError = require_error().MongoError;
    var kerberos;
    var GSSAPI = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (credentials == null)
          return callback(new MongoError("credentials required"));
        const username = credentials.username;
        function externalCommand(command, cb) {
          return connection.command("$external.$cmd", command, cb);
        }
        makeKerberosClient(authContext, (err, client) => {
          if (err)
            return callback(err);
          if (client == null)
            return callback(new MongoError("gssapi client missing"));
          client.step("", (err2, payload) => {
            if (err2)
              return callback(err2);
            externalCommand(saslStart(payload), (err3, response) => {
              if (err3)
                return callback(err3);
              const result = response.result;
              negotiate(client, 10, result.payload, (err4, payload2) => {
                if (err4)
                  return callback(err4);
                externalCommand(saslContinue(payload2, result.conversationId), (err5, response2) => {
                  if (err5)
                    return callback(err5);
                  const result2 = response2.result;
                  finalize(client, username, result2.payload, (err6, payload3) => {
                    if (err6)
                      return callback(err6);
                    externalCommand({
                      saslContinue: 1,
                      conversationId: result2.conversationId,
                      payload: payload3
                    }, (err7, result3) => {
                      if (err7)
                        return callback(err7);
                      callback(void 0, result3);
                    });
                  });
                });
              });
            });
          });
        });
      }
    };
    module2.exports = GSSAPI;
    function makeKerberosClient(authContext, callback) {
      const host = authContext.options.host;
      const port = authContext.options.port;
      const credentials = authContext.credentials;
      if (!host || !port || !credentials) {
        return callback(new MongoError(`Connection must specify: ${host ? "host" : ""}, ${port ? "port" : ""}, ${credentials ? "host" : "credentials"}.`));
      }
      if (kerberos == null) {
        try {
          kerberos = retrieveKerberos();
        } catch (e) {
          return callback(e);
        }
      }
      const username = credentials.username;
      const password = credentials.password;
      const mechanismProperties = credentials.mechanismProperties;
      const serviceName = mechanismProperties["gssapiservicename"] || mechanismProperties["gssapiServiceName"] || "mongodb";
      performGssapiCanonicalizeHostName(host, mechanismProperties, (err, host2) => {
        if (err)
          return callback(err);
        const initOptions = {};
        if (password != null) {
          Object.assign(initOptions, { user: username, password });
        }
        kerberos.initializeClient(`${serviceName}${process.platform === "win32" ? "/" : "@"}${host2}`, initOptions, (err2, client) => {
          if (err2)
            return callback(new MongoError(err2));
          callback(null, client);
        });
      });
    }
    function saslStart(payload) {
      return {
        saslStart: 1,
        mechanism: "GSSAPI",
        payload,
        autoAuthorize: 1
      };
    }
    function saslContinue(payload, conversationId) {
      return {
        saslContinue: 1,
        conversationId,
        payload
      };
    }
    function negotiate(client, retries, payload, callback) {
      client.step(payload, (err, response) => {
        if (err && retries === 0)
          return callback(err);
        if (err)
          return negotiate(client, retries - 1, payload, callback);
        callback(void 0, response || "");
      });
    }
    function finalize(client, user2, payload, callback) {
      client.unwrap(payload, (err, response) => {
        if (err)
          return callback(err);
        client.wrap(response || "", { user: user2 }, (err2, wrapped) => {
          if (err2)
            return callback(err2);
          callback(void 0, wrapped);
        });
      });
    }
    function performGssapiCanonicalizeHostName(host, mechanismProperties, callback) {
      const canonicalizeHostName = typeof mechanismProperties.gssapiCanonicalizeHostName === "boolean" ? mechanismProperties.gssapiCanonicalizeHostName : false;
      if (!canonicalizeHostName)
        return callback(void 0, host);
      dns.resolveCname(host, (err, r) => {
        if (err)
          return callback(err);
        if (Array.isArray(r) && r.length > 0) {
          return callback(void 0, r[0]);
        }
        callback(void 0, host);
      });
    }
  }
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS({
  "node_modules/memory-pager/index.js"(exports2, module2) {
    init_shims();
    module2.exports = Pager;
    function Pager(pageSize, opts) {
      if (!(this instanceof Pager))
        return new Pager(pageSize, opts);
      this.length = 0;
      this.updates = [];
      this.path = new Uint16Array(4);
      this.pages = new Array(32768);
      this.maxPages = this.pages.length;
      this.level = 0;
      this.pageSize = pageSize || 1024;
      this.deduplicate = opts ? opts.deduplicate : null;
      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
    }
    Pager.prototype.updated = function(page) {
      while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
        page.deduplicate++;
        if (page.deduplicate === this.deduplicate.length) {
          page.deduplicate = 0;
          if (page.buffer.equals && page.buffer.equals(this.deduplicate))
            page.buffer = this.deduplicate;
          break;
        }
      }
      if (page.updated || !this.updates)
        return;
      page.updated = true;
      this.updates.push(page);
    };
    Pager.prototype.lastUpdate = function() {
      if (!this.updates || !this.updates.length)
        return null;
      var page = this.updates.pop();
      page.updated = false;
      return page;
    };
    Pager.prototype._array = function(i, noAllocate) {
      if (i >= this.maxPages) {
        if (noAllocate)
          return;
        grow(this, i);
      }
      factor(i, this.path);
      var arr = this.pages;
      for (var j = this.level; j > 0; j--) {
        var p = this.path[j];
        var next = arr[p];
        if (!next) {
          if (noAllocate)
            return;
          next = arr[p] = new Array(32768);
        }
        arr = next;
      }
      return arr;
    };
    Pager.prototype.get = function(i, noAllocate) {
      var arr = this._array(i, noAllocate);
      var first = this.path[0];
      var page = arr && arr[first];
      if (!page && !noAllocate) {
        page = arr[first] = new Page(i, alloc(this.pageSize));
        if (i >= this.length)
          this.length = i + 1;
      }
      if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
        page.buffer = copy(page.buffer);
        page.deduplicate = 0;
      }
      return page;
    };
    Pager.prototype.set = function(i, buf) {
      var arr = this._array(i, false);
      var first = this.path[0];
      if (i >= this.length)
        this.length = i + 1;
      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
        arr[first] = void 0;
        return;
      }
      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
        buf = this.deduplicate;
      }
      var page = arr[first];
      var b = truncate(buf, this.pageSize);
      if (page)
        page.buffer = b;
      else
        arr[first] = new Page(i, b);
    };
    Pager.prototype.toBuffer = function() {
      var list = new Array(this.length);
      var empty2 = alloc(this.pageSize);
      var ptr = 0;
      while (ptr < list.length) {
        var arr = this._array(ptr, true);
        for (var i = 0; i < 32768 && ptr < list.length; i++) {
          list[ptr++] = arr && arr[i] ? arr[i].buffer : empty2;
        }
      }
      return Buffer.concat(list);
    };
    function grow(pager, index2) {
      while (pager.maxPages < index2) {
        var old = pager.pages;
        pager.pages = new Array(32768);
        pager.pages[0] = old;
        pager.level++;
        pager.maxPages *= 32768;
      }
    }
    function truncate(buf, len) {
      if (buf.length === len)
        return buf;
      if (buf.length > len)
        return buf.slice(0, len);
      var cpy = alloc(len);
      buf.copy(cpy);
      return cpy;
    }
    function alloc(size) {
      if (Buffer.alloc)
        return Buffer.alloc(size);
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
    function copy(buf) {
      var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
      buf.copy(cpy);
      return cpy;
    }
    function Page(i, buf) {
      this.offset = i * buf.length;
      this.buffer = buf;
      this.updated = false;
      this.deduplicate = 0;
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS({
  "node_modules/sparse-bitfield/index.js"(exports2, module2) {
    init_shims();
    var pager = require_memory_pager();
    module2.exports = Bitfield;
    function Bitfield(opts) {
      if (!(this instanceof Bitfield))
        return new Bitfield(opts);
      if (!opts)
        opts = {};
      if (Buffer.isBuffer(opts))
        opts = { buffer: opts };
      this.pageOffset = opts.pageOffset || 0;
      this.pageSize = opts.pageSize || 1024;
      this.pages = opts.pages || pager(this.pageSize);
      this.byteLength = this.pages.length * this.pageSize;
      this.length = 8 * this.byteLength;
      if (!powerOfTwo(this.pageSize))
        throw new Error("The page size should be a power of two");
      this._trackUpdates = !!opts.trackUpdates;
      this._pageMask = this.pageSize - 1;
      if (opts.buffer) {
        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
        }
        this.byteLength = opts.buffer.length;
        this.length = 8 * this.byteLength;
      }
    }
    Bitfield.prototype.get = function(i) {
      var o = i & 7;
      var j = (i - o) / 8;
      return !!(this.getByte(j) & 128 >> o);
    };
    Bitfield.prototype.getByte = function(i) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, true);
      return page ? page.buffer[o + this.pageOffset] : 0;
    };
    Bitfield.prototype.set = function(i, v) {
      var o = i & 7;
      var j = (i - o) / 8;
      var b = this.getByte(j);
      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
    };
    Bitfield.prototype.toBuffer = function() {
      var all = alloc(this.pages.length * this.pageSize);
      for (var i = 0; i < this.pages.length; i++) {
        var next = this.pages.get(i, true);
        var allOffset = i * this.pageSize;
        if (next)
          next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
      }
      return all;
    };
    Bitfield.prototype.setByte = function(i, b) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, false);
      o += this.pageOffset;
      if (page.buffer[o] === b)
        return false;
      page.buffer[o] = b;
      if (i >= this.byteLength) {
        this.byteLength = i + 1;
        this.length = this.byteLength * 8;
      }
      if (this._trackUpdates)
        this.pages.updated(page);
      return true;
    };
    function alloc(n) {
      if (Buffer.alloc)
        return Buffer.alloc(n);
      var b = new Buffer(n);
      b.fill(0);
      return b;
    }
    function powerOfTwo(x) {
      return !(x & x - 1);
    }
  }
});

// node_modules/saslprep/lib/memory-code-points.js
var require_memory_code_points = __commonJS({
  "node_modules/saslprep/lib/memory-code-points.js"(exports2, module2) {
    init_shims();
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var bitfield = require_sparse_bitfield();
    var memory = fs.readFileSync(path.resolve(__dirname, "../code-points.mem"));
    var offset = 0;
    function read2() {
      const size = memory.readUInt32BE(offset);
      offset += 4;
      const codepoints = memory.slice(offset, offset + size);
      offset += size;
      return bitfield({ buffer: codepoints });
    }
    var unassigned_code_points = read2();
    var commonly_mapped_to_nothing = read2();
    var non_ASCII_space_characters = read2();
    var prohibited_characters = read2();
    var bidirectional_r_al = read2();
    var bidirectional_l = read2();
    module2.exports = {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    };
  }
});

// node_modules/saslprep/index.js
var require_saslprep = __commonJS({
  "node_modules/saslprep/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    } = require_memory_code_points();
    module2.exports = saslprep;
    var mapping2space = non_ASCII_space_characters;
    var mapping2nothing = commonly_mapped_to_nothing;
    var getCodePoint = (character) => character.codePointAt(0);
    var first = (x) => x[0];
    var last = (x) => x[x.length - 1];
    function toCodePoints(input) {
      const codepoints = [];
      const size = input.length;
      for (let i = 0; i < size; i += 1) {
        const before = input.charCodeAt(i);
        if (before >= 55296 && before <= 56319 && size > i + 1) {
          const next = input.charCodeAt(i + 1);
          if (next >= 56320 && next <= 57343) {
            codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
            i += 1;
            continue;
          }
        }
        codepoints.push(before);
      }
      return codepoints;
    }
    function saslprep(input, opts = {}) {
      if (typeof input !== "string") {
        throw new TypeError("Expected string.");
      }
      if (input.length === 0) {
        return "";
      }
      const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
      const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
      const normalized_map = toCodePoints(normalized_input);
      const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
      if (hasProhibited) {
        throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
      }
      if (opts.allowUnassigned !== true) {
        const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
        if (hasUnassigned) {
          throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
        }
      }
      const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
      const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
      if (hasBidiRAL && hasBidiL) {
        throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
      const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
      if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
        throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      return normalized_input;
    }
  }
});

// node_modules/mongodb/lib/core/auth/scram.js
var require_scram = __commonJS({
  "node_modules/mongodb/lib/core/auth/scram.js"(exports2, module2) {
    init_shims();
    "use strict";
    var crypto = require("crypto");
    var Buffer2 = require_safe_buffer().Buffer;
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var AuthProvider = require_auth_provider().AuthProvider;
    var emitWarningOnce = require_utils4().emitWarning;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var saslprep;
    try {
      saslprep = require_saslprep();
    } catch (e) {
    }
    var ScramSHA = class extends AuthProvider {
      constructor(bson, cryptoMethod) {
        super(bson);
        this.cryptoMethod = cryptoMethod || "sha1";
      }
      prepare(handshakeDoc, authContext, callback) {
        const cryptoMethod = this.cryptoMethod;
        if (cryptoMethod === "sha256" && saslprep == null) {
          emitWarningOnce("Warning: no saslprep library specified. Passwords will not be sanitized");
        }
        crypto.randomBytes(24, (err, nonce) => {
          if (err) {
            return callback(err);
          }
          Object.assign(authContext, { nonce });
          const credentials = authContext.credentials;
          const request = Object.assign({}, handshakeDoc, {
            speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
              db: credentials.source
            })
          });
          callback(void 0, request);
        });
      }
      auth(authContext, callback) {
        const response = authContext.response;
        if (response && response.speculativeAuthenticate) {
          continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);
          return;
        }
        executeScram(this.cryptoMethod, authContext, callback);
      }
    };
    function cleanUsername(username) {
      return username.replace("=", "=3D").replace(",", "=2C");
    }
    function clientFirstMessageBare(username, nonce) {
      return Buffer2.concat([
        Buffer2.from("n=", "utf8"),
        Buffer2.from(username, "utf8"),
        Buffer2.from(",r=", "utf8"),
        Buffer2.from(nonce.toString("base64"), "utf8")
      ]);
    }
    function makeFirstMessage(cryptoMethod, credentials, nonce) {
      const username = cleanUsername(credentials.username);
      const mechanism = cryptoMethod === "sha1" ? "SCRAM-SHA-1" : "SCRAM-SHA-256";
      return {
        saslStart: 1,
        mechanism,
        payload: new Binary2(Buffer2.concat([Buffer2.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
        autoAuthorize: 1,
        options: { skipEmptyExchange: true }
      };
    }
    function executeScram(cryptoMethod, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
      connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        continueScramConversation(cryptoMethod, result.result, authContext, callback);
      });
    }
    function continueScramConversation(cryptoMethod, response, authContext, callback) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const username = cleanUsername(credentials.username);
      const password = credentials.password;
      let processedPassword;
      if (cryptoMethod === "sha256") {
        processedPassword = saslprep ? saslprep(password) : password;
      } else {
        try {
          processedPassword = passwordDigest(username, password);
        } catch (e) {
          return callback(e);
        }
      }
      const payload = Buffer2.isBuffer(response.payload) ? new Binary2(response.payload) : response.payload;
      const dict = parsePayload(payload.value());
      const iterations = parseInt(dict.i, 10);
      if (iterations && iterations < 4096) {
        callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);
        return;
      }
      const salt = dict.s;
      const rnonce = dict.r;
      if (rnonce.startsWith("nonce")) {
        callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);
        return;
      }
      const withoutProof = `c=biws,r=${rnonce}`;
      const saltedPassword = HI(processedPassword, Buffer2.from(salt, "base64"), iterations, cryptoMethod);
      const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
      const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
      const storedKey = H(cryptoMethod, clientKey);
      const authMessage = [
        clientFirstMessageBare(username, nonce),
        payload.value().toString("base64"),
        withoutProof
      ].join(",");
      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
      const clientProof = `p=${xor(clientKey, clientSignature)}`;
      const clientFinal = [withoutProof, clientProof].join(",");
      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
      const saslContinueCmd = {
        saslContinue: 1,
        conversationId: response.conversationId,
        payload: new Binary2(Buffer2.from(clientFinal))
      };
      connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        const r = result.result;
        const parsedResponse = parsePayload(r.payload.value());
        if (!compareDigest(Buffer2.from(parsedResponse.v, "base64"), serverSignature)) {
          callback(new MongoError("Server returned an invalid signature"));
          return;
        }
        if (!r || r.done !== false) {
          return callback(err, r);
        }
        const retrySaslContinueCmd = {
          saslContinue: 1,
          conversationId: r.conversationId,
          payload: Buffer2.alloc(0)
        };
        connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);
      });
    }
    function parsePayload(payload) {
      const dict = {};
      const parts = payload.split(",");
      for (let i = 0; i < parts.length; i++) {
        const valueParts = parts[i].split("=");
        dict[valueParts[0]] = valueParts[1];
      }
      return dict;
    }
    function passwordDigest(username, password) {
      if (typeof username !== "string") {
        throw new MongoError("username must be a string");
      }
      if (typeof password !== "string") {
        throw new MongoError("password must be a string");
      }
      if (password.length === 0) {
        throw new MongoError("password cannot be empty");
      }
      const md5 = crypto.createHash("md5");
      md5.update(`${username}:mongo:${password}`, "utf8");
      return md5.digest("hex");
    }
    function xor(a, b) {
      if (!Buffer2.isBuffer(a)) {
        a = Buffer2.from(a);
      }
      if (!Buffer2.isBuffer(b)) {
        b = Buffer2.from(b);
      }
      const length = Math.max(a.length, b.length);
      const res = [];
      for (let i = 0; i < length; i += 1) {
        res.push(a[i] ^ b[i]);
      }
      return Buffer2.from(res).toString("base64");
    }
    function H(method, text) {
      return crypto.createHash(method).update(text).digest();
    }
    function HMAC(method, key, text) {
      return crypto.createHmac(method, key).update(text).digest();
    }
    var _hiCache = {};
    var _hiCacheCount = 0;
    function _hiCachePurge() {
      _hiCache = {};
      _hiCacheCount = 0;
    }
    var hiLengthMap = {
      sha256: 32,
      sha1: 20
    };
    function HI(data, salt, iterations, cryptoMethod) {
      const key = [data, salt.toString("base64"), iterations].join("_");
      if (_hiCache[key] !== void 0) {
        return _hiCache[key];
      }
      const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
      if (_hiCacheCount >= 200) {
        _hiCachePurge();
      }
      _hiCache[key] = saltedData;
      _hiCacheCount += 1;
      return saltedData;
    }
    function compareDigest(lhs, rhs) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      if (typeof crypto.timingSafeEqual === "function") {
        return crypto.timingSafeEqual(lhs, rhs);
      }
      let result = 0;
      for (let i = 0; i < lhs.length; i++) {
        result |= lhs[i] ^ rhs[i];
      }
      return result === 0;
    }
    function resolveError(err, result) {
      if (err)
        return err;
      const r = result.result;
      if (r.$err || r.errmsg)
        return new MongoError(r);
    }
    var ScramSHA1 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha1");
      }
    };
    var ScramSHA256 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha256");
      }
    };
    module2.exports = { ScramSHA1, ScramSHA256 };
  }
});

// node_modules/mongodb/lib/core/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongo_credentials.js"(exports2, module2) {
    init_shims();
    "use strict";
    function getDefaultAuthMechanism(ismaster) {
      if (ismaster) {
        if (Array.isArray(ismaster.saslSupportedMechs)) {
          return ismaster.saslSupportedMechs.indexOf("SCRAM-SHA-256") >= 0 ? "scram-sha-256" : "scram-sha-1";
        }
        if (ismaster.maxWireVersion >= 3) {
          return "scram-sha-1";
        }
      }
      return "mongocr";
    }
    var MongoCredentials = class {
      constructor(options2) {
        options2 = options2 || {};
        this.username = options2.username;
        this.password = options2.password;
        this.source = options2.source || options2.db;
        this.mechanism = options2.mechanism || "default";
        this.mechanismProperties = options2.mechanismProperties || {};
        if (/MONGODB-AWS/i.test(this.mechanism)) {
          if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
            this.username = process.env.AWS_ACCESS_KEY_ID;
          }
          if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
            this.password = process.env.AWS_SECRET_ACCESS_KEY;
          }
          if (!this.mechanismProperties.AWS_SESSION_TOKEN && process.env.AWS_SESSION_TOKEN) {
            this.mechanismProperties.AWS_SESSION_TOKEN = process.env.AWS_SESSION_TOKEN;
          }
        }
        Object.freeze(this.mechanismProperties);
        Object.freeze(this);
      }
      equals(other) {
        return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
      }
      resolveAuthMechanism(ismaster) {
        if (/DEFAULT/i.test(this.mechanism)) {
          return new MongoCredentials({
            username: this.username,
            password: this.password,
            source: this.source,
            mechanism: getDefaultAuthMechanism(ismaster),
            mechanismProperties: this.mechanismProperties
          });
        }
        return this;
      }
    };
    module2.exports = { MongoCredentials };
  }
});

// node_modules/mongodb/lib/core/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongodb_aws.js"(exports2, module2) {
    init_shims();
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCredentials = require_mongo_credentials().MongoCredentials;
    var MongoError = require_error().MongoError;
    var crypto = require("crypto");
    var http2 = require("http");
    var maxWireVersion = require_utils2().maxWireVersion;
    var url = require("url");
    var aws4;
    try {
      aws4 = require("aws4");
    } catch (e) {
    }
    var ASCII_N = 110;
    var AWS_RELATIVE_URI = "http://169.254.170.2";
    var AWS_EC2_URI = "http://169.254.169.254";
    var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
    var MongoDBAWS = class extends AuthProvider {
      auth(authContext, callback) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (maxWireVersion(connection) < 9) {
          callback(new MongoError("MONGODB-AWS authentication requires MongoDB version 4.4 or later"));
          return;
        }
        if (aws4 == null) {
          callback(new MongoError("MONGODB-AWS authentication requires the `aws4` module, please install it as a dependency of your project"));
          return;
        }
        if (credentials.username == null) {
          makeTempCredentials(credentials, (err, tempCredentials) => {
            if (err)
              return callback(err);
            authContext.credentials = tempCredentials;
            this.auth(authContext, callback);
          });
          return;
        }
        const username = credentials.username;
        const password = credentials.password;
        const db = credentials.source;
        const token2 = credentials.mechanismProperties.AWS_SESSION_TOKEN;
        const bson = this.bson;
        crypto.randomBytes(32, (err, nonce) => {
          if (err) {
            callback(err);
            return;
          }
          const saslStart = {
            saslStart: 1,
            mechanism: "MONGODB-AWS",
            payload: bson.serialize({ r: nonce, p: ASCII_N })
          };
          connection.command(`${db}.$cmd`, saslStart, (err2, result) => {
            if (err2)
              return callback(err2);
            const res = result.result;
            const serverResponse = bson.deserialize(res.payload.buffer);
            const host = serverResponse.h;
            const serverNonce = serverResponse.s.buffer;
            if (serverNonce.length !== 64) {
              callback(new MongoError(`Invalid server nonce length ${serverNonce.length}, expected 64`));
              return;
            }
            if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
              callback(new MongoError("Server nonce does not begin with client nonce"));
              return;
            }
            if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
              callback(new MongoError(`Server returned an invalid host: "${host}"`));
              return;
            }
            const body = "Action=GetCallerIdentity&Version=2011-06-15";
            const options2 = aws4.sign({
              method: "POST",
              host,
              region: deriveRegion(serverResponse.h),
              service: "sts",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Content-Length": body.length,
                "X-MongoDB-Server-Nonce": serverNonce.toString("base64"),
                "X-MongoDB-GS2-CB-Flag": "n"
              },
              path: "/",
              body
            }, {
              accessKeyId: username,
              secretAccessKey: password,
              token: token2
            });
            const authorization = options2.headers.Authorization;
            const date = options2.headers["X-Amz-Date"];
            const payload = { a: authorization, d: date };
            if (token2) {
              payload.t = token2;
            }
            const saslContinue = {
              saslContinue: 1,
              conversationId: 1,
              payload: bson.serialize(payload)
            };
            connection.command(`${db}.$cmd`, saslContinue, (err3) => {
              if (err3)
                return callback(err3);
              callback();
            });
          });
        });
      }
    };
    function makeTempCredentials(credentials, callback) {
      function done(creds) {
        if (creds.AccessKeyId == null || creds.SecretAccessKey == null || creds.Token == null) {
          callback(new MongoError("Could not obtain temporary MONGODB-AWS credentials"));
          return;
        }
        callback(void 0, new MongoCredentials({
          username: creds.AccessKeyId,
          password: creds.SecretAccessKey,
          source: credentials.source,
          mechanism: "MONGODB-AWS",
          mechanismProperties: {
            AWS_SESSION_TOKEN: creds.Token
          }
        }));
      }
      if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
        request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, (err, res) => {
          if (err)
            return callback(err);
          done(res);
        });
        return;
      }
      request(`${AWS_EC2_URI}/latest/api/token`, { method: "PUT", json: false, headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 } }, (err, token2) => {
        if (err)
          return callback(err);
        request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, { json: false, headers: { "X-aws-ec2-metadata-token": token2 } }, (err2, roleName) => {
          if (err2)
            return callback(err2);
          request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, { headers: { "X-aws-ec2-metadata-token": token2 } }, (err3, creds) => {
            if (err3)
              return callback(err3);
            done(creds);
          });
        });
      });
    }
    function deriveRegion(host) {
      const parts = host.split(".");
      if (parts.length === 1 || parts[1] === "amazonaws") {
        return "us-east-1";
      }
      return parts[1];
    }
    function request(uri, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = Object.assign({
        method: "GET",
        timeout: 1e4,
        json: true
      }, url.parse(uri), options2);
      const req = http2.request(options2, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d2) => data += d2);
        res.on("end", () => {
          if (options2.json === false) {
            callback(void 0, data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            callback(void 0, parsed);
          } catch (err) {
            callback(new MongoError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.on("error", (err) => callback(err));
      req.end();
    }
    module2.exports = MongoDBAWS;
  }
});

// node_modules/mongodb/lib/core/auth/defaultAuthProviders.js
var require_defaultAuthProviders = __commonJS({
  "node_modules/mongodb/lib/core/auth/defaultAuthProviders.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoCR = require_mongocr();
    var X509 = require_x509();
    var Plain = require_plain();
    var GSSAPI = require_gssapi();
    var ScramSHA1 = require_scram().ScramSHA1;
    var ScramSHA256 = require_scram().ScramSHA256;
    var MongoDBAWS = require_mongodb_aws();
    function defaultAuthProviders(bson) {
      return {
        "mongodb-aws": new MongoDBAWS(bson),
        mongocr: new MongoCR(bson),
        x509: new X509(bson),
        plain: new Plain(bson),
        gssapi: new GSSAPI(bson),
        "scram-sha-1": new ScramSHA1(bson),
        "scram-sha-256": new ScramSHA256(bson)
      };
    }
    module2.exports = { defaultAuthProviders };
  }
});

// node_modules/mongodb/lib/core/connection/connect.js
var require_connect = __commonJS({
  "node_modules/mongodb/lib/core/connection/connect.js"(exports2, module2) {
    init_shims();
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var Connection = require_connection();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var defaultAuthProviders = require_defaultAuthProviders().defaultAuthProviders;
    var AuthContext = require_auth_provider().AuthContext;
    var WIRE_CONSTANTS = require_constants();
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var AUTH_PROVIDERS;
    function connect(options2, cancellationToken, callback) {
      if (typeof cancellationToken === "function") {
        callback = cancellationToken;
        cancellationToken = void 0;
      }
      const ConnectionType = options2 && options2.connectionType ? options2.connectionType : Connection;
      if (AUTH_PROVIDERS == null) {
        AUTH_PROVIDERS = defaultAuthProviders(options2.bson);
      }
      const family = options2.family !== void 0 ? options2.family : 0;
      makeConnection(family, options2, cancellationToken, (err, socket) => {
        if (err) {
          callback(err, socket);
          return;
        }
        performInitialHandshake(new ConnectionType(socket, options2), options2, callback);
      });
    }
    function isModernConnectionType(conn) {
      return !(conn instanceof Connection);
    }
    function checkSupportedServer(ismaster, options2) {
      const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === "number" && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;
      const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === "number" && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;
      if (serverVersionHighEnough) {
        if (serverVersionLowEnough) {
          return null;
        }
        const message2 = `Server at ${options2.host}:${options2.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        return new MongoError(message2);
      }
      const message = `Server at ${options2.host}:${options2.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;
      return new MongoError(message);
    }
    function performInitialHandshake(conn, options2, _callback) {
      const callback = function(err, ret2) {
        if (err && conn) {
          conn.destroy();
        }
        _callback(err, ret2);
      };
      const credentials = options2.credentials;
      if (credentials) {
        if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {
          callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));
          return;
        }
      }
      const authContext = new AuthContext(conn, credentials, options2);
      prepareHandshakeDocument(authContext, (err, handshakeDoc) => {
        if (err) {
          return callback(err);
        }
        const handshakeOptions = Object.assign({}, options2);
        if (options2.connectTimeoutMS || options2.connectionTimeout) {
          handshakeOptions.socketTimeout = options2.connectTimeoutMS || options2.connectionTimeout;
        }
        const start = new Date().getTime();
        conn.command("admin.$cmd", handshakeDoc, handshakeOptions, (err2, result) => {
          if (err2) {
            callback(err2);
            return;
          }
          const response = result.result;
          if (response.ok === 0) {
            callback(new MongoError(response));
            return;
          }
          const supportedServerErr = checkSupportedServer(response, options2);
          if (supportedServerErr) {
            callback(supportedServerErr);
            return;
          }
          if (!isModernConnectionType(conn)) {
            if (response.compression) {
              const agreedCompressors = handshakeDoc.compression.filter((compressor) => response.compression.indexOf(compressor) !== -1);
              if (agreedCompressors.length) {
                conn.agreedCompressor = agreedCompressors[0];
              }
              if (options2.compression && options2.compression.zlibCompressionLevel) {
                conn.zlibCompressionLevel = options2.compression.zlibCompressionLevel;
              }
            }
          }
          conn.ismaster = response;
          conn.lastIsMasterMS = new Date().getTime() - start;
          if (!response.arbiterOnly && credentials) {
            Object.assign(authContext, { response });
            const resolvedCredentials = credentials.resolveAuthMechanism(response);
            const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];
            authProvider.auth(authContext, (err3) => {
              if (err3)
                return callback(err3);
              callback(void 0, conn);
            });
            return;
          }
          callback(void 0, conn);
        });
      });
    }
    function prepareHandshakeDocument(authContext, callback) {
      const options2 = authContext.options;
      const compressors = options2.compression && options2.compression.compressors ? options2.compression.compressors : [];
      const handshakeDoc = {
        ismaster: true,
        client: options2.metadata || makeClientMetadata(options2),
        compression: compressors
      };
      const credentials = authContext.credentials;
      if (credentials) {
        if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {
          Object.assign(handshakeDoc, {
            saslSupportedMechs: `${credentials.source}.${credentials.username}`
          });
          AUTH_PROVIDERS["scram-sha-256"].prepare(handshakeDoc, authContext, callback);
          return;
        }
        const authProvider = AUTH_PROVIDERS[credentials.mechanism];
        if (authProvider == null) {
          return callback(new MongoError(`No AuthProvider for ${credentials.mechanism} defined.`));
        }
        authProvider.prepare(handshakeDoc, authContext, callback);
        return;
      }
      callback(void 0, handshakeDoc);
    }
    var LEGAL_SSL_SOCKET_OPTIONS = [
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "NPNProtocols",
      "ALPNProtocols",
      "servername",
      "ecdhCurve",
      "secureProtocol",
      "secureContext",
      "session",
      "minDHSize",
      "crl",
      "rejectUnauthorized"
    ];
    function parseConnectOptions(family, options2) {
      const host = typeof options2.host === "string" ? options2.host : "localhost";
      if (host.indexOf("/") !== -1) {
        return { path: host };
      }
      const result = {
        family,
        host,
        port: typeof options2.port === "number" ? options2.port : 27017,
        rejectUnauthorized: false
      };
      return result;
    }
    function parseSslOptions(family, options2) {
      const result = parseConnectOptions(family, options2);
      for (const name in options2) {
        if (options2[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {
          result[name] = options2[name];
        }
      }
      if (options2.checkServerIdentity === false) {
        result.checkServerIdentity = function() {
          return void 0;
        };
      } else if (typeof options2.checkServerIdentity === "function") {
        result.checkServerIdentity = options2.checkServerIdentity;
      }
      if (result.servername == null && !net.isIP(result.host)) {
        result.servername = result.host;
      }
      return result;
    }
    var SOCKET_ERROR_EVENTS = new Set(["error", "close", "timeout", "parseError"]);
    function makeConnection(family, options2, cancellationToken, _callback) {
      const useSsl = typeof options2.ssl === "boolean" ? options2.ssl : false;
      const keepAlive = typeof options2.keepAlive === "boolean" ? options2.keepAlive : true;
      let keepAliveInitialDelay = typeof options2.keepAliveInitialDelay === "number" ? options2.keepAliveInitialDelay : 12e4;
      const noDelay = typeof options2.noDelay === "boolean" ? options2.noDelay : true;
      const connectionTimeout = typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : typeof options2.connectTimeoutMS === "number" ? options2.connectTimeoutMS : 3e4;
      const socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
      const rejectUnauthorized = typeof options2.rejectUnauthorized === "boolean" ? options2.rejectUnauthorized : true;
      if (keepAliveInitialDelay > socketTimeout) {
        keepAliveInitialDelay = Math.round(socketTimeout / 2);
      }
      let socket;
      const callback = function(err, ret2) {
        if (err && socket) {
          socket.destroy();
        }
        _callback(err, ret2);
      };
      try {
        if (useSsl) {
          socket = tls.connect(parseSslOptions(family, options2));
          if (typeof socket.disableRenegotiation === "function") {
            socket.disableRenegotiation();
          }
        } else {
          socket = net.createConnection(parseConnectOptions(family, options2));
        }
      } catch (err) {
        return callback(err);
      }
      socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
      socket.setTimeout(connectionTimeout);
      socket.setNoDelay(noDelay);
      const connectEvent = useSsl ? "secureConnect" : "connect";
      let cancellationHandler;
      function errorHandler(eventName) {
        return (err) => {
          SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
          if (cancellationHandler) {
            cancellationToken.removeListener("cancel", cancellationHandler);
          }
          socket.removeListener(connectEvent, connectHandler);
          callback(connectionFailureError(eventName, err));
        };
      }
      function connectHandler() {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler) {
          cancellationToken.removeListener("cancel", cancellationHandler);
        }
        if (socket.authorizationError && rejectUnauthorized) {
          return callback(socket.authorizationError);
        }
        socket.setTimeout(socketTimeout);
        callback(null, socket);
      }
      SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
      if (cancellationToken) {
        cancellationHandler = errorHandler("cancel");
        cancellationToken.once("cancel", cancellationHandler);
      }
      socket.once(connectEvent, connectHandler);
    }
    function connectionFailureError(type, err) {
      switch (type) {
        case "error":
          return new MongoNetworkError(err);
        case "timeout":
          return new MongoNetworkTimeoutError(`connection timed out`);
        case "close":
          return new MongoNetworkError(`connection closed`);
        case "cancel":
          return new MongoNetworkError(`connection establishment was cancelled`);
        default:
          return new MongoNetworkError(`unknown network error`);
      }
    }
    module2.exports = connect;
  }
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS({
  "node_modules/mongodb/lib/read_concern.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ReadConcern = class {
      constructor(level) {
        if (level != null) {
          this.level = level;
        }
      }
      static fromOptions(options2) {
        if (options2 == null) {
          return;
        }
        if (options2.readConcern) {
          if (options2.readConcern instanceof ReadConcern) {
            return options2.readConcern;
          }
          return new ReadConcern(options2.readConcern.level);
        }
        if (options2.level) {
          return new ReadConcern(options2.level);
        }
      }
      static get MAJORITY() {
        return "majority";
      }
      static get AVAILABLE() {
        return "available";
      }
      static get LINEARIZABLE() {
        return "linearizable";
      }
      static get SNAPSHOT() {
        return "snapshot";
      }
    };
    module2.exports = ReadConcern;
  }
});

// node_modules/mongodb/lib/core/transactions.js
var require_transactions = __commonJS({
  "node_modules/mongodb/lib/core/transactions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_error().MongoError;
    var ReadPreference = require_read_preference();
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var TxnState;
    var stateMachine;
    (() => {
      const NO_TRANSACTION = "NO_TRANSACTION";
      const STARTING_TRANSACTION = "STARTING_TRANSACTION";
      const TRANSACTION_IN_PROGRESS = "TRANSACTION_IN_PROGRESS";
      const TRANSACTION_COMMITTED = "TRANSACTION_COMMITTED";
      const TRANSACTION_COMMITTED_EMPTY = "TRANSACTION_COMMITTED_EMPTY";
      const TRANSACTION_ABORTED = "TRANSACTION_ABORTED";
      TxnState = {
        NO_TRANSACTION,
        STARTING_TRANSACTION,
        TRANSACTION_IN_PROGRESS,
        TRANSACTION_COMMITTED,
        TRANSACTION_COMMITTED_EMPTY,
        TRANSACTION_ABORTED
      };
      stateMachine = {
        [NO_TRANSACTION]: [NO_TRANSACTION, STARTING_TRANSACTION],
        [STARTING_TRANSACTION]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_IN_PROGRESS]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_COMMITTED]: [
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          STARTING_TRANSACTION,
          NO_TRANSACTION
        ],
        [TRANSACTION_ABORTED]: [STARTING_TRANSACTION, NO_TRANSACTION],
        [TRANSACTION_COMMITTED_EMPTY]: [TRANSACTION_COMMITTED_EMPTY, NO_TRANSACTION]
      };
    })();
    var Transaction = class {
      constructor(options2) {
        options2 = options2 || {};
        this.state = TxnState.NO_TRANSACTION;
        this.options = {};
        const writeConcern = WriteConcern.fromOptions(options2);
        if (writeConcern) {
          if (writeConcern.w <= 0) {
            throw new MongoError("Transactions do not support unacknowledged write concern");
          }
          this.options.writeConcern = writeConcern;
        }
        if (options2.readConcern) {
          this.options.readConcern = ReadConcern.fromOptions(options2);
        }
        if (options2.readPreference) {
          this.options.readPreference = ReadPreference.fromOptions(options2);
        }
        if (options2.maxCommitTimeMS) {
          this.options.maxTimeMS = options2.maxCommitTimeMS;
        }
        this._pinnedServer = void 0;
        this._recoveryToken = void 0;
      }
      get server() {
        return this._pinnedServer;
      }
      get recoveryToken() {
        return this._recoveryToken;
      }
      get isPinned() {
        return !!this.server;
      }
      get isActive() {
        return [TxnState.STARTING_TRANSACTION, TxnState.TRANSACTION_IN_PROGRESS].indexOf(this.state) !== -1;
      }
      transition(nextState) {
        const nextStates = stateMachine[this.state];
        if (nextStates && nextStates.indexOf(nextState) !== -1) {
          this.state = nextState;
          if (this.state === TxnState.NO_TRANSACTION || this.state === TxnState.STARTING_TRANSACTION) {
            this.unpinServer();
          }
          return;
        }
        throw new MongoError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
      }
      pinServer(server) {
        if (this.isActive) {
          this._pinnedServer = server;
        }
      }
      unpinServer() {
        this._pinnedServer = void 0;
      }
    };
    function isTransactionCommand(command) {
      return !!(command.commitTransaction || command.abortTransaction);
    }
    module2.exports = { TxnState, Transaction, isTransactionCommand };
  }
});

// node_modules/mongodb/lib/core/topologies/shared.js
var require_shared2 = __commonJS({
  "node_modules/mongodb/lib/core/topologies/shared.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ReadPreference = require_read_preference();
    var TopologyType = require_common().TopologyType;
    var MongoError = require_error().MongoError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MMAPv1_RETRY_WRITES_ERROR_CODE = 20;
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    function createCompressionInfo(options2) {
      if (!options2.compression || !options2.compression.compressors) {
        return [];
      }
      options2.compression.compressors.forEach(function(compressor) {
        if (compressor !== "snappy" && compressor !== "zlib") {
          throw new Error("compressors must be at least one of snappy or zlib");
        }
      });
      return options2.compression.compressors;
    }
    function clone2(object) {
      return JSON.parse(JSON.stringify(object));
    }
    var getPreviousDescription = function(self2) {
      if (!self2.s.serverDescription) {
        self2.s.serverDescription = {
          address: self2.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: "Unknown"
        };
      }
      return self2.s.serverDescription;
    };
    var emitServerDescriptionChanged = function(self2, description) {
      if (self2.listeners("serverDescriptionChanged").length > 0) {
        self2.emit("serverDescriptionChanged", {
          topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
          address: self2.name,
          previousDescription: getPreviousDescription(self2),
          newDescription: description
        });
        self2.s.serverDescription = description;
      }
    };
    var getPreviousTopologyDescription = function(self2) {
      if (!self2.s.topologyDescription) {
        self2.s.topologyDescription = {
          topologyType: "Unknown",
          servers: [
            {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            }
          ]
        };
      }
      return self2.s.topologyDescription;
    };
    var emitTopologyDescriptionChanged = function(self2, description) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        self2.emit("topologyDescriptionChanged", {
          topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
          address: self2.name,
          previousDescription: getPreviousTopologyDescription(self2),
          newDescription: description
        });
        self2.s.serverDescription = description;
      }
    };
    var changedIsMaster = function(self2, currentIsmaster, ismaster) {
      var currentType = getTopologyType(self2, currentIsmaster);
      var newType = getTopologyType(self2, ismaster);
      if (newType !== currentType)
        return true;
      return false;
    };
    var getTopologyType = function(self2, ismaster) {
      if (!ismaster) {
        ismaster = self2.ismaster;
      }
      if (!ismaster)
        return "Unknown";
      if (ismaster.ismaster && ismaster.msg === "isdbgrid")
        return "Mongos";
      if (ismaster.ismaster && !ismaster.hosts)
        return "Standalone";
      if (ismaster.ismaster)
        return "RSPrimary";
      if (ismaster.secondary)
        return "RSSecondary";
      if (ismaster.arbiterOnly)
        return "RSArbiter";
      return "Unknown";
    };
    var inquireServerState = function(self2) {
      return function(callback) {
        if (self2.s.state === "destroyed")
          return;
        var start = new Date().getTime();
        emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: self2.name });
        self2.command("admin.$cmd", { ismaster: true }, { monitoring: true }, function(err, r) {
          if (!err) {
            self2.emit("ismaster", r, self2);
            var latencyMS = new Date().getTime() - start;
            emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: self2.name
            });
            if (changedIsMaster(self2, self2.s.ismaster, r.result)) {
              emitServerDescriptionChanged(self2, {
                address: self2.name,
                arbiters: [],
                hosts: [],
                passives: [],
                type: !self2.s.inTopology ? "Standalone" : getTopologyType(self2)
              });
            }
            self2.s.ismaster = r.result;
            self2.s.isMasterLatencyMS = latencyMS;
          } else {
            emitSDAMEvent(self2, "serverHeartbeatFailed", {
              durationMS: latencyMS,
              failure: err,
              connectionId: self2.name
            });
          }
          if (typeof callback === "function") {
            return callback(err, r);
          }
          self2.s.inquireServerStateTimeout = setTimeout(inquireServerState(self2), self2.s.haInterval);
        });
      };
    };
    var cloneOptions = function(options2) {
      var opts = {};
      for (var name in options2) {
        opts[name] = options2[name];
      }
      return opts;
    };
    function Interval(fn, time) {
      var timer = false;
      this.start = function() {
        if (!this.isRunning()) {
          timer = setInterval(fn, time);
        }
        return this;
      };
      this.stop = function() {
        clearInterval(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function Timeout(fn, time) {
      var timer = false;
      var func = () => {
        if (timer) {
          clearTimeout(timer);
          timer = false;
          fn();
        }
      };
      this.start = function() {
        if (!this.isRunning()) {
          timer = setTimeout(func, time);
        }
        return this;
      };
      this.stop = function() {
        clearTimeout(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function diff(previous, current) {
      var diff2 = {
        servers: []
      };
      if (!previous) {
        previous = { servers: [] };
      }
      for (var i = 0; i < previous.servers.length; i++) {
        var found = false;
        for (var j = 0; j < current.servers.length; j++) {
          if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: previous.servers[i].address,
            from: previous.servers[i].type,
            to: "Unknown"
          });
        }
      }
      for (j = 0; j < current.servers.length; j++) {
        found = false;
        for (i = 0; i < previous.servers.length; i++) {
          if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: current.servers[j].address,
            from: "Unknown",
            to: current.servers[j].type
          });
        }
      }
      for (i = 0; i < previous.servers.length; i++) {
        var prevServer = previous.servers[i];
        for (j = 0; j < current.servers.length; j++) {
          var currServer = current.servers[j];
          if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {
            if (prevServer.type !== currServer.type) {
              diff2.servers.push({
                address: prevServer.address,
                from: prevServer.type,
                to: currServer.type
              });
            }
          }
        }
      }
      return diff2;
    }
    function resolveClusterTime(topology, $clusterTime) {
      if (topology.clusterTime == null) {
        topology.clusterTime = $clusterTime;
      } else {
        if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {
          topology.clusterTime = $clusterTime;
        }
      }
    }
    var SessionMixins = {
      endSessions: function(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command("admin.$cmd", { endSessions: sessions }, { readPreference: ReadPreference.primaryPreferred }, () => {
          if (typeof callback === "function")
            callback();
        });
      }
    };
    function topologyType(topology) {
      if (topology.description) {
        return topology.description.type;
      }
      if (topology.type === "mongos") {
        return TopologyType.Sharded;
      } else if (topology.type === "replset") {
        return TopologyType.ReplicaSetWithPrimary;
      }
      return TopologyType.Single;
    }
    var RETRYABLE_WIRE_VERSION = 6;
    var isRetryableWritesSupported = function(topology) {
      const maxWireVersion2 = topology.lastIsMaster().maxWireVersion;
      if (maxWireVersion2 < RETRYABLE_WIRE_VERSION) {
        return false;
      }
      if (!topology.logicalSessionTimeoutMinutes) {
        return false;
      }
      if (topologyType(topology) === TopologyType.Single) {
        return false;
      }
      return true;
    };
    var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
    function getMMAPError(err) {
      if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes("Transaction numbers")) {
        return err;
      }
      const newErr = new MongoError({
        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        originalError: err
      });
      return newErr;
    }
    function legacyIsRetryableWriteError(err, topology) {
      if (!(err instanceof MongoError)) {
        return false;
      }
      if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {
        err.addErrorLabel("RetryableWriteError");
      }
      return err.hasErrorLabel("RetryableWriteError");
    }
    module2.exports = {
      SessionMixins,
      resolveClusterTime,
      inquireServerState,
      getTopologyType,
      emitServerDescriptionChanged,
      emitTopologyDescriptionChanged,
      cloneOptions,
      createCompressionInfo,
      clone: clone2,
      diff,
      Interval,
      Timeout,
      isRetryableWritesSupported,
      getMMAPError,
      topologyType,
      legacyIsRetryableWriteError
    };
  }
});

// node_modules/mongodb/lib/core/sessions.js
var require_sessions = __commonJS({
  "node_modules/mongodb/lib/core/sessions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var EventEmitter = require("events");
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var uuidV4 = require_utils2().uuidV4;
    var MongoError = require_error().MongoError;
    var isRetryableError = require_error().isRetryableError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Transaction = require_transactions().Transaction;
    var TxnState = require_transactions().TxnState;
    var isPromiseLike = require_utils2().isPromiseLike;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils4().maybePromise;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils2().maxWireVersion;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var minWireVersionForShardedTransactions = 8;
    function assertAlive(session, callback) {
      if (session.serverSession == null) {
        const error2 = new MongoError("Cannot use a session that has ended");
        if (typeof callback === "function") {
          callback(error2, null);
          return false;
        }
        throw error2;
      }
      return true;
    }
    var kServerSession = Symbol("serverSession");
    var ClientSession = class extends EventEmitter {
      constructor(topology, sessionPool, options2, clientOptions) {
        super();
        if (topology == null) {
          throw new Error("ClientSession requires a topology");
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
          throw new Error("ClientSession requires a ServerSessionPool");
        }
        options2 = options2 || {};
        clientOptions = clientOptions || {};
        this.topology = topology;
        this.sessionPool = sessionPool;
        this.hasEnded = false;
        this.clientOptions = clientOptions;
        this[kServerSession] = void 0;
        this.supports = {
          causalConsistency: typeof options2.causalConsistency !== "undefined" ? options2.causalConsistency : true
        };
        this.clusterTime = options2.initialClusterTime;
        this.operationTime = null;
        this.explicit = !!options2.explicit;
        this.owner = options2.owner;
        this.defaultTransactionOptions = Object.assign({}, options2.defaultTransactionOptions);
        this.transaction = new Transaction();
      }
      get id() {
        return this.serverSession.id;
      }
      get serverSession() {
        if (this[kServerSession] == null) {
          this[kServerSession] = this.sessionPool.acquire();
        }
        return this[kServerSession];
      }
      endSession(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        const session = this;
        return maybePromise(this, callback, (done) => {
          if (session.hasEnded) {
            return done();
          }
          function completeEndSession() {
            session.sessionPool.release(session.serverSession);
            session[kServerSession] = void 0;
            session.hasEnded = true;
            session.emit("ended", session);
            done();
          }
          if (session.serverSession && session.inTransaction()) {
            session.abortTransaction((err) => {
              if (err)
                return done(err);
              completeEndSession();
            });
            return;
          }
          completeEndSession();
        });
      }
      advanceOperationTime(operationTime) {
        if (this.operationTime == null) {
          this.operationTime = operationTime;
          return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
          this.operationTime = operationTime;
        }
      }
      equals(session) {
        if (!(session instanceof ClientSession)) {
          return false;
        }
        return this.id.id.buffer.equals(session.id.id.buffer);
      }
      incrementTransactionNumber() {
        this.serverSession.txnNumber++;
      }
      inTransaction() {
        return this.transaction.isActive;
      }
      startTransaction(options2) {
        assertAlive(this);
        if (this.inTransaction()) {
          throw new MongoError("Transaction already in progress");
        }
        const topologyMaxWireVersion = maxWireVersion(this.topology);
        if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
          throw new MongoError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
        }
        this.incrementTransactionNumber();
        this.transaction = new Transaction(Object.assign({}, this.clientOptions, options2 || this.defaultTransactionOptions));
        this.transaction.transition(TxnState.STARTING_TRANSACTION);
      }
      commitTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "commitTransaction", done));
      }
      abortTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "abortTransaction", done));
      }
      toBSON() {
        throw new Error("ClientSession cannot be serialized to BSON.");
      }
      withTransaction(fn, options2) {
        const startTime = now();
        return attemptTransaction(this, startTime, fn, options2);
      }
    };
    var MAX_WITH_TRANSACTION_TIMEOUT = 12e4;
    var UNSATISFIABLE_WRITE_CONCERN_CODE = 100;
    var UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;
    var MAX_TIME_MS_EXPIRED_CODE = 50;
    var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
      "CannotSatisfyWriteConcern",
      "UnknownReplWriteConcern",
      "UnsatisfiableWriteConcern"
    ]);
    function hasNotTimedOut(startTime, max) {
      return calculateDurationInMs(startTime) < max;
    }
    function isUnknownTransactionCommitResult(err) {
      return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;
    }
    function isMaxTimeMSExpiredError(err) {
      if (err == null)
        return false;
      return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;
    }
    function attemptTransactionCommit(session, startTime, fn, options2) {
      return session.commitTransaction().catch((err) => {
        if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
          if (err.hasErrorLabel("UnknownTransactionCommitResult")) {
            return attemptTransactionCommit(session, startTime, fn, options2);
          }
          if (err.hasErrorLabel("TransientTransactionError")) {
            return attemptTransaction(session, startTime, fn, options2);
          }
        }
        throw err;
      });
    }
    var USER_EXPLICIT_TXN_END_STATES = new Set([
      TxnState.NO_TRANSACTION,
      TxnState.TRANSACTION_COMMITTED,
      TxnState.TRANSACTION_ABORTED
    ]);
    function userExplicitlyEndedTransaction(session) {
      return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
    }
    function attemptTransaction(session, startTime, fn, options2) {
      session.startTransaction(options2);
      let promise;
      try {
        promise = fn(session);
      } catch (err) {
        promise = Promise.reject(err);
      }
      if (!isPromiseLike(promise)) {
        session.abortTransaction();
        throw new TypeError("Function provided to `withTransaction` must return a Promise");
      }
      return promise.then(() => {
        if (userExplicitlyEndedTransaction(session)) {
          return;
        }
        return attemptTransactionCommit(session, startTime, fn, options2);
      }).catch((err) => {
        function maybeRetryOrThrow(err2) {
          if (err2 instanceof MongoError && err2.hasErrorLabel("TransientTransactionError") && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
            return attemptTransaction(session, startTime, fn, options2);
          }
          if (isMaxTimeMSExpiredError(err2)) {
            err2.addErrorLabel("UnknownTransactionCommitResult");
          }
          throw err2;
        }
        if (session.transaction.isActive) {
          return session.abortTransaction().then(() => maybeRetryOrThrow(err));
        }
        return maybeRetryOrThrow(err);
      });
    }
    function endTransaction(session, commandName, callback) {
      if (!assertAlive(session, callback)) {
        return;
      }
      let txnState = session.transaction.state;
      if (txnState === TxnState.NO_TRANSACTION) {
        callback(new MongoError("No transaction started"));
        return;
      }
      if (commandName === "commitTransaction") {
        if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call commitTransaction after calling abortTransaction"));
          return;
        }
      } else {
        if (txnState === TxnState.STARTING_TRANSACTION) {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call abortTransaction twice"));
          return;
        }
        if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          callback(new MongoError("Cannot call abortTransaction after calling commitTransaction"));
          return;
        }
      }
      const command = { [commandName]: 1 };
      let writeConcern;
      if (session.transaction.options.writeConcern) {
        writeConcern = Object.assign({}, session.transaction.options.writeConcern);
      } else if (session.clientOptions && session.clientOptions.w) {
        writeConcern = { w: session.clientOptions.w };
      }
      if (txnState === TxnState.TRANSACTION_COMMITTED) {
        writeConcern = Object.assign({ wtimeout: 1e4 }, writeConcern, { w: "majority" });
      }
      if (writeConcern) {
        Object.assign(command, { writeConcern });
      }
      if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
        Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });
      }
      function commandHandler(e, r) {
        if (commandName === "commitTransaction") {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED);
          if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {
            if (isUnknownTransactionCommitResult(e)) {
              e.addErrorLabel("UnknownTransactionCommitResult");
              session.transaction.unpinServer();
            }
          }
        } else {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
        }
        callback(e, r);
      }
      function transactionError(err) {
        return commandName === "commitTransaction" ? err : null;
      }
      if (session.transaction.recoveryToken && supportsRecoveryToken(session)) {
        command.recoveryToken = session.transaction.recoveryToken;
      }
      session.topology.command("admin.$cmd", command, { session }, (err, reply) => {
        if (err && isRetryableError(err)) {
          if (command.commitTransaction) {
            session.transaction.unpinServer();
            command.writeConcern = Object.assign({ wtimeout: 1e4 }, command.writeConcern, {
              w: "majority"
            });
          }
          return session.topology.command("admin.$cmd", command, { session }, (_err, _reply) => commandHandler(transactionError(_err), _reply));
        }
        commandHandler(transactionError(err), reply);
      });
    }
    function supportsRecoveryToken(session) {
      const topology = session.topology;
      return !!topology.s.options.useRecoveryToken;
    }
    var ServerSession = class {
      constructor() {
        this.id = { id: new Binary2(uuidV4(), Binary2.SUBTYPE_UUID) };
        this.lastUse = now();
        this.txnNumber = 0;
        this.isDirty = false;
      }
      hasTimedOut(sessionTimeoutMinutes) {
        const idleTimeMinutes = Math.round(calculateDurationInMs(this.lastUse) % 864e5 % 36e5 / 6e4);
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
      }
    };
    var ServerSessionPool = class {
      constructor(topology) {
        if (topology == null) {
          throw new Error("ServerSessionPool requires a topology");
        }
        this.topology = topology;
        this.sessions = [];
      }
      endAllPooledSessions(callback) {
        if (this.sessions.length) {
          this.topology.endSessions(this.sessions.map((session) => session.id), () => {
            this.sessions = [];
            if (typeof callback === "function") {
              callback();
            }
          });
          return;
        }
        if (typeof callback === "function") {
          callback();
        }
      }
      acquire() {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const session = this.sessions.shift();
          if (!session.hasTimedOut(sessionTimeoutMinutes)) {
            return session;
          }
        }
        return new ServerSession();
      }
      release(session) {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const pooledSession = this.sessions[this.sessions.length - 1];
          if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {
            this.sessions.pop();
          } else {
            break;
          }
        }
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          if (session.isDirty) {
            return;
          }
          this.sessions.unshift(session);
        }
      }
    };
    function commandSupportsReadConcern(command, options2) {
      if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {
        return true;
      }
      if (command.mapReduce && options2 && options2.out && (options2.out.inline === 1 || options2.out === "inline")) {
        return true;
      }
      return false;
    }
    function applySession(session, command, options2) {
      if (session.hasEnded) {
        return new MongoError("Cannot use a session that has ended");
      }
      if (options2 && options2.writeConcern && options2.writeConcern.w === 0) {
        return;
      }
      const serverSession = session.serverSession;
      serverSession.lastUse = now();
      command.lsid = serverSession.id;
      const inTransaction = session.inTransaction() || isTransactionCommand(command);
      const isRetryableWrite = options2.willRetryWrite;
      const shouldApplyReadConcern = commandSupportsReadConcern(command, options2);
      if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {
        command.txnNumber = BSON2.Long.fromNumber(serverSession.txnNumber);
      }
      if (!inTransaction) {
        if (session.transaction.state !== TxnState.NO_TRANSACTION) {
          session.transaction.transition(TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
        return;
      }
      if (options2.readPreference && !options2.readPreference.equals(ReadPreference.primary)) {
        return new MongoError(`Read preference in a transaction must be primary, not: ${options2.readPreference.mode}`);
      }
      command.autocommit = false;
      if (session.transaction.state === TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);
        command.startTransaction = true;
        const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;
        if (readConcern) {
          command.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
      }
    }
    function updateSessionFromResponse(session, document2) {
      if (document2.$clusterTime) {
        resolveClusterTime(session, document2.$clusterTime);
      }
      if (document2.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document2.operationTime);
      }
      if (document2.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document2.recoveryToken;
      }
    }
    module2.exports = {
      ClientSession,
      ServerSession,
      ServerSessionPool,
      TxnState,
      applySession,
      updateSessionFromResponse,
      commandSupportsReadConcern
    };
  }
});

// node_modules/mongodb/lib/core/connection/pool.js
var require_pool = __commonJS({
  "node_modules/mongodb/lib/core/connection/pool.js"(exports2, module2) {
    init_shims();
    "use strict";
    var inherits2 = require("util").inherits;
    var EventEmitter = require("events").EventEmitter;
    var MongoError = require_error().MongoError;
    var MongoTimeoutError = require_error().MongoTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Logger = require_logger();
    var f = require("util").format;
    var Msg = require_msg().Msg;
    var CommandResult = require_command_result();
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var apm = require_apm();
    var Buffer2 = require_safe_buffer().Buffer;
    var connect = require_connect();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var eachAsync = require_utils2().eachAsync;
    var makeStateMachine = require_utils2().makeStateMachine;
    var now = require_utils4().now;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var DRAINING = "draining";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    var stateTransition = makeStateMachine({
      [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],
      [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],
      [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],
      [DRAINING]: [DRAINING, DESTROYING, DESTROYED],
      [DESTROYING]: [DESTROYING, DESTROYED],
      [DESTROYED]: [DESTROYED]
    });
    var CONNECTION_EVENTS = new Set([
      "error",
      "close",
      "timeout",
      "parseError",
      "connect",
      "message"
    ]);
    var _id = 0;
    var Pool = function(topology, options2) {
      EventEmitter.call(this);
      this.topology = topology;
      this.s = {
        state: DISCONNECTED,
        cancellationToken: new EventEmitter()
      };
      this.s.cancellationToken.setMaxListeners(Infinity);
      this.options = Object.assign({
        host: "localhost",
        port: 27017,
        size: 5,
        minSize: 0,
        connectionTimeout: 3e4,
        socketTimeout: 0,
        keepAlive: true,
        keepAliveInitialDelay: 12e4,
        noDelay: true,
        ssl: false,
        checkServerIdentity: true,
        ca: null,
        crl: null,
        cert: null,
        key: null,
        passphrase: null,
        rejectUnauthorized: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false,
        reconnect: true,
        reconnectInterval: 1e3,
        reconnectTries: 30,
        domainsEnabled: false,
        legacyCompatMode: true
      }, options2);
      this.id = _id++;
      this.retriesLeft = this.options.reconnectTries;
      this.reconnectId = null;
      this.reconnectError = null;
      if (!options2.bson || options2.bson && (typeof options2.bson.serialize !== "function" || typeof options2.bson.deserialize !== "function")) {
        throw new Error("must pass in valid bson parser");
      }
      this.logger = Logger("Pool", options2);
      this.availableConnections = [];
      this.inUseConnections = [];
      this.connectingConnections = 0;
      this.executing = false;
      this.queue = [];
      this.numberOfConsecutiveTimeouts = 0;
      this.connectionIndex = 0;
      const pool = this;
      this._messageHandler = messageHandler(this);
      this._connectionCloseHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "close", err, connection);
      };
      this._connectionErrorHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "error", err, connection);
      };
      this._connectionTimeoutHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "timeout", err, connection);
      };
      this._connectionParseErrorHandler = function(err) {
        const connection = this;
        connectionFailureHandler(pool, "parseError", err, connection);
      };
    };
    inherits2(Pool, EventEmitter);
    Object.defineProperty(Pool.prototype, "size", {
      enumerable: true,
      get: function() {
        return this.options.size;
      }
    });
    Object.defineProperty(Pool.prototype, "minSize", {
      enumerable: true,
      get: function() {
        return this.options.minSize;
      }
    });
    Object.defineProperty(Pool.prototype, "connectionTimeout", {
      enumerable: true,
      get: function() {
        return this.options.connectionTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "socketTimeout", {
      enumerable: true,
      get: function() {
        return this.options.socketTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "state", {
      enumerable: true,
      get: function() {
        return this.s.state;
      }
    });
    function resetPoolState(pool) {
      pool.inUseConnections = [];
      pool.availableConnections = [];
      pool.connectingConnections = 0;
      pool.executing = false;
      pool.numberOfConsecutiveTimeouts = 0;
      pool.connectionIndex = 0;
      pool.retriesLeft = pool.options.reconnectTries;
      pool.reconnectId = null;
    }
    function connectionFailureHandler(pool, event, err, conn) {
      if (conn) {
        if (conn._connectionFailHandled) {
          return;
        }
        conn._connectionFailHandled = true;
        conn.destroy();
        removeConnection(pool, conn);
        conn.flush(err);
      }
      if (event === "timeout") {
        pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;
        if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {
          pool.numberOfConsecutiveTimeouts = 0;
          pool.destroy(true);
          return pool.emit("close", pool);
        }
      }
      if (pool.socketCount() === 0) {
        if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {
          if (pool.options.reconnect) {
            stateTransition(pool, DISCONNECTED);
          }
        }
        event = event === "error" ? "close" : event;
        pool.emit(event, err);
      }
      if (!pool.reconnectId && pool.options.reconnect) {
        pool.reconnectError = err;
        pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);
      }
      const totalConnections = totalConnectionCount(pool);
      if (totalConnections < pool.minSize) {
        createConnection(pool);
      }
    }
    function attemptReconnect(pool, callback) {
      return function() {
        pool.emit("attemptReconnect", pool);
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Cannot create connection when pool is destroyed"));
          }
          return;
        }
        pool.retriesLeft = pool.retriesLeft - 1;
        if (pool.retriesLeft <= 0) {
          pool.destroy();
          const error2 = new MongoTimeoutError(`failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`, pool.reconnectError);
          pool.emit("reconnectFailed", error2);
          if (typeof callback === "function") {
            callback(error2);
          }
          return;
        }
        pool.reconnectId = null;
        createConnection(pool, (err, conn) => {
          if (err == null) {
            pool.reconnectId = null;
            pool.retriesLeft = pool.options.reconnectTries;
            pool.emit("reconnect", pool);
          }
          if (typeof callback === "function") {
            callback(err, conn);
          }
        });
      };
    }
    function moveConnectionBetween(connection, from, to) {
      var index2 = from.indexOf(connection);
      if (index2 !== -1) {
        from.splice(index2, 1);
        to.push(connection);
      }
    }
    function messageHandler(self2) {
      return function(message, connection) {
        var workItem = null;
        for (var i = 0; i < connection.workItems.length; i++) {
          if (connection.workItems[i].requestId === message.responseTo) {
            workItem = connection.workItems[i];
            connection.workItems.splice(i, 1);
          }
        }
        if (workItem && workItem.monitoring) {
          moveConnectionBetween(connection, self2.inUseConnections, self2.availableConnections);
        }
        self2.numberOfConsecutiveTimeouts = 0;
        if (workItem && workItem.socketTimeout) {
          connection.resetSocketTimeout();
        }
        if (self2.logger.isDebug()) {
          self2.logger.debug(f("message [ %s ] received from %s:%s", message.raw.length, self2.options.host, self2.options.port));
        }
        function handleOperationCallback(self3, cb, err, result) {
          if (!self3.options.domainsEnabled) {
            return process.nextTick(function() {
              return cb(err, result);
            });
          }
          cb(err, result);
        }
        if (!self2.executing) {
          process.nextTick(function() {
            _execute(self2)();
          });
        }
        if (workItem && !workItem.immediateRelease) {
          try {
            message.parse(workItem);
          } catch (err) {
            return handleOperationCallback(self2, workItem.cb, new MongoError(err));
          }
          if (message.documents[0]) {
            const document2 = message.documents[0];
            const session = workItem.session;
            if (session) {
              updateSessionFromResponse(session, document2);
            }
            if (self2.topology && document2.$clusterTime) {
              self2.topology.clusterTime = document2.$clusterTime;
            }
          }
          if (workItem.command && message.documents[0]) {
            const responseDoc = message.documents[0];
            if (responseDoc.writeConcernError) {
              const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);
              return handleOperationCallback(self2, workItem.cb, err);
            }
            if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {
              return handleOperationCallback(self2, workItem.cb, new MongoError(responseDoc));
            }
          }
          message.hashedName = connection.hashedName;
          handleOperationCallback(self2, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));
        }
      };
    }
    Pool.prototype.socketCount = function() {
      return this.availableConnections.length + this.inUseConnections.length;
    };
    function totalConnectionCount(pool) {
      return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;
    }
    Pool.prototype.allConnections = function() {
      return this.availableConnections.concat(this.inUseConnections);
    };
    Pool.prototype.get = function() {
      return this.allConnections()[0];
    };
    Pool.prototype.isConnected = function() {
      if (this.state === DESTROYED || this.state === DESTROYING) {
        return false;
      }
      var connections = this.availableConnections.concat(this.inUseConnections);
      for (var i = 0; i < connections.length; i++) {
        if (connections[i].isConnected())
          return true;
      }
      return false;
    };
    Pool.prototype.isDestroyed = function() {
      return this.state === DESTROYED || this.state === DESTROYING;
    };
    Pool.prototype.isDisconnected = function() {
      return this.state === DISCONNECTED;
    };
    Pool.prototype.connect = function(callback) {
      if (this.state !== DISCONNECTED) {
        throw new MongoError("connection in unlawful state " + this.state);
      }
      stateTransition(this, CONNECTING);
      createConnection(this, (err, conn) => {
        if (err) {
          if (typeof callback === "function") {
            this.destroy();
            callback(err);
            return;
          }
          if (this.state === CONNECTING) {
            this.emit("error", err);
          }
          this.destroy();
          return;
        }
        stateTransition(this, CONNECTED);
        if (this.minSize) {
          for (let i = 0; i < this.minSize; i++) {
            createConnection(this);
          }
        }
        if (typeof callback === "function") {
          callback(null, conn);
        } else {
          this.emit("connect", this, conn);
        }
      });
    };
    Pool.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.logout = function(dbName, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.unref = function() {
      var connections = this.availableConnections.concat(this.inUseConnections);
      connections.forEach(function(c) {
        c.unref();
      });
    };
    function destroy(self2, connections, options2, callback) {
      stateTransition(self2, DESTROYING);
      self2.s.cancellationToken.emit("cancel");
      eachAsync(connections, (conn, cb) => {
        for (const eventName of CONNECTION_EVENTS) {
          conn.removeAllListeners(eventName);
        }
        conn.on("error", () => {
        });
        conn.destroy(options2, cb);
      }, (err) => {
        if (err) {
          if (typeof callback === "function")
            callback(err, null);
          return;
        }
        resetPoolState(self2);
        self2.queue = [];
        stateTransition(self2, DESTROYED);
        if (typeof callback === "function")
          callback(null, null);
      });
    }
    Pool.prototype.destroy = function(force, callback) {
      var self2 = this;
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      if (this.state === DESTROYED || self2.state === DESTROYING) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DRAINING);
      if (force) {
        var connections = self2.availableConnections.concat(self2.inUseConnections);
        while (self2.queue.length > 0) {
          var workItem = self2.queue.shift();
          if (typeof workItem.cb === "function") {
            workItem.cb(new MongoError("Pool was force destroyed"));
          }
        }
        return destroy(self2, connections, { force: true }, callback);
      }
      if (this.reconnectId) {
        clearTimeout(this.reconnectId);
      }
      function checkStatus() {
        if (self2.state === DESTROYED || self2.state === DESTROYING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        flushMonitoringOperations(self2.queue);
        if (self2.queue.length === 0) {
          var connections2 = self2.availableConnections.concat(self2.inUseConnections);
          for (var i = 0; i < connections2.length; i++) {
            if (connections2[i].workItems.length > 0) {
              return setTimeout(checkStatus, 1);
            }
          }
          destroy(self2, connections2, { force: false }, callback);
        } else {
          _execute(self2)();
          setTimeout(checkStatus, 1);
        }
      }
      checkStatus();
    };
    Pool.prototype.reset = function(callback) {
      if (this.s.state !== CONNECTED) {
        if (typeof callback === "function") {
          callback(new MongoError("pool is not connected, reset aborted"));
        }
        return;
      }
      this.s.cancellationToken.emit("cancel");
      const connections = this.availableConnections.concat(this.inUseConnections);
      eachAsync(connections, (conn, cb) => {
        for (const eventName of CONNECTION_EVENTS) {
          conn.removeAllListeners(eventName);
        }
        conn.destroy({ force: true }, cb);
      }, (err) => {
        if (err) {
          if (typeof callback === "function") {
            callback(err, null);
            return;
          }
        }
        resetPoolState(this);
        createConnection(this, () => {
          if (typeof callback === "function") {
            callback(null, null);
          }
        });
      });
    };
    function serializeCommand(self2, command, callback) {
      const originalCommandBuffer = command.toBin();
      const shouldCompress = !!self2.options.agreedCompressor;
      if (!shouldCompress || !canCompress(command)) {
        return callback(null, originalCommandBuffer);
      }
      const concatenatedOriginalCommandBuffer = Buffer2.concat(originalCommandBuffer);
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      compress(self2, messageToBeCompressed, function(err, compressedMessage) {
        if (err)
          return callback(err, null);
        const msgHeader = Buffer2.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
        const compressionDetails = Buffer2.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compressorIDs[self2.options.agreedCompressor], 8);
        return callback(null, [msgHeader, compressionDetails, compressedMessage]);
      });
    }
    Pool.prototype.write = function(command, options2, cb) {
      var self2 = this;
      if (typeof options2 === "function") {
        cb = options2;
      }
      options2 = options2 || {};
      if (!(typeof cb === "function") && !options2.noResponse) {
        throw new MongoError("write method must provide a callback");
      }
      if (this.state === DESTROYED || this.state === DESTROYING) {
        cb(new MongoError("pool destroyed"));
        return;
      }
      if (this.state === DRAINING) {
        cb(new MongoError("pool is draining, new operations prohibited"));
        return;
      }
      if (this.options.domainsEnabled && process.domain && typeof cb === "function") {
        var oldCb = cb;
        cb = process.domain.bind(function() {
          var args = new Array(arguments.length);
          for (var i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          process.nextTick(function() {
            oldCb.apply(null, args);
          });
        });
      }
      var operation = {
        cb,
        raw: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false,
        fullResult: false
      };
      operation.promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true;
      operation.promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : true;
      operation.promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false;
      operation.bsonRegExp = typeof options2.bsonRegExp === "boolean" ? options2.bsonRegExp : false;
      operation.raw = typeof options2.raw === "boolean" ? options2.raw : false;
      operation.immediateRelease = typeof options2.immediateRelease === "boolean" ? options2.immediateRelease : false;
      operation.documentsReturnedIn = options2.documentsReturnedIn;
      operation.command = typeof options2.command === "boolean" ? options2.command : false;
      operation.fullResult = typeof options2.fullResult === "boolean" ? options2.fullResult : false;
      operation.noResponse = typeof options2.noResponse === "boolean" ? options2.noResponse : false;
      operation.session = options2.session || null;
      operation.socketTimeout = options2.socketTimeout;
      operation.monitoring = options2.monitoring;
      operation.requestId = command.requestId;
      if (self2.options.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
        operation.started = now();
        operation.cb = (err, reply) => {
          if (err) {
            self2.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operation.started));
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              self2.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operation.started));
            } else {
              self2.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operation.started));
            }
          }
          if (typeof cb === "function")
            cb(err, reply);
        };
      }
      serializeCommand(self2, command, (err, serializedBuffers) => {
        if (err)
          throw err;
        operation.buffer = serializedBuffers;
        if (options2.monitoring) {
          self2.queue.unshift(operation);
        } else {
          self2.queue.push(operation);
        }
        if (!self2.executing) {
          process.nextTick(function() {
            _execute(self2)();
          });
        }
      });
    };
    function canCompress(command) {
      const commandDoc = command instanceof Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function remove(connection, connections) {
      for (var i = 0; i < connections.length; i++) {
        if (connections[i] === connection) {
          connections.splice(i, 1);
          return true;
        }
      }
    }
    function removeConnection(self2, connection) {
      if (remove(connection, self2.availableConnections))
        return;
      if (remove(connection, self2.inUseConnections))
        return;
    }
    function createConnection(pool, callback) {
      if (pool.state === DESTROYED || pool.state === DESTROYING) {
        if (typeof callback === "function") {
          callback(new MongoError("Cannot create connection when pool is destroyed"));
        }
        return;
      }
      pool.connectingConnections++;
      connect(pool.options, pool.s.cancellationToken, (err, connection) => {
        pool.connectingConnections--;
        if (err) {
          if (pool.logger.isDebug()) {
            pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          }
          if (!pool.reconnectId && pool.options.reconnect) {
            if (pool.state === CONNECTING && pool.options.legacyCompatMode) {
              callback(err);
              return;
            }
            pool.reconnectError = err;
            pool.reconnectId = setTimeout(attemptReconnect(pool, callback), pool.options.reconnectInterval);
            return;
          }
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Pool was destroyed after connection creation"));
          }
          connection.destroy();
          return;
        }
        connection.on("error", pool._connectionErrorHandler);
        connection.on("close", pool._connectionCloseHandler);
        connection.on("timeout", pool._connectionTimeoutHandler);
        connection.on("parseError", pool._connectionParseErrorHandler);
        connection.on("message", pool._messageHandler);
        pool.availableConnections.push(connection);
        if (typeof callback === "function") {
          callback(null, connection);
        }
        _execute(pool)();
      });
    }
    function flushMonitoringOperations(queue) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].monitoring) {
          var workItem = queue[i];
          queue.splice(i, 1);
          workItem.cb(new MongoError({ message: "no connection available for monitoring", driver: true }));
        }
      }
    }
    function _execute(self2) {
      return function() {
        if (self2.state === DESTROYED)
          return;
        if (self2.executing)
          return;
        self2.executing = true;
        if (self2.connectingConnections > 0) {
          self2.executing = false;
          return;
        }
        while (true) {
          const totalConnections = totalConnectionCount(self2);
          if (self2.availableConnections.length === 0) {
            flushMonitoringOperations(self2.queue);
            if (totalConnections < self2.options.size && self2.queue.length > 0) {
              createConnection(self2);
            }
            break;
          }
          if (self2.queue.length === 0) {
            break;
          }
          var connection = null;
          const connections = self2.availableConnections.filter((conn) => conn.workItems.length === 0);
          if (connections.length === 0) {
            connection = self2.availableConnections[self2.connectionIndex++ % self2.availableConnections.length];
          } else {
            connection = connections[self2.connectionIndex++ % connections.length];
          }
          if (!connection.isConnected()) {
            removeConnection(self2, connection);
            flushMonitoringOperations(self2.queue);
            break;
          }
          var workItem = self2.queue.shift();
          if (workItem.monitoring) {
            var foundValidConnection = false;
            for (let i = 0; i < self2.availableConnections.length; i++) {
              if (self2.availableConnections[i].isConnected() && self2.availableConnections[i].workItems.length === 0) {
                foundValidConnection = true;
                connection = self2.availableConnections[i];
                break;
              }
            }
            if (!foundValidConnection) {
              self2.queue.unshift(workItem);
              if (totalConnections < self2.options.size && self2.queue.length > 0) {
                createConnection(self2);
              }
              setTimeout(() => _execute(self2)(), 10);
              break;
            }
          }
          if (totalConnections < self2.options.size) {
            if (connection.workItems.length > 0) {
              self2.queue.unshift(workItem);
              createConnection(self2);
              break;
            }
          }
          var buffer = workItem.buffer;
          if (workItem.monitoring) {
            moveConnectionBetween(connection, self2.availableConnections, self2.inUseConnections);
          }
          if (!workItem.noResponse) {
            connection.workItems.push(workItem);
          }
          if (!workItem.immediateRelease && typeof workItem.socketTimeout === "number") {
            connection.setSocketTimeout(workItem.socketTimeout);
          }
          var writeSuccessful = true;
          if (Array.isArray(buffer)) {
            for (let i = 0; i < buffer.length; i++) {
              writeSuccessful = connection.write(buffer[i]);
            }
          } else {
            writeSuccessful = connection.write(buffer);
          }
          if (workItem.noResponse && typeof workItem.cb === "function") {
            workItem.cb(null, null);
          }
          if (writeSuccessful === false) {
            self2.queue.unshift(workItem);
            removeConnection(self2, connection);
            flushMonitoringOperations(self2.queue);
            break;
          }
        }
        self2.executing = false;
      };
    }
    Pool._execute = _execute;
    module2.exports = Pool;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/command.js
var require_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/command.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Query = require_commands().Query;
    var Msg = require_msg().Msg;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var isSharded = require_shared().isSharded;
    var databaseNamespace = require_shared().databaseNamespace;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var applySession = require_sessions().applySession;
    var MongoNetworkError = require_error().MongoNetworkError;
    var maxWireVersion = require_utils2().maxWireVersion;
    function isClientEncryptionEnabled(server) {
      const wireVersion = maxWireVersion(server);
      return wireVersion && server.autoEncrypter;
    }
    function command(server, ns, cmd, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (cmd == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
      }
      if (!isClientEncryptionEnabled(server)) {
        _command(server, ns, cmd, options2, callback);
        return;
      }
      const wireVersion = maxWireVersion(server);
      if (typeof wireVersion !== "number" || wireVersion < 8) {
        callback(new MongoError("Auto-encryption requires a minimum MongoDB version of 4.2"));
        return;
      }
      _cryptCommand(server, ns, cmd, options2, callback);
    }
    function _command(server, ns, cmd, options2, callback) {
      const bson = server.s.bson;
      const pool = server.s.pool;
      const readPreference = getReadPreference(cmd, options2);
      const shouldUseOpMsg = supportsOpMsg(server);
      const session = options2.session;
      const serverClusterTime = server.clusterTime;
      let clusterTime = serverClusterTime;
      let finalCmd = Object.assign({}, cmd);
      if (hasSessionSupport(server) && session) {
        const sessionClusterTime = session.clusterTime;
        if (serverClusterTime && serverClusterTime.clusterTime && sessionClusterTime && sessionClusterTime.clusterTime && sessionClusterTime.clusterTime.greaterThan(serverClusterTime.clusterTime)) {
          clusterTime = sessionClusterTime;
        }
        const err = applySession(session, finalCmd, options2);
        if (err) {
          return callback(err);
        }
      }
      if (clusterTime) {
        finalCmd.$clusterTime = clusterTime;
      }
      if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
        finalCmd = {
          $query: finalCmd,
          $readPreference: readPreference.toJSON()
        };
      }
      const commandOptions = Object.assign({
        command: true,
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false
      }, options2);
      commandOptions.slaveOk = readPreference.slaveOk();
      const cmdNs = `${databaseNamespace(ns)}.$cmd`;
      const message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query(bson, cmdNs, finalCmd, commandOptions);
      const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));
      const commandResponseHandler = inTransaction ? function(err) {
        if (err && err instanceof MongoNetworkError && !err.hasErrorLabel("TransientTransactionError")) {
          err.addErrorLabel("TransientTransactionError");
        }
        if (!cmd.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel("TransientTransactionError")) {
          session.transaction.unpinServer();
        }
        return callback.apply(null, arguments);
      } : callback;
      try {
        pool.write(message, commandOptions, commandResponseHandler);
      } catch (err) {
        commandResponseHandler(err);
      }
    }
    function hasSessionSupport(topology) {
      if (topology == null)
        return false;
      if (topology.description) {
        return topology.description.maxWireVersion >= 6;
      }
      return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;
    }
    function supportsOpMsg(topologyOrServer) {
      const description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;
      if (description == null) {
        return false;
      }
      return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;
    }
    function _cryptCommand(server, ns, cmd, options2, callback) {
      const autoEncrypter = server.autoEncrypter;
      function commandResponseHandler(err, response) {
        if (err || response == null) {
          callback(err, response);
          return;
        }
        autoEncrypter.decrypt(response.result, options2, (err2, decrypted) => {
          if (err2) {
            callback(err2, null);
            return;
          }
          response.result = decrypted;
          response.message.documents = [decrypted];
          callback(null, response);
        });
      }
      autoEncrypter.encrypt(ns, cmd, options2, (err, encrypted) => {
        if (err) {
          callback(err, null);
          return;
        }
        _command(server, ns, encrypted, options2, commandResponseHandler);
      });
    }
    module2.exports = command;
  }
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS({
  "node_modules/mongodb/lib/explain.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_error().MongoError;
    var ExplainVerbosity = {
      queryPlanner: "queryPlanner",
      queryPlannerExtended: "queryPlannerExtended",
      executionStats: "executionStats",
      allPlansExecution: "allPlansExecution"
    };
    var Explain = class {
      constructor(verbosity) {
        if (typeof verbosity === "boolean") {
          this.verbosity = verbosity ? "allPlansExecution" : "queryPlanner";
        } else {
          this.verbosity = verbosity;
        }
      }
      static fromOptions(options2) {
        if (options2 == null || options2.explain === void 0) {
          return;
        }
        const explain = options2.explain;
        if (typeof explain === "boolean" || explain in ExplainVerbosity) {
          return new Explain(options2.explain);
        }
        throw new MongoError(`explain must be one of ${Object.keys(ExplainVerbosity)} or a boolean`);
      }
    };
    module2.exports = { Explain };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/write_command.js
var require_write_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/write_command.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_error().MongoError;
    var collectionNamespace = require_shared().collectionNamespace;
    var command = require_command();
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var Explain = require_explain().Explain;
    function writeCommand(server, type, opsField, ns, ops, options2, callback) {
      if (ops.length === 0)
        throw new MongoError(`${type} must contain at least one document`);
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      const ordered = typeof options2.ordered === "boolean" ? options2.ordered : true;
      const writeConcern = options2.writeConcern;
      let writeCommand2 = {};
      writeCommand2[type] = collectionNamespace(ns);
      writeCommand2[opsField] = ops;
      writeCommand2.ordered = ordered;
      if (writeConcern && Object.keys(writeConcern).length > 0) {
        writeCommand2.writeConcern = writeConcern;
      }
      if (options2.collation) {
        for (let i = 0; i < writeCommand2[opsField].length; i++) {
          if (!writeCommand2[opsField][i].collation) {
            writeCommand2[opsField][i].collation = options2.collation;
          }
        }
      }
      if (options2.bypassDocumentValidation === true) {
        writeCommand2.bypassDocumentValidation = options2.bypassDocumentValidation;
      }
      const explain = Explain.fromOptions(options2);
      if (explain) {
        writeCommand2 = decorateWithExplain(writeCommand2, explain);
      }
      const commandOptions = Object.assign({
        checkKeys: type === "insert",
        numberToReturn: 1
      }, options2);
      command(server, ns, writeCommand2, commandOptions, callback);
    }
    module2.exports = writeCommand;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js
var require_kill_cursors = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js"(exports2, module2) {
    init_shims();
    "use strict";
    var KillCursor = require_commands().KillCursor;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils2().maxWireVersion;
    var emitWarning = require_utils2().emitWarning;
    var command = require_command();
    function killCursors(server, ns, cursorState, callback) {
      callback = typeof callback === "function" ? callback : () => {
      };
      const cursorId = cursorState.cursorId;
      if (maxWireVersion(server) < 4) {
        const bson = server.s.bson;
        const pool = server.s.pool;
        const killCursor = new KillCursor(bson, ns, [cursorId]);
        const options3 = {
          immediateRelease: true,
          noResponse: true
        };
        if (typeof cursorState.session === "object") {
          options3.session = cursorState.session;
        }
        if (pool && pool.isConnected()) {
          try {
            pool.write(killCursor, options3, callback);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err, null);
            } else {
              emitWarning(err);
            }
          }
        }
        return;
      }
      const killCursorCmd = {
        killCursors: collectionNamespace(ns),
        cursors: [cursorId]
      };
      const options2 = {};
      if (typeof cursorState.session === "object")
        options2.session = cursorState.session;
      command(server, ns, killCursorCmd, options2, (err, result) => {
        if (err) {
          return callback(err);
        }
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (!Array.isArray(response.documents) || response.documents.length === 0) {
          return callback(new MongoError(`invalid killCursors result returned for cursor id ${cursorId}`));
        }
        callback(null, response.documents[0]);
      });
    }
    module2.exports = killCursors;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/get_more.js
var require_get_more = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/get_more.js"(exports2, module2) {
    init_shims();
    "use strict";
    var GetMore = require_commands().GetMore;
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils2().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command = require_command();
    function getMore(server, ns, cursorState, batchSize, options2, callback) {
      options2 = options2 || {};
      const wireVersion = maxWireVersion(server);
      function queryCallback(err, result) {
        if (err)
          return callback(err);
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (wireVersion < 4) {
          const cursorId3 = typeof response.cursorId === "number" ? Long2.fromNumber(response.cursorId) : response.cursorId;
          cursorState.documents = response.documents;
          cursorState.cursorId = cursorId3;
          callback(null, null, response.connection);
          return;
        }
        if (response.documents[0].ok === 0) {
          return callback(new MongoError(response.documents[0]));
        }
        const cursorId2 = typeof response.documents[0].cursor.id === "number" ? Long2.fromNumber(response.documents[0].cursor.id) : response.documents[0].cursor.id;
        cursorState.documents = response.documents[0].cursor.nextBatch;
        cursorState.cursorId = cursorId2;
        callback(null, response.documents[0], response.connection);
      }
      if (wireVersion < 4) {
        const bson = server.s.bson;
        const getMoreOp = new GetMore(bson, ns, cursorState.cursorId, { numberToReturn: batchSize });
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        server.s.pool.write(getMoreOp, queryOptions, queryCallback);
        return;
      }
      const cursorId = cursorState.cursorId instanceof Long2 ? cursorState.cursorId : Long2.fromNumber(cursorState.cursorId);
      const getMoreCmd = {
        getMore: cursorId,
        collection: collectionNamespace(ns),
        batchSize: Math.abs(batchSize)
      };
      if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === "number") {
        getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
      }
      const commandOptions = Object.assign({
        returnFieldSelector: null,
        documentsReturnedIn: "nextBatch"
      }, options2);
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command(server, ns, getMoreCmd, commandOptions, queryCallback);
    }
    module2.exports = getMore;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/query.js
var require_query = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/query.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Query = require_commands().Query;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var collectionNamespace = require_shared().collectionNamespace;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils2().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command = require_command();
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var Explain = require_explain().Explain;
    function query(server, ns, cmd, cursorState, options2, callback) {
      options2 = options2 || {};
      if (cursorState.cursorId != null) {
        return callback();
      }
      if (cmd == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
      }
      if (maxWireVersion(server) < 4) {
        const query2 = prepareLegacyFindQuery(server, ns, cmd, cursorState, options2);
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        if (typeof query2.documentsReturnedIn === "string") {
          queryOptions.documentsReturnedIn = query2.documentsReturnedIn;
        }
        server.s.pool.write(query2, queryOptions, callback);
        return;
      }
      const readPreference = getReadPreference(cmd, options2);
      let findCmd = prepareFindCommand(server, ns, cmd, cursorState, options2);
      const explain = Explain.fromOptions(options2);
      if (explain) {
        findCmd = decorateWithExplain(findCmd, explain);
      }
      cmd.virtual = false;
      const commandOptions = Object.assign({
        documentsReturnedIn: "firstBatch",
        numberToReturn: 1,
        slaveOk: readPreference.slaveOk()
      }, options2);
      if (cmd.readPreference) {
        commandOptions.readPreference = readPreference;
      }
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command(server, ns, findCmd, commandOptions, callback);
    }
    function prepareFindCommand(server, ns, cmd, cursorState) {
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      const findCmd = {
        find: collectionNamespace(ns)
      };
      if (cmd.query) {
        if (cmd.query["$query"]) {
          findCmd.filter = cmd.query["$query"];
        } else {
          findCmd.filter = cmd.query;
        }
      }
      let sortValue = cmd.sort;
      if (Array.isArray(sortValue)) {
        const sortObject = {};
        if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {
          let sortDirection = sortValue[1];
          if (sortDirection === "asc") {
            sortDirection = 1;
          } else if (sortDirection === "desc") {
            sortDirection = -1;
          }
          sortObject[sortValue[0]] = sortDirection;
        } else {
          for (let i = 0; i < sortValue.length; i++) {
            let sortDirection = sortValue[i][1];
            if (sortDirection === "asc") {
              sortDirection = 1;
            } else if (sortDirection === "desc") {
              sortDirection = -1;
            }
            sortObject[sortValue[i][0]] = sortDirection;
          }
        }
        sortValue = sortObject;
      }
      if (typeof cmd.allowDiskUse === "boolean") {
        findCmd.allowDiskUse = cmd.allowDiskUse;
      }
      if (cmd.sort)
        findCmd.sort = sortValue;
      if (cmd.fields)
        findCmd.projection = cmd.fields;
      if (cmd.hint)
        findCmd.hint = cmd.hint;
      if (cmd.skip)
        findCmd.skip = cmd.skip;
      if (cmd.limit)
        findCmd.limit = cmd.limit;
      if (cmd.limit < 0) {
        findCmd.limit = Math.abs(cmd.limit);
        findCmd.singleBatch = true;
      }
      if (typeof cmd.batchSize === "number") {
        if (cmd.batchSize < 0) {
          if (cmd.limit !== 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {
            findCmd.limit = Math.abs(cmd.batchSize);
          }
          findCmd.singleBatch = true;
        }
        findCmd.batchSize = Math.abs(cmd.batchSize);
      }
      if (cmd.comment)
        findCmd.comment = cmd.comment;
      if (cmd.maxScan)
        findCmd.maxScan = cmd.maxScan;
      if (cmd.maxTimeMS)
        findCmd.maxTimeMS = cmd.maxTimeMS;
      if (cmd.min)
        findCmd.min = cmd.min;
      if (cmd.max)
        findCmd.max = cmd.max;
      findCmd.returnKey = cmd.returnKey ? cmd.returnKey : false;
      findCmd.showRecordId = cmd.showDiskLoc ? cmd.showDiskLoc : false;
      if (cmd.snapshot)
        findCmd.snapshot = cmd.snapshot;
      if (cmd.tailable)
        findCmd.tailable = cmd.tailable;
      if (cmd.oplogReplay)
        findCmd.oplogReplay = cmd.oplogReplay;
      if (cmd.noCursorTimeout)
        findCmd.noCursorTimeout = cmd.noCursorTimeout;
      if (cmd.awaitData)
        findCmd.awaitData = cmd.awaitData;
      if (cmd.awaitdata)
        findCmd.awaitData = cmd.awaitdata;
      if (cmd.partial)
        findCmd.partial = cmd.partial;
      if (cmd.collation)
        findCmd.collation = cmd.collation;
      if (cmd.readConcern)
        findCmd.readConcern = cmd.readConcern;
      return findCmd;
    }
    function prepareLegacyFindQuery(server, ns, cmd, cursorState, options2) {
      options2 = options2 || {};
      const bson = server.s.bson;
      const readPreference = getReadPreference(cmd, options2);
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      let numberToReturn = 0;
      if (cursorState.limit < 0 || cursorState.limit !== 0 && cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize === 0) {
        numberToReturn = cursorState.limit;
      } else {
        numberToReturn = cursorState.batchSize;
      }
      const numberToSkip = cursorState.skip || 0;
      const findCmd = {};
      if (isSharded(server) && readPreference) {
        findCmd["$readPreference"] = readPreference.toJSON();
      }
      if (cmd.sort)
        findCmd["$orderby"] = cmd.sort;
      if (cmd.hint)
        findCmd["$hint"] = cmd.hint;
      if (cmd.snapshot)
        findCmd["$snapshot"] = cmd.snapshot;
      if (typeof cmd.returnKey !== "undefined")
        findCmd["$returnKey"] = cmd.returnKey;
      if (cmd.maxScan)
        findCmd["$maxScan"] = cmd.maxScan;
      if (cmd.min)
        findCmd["$min"] = cmd.min;
      if (cmd.max)
        findCmd["$max"] = cmd.max;
      if (typeof cmd.showDiskLoc !== "undefined")
        findCmd["$showDiskLoc"] = cmd.showDiskLoc;
      if (cmd.comment)
        findCmd["$comment"] = cmd.comment;
      if (cmd.maxTimeMS)
        findCmd["$maxTimeMS"] = cmd.maxTimeMS;
      if (options2.explain !== void 0) {
        numberToReturn = -Math.abs(cmd.limit || 0);
        findCmd["$explain"] = true;
      }
      findCmd["$query"] = cmd.query;
      if (cmd.readConcern && cmd.readConcern.level !== "local") {
        throw new MongoError(`server find command does not support a readConcern level of ${cmd.readConcern.level}`);
      }
      if (cmd.readConcern) {
        cmd = Object.assign({}, cmd);
        delete cmd["readConcern"];
      }
      const serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      const ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
      const query2 = new Query(bson, ns, findCmd, {
        numberToSkip,
        numberToReturn,
        pre32Limit: typeof cmd.limit !== "undefined" ? cmd.limit : void 0,
        checkKeys: false,
        returnFieldSelector: cmd.fields,
        serializeFunctions,
        ignoreUndefined
      });
      if (typeof cmd.tailable === "boolean")
        query2.tailable = cmd.tailable;
      if (typeof cmd.oplogReplay === "boolean")
        query2.oplogReplay = cmd.oplogReplay;
      if (typeof cmd.noCursorTimeout === "boolean")
        query2.noCursorTimeout = cmd.noCursorTimeout;
      if (typeof cmd.awaitData === "boolean")
        query2.awaitData = cmd.awaitData;
      if (typeof cmd.partial === "boolean")
        query2.partial = cmd.partial;
      query2.slaveOk = readPreference.slaveOk();
      return query2;
    }
    module2.exports = query;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/index.js
var require_wireprotocol = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var writeCommand = require_write_command();
    module2.exports = {
      insert: function insert(server, ns, ops, options2, callback) {
        writeCommand(server, "insert", "documents", ns, ops, options2, callback);
      },
      update: function update(server, ns, ops, options2, callback) {
        writeCommand(server, "update", "updates", ns, ops, options2, callback);
      },
      remove: function remove(server, ns, ops, options2, callback) {
        writeCommand(server, "delete", "deletes", ns, ops, options2, callback);
      },
      killCursors: require_kill_cursors(),
      getMore: require_get_more(),
      query: require_query(),
      command: require_command()
    };
  }
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS({
  "node_modules/mongodb/lib/operations/operation.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Explain = require_explain().Explain;
    var MongoError = require_error().MongoError;
    var Aspect = {
      READ_OPERATION: Symbol("READ_OPERATION"),
      WRITE_OPERATION: Symbol("WRITE_OPERATION"),
      RETRYABLE: Symbol("RETRYABLE"),
      EXECUTE_WITH_SELECTION: Symbol("EXECUTE_WITH_SELECTION"),
      NO_INHERIT_OPTIONS: Symbol("NO_INHERIT_OPTIONS"),
      EXPLAINABLE: Symbol("EXPLAINABLE")
    };
    var OperationBase = class {
      constructor(options2) {
        this.options = Object.assign({}, options2);
        if (this.hasAspect(Aspect.EXPLAINABLE)) {
          this.explain = Explain.fromOptions(options2);
        } else if (this.options.explain !== void 0) {
          throw new MongoError(`explain is not supported on this command`);
        }
      }
      hasAspect(aspect) {
        if (this.constructor.aspects == null) {
          return false;
        }
        return this.constructor.aspects.has(aspect);
      }
      set session(session) {
        Object.assign(this.options, { session });
      }
      get session() {
        return this.options.session;
      }
      clearSession() {
        delete this.options.session;
      }
      get canRetryRead() {
        return true;
      }
      execute() {
        throw new TypeError("`execute` must be implemented for OperationBase subclasses");
      }
    };
    function defineAspects(operation, aspects) {
      if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
        aspects = [aspects];
      }
      aspects = new Set(aspects);
      Object.defineProperty(operation, "aspects", {
        value: aspects,
        writable: false
      });
      return aspects;
    }
    module2.exports = {
      Aspect,
      defineAspects,
      OperationBase
    };
  }
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS({
  "node_modules/mongodb/lib/operations/execute_operation.js"(exports2, module2) {
    init_shims();
    "use strict";
    var maybePromise = require_utils4().maybePromise;
    var MongoError = require_error().MongoError;
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_read_preference();
    var isRetryableError = require_error().isRetryableError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var isUnifiedTopology = require_utils2().isUnifiedTopology;
    function executeOperation(topology, operation, cb) {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!(operation instanceof OperationBase)) {
        throw new TypeError("This method requires a valid operation instance");
      }
      return maybePromise(topology, cb, (callback) => {
        if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {
          return selectServerForSessionSupport(topology, operation, callback);
        }
        let session, owner;
        if (topology.hasSessionSupport()) {
          if (operation.session == null) {
            owner = Symbol();
            session = topology.startSession({ owner });
            operation.session = session;
          } else if (operation.session.hasEnded) {
            return callback(new MongoError("Use of expired sessions is not permitted"));
          }
        } else if (operation.session) {
          return callback(new MongoError("Current topology does not support sessions"));
        }
        function executeCallback(err, result) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(err, result);
        }
        try {
          if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {
            executeWithServerSelection(topology, operation, executeCallback);
          } else {
            operation.execute(executeCallback);
          }
        } catch (error2) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(error2);
        }
      });
    }
    function supportsRetryableReads(server) {
      return maxWireVersion(server) >= 6;
    }
    function executeWithServerSelection(topology, operation, callback) {
      const readPreference = operation.readPreference || ReadPreference.primary;
      const inTransaction = operation.session && operation.session.inTransaction();
      if (inTransaction && !readPreference.equals(ReadPreference.primary)) {
        callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));
        return;
      }
      const serverSelectionOptions = {
        readPreference,
        session: operation.session
      };
      function callbackWithRetry(err, result) {
        if (err == null) {
          return callback(null, result);
        }
        if (!isRetryableError(err)) {
          return callback(err);
        }
        topology.selectServer(serverSelectionOptions, (err2, server) => {
          if (err2 || !supportsRetryableReads(server)) {
            callback(err2, null);
            return;
          }
          operation.execute(server, callback);
        });
      }
      topology.selectServer(serverSelectionOptions, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;
        if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {
          operation.execute(server, callbackWithRetry);
          return;
        }
        operation.execute(server, callback);
      });
    }
    function selectServerForSessionSupport(topology, operation, callback) {
      topology.selectServer(ReadPreference.primaryPreferred, (err) => {
        if (err) {
          return callback(err);
        }
        executeOperation(topology, operation, callback);
      });
    }
    module2.exports = executeOperation;
  }
});

// node_modules/mongodb/lib/core/cursor.js
var require_cursor = __commonJS({
  "node_modules/mongodb/lib/core/cursor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Logger = require_logger();
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collationNotSupported = require_utils2().collationNotSupported;
    var ReadPreference = require_read_preference();
    var isUnifiedTopology = require_utils2().isUnifiedTopology;
    var executeOperation = require_execute_operation();
    var Readable2 = require("stream").Readable;
    var SUPPORTS = require_utils4().SUPPORTS;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var mergeOptions = require_utils4().mergeOptions;
    var OperationBase = require_operation().OperationBase;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var CursorState = {
      INIT: 0,
      OPEN: 1,
      CLOSED: 2,
      GET_MORE: 3
    };
    function handleCallback(callback, err, result) {
      try {
        callback(err, result);
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
      }
    }
    var CoreCursor = class extends Readable2 {
      constructor(topology, ns, cmd, options2) {
        super({ objectMode: true });
        options2 = options2 || {};
        if (ns instanceof OperationBase) {
          this.operation = ns;
          ns = this.operation.ns.toString();
          options2 = this.operation.options;
          cmd = this.operation.cmd ? this.operation.cmd : {};
        }
        this.pool = null;
        this.server = null;
        this.disconnectHandler = options2.disconnectHandler;
        this.bson = topology.s.bson;
        this.ns = ns;
        this.namespace = MongoDBNamespace.fromString(ns);
        this.cmd = cmd;
        this.options = options2;
        this.topology = topology;
        this.cursorState = {
          cursorId: null,
          cmd,
          documents: options2.documents || [],
          cursorIndex: 0,
          dead: false,
          killed: false,
          init: false,
          notified: false,
          limit: options2.limit || cmd.limit || 0,
          skip: options2.skip || cmd.skip || 0,
          batchSize: options2.batchSize || cmd.batchSize || 1e3,
          currentLimit: 0,
          transforms: options2.transforms,
          raw: options2.raw || cmd && cmd.raw
        };
        if (typeof options2.session === "object") {
          this.cursorState.session = options2.session;
        }
        const topologyOptions = topology.s.options;
        if (typeof topologyOptions.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = topologyOptions.promoteLongs;
        } else if (typeof options2.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = options2.promoteLongs;
        }
        if (typeof topologyOptions.promoteValues === "boolean") {
          this.cursorState.promoteValues = topologyOptions.promoteValues;
        } else if (typeof options2.promoteValues === "boolean") {
          this.cursorState.promoteValues = options2.promoteValues;
        }
        if (typeof topologyOptions.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
        } else if (typeof options2.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = options2.promoteBuffers;
        }
        if (typeof topologyOptions.bsonRegExp === "boolean") {
          this.cursorState.bsonRegExp = topologyOptions.bsonRegExp;
        } else if (typeof options2.bsonRegExp === "boolean") {
          this.cursorState.bsonRegExp = options2.bsonRegExp;
        }
        if (topologyOptions.reconnect) {
          this.cursorState.reconnect = topologyOptions.reconnect;
        }
        this.logger = Logger("Cursor", topologyOptions);
        if (typeof cmd === "number") {
          this.cursorState.cursorId = Long2.fromNumber(cmd);
          this.cursorState.lastCursorId = this.cursorState.cursorId;
        } else if (cmd instanceof Long2) {
          this.cursorState.cursorId = cmd;
          this.cursorState.lastCursorId = cmd;
        }
        if (this.operation) {
          this.operation.cursorState = this.cursorState;
        }
      }
      setCursorBatchSize(value) {
        this.cursorState.batchSize = value;
      }
      cursorBatchSize() {
        return this.cursorState.batchSize;
      }
      setCursorLimit(value) {
        this.cursorState.limit = value;
      }
      cursorLimit() {
        return this.cursorState.limit;
      }
      setCursorSkip(value) {
        this.cursorState.skip = value;
      }
      cursorSkip() {
        return this.cursorState.skip;
      }
      _next(callback) {
        nextFunction(this, callback);
      }
      clone() {
        const clonedOptions = mergeOptions({}, this.options);
        delete clonedOptions.session;
        return this.topology.cursor(this.ns, this.cmd, clonedOptions);
      }
      isDead() {
        return this.cursorState.dead === true;
      }
      isKilled() {
        return this.cursorState.killed === true;
      }
      isNotified() {
        return this.cursorState.notified === true;
      }
      bufferedCount() {
        return this.cursorState.documents.length - this.cursorState.cursorIndex;
      }
      readBufferedDocuments(number) {
        const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
        const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
        let elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
        if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === "function") {
          for (let i = 0; i < elements.length; i++) {
            elements[i] = this.cursorState.transforms.doc(elements[i]);
          }
        }
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {
          elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
          this.kill();
        }
        this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
        this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
        return elements;
      }
      kill(callback) {
        this.cursorState.dead = true;
        this.cursorState.killed = true;
        this.cursorState.documents = [];
        if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {
          if (callback)
            callback(null, null);
          return;
        }
        this.server.killCursors(this.ns, this.cursorState, callback);
      }
      rewind() {
        if (this.cursorState.init) {
          if (!this.cursorState.dead) {
            this.kill();
          }
          this.cursorState.currentLimit = 0;
          this.cursorState.init = false;
          this.cursorState.dead = false;
          this.cursorState.killed = false;
          this.cursorState.notified = false;
          this.cursorState.documents = [];
          this.cursorState.cursorId = null;
          this.cursorState.cursorIndex = 0;
        }
      }
      _read() {
        if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {
          return this.push(null);
        }
        this._next((err, result) => {
          if (err) {
            if (this.listeners("error") && this.listeners("error").length > 0) {
              this.emit("error", err);
            }
            if (!this.isDead())
              this.close();
            this.emit("end");
            return this.emit("finish");
          }
          if (this.cursorState.streamOptions && typeof this.cursorState.streamOptions.transform === "function" && result != null) {
            return this.push(this.cursorState.streamOptions.transform(result));
          }
          this.push(result);
          if (result === null && this.isDead()) {
            this.once("end", () => {
              this.close();
              this.emit("finish");
            });
          }
        });
      }
      _endSession(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = options2 || {};
        const session = this.cursorState.session;
        if (session && (options2.force || session.owner === this)) {
          this.cursorState.session = void 0;
          if (this.operation) {
            this.operation.clearSession();
          }
          session.endSession(callback);
          return true;
        }
        if (callback) {
          callback();
        }
        return false;
      }
      _getMore(callback) {
        if (this.logger.isDebug()) {
          this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);
        }
        let batchSize = this.cursorState.batchSize;
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {
          batchSize = this.cursorState.limit - this.cursorState.currentLimit;
        }
        const cursorState = this.cursorState;
        this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            this._endSession();
          }
          callback(err, result, conn);
        });
      }
      _initializeCursor(callback) {
        const cursor = this;
        if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {
          cursor.topology.selectServer(ReadPreference.primaryPreferred, (err) => {
            if (err) {
              callback(err);
              return;
            }
            this._initializeCursor(callback);
          });
          return;
        }
        function done(err, result) {
          const cursorState = cursor.cursorState;
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            cursor._endSession();
          }
          if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {
            return setCursorNotified(cursor, callback);
          }
          callback(err, result);
        }
        const queryCallback = (err, r) => {
          if (err) {
            return done(err);
          }
          const result = r.message;
          if (Array.isArray(result.documents) && result.documents.length === 1) {
            const document2 = result.documents[0];
            if (result.queryFailure) {
              return done(new MongoError(document2), null);
            }
            if (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) {
              if (document2.$err || document2.errmsg) {
                return done(new MongoError(document2), null);
              }
              if (document2.cursor != null && typeof document2.cursor !== "string") {
                const id = document2.cursor.id;
                if (document2.cursor.ns) {
                  cursor.ns = document2.cursor.ns;
                }
                cursor.cursorState.cursorId = typeof id === "number" ? Long2.fromNumber(id) : id;
                cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;
                cursor.cursorState.operationTime = document2.operationTime;
                if (Array.isArray(document2.cursor.firstBatch)) {
                  cursor.cursorState.documents = document2.cursor.firstBatch;
                }
                return done(null, result);
              }
            }
          }
          const cursorId = result.cursorId || 0;
          cursor.cursorState.cursorId = cursorId instanceof Long2 ? cursorId : Long2.fromNumber(cursorId);
          cursor.cursorState.documents = result.documents;
          cursor.cursorState.lastCursorId = result.cursorId;
          if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === "function") {
            cursor.cursorState.documents = cursor.cursorState.transforms.query(result);
          }
          done(null, result);
        };
        if (cursor.operation) {
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
          }
          executeOperation(cursor.topology, cursor.operation, (err, result) => {
            if (err) {
              done(err);
              return;
            }
            cursor.server = cursor.operation.server;
            cursor.cursorState.init = true;
            if (cursor.cursorState.cursorId != null) {
              return done();
            }
            queryCallback(err, result);
          });
          return;
        }
        const serverSelectOptions = {};
        if (cursor.cursorState.session) {
          serverSelectOptions.session = cursor.cursorState.session;
        }
        if (cursor.operation) {
          serverSelectOptions.readPreference = cursor.operation.readPreference;
        } else if (cursor.options.readPreference) {
          serverSelectOptions.readPreference = cursor.options.readPreference;
        }
        return cursor.topology.selectServer(serverSelectOptions, (err, server) => {
          if (err) {
            const disconnectHandler = cursor.disconnectHandler;
            if (disconnectHandler != null) {
              return disconnectHandler.addObjectAndMethod("cursor", cursor, "next", [callback], callback);
            }
            return callback(err);
          }
          cursor.server = server;
          cursor.cursorState.init = true;
          if (collationNotSupported(cursor.server, cursor.cmd)) {
            return callback(new MongoError(`server ${cursor.server.name} does not support collation`));
          }
          if (cursor.cursorState.cursorId != null) {
            return done();
          }
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
          }
          if (cursor.cmd.find != null) {
            server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);
            return;
          }
          const commandOptions = Object.assign({ session: cursor.cursorState.session }, cursor.options);
          server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);
        });
      }
    };
    if (SUPPORTS.ASYNC_ITERATOR) {
      CoreCursor.prototype[Symbol.asyncIterator] = require_async_iterator().asyncIterator;
    }
    function isConnectionDead(self2, callback) {
      if (self2.pool && self2.pool.isDestroyed()) {
        self2.cursorState.killed = true;
        const err = new MongoNetworkError(`connection to host ${self2.pool.host}:${self2.pool.port} was destroyed`);
        _setCursorNotifiedImpl(self2, () => callback(err));
        return true;
      }
      return false;
    }
    function isCursorDeadButNotkilled(self2, callback) {
      if (self2.cursorState.dead && !self2.cursorState.killed) {
        self2.cursorState.killed = true;
        setCursorNotified(self2, callback);
        return true;
      }
      return false;
    }
    function isCursorDeadAndKilled(self2, callback) {
      if (self2.cursorState.dead && self2.cursorState.killed) {
        handleCallback(callback, new MongoError("cursor is dead"));
        return true;
      }
      return false;
    }
    function isCursorKilled(self2, callback) {
      if (self2.cursorState.killed) {
        setCursorNotified(self2, callback);
        return true;
      }
      return false;
    }
    function setCursorDeadAndNotified(self2, callback) {
      self2.cursorState.dead = true;
      setCursorNotified(self2, callback);
    }
    function setCursorNotified(self2, callback) {
      _setCursorNotifiedImpl(self2, () => handleCallback(callback, null, null));
    }
    function _setCursorNotifiedImpl(self2, callback) {
      self2.cursorState.notified = true;
      self2.cursorState.documents = [];
      self2.cursorState.cursorIndex = 0;
      if (self2.cursorState.session) {
        self2._endSession(callback);
        return;
      }
      return callback();
    }
    function nextFunction(self2, callback) {
      if (self2.cursorState.notified) {
        return callback(new Error("cursor is exhausted"));
      }
      if (isCursorKilled(self2, callback))
        return;
      if (isCursorDeadButNotkilled(self2, callback))
        return;
      if (isCursorDeadAndKilled(self2, callback))
        return;
      if (!self2.cursorState.init) {
        if (!self2.topology.isConnected(self2.options)) {
          if (self2.topology._type === "server" && !self2.topology.s.options.reconnect) {
            return callback(new MongoError("no connection available"));
          }
          if (self2.disconnectHandler != null) {
            if (self2.topology.isDestroyed()) {
              return callback(new MongoError("Topology was destroyed"));
            }
            self2.disconnectHandler.addObjectAndMethod("cursor", self2, "next", [callback], callback);
            return;
          }
        }
        self2._initializeCursor((err, result) => {
          if (err || result === null) {
            callback(err, result);
            return;
          }
          nextFunction(self2, callback);
        });
        return;
      }
      if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
        self2.kill(() => setCursorDeadAndNotified(self2, callback));
      } else if (self2.cursorState.cursorIndex === self2.cursorState.documents.length && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
        self2.cursorState.documents = [];
        self2.cursorState.cursorIndex = 0;
        if (self2.topology.isDestroyed())
          return callback(new MongoNetworkError("connection destroyed, not possible to instantiate cursor"));
        if (isConnectionDead(self2, callback))
          return;
        self2._getMore(function(err, doc, connection) {
          if (err) {
            return handleCallback(callback, err);
          }
          self2.connection = connection;
          if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
            return handleCallback(callback, new MongoError({
              message: "No more documents in tailed cursor",
              tailable: self2.cmd.tailable,
              awaitData: self2.cmd.awaitData
            }));
          } else if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
            return nextFunction(self2, callback);
          }
          if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
            return setCursorDeadAndNotified(self2, callback);
          }
          nextFunction(self2, callback);
        });
      } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
        return handleCallback(callback, new MongoError({
          message: "No more documents in tailed cursor",
          tailable: self2.cmd.tailable,
          awaitData: self2.cmd.awaitData
        }));
      } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && Long2.ZERO.equals(self2.cursorState.cursorId)) {
        setCursorDeadAndNotified(self2, callback);
      } else {
        if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
          self2.kill(() => setCursorDeadAndNotified(self2, callback));
          return;
        }
        self2.cursorState.currentLimit += 1;
        let doc = self2.cursorState.documents[self2.cursorState.cursorIndex++];
        if (!doc || doc.$err) {
          self2.kill(() => setCursorDeadAndNotified(self2, function() {
            handleCallback(callback, new MongoError(doc ? doc.$err : void 0));
          }));
          return;
        }
        if (self2.cursorState.transforms && typeof self2.cursorState.transforms.doc === "function") {
          doc = self2.cursorState.transforms.doc(doc);
        }
        handleCallback(callback, null, doc);
      }
    }
    module2.exports = {
      CursorState,
      CoreCursor
    };
  }
});

// node_modules/mongodb/lib/core/topologies/server.js
var require_server = __commonJS({
  "node_modules/mongodb/lib/core/topologies/server.js"(exports2, module2) {
    init_shims();
    "use strict";
    var inherits2 = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var Logger = require_logger();
    var debugOptions = require_utils3().debugOptions;
    var retrieveBSON = require_utils3().retrieveBSON;
    var Pool = require_pool();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var wireProtocol = require_wireprotocol();
    var CoreCursor = require_cursor().CoreCursor;
    var sdam = require_shared2();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SessionMixins = require_shared2().SessionMixins;
    var extractCommand = require_command_utils().extractCommand;
    var relayEvents = require_utils2().relayEvents;
    var collationNotSupported = require_utils2().collationNotSupported;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var debugFields = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "servername"
    ];
    var id = 0;
    var serverAccounting = false;
    var servers = {};
    var BSON2 = retrieveBSON();
    function topologyId(server) {
      return server.s.parent == null ? server.id : server.s.parent.id;
    }
    var Server = function(options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.id = id++;
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options2) }, options2),
        logger: Logger("Server", options2),
        Cursor: options2.cursorFactory || CoreCursor,
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        pool: null,
        disconnectHandler: options2.disconnectHandler,
        monitoring: typeof options2.monitoring === "boolean" ? options2.monitoring : true,
        inTopology: !!options2.parent,
        monitoringInterval: typeof options2.monitoringInterval === "number" ? options2.monitoringInterval : 5e3,
        compression: { compressors: createCompressionInfo(options2) },
        parent: options2.parent
      };
      if (!this.s.parent) {
        this.s.clusterTime = null;
      }
      this.ismaster = null;
      this.lastIsMasterMS = -1;
      this.monitoringProcessId = null;
      this.initialConnect = true;
      this._type = "server";
      this.lastUpdateTime = 0;
      this.lastWriteDate = 0;
      this.staleness = 0;
    };
    inherits2(Server, EventEmitter);
    Object.assign(Server.prototype, SessionMixins);
    Object.defineProperty(Server.prototype, "type", {
      enumerable: true,
      get: function() {
        return this._type;
      }
    });
    Object.defineProperty(Server.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Server.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    Object.defineProperty(Server.prototype, "clientMetadata", {
      enumerable: true,
      get: function() {
        return this.s.options.metadata;
      }
    });
    Object.defineProperty(Server.prototype, "clusterTime", {
      enumerable: true,
      set: function(clusterTime) {
        const settings = this.s.parent ? this.s.parent : this.s;
        resolveClusterTime(settings, clusterTime);
      },
      get: function() {
        const settings = this.s.parent ? this.s.parent : this.s;
        return settings.clusterTime || null;
      }
    });
    Server.enableServerAccounting = function() {
      serverAccounting = true;
      servers = {};
    };
    Server.disableServerAccounting = function() {
      serverAccounting = false;
    };
    Server.servers = function() {
      return servers;
    };
    Object.defineProperty(Server.prototype, "name", {
      enumerable: true,
      get: function() {
        return this.s.options.host + ":" + this.s.options.port;
      }
    });
    function disconnectHandler(self2, type, ns, cmd, options2, callback) {
      if (!self2.s.pool.isConnected() && self2.s.options.reconnect && self2.s.disconnectHandler != null && !options2.monitoring) {
        self2.s.disconnectHandler.add(type, ns, cmd, options2, callback);
        return true;
      }
      if (!self2.s.pool.isConnected()) {
        callback(new MongoError(f("no connection available to server %s", self2.name)));
        return true;
      }
    }
    function monitoringProcess(self2) {
      return function() {
        if (self2.s.pool.isDestroyed())
          return;
        self2.emit("monitoring", self2);
        var start = new Date().getTime();
        self2.command("admin.$cmd", { ismaster: true }, {
          socketTimeout: typeof self2.s.options.connectionTimeout !== "number" ? 2e3 : self2.s.options.connectionTimeout,
          monitoring: true
        }, (err, result) => {
          self2.lastIsMasterMS = new Date().getTime() - start;
          if (self2.s.pool.isDestroyed())
            return;
          if (result) {
            self2.ismaster = result.result;
          }
          self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
        });
      };
    }
    var eventHandler = function(self2, event) {
      return function(err, conn) {
        if (self2.s.logger.isInfo()) {
          var object = err instanceof MongoError ? JSON.stringify(err) : {};
          self2.s.logger.info(f("server %s fired event %s out with message %s", self2.name, event, object));
        }
        if (event === "connect") {
          self2.initialConnect = false;
          self2.ismaster = conn.ismaster;
          self2.lastIsMasterMS = conn.lastIsMasterMS;
          if (conn.agreedCompressor) {
            self2.s.pool.options.agreedCompressor = conn.agreedCompressor;
          }
          if (conn.zlibCompressionLevel) {
            self2.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;
          }
          if (conn.ismaster.$clusterTime) {
            const $clusterTime = conn.ismaster.$clusterTime;
            self2.clusterTime = $clusterTime;
          }
          if (self2.ismaster.msg === "isdbgrid") {
            self2._type = "mongos";
          }
          if (self2.s.monitoring) {
            self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
          }
          sdam.emitServerDescriptionChanged(self2, {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: sdam.getTopologyType(self2)
          });
          if (!self2.s.inTopology) {
            sdam.emitTopologyDescriptionChanged(self2, {
              topologyType: "Single",
              servers: [
                {
                  address: self2.name,
                  arbiters: [],
                  hosts: [],
                  passives: [],
                  type: sdam.getTopologyType(self2)
                }
              ]
            });
          }
          if (self2.s.logger.isInfo()) {
            self2.s.logger.info(f("server %s connected with ismaster [%s]", self2.name, JSON.stringify(self2.ismaster)));
          }
          self2.emit("connect", self2);
        } else if (event === "error" || event === "parseError" || event === "close" || event === "timeout" || event === "reconnect" || event === "attemptReconnect" || event === "reconnectFailed") {
          if (serverAccounting && ["close", "timeout", "error", "parseError", "reconnectFailed"].indexOf(event) !== -1) {
            if (!self2.s.inTopology) {
              self2.emit("topologyOpening", { topologyId: self2.id });
            }
            delete servers[self2.id];
          }
          if (event === "close") {
            sdam.emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            });
          }
          if (event === "reconnectFailed") {
            self2.emit("reconnectFailed", err);
            if (self2.listeners("error").length > 0) {
              self2.emit("error", err);
            }
            return;
          }
          if (["disconnected", "connecting"].indexOf(self2.s.pool.state) !== -1 && self2.initialConnect && ["close", "timeout", "error", "parseError"].indexOf(event) !== -1) {
            self2.initialConnect = false;
            return self2.emit("error", new MongoNetworkError(f("failed to connect to server [%s] on first connect [%s]", self2.name, err)));
          }
          if (event === "reconnect") {
            sdam.emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: sdam.getTopologyType(self2)
            });
            return self2.emit(event, self2);
          }
          self2.emit(event, err);
        }
      };
    };
    Server.prototype.connect = function(options2) {
      var self2 = this;
      options2 = options2 || {};
      if (serverAccounting)
        servers[this.id] = this;
      if (self2.s.pool && !self2.s.pool.isDisconnected() && !self2.s.pool.isDestroyed()) {
        throw new MongoError(f("server instance in invalid state %s", self2.s.pool.state));
      }
      self2.s.pool = new Pool(this, Object.assign(self2.s.options, options2, { bson: this.s.bson }));
      self2.s.pool.on("close", eventHandler(self2, "close"));
      self2.s.pool.on("error", eventHandler(self2, "error"));
      self2.s.pool.on("timeout", eventHandler(self2, "timeout"));
      self2.s.pool.on("parseError", eventHandler(self2, "parseError"));
      self2.s.pool.on("connect", eventHandler(self2, "connect"));
      self2.s.pool.on("reconnect", eventHandler(self2, "reconnect"));
      self2.s.pool.on("reconnectFailed", eventHandler(self2, "reconnectFailed"));
      relayEvents(self2.s.pool, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
      if (!self2.s.inTopology) {
        this.emit("topologyOpening", { topologyId: topologyId(self2) });
      }
      self2.emit("serverOpening", { topologyId: topologyId(self2), address: self2.name });
      self2.s.pool.connect();
    };
    Server.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Server.prototype.getDescription = function() {
      var ismaster = this.ismaster || {};
      var description = {
        type: sdam.getTopologyType(this),
        address: this.name
      };
      if (ismaster.hosts)
        description.hosts = ismaster.hosts;
      if (ismaster.arbiters)
        description.arbiters = ismaster.arbiters;
      if (ismaster.passives)
        description.passives = ismaster.passives;
      if (ismaster.setName)
        description.setName = ismaster.setName;
      return description;
    };
    Server.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Server.prototype.unref = function() {
      this.s.pool.unref();
    };
    Server.prototype.isConnected = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isConnected();
    };
    Server.prototype.isDestroyed = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isDestroyed();
    };
    function basicWriteValidations(self2) {
      if (!self2.s.pool)
        return new MongoError("server instance is not connected");
      if (self2.s.pool.isDestroyed())
        return new MongoError("server instance pool was destroyed");
    }
    function basicReadValidations(self2, options2) {
      basicWriteValidations(self2, options2);
      if (options2.readPreference && !(options2.readPreference instanceof ReadPreference)) {
        throw new Error("readPreference must be an instance of ReadPreference");
      }
    }
    Server.prototype.command = function(ns, cmd, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicReadValidations(self2, options2);
      if (result)
        return callback(result);
      options2 = Object.assign({}, options2, { wireProtocolCommand: false });
      if (self2.s.logger.isDebug()) {
        const extractedCommand = extractCommand(cmd);
        self2.s.logger.debug(f("executing command [%s] against %s", JSON.stringify({
          ns,
          cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,
          options: debugOptions(debugFields, options2)
        }), self2.name));
      }
      if (disconnectHandler(self2, "command", ns, cmd, options2, callback))
        return;
      if (collationNotSupported(this, cmd)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      wireProtocol.command(self2, ns, cmd, options2, callback);
    };
    Server.prototype.query = function(ns, cmd, cursorState, options2, callback) {
      wireProtocol.query(this, ns, cmd, cursorState, options2, callback);
    };
    Server.prototype.getMore = function(ns, cursorState, batchSize, options2, callback) {
      wireProtocol.getMore(this, ns, cursorState, batchSize, options2, callback);
    };
    Server.prototype.killCursors = function(ns, cursorState, callback) {
      wireProtocol.killCursors(this, ns, cursorState, callback);
    };
    Server.prototype.insert = function(ns, ops, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self2, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "insert", ns, ops, options2, callback))
        return;
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.insert(self2, ns, ops, options2, callback);
    };
    Server.prototype.update = function(ns, ops, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self2, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "update", ns, ops, options2, callback))
        return;
      if (collationNotSupported(this, options2)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.update(self2, ns, ops, options2, callback);
    };
    Server.prototype.remove = function(ns, ops, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self2, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "remove", ns, ops, options2, callback))
        return;
      if (collationNotSupported(this, options2)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.remove(self2, ns, ops, options2, callback);
    };
    Server.prototype.cursor = function(ns, cmd, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options2);
    };
    Server.prototype.equals = function(server) {
      if (typeof server === "string")
        return this.name.toLowerCase() === server.toLowerCase();
      if (server.name)
        return this.name.toLowerCase() === server.name.toLowerCase();
      return false;
    };
    Server.prototype.connections = function() {
      return this.s.pool.allConnections();
    };
    Server.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector, selector = void 0;
      callback(null, this);
    };
    var listeners = ["close", "error", "timeout", "parseError", "connect"];
    Server.prototype.destroy = function(options2, callback) {
      if (this._destroyed) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      var self2 = this;
      if (serverAccounting)
        delete servers[this.id];
      if (this.monitoringProcessId) {
        clearTimeout(this.monitoringProcessId);
      }
      if (!self2.s.pool || this._destroyed) {
        this._destroyed = true;
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      this._destroyed = true;
      if (options2.emitClose) {
        self2.emit("close", self2);
      }
      if (options2.emitDestroy) {
        self2.emit("destroy", self2);
      }
      listeners.forEach(function(event) {
        self2.s.pool.removeAllListeners(event);
      });
      if (self2.listeners("serverClosed").length > 0)
        self2.emit("serverClosed", { topologyId: topologyId(self2), address: self2.name });
      if (self2.listeners("topologyClosed").length > 0 && !self2.s.inTopology) {
        self2.emit("topologyClosed", { topologyId: topologyId(self2) });
      }
      if (self2.s.logger.isDebug()) {
        self2.s.logger.debug(f("destroy called on server %s", self2.name));
      }
      this.s.pool.destroy(options2.force, callback);
    };
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/core/topologies/replset_state.js
var require_replset_state = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset_state.js"(exports2, module2) {
    init_shims();
    "use strict";
    var inherits2 = require("util").inherits;
    var f = require("util").format;
    var diff = require_shared2().diff;
    var EventEmitter = require("events").EventEmitter;
    var Logger = require_logger();
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var Buffer2 = require_safe_buffer().Buffer;
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    var ReplSetState = function(options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      this.setName = options2.setName;
      this.set = {};
      this.id = options2.id;
      this.setName = options2.setName;
      this.logger = options2.logger || Logger("ReplSet", options2);
      this.index = 0;
      this.acceptableLatency = options2.acceptableLatency || 15;
      this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 1e4;
      this.primary = null;
      this.secondaries = [];
      this.arbiters = [];
      this.passives = [];
      this.ghosts = [];
      this.unknownServers = [];
      this.set = {};
      this.maxElectionId = null;
      this.maxSetVersion = 0;
      this.replicasetDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.logicalSessionTimeoutMinutes = void 0;
    };
    inherits2(ReplSetState, EventEmitter);
    ReplSetState.prototype.hasPrimaryAndSecondary = function() {
      return this.primary != null && this.secondaries.length > 0;
    };
    ReplSetState.prototype.hasPrimaryOrSecondary = function() {
      return this.hasPrimary() || this.hasSecondary();
    };
    ReplSetState.prototype.hasPrimary = function() {
      return this.primary != null;
    };
    ReplSetState.prototype.hasSecondary = function() {
      return this.secondaries.length > 0;
    };
    ReplSetState.prototype.get = function(host) {
      var servers = this.allServers();
      for (var i = 0; i < servers.length; i++) {
        if (servers[i].name.toLowerCase() === host.toLowerCase()) {
          return servers[i];
        }
      }
      return null;
    };
    ReplSetState.prototype.allServers = function(options2) {
      options2 = options2 || {};
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      if (!options2.ignoreArbiters)
        servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      return servers;
    };
    ReplSetState.prototype.destroy = function(options2, callback) {
      const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);
      if (this.primary)
        serversToDestroy.push(this.primary);
      let serverCount = serversToDestroy.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        this.secondaries = [];
        this.arbiters = [];
        this.passives = [];
        this.ghosts = [];
        this.unknownServers = [];
        this.set = {};
        this.primary = null;
        emitTopologyDescriptionChanged(this);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      serversToDestroy.forEach((server) => server.destroy(options2, serverDestroyed));
    };
    ReplSetState.prototype.remove = function(server, options2) {
      options2 = options2 || {};
      var serverName = server.name.toLowerCase();
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      for (var i = 0; i < servers.length; i++) {
        if (!options2.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {
          return;
        }
      }
      if (this.set[serverName]) {
        this.set[serverName].type = ServerType.Unknown;
        this.set[serverName].electionId = null;
        this.set[serverName].setName = null;
        this.set[serverName].setVersion = null;
      }
      var removeType = null;
      if (this.primary && this.primary.equals(server)) {
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        removeType = "primary";
      }
      removeType = removeFrom(server, this.secondaries) ? "secondary" : removeType;
      removeType = removeFrom(server, this.arbiters) ? "arbiter" : removeType;
      removeType = removeFrom(server, this.passives) ? "secondary" : removeType;
      removeFrom(server, this.ghosts);
      removeFrom(server, this.unknownServers);
      this.unknownServers.push(serverName);
      if (removeType) {
        this.emit("left", removeType, server);
      }
    };
    var isArbiter = (ismaster) => ismaster.arbiterOnly && ismaster.setName;
    ReplSetState.prototype.update = function(server) {
      var self2 = this;
      var ismaster = server.lastIsMaster();
      var serverName = server.name.toLowerCase();
      if (ismaster) {
        var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
        hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
        hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
        hosts = hosts.map(function(s2) {
          return s2.toLowerCase();
        });
        for (var i = 0; i < hosts.length; i++) {
          if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {
            this.unknownServers.push(hosts[i].toLowerCase());
          }
          if (!this.set[hosts[i]]) {
            this.set[hosts[i]] = {
              type: ServerType.Unknown,
              electionId: null,
              setName: null,
              setVersion: null
            };
          }
        }
      }
      if (!ismaster && !inList(ismaster, server, this.unknownServers)) {
        self2.set[serverName] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self2.set[serverName].type = ServerType.Unknown;
        self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
        self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
        self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
        if (self2.unknownServers.indexOf(server.name) === -1) {
          self2.unknownServers.push(serverName);
        }
        return false;
      }
      if (ismaster.logicalSessionTimeoutMinutes !== void 0 && !isArbiter(ismaster)) {
        if (self2.logicalSessionTimeoutMinutes === void 0 || ismaster.logicalSessionTimeoutMinutes === null) {
          self2.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;
        } else {
          self2.logicalSessionTimeoutMinutes = Math.min(self2.logicalSessionTimeoutMinutes, ismaster.logicalSessionTimeoutMinutes);
        }
      }
      if (ismaster && ismaster.msg === "isdbgrid") {
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        return false;
      }
      if (ismaster.isreplicaset) {
        self2.set[serverName] = {
          type: ServerType.RSGhost,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
        }
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {
        self2.set[serverName] = {
          type: ServerType.RSOther,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster && ismaster.ismaster && !ismaster.setName) {
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
        this.remove(server, { force: true });
        return false;
      }
      if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
        this.remove(server, { force: true });
        return false;
      }
      if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {
        if (this.logger.isWarn()) {
          this.logger.warn(f("the seedlist server was removed due to its address %s not matching its ismaster.me address %s", server.name, ismaster.me));
        }
        delete this.set[serverName];
        removeFrom(server, self2.unknownServers);
        server.destroy({ force: true });
        if (this.primary && !this.primary.equals(server)) {
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        if (!this.primary && ismaster.primary) {
          this.set[ismaster.primary.toLowerCase()] = {
            type: ServerType.PossiblePrimary,
            setName: null,
            electionId: null,
            setVersion: null
          };
        }
        return false;
      }
      if (!this.primary && ismaster.ismaster && ismaster.setName) {
        var ismasterElectionId = server.lastIsMaster().electionId;
        if (this.setName && this.setName !== ismaster.setName) {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return new MongoError(f("setName from ismaster does not match provided connection setName [%s] != [%s]", ismaster.setName, this.setName));
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          var ismasterSetVersion = server.lastIsMaster().setVersion;
          if (result === 1) {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
            return false;
          } else if (result === 0 && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              this.topologyType = TopologyType.ReplicaSetNoPrimary;
              return false;
            }
          }
          this.maxSetVersion = ismasterSetVersion;
          this.maxElectionId = ismasterElectionId;
        }
        var normalizedHosts = ismaster.hosts.map(function(x) {
          return x.toLowerCase();
        });
        var locationIndex = normalizedHosts.indexOf(serverName);
        if (locationIndex !== -1) {
          self2.primary = server;
          self2.set[serverName] = {
            type: ServerType.RSPrimary,
            setVersion: ismaster.setVersion,
            electionId: ismaster.electionId,
            setName: ismaster.setName
          };
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
          if (ismaster.setName)
            this.setName = ismaster.setName;
          removeFrom(server, self2.unknownServers);
          removeFrom(server, self2.secondaries);
          removeFrom(server, self2.passives);
          self2.emit("joined", "primary", server);
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        emitTopologyDescriptionChanged(self2);
        return true;
      } else if (ismaster.ismaster && ismaster.setName) {
        var currentElectionId = self2.set[self2.primary.name.toLowerCase()].electionId;
        var currentSetVersion = self2.set[self2.primary.name.toLowerCase()].setVersion;
        var currentSetName = self2.set[self2.primary.name.toLowerCase()].setName;
        ismasterElectionId = server.lastIsMaster().electionId;
        ismasterSetVersion = server.lastIsMaster().setVersion;
        var ismasterSetName = server.lastIsMaster().setName;
        if (this.primary.equals(server) && currentSetName === ismasterSetName) {
          return false;
        }
        if (currentSetName && currentSetName !== ismasterSetName) {
          if (!this.primary.equals(server)) {
            this.topologyType = TopologyType.ReplicaSetWithPrimary;
          } else {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
          }
          return false;
        }
        if (currentElectionId && ismasterElectionId) {
          result = compareObjectIds(currentElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion > ismasterSetVersion) {
            return false;
          }
        } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          } else {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          }
          this.maxElectionId = ismasterElectionId;
          this.maxSetVersion = ismasterSetVersion;
        } else {
          this.maxSetVersion = ismasterSetVersion;
        }
        self2.set[self2.primary.name.toLowerCase()] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self2.emit("left", "primary", this.primary);
        self2.primary.destroy({ force: true });
        self2.primary = server;
        self2.set[serverName] = {
          type: ServerType.RSPrimary,
          setVersion: ismaster.setVersion,
          electionId: ismaster.electionId,
          setName: ismaster.setName
        };
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        removeFrom(server, self2.secondaries);
        removeFrom(server, self2.passives);
        self2.emit("joined", "primary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (!this.primary && ismaster.primary) {
        self2.set[ismaster.primary.toLowerCase()] = {
          type: ServerType.PossiblePrimary,
          setVersion: null,
          electionId: null,
          setName: null
        };
      }
      if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSSecondary, ismaster, server, this.secondaries);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({ force: true });
          this.primary = null;
          self2.emit("left", "primary", server);
        }
        self2.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSArbiter, ismaster, server, this.arbiters);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        self2.emit("joined", "arbiter", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSSecondary, ismaster, server, this.passives);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({ force: true });
          this.primary = null;
          self2.emit("left", "primary", server);
        }
        self2.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {
        self2.emit("left", "primary", this.primary);
        this.primary.destroy({ force: true });
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return false;
      }
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      return false;
    };
    ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {
      var max = 0;
      for (var i = 0; i < this.secondaries.length; i++) {
        max = Math.max(max, this.secondaries[i].lastWriteDate);
      }
      if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {
        server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;
      } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {
        server.staleness = max - server.lastWriteDate + haInterval;
      }
    };
    ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {
      for (var i = 0; i < this.secondaries.length; i++) {
        this.updateServerMaxStaleness(this.secondaries[i], haInterval);
      }
    };
    ReplSetState.prototype.pickServer = function(readPreference) {
      readPreference = readPreference || ReadPreference.primary;
      if (readPreference.preference === "primary" && readPreference.maxStalenessSeconds != null) {
        return new MongoError("primary readPreference incompatible with maxStalenessSeconds");
      }
      var allservers = this.primary ? [this.primary] : [];
      allservers = allservers.concat(this.secondaries);
      if (readPreference.maxStalenessSeconds != null) {
        for (var i = 0; i < allservers.length; i++) {
          if (allservers[i].ismaster.maxWireVersion < 5) {
            return new MongoError("maxStalenessSeconds not supported by at least one of the replicaset members");
          }
        }
      }
      if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds == null) {
        return pickNearest(this, readPreference);
      } else if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds != null) {
        return pickNearestMaxStalenessSeconds(this, readPreference);
      }
      var secondaries = this.secondaries;
      if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {
        return new MongoError("no secondary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {
        return new MongoError("no secondary or primary server available");
      }
      if (readPreference.equals(ReadPreference.primary) && this.primary == null) {
        return new MongoError("no primary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          var server = pickNearest(this, readPreference);
          if (server) {
            return server;
          }
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
          if (server) {
            return server;
          }
        }
        if (readPreference.equals(ReadPreference.secondaryPreferred)) {
          return this.primary;
        }
        return null;
      }
      if (readPreference.equals(ReadPreference.primaryPreferred)) {
        server = null;
        if (this.primary) {
          return this.primary;
        }
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          server = pickNearest(this, readPreference);
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
        }
        if (server)
          return server;
      }
      return this.primary;
    };
    var filterByTags = function(readPreference, servers) {
      if (readPreference.tags == null)
        return servers;
      var filteredServers = [];
      var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
      for (var j = 0; j < tagsArray.length; j++) {
        var tags = tagsArray[j];
        for (var i = 0; i < servers.length; i++) {
          var serverTag = servers[i].lastIsMaster().tags || {};
          var found = true;
          for (var name in tags) {
            if (serverTag[name] !== tags[name]) {
              found = false;
            }
          }
          if (found) {
            filteredServers.push(servers[i]);
          }
        }
      }
      return filteredServers;
    };
    function pickNearestMaxStalenessSeconds(self2, readPreference) {
      var servers = [];
      var maxStalenessMS = readPreference.maxStalenessSeconds * 1e3;
      if (maxStalenessMS < 90 * 1e3) {
        return new MongoError("maxStalenessSeconds must be set to at least 90 seconds");
      }
      if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      for (var i = 0; i < self2.secondaries.length; i++) {
        servers.push(self2.secondaries[i]);
      }
      if (self2.primary && servers.length === 0 && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers = servers.filter(function(s2) {
        return s2.staleness <= maxStalenessMS;
      });
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      if (servers.length === 0) {
        return null;
      }
      self2.index = self2.index % servers.length;
      var server = servers[self2.index];
      self2.index = self2.index + 1;
      return server;
    }
    function pickNearest(self2, readPreference) {
      var servers = [];
      if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      for (var i = 0; i < self2.secondaries.length; i++) {
        servers.push(self2.secondaries[i]);
      }
      if (servers.length === 0 && self2.primary && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
      servers = servers.filter(function(s2) {
        return s2.lastIsMasterMS <= lowest + self2.acceptableLatency;
      });
      if (servers.length === 0) {
        return null;
      }
      self2.index = self2.index % servers.length;
      var server = servers[self2.index];
      self2.index = self2.index + 1;
      return server;
    }
    function inList(ismaster, server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i] && list[i].name && list[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      return false;
    }
    function addToList(self2, type, ismaster, server, list) {
      var serverName = server.name.toLowerCase();
      self2.set[serverName].type = type;
      self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
      self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
      self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
      list.push(server);
    }
    function compareObjectIds(id1, id2) {
      var a = Buffer2.from(id1.toHexString(), "hex");
      var b = Buffer2.from(id2.toHexString(), "hex");
      if (a === b) {
        return 0;
      }
      if (typeof Buffer2.compare === "function") {
        return Buffer2.compare(a, b);
      }
      var x = a.length;
      var y = b.length;
      var len = Math.min(x, y);
      for (var i = 0; i < len; i++) {
        if (a[i] !== b[i]) {
          break;
        }
      }
      if (i !== len) {
        x = a[i];
        y = b[i];
      }
      return x < y ? -1 : y < x ? 1 : 0;
    }
    function removeFrom(server, list) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].equals && list[i].equals(server)) {
          list.splice(i, 1);
          return true;
        } else if (typeof list[i] === "string" && list[i].toLowerCase() === server.name.toLowerCase()) {
          list.splice(i, 1);
          return true;
        }
      }
      return false;
    }
    function emitTopologyDescriptionChanged(self2) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        var setName = self2.setName;
        if (self2.hasPrimaryAndSecondary()) {
          topology = "ReplicaSetWithPrimary";
        } else if (!self2.hasPrimary() && self2.hasSecondary()) {
          topology = "ReplicaSetNoPrimary";
        }
        var description = {
          topologyType: topology,
          setName,
          servers: []
        };
        if (self2.hasPrimary()) {
          var desc = self2.primary.getDescription();
          desc.type = "RSPrimary";
          description.servers.push(desc);
        }
        description.servers = description.servers.concat(self2.secondaries.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSSecondary";
          return description2;
        }));
        description.servers = description.servers.concat(self2.arbiters.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSArbiter";
          return description2;
        }));
        description.servers = description.servers.concat(self2.passives.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSSecondary";
          return description2;
        }));
        var diffResult = diff(self2.replicasetDescription, description);
        var result = {
          topologyId: self2.id,
          previousDescription: self2.replicasetDescription,
          newDescription: description,
          diff: diffResult
        };
        self2.emit("topologyDescriptionChanged", result);
        self2.replicasetDescription = description;
      }
    }
    module2.exports = ReplSetState;
  }
});

// node_modules/mongodb/lib/core/topologies/replset.js
var require_replset = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset.js"(exports2, module2) {
    init_shims();
    "use strict";
    var inherits2 = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var CoreCursor = require_cursor().CoreCursor;
    var retrieveBSON = require_utils3().retrieveBSON;
    var Logger = require_logger();
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var ReplSetState = require_replset_state();
    var Timeout = require_shared2().Timeout;
    var Interval = require_shared2().Interval;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYED = "destroyed";
    function stateTransition(self2, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self2.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self2.state = newState;
      } else {
        self2.s.logger.error(f("Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers = ["connect", "close", "error", "timeout", "parseError"];
    var ReplSet = function(seedlist, options2) {
      var self2 = this;
      options2 = options2 || {};
      if (!Array.isArray(seedlist))
        throw new MongoError("seedlist must be an array");
      if (seedlist.length === 0)
        throw new MongoError("seedlist must contain at least one entry");
      seedlist.forEach(function(e) {
        if (typeof e.host !== "string" || typeof e.port !== "number")
          throw new MongoError("seedlist entry must contain a host and port");
      });
      EventEmitter.call(this);
      this.id = id++;
      var localThresholdMS = options2.localThresholdMS || 15;
      if (options2.acceptableLatency)
        localThresholdMS = options2.acceptableLatency;
      var logger = Logger("ReplSet", options2);
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options2) }, options2),
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        Cursor: options2.cursorFactory || CoreCursor,
        logger,
        seedlist,
        replicaSetState: new ReplSetState({
          id: this.id,
          setName: options2.setName,
          acceptableLatency: localThresholdMS,
          heartbeatFrequencyMS: options2.haInterval ? options2.haInterval : 1e4,
          logger
        }),
        connectingServers: [],
        haInterval: options2.haInterval ? options2.haInterval : 1e4,
        minHeartbeatFrequencyMS: 500,
        disconnectHandler: options2.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options2.debug === "boolean" ? options2.debug : false
      };
      this.s.replicaSetState.on("topologyDescriptionChanged", function(r) {
        self2.emit("topologyDescriptionChanged", r);
      });
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
      }
      var types2 = ["joined", "left"];
      types2.forEach(function(x) {
        self2.s.replicaSetState.on(x, function(t, s2) {
          self2.emit(x, t, s2);
        });
      });
      this.initialConnectState = {
        connect: false,
        fullsetup: false,
        all: false
      };
      this.state = DISCONNECTED;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.intervalIds = [];
      this.clusterTime = null;
    };
    inherits2(ReplSet, EventEmitter);
    Object.assign(ReplSet.prototype, SessionMixins);
    Object.defineProperty(ReplSet.prototype, "type", {
      enumerable: true,
      get: function() {
        return "replset";
      }
    });
    Object.defineProperty(ReplSet.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(ReplSet.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;
      }
    });
    function rexecuteOperations(self2) {
      if (self2.s.replicaSetState.hasPrimaryAndSecondary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute();
      } else if (self2.s.replicaSetState.hasPrimary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute({ executePrimary: true });
      } else if (self2.s.replicaSetState.hasSecondary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute({ executeSecondary: true });
      }
    }
    function connectNewServers(self2, servers, callback) {
      if (servers.length === 0) {
        return callback();
      }
      var count = servers.length;
      var error2 = null;
      function done() {
        count = count - 1;
        if (count === 0) {
          callback(error2);
        }
      }
      var _handleEvent = function(self3, event) {
        return function(err) {
          var _self = this;
          if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
            this.destroy({ force: true });
            return done();
          }
          if (event === "connect") {
            var result = self3.s.replicaSetState.update(_self);
            if (result) {
              if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
                self3.ismaster = _self.lastIsMaster();
              }
              for (let i2 = 0; i2 < handlers.length; i2++) {
                _self.removeAllListeners(handlers[i2]);
              }
              _self.on("error", handleEvent(self3, "error"));
              _self.on("close", handleEvent(self3, "close"));
              _self.on("timeout", handleEvent(self3, "timeout"));
              _self.on("parseError", handleEvent(self3, "parseError"));
              monitorServer(_self.lastIsMaster().me, self3, {});
              rexecuteOperations(self3);
            } else {
              _self.destroy({ force: true });
            }
          } else if (event === "error") {
            error2 = err;
          }
          rexecuteOperations(self3);
          done();
        };
      };
      function execute(_server, i2) {
        setTimeout(function() {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          const existingServerIdx = self2.s.connectingServers.findIndex((s2) => s2.name === _server);
          if (existingServerIdx >= 0) {
            const connectingServer = self2.s.connectingServers[existingServerIdx];
            connectingServer.destroy({ force: true });
            self2.s.connectingServers.splice(existingServerIdx, 1);
            return done();
          }
          var server = new Server(Object.assign({}, self2.s.options, {
            host: _server.split(":")[0],
            port: parseInt(_server.split(":")[1], 10),
            reconnect: false,
            monitoring: false,
            parent: self2
          }));
          server.once("connect", _handleEvent(self2, "connect"));
          server.once("close", _handleEvent(self2, "close"));
          server.once("timeout", _handleEvent(self2, "timeout"));
          server.once("error", _handleEvent(self2, "error"));
          server.once("parseError", _handleEvent(self2, "parseError"));
          server.on("serverOpening", (e) => self2.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self2.emit("serverClosed", e));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self2.s.connectingServers.push(server);
          server.connect(self2.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < servers.length; i++) {
        execute(servers[i], i);
      }
    }
    var pingServer = function(self2, server, cb) {
      var start = new Date().getTime();
      emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: server.name });
      server.command("admin.$cmd", {
        ismaster: true
      }, {
        monitoring: true,
        socketTimeout: self2.s.options.connectionTimeout || 2e3
      }, function(err, r) {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          server.destroy({ force: true });
          return cb(err, r);
        }
        var latencyMS = new Date().getTime() - start;
        server.lastUpdateTime = now();
        if (err) {
          emitSDAMEvent(self2, "serverHeartbeatFailed", {
            durationMS: latencyMS,
            failure: err,
            connectionId: server.name
          });
          self2.s.replicaSetState.remove(server);
        } else {
          server.ismaster = r.result;
          if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {
            server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();
          }
          if (server.lastIsMasterMS === -1) {
            server.lastIsMasterMS = latencyMS;
          } else if (server.lastIsMasterMS) {
            server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;
          }
          if (self2.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self2.ismaster = server.lastIsMaster();
            }
          }
          emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
            durationMS: latencyMS,
            reply: r.result,
            connectionId: server.name
          });
        }
        self2.s.replicaSetState.updateServerMaxStaleness(server, self2.s.haInterval);
        cb(err, r);
      });
    };
    var monitorServer = function(host, self2, options2) {
      if (!options2.haInterval) {
        for (var i = 0; i < self2.intervalIds.length; i++) {
          if (self2.intervalIds[i].__host === host) {
            return;
          }
        }
      }
      var _process = options2.haInterval ? Timeout : Interval;
      var _haInterval = options2.haInterval ? options2.haInterval : self2.s.haInterval;
      var intervalId = new _process(function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          intervalId.stop();
          return;
        }
        var _server = self2.s.replicaSetState.get(host);
        if (_server) {
          return pingServer(self2, _server, function(err) {
            if (err) {
              return;
            }
            if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
              intervalId.stop();
              return;
            }
            self2.intervalIds = self2.intervalIds.filter(function(intervalId2) {
              return intervalId2.isRunning();
            });
            if (_process === Timeout) {
              if (self2.state === CONNECTING && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
                stateTransition(self2, CONNECTED);
                process.nextTick(function() {
                  self2.emit("connect", self2);
                });
                topologyMonitor(self2, {});
              }
            } else {
              if (self2.state === DISCONNECTED && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
                stateTransition(self2, CONNECTING);
                rexecuteOperations(self2);
                process.nextTick(function() {
                  self2.emit("reconnect", self2);
                });
              }
            }
            if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
              self2.initialConnectState.fullsetup = true;
              self2.initialConnectState.all = true;
              process.nextTick(function() {
                self2.emit("fullsetup", self2);
                self2.emit("all", self2);
              });
            }
          });
        }
      }, _haInterval);
      intervalId.start();
      intervalId.__host = host;
      self2.intervalIds.push(intervalId);
    };
    function topologyMonitor(self2, options2) {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED)
        return;
      options2 = options2 || {};
      var servers = Object.keys(self2.s.replicaSetState.set);
      var _process = options2.haInterval ? Timeout : Interval;
      var _haInterval = options2.haInterval ? options2.haInterval : self2.s.haInterval;
      if (_process === Timeout) {
        return connectNewServers(self2, self2.s.replicaSetState.unknownServers, function(err) {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          if (!self2.s.replicaSetState.hasPrimary() && !self2.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self2.emit("error", err);
            }
            self2.emit("error", new MongoError("no primary found in replicaset or invalid replica set name"));
            return self2.destroy({ force: true });
          } else if (!self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self2.emit("error", err);
            }
            self2.emit("error", new MongoError("no secondary found in replicaset or invalid replica set name"));
            return self2.destroy({ force: true });
          }
          for (var i2 = 0; i2 < servers.length; i2++) {
            monitorServer(servers[i2], self2, options2);
          }
        });
      } else {
        for (var i = 0; i < servers.length; i++) {
          monitorServer(servers[i], self2, options2);
        }
      }
      function executeReconnect(self3) {
        return function() {
          if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
            return;
          }
          connectNewServers(self3, self3.s.replicaSetState.unknownServers, function() {
            var monitoringFrequencey = self3.s.replicaSetState.hasPrimary() ? _haInterval : self3.s.minHeartbeatFrequencyMS;
            self3.intervalIds.push(new Timeout(executeReconnect(self3), monitoringFrequencey).start());
          });
        };
      }
      var intervalTime = !self2.s.replicaSetState.hasPrimary() ? self2.s.minHeartbeatFrequencyMS : _haInterval;
      self2.intervalIds.push(new Timeout(executeReconnect(self2), intervalTime).start());
    }
    function addServerToList(list, server) {
      for (var i = 0; i < list.length; i++) {
        if (list[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      list.push(server);
    }
    function handleEvent(self2, event) {
      return function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED)
          return;
        if (self2.s.logger.isDebug()) {
          self2.s.logger.debug(f("handleEvent %s from server %s in replset with id %s", event, this.name, self2.id));
        }
        self2.s.replicaSetState.remove(this);
        if (self2.state === DESTROYED || self2.state === UNREFERENCED)
          return;
        if (!self2.s.replicaSetState.hasPrimary() && !self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
          stateTransition(self2, DISCONNECTED);
        } else if (!self2.s.replicaSetState.hasPrimary()) {
          stateTransition(self2, DISCONNECTED);
        }
        addServerToList(self2.s.connectingServers, this);
      };
    }
    function shouldTriggerConnect(self2) {
      const isConnecting = self2.state === CONNECTING;
      const hasPrimary = self2.s.replicaSetState.hasPrimary();
      const hasSecondary = self2.s.replicaSetState.hasSecondary();
      const secondaryOnlyConnectionAllowed = self2.s.options.secondaryOnlyConnectionAllowed;
      const readPreferenceSecondary = self2.s.connectOptions.readPreference && self2.s.connectOptions.readPreference.equals(ReadPreference.secondary);
      return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;
    }
    function handleInitialConnectEvent(self2, event) {
      return function() {
        var _this = this;
        if (self2.s.logger.isDebug()) {
          self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s", event, this.name, self2.id));
        }
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          return this.destroy({ force: true });
        }
        if (event === "connect") {
          var result = self2.s.replicaSetState.update(_this);
          if (result === true) {
            if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {
              self2.ismaster = _this.lastIsMaster();
            }
            if (self2.s.logger.isDebug()) {
              self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]", event, _this.name, self2.id, JSON.stringify(self2.s.replicaSetState.set)));
            }
            for (let i2 = 0; i2 < handlers.length; i2++) {
              _this.removeAllListeners(handlers[i2]);
            }
            _this.on("error", handleEvent(self2, "error"));
            _this.on("close", handleEvent(self2, "close"));
            _this.on("timeout", handleEvent(self2, "timeout"));
            _this.on("parseError", handleEvent(self2, "parseError"));
            if (shouldTriggerConnect(self2)) {
              stateTransition(self2, CONNECTED);
              self2.initialConnectState.connect = true;
              process.nextTick(function() {
                self2.emit("connect", self2);
              });
              topologyMonitor(self2, {});
            }
          } else if (result instanceof MongoError) {
            _this.destroy({ force: true });
            self2.destroy({ force: true });
            return self2.emit("error", result);
          } else {
            _this.destroy({ force: true });
          }
        } else {
          self2.emit("failed", this);
          addServerToList(self2.s.connectingServers, this);
          self2.s.replicaSetState.remove(this);
        }
        if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
          self2.initialConnectState.fullsetup = true;
          self2.initialConnectState.all = true;
          process.nextTick(function() {
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          });
        }
        for (var i = 0; i < self2.s.connectingServers.length; i++) {
          if (self2.s.connectingServers[i].equals(this)) {
            self2.s.connectingServers.splice(i, 1);
          }
        }
        if (self2.s.connectingServers.length === 0 && self2.state === CONNECTING) {
          topologyMonitor(self2, { haInterval: 1 });
        }
      };
    }
    function connectServers(self2, servers) {
      self2.s.connectingServers = self2.s.connectingServers.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval2) {
        setTimeout(function() {
          if (self2.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self2.ismaster = server.lastIsMaster();
            }
          }
          server.once("close", handleInitialConnectEvent(self2, "close"));
          server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
          server.once("error", handleInitialConnectEvent(self2, "error"));
          server.once("connect", handleInitialConnectEvent(self2, "connect"));
          server.on("serverOpening", (e) => self2.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self2.emit("serverClosed", e));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self2.s.connectOptions);
        }, timeoutInterval2);
      }
      while (servers.length > 0) {
        connect(servers.shift(), timeoutInterval++);
      }
    }
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    ReplSet.prototype.connect = function(options2) {
      var self2 = this;
      this.s.connectOptions = options2 || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        return new Server(Object.assign({}, self2.s.options, x, options2, {
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
      });
      if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {
        return self2.emit("error", new MongoError(f("haInterval [%s] MS must be set to less than socketTimeout [%s] MS", this.s.options.haInterval, this.s.options.socketTimeout)));
      }
      emitSDAMEvent(this, "topologyOpening", { topologyId: this.id });
      connectServers(self2, servers);
    };
    ReplSet.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    ReplSet.prototype.destroy = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      let destroyCount = this.s.connectingServers.length + 1;
      const serverDestroyed = () => {
        destroyCount--;
        if (destroyCount > 0) {
          return;
        }
        emitSDAMEvent(this, "topologyClosed", { topologyId: this.id });
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (this.state === DESTROYED) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DESTROYED);
      if (this.haTimeoutId)
        clearTimeout(this.haTimeoutId);
      for (var i = 0; i < this.intervalIds.length; i++) {
        this.intervalIds[i].stop();
      }
      this.intervalIds = [];
      if (destroyCount === 0) {
        serverDestroyed();
        return;
      }
      this.s.replicaSetState.destroy(options2, serverDestroyed);
      this.s.connectingServers.forEach(function(x) {
        x.destroy(options2, serverDestroyed);
      });
    };
    ReplSet.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      this.s.replicaSetState.allServers().forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    ReplSet.prototype.lastIsMaster = function() {
      if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {
        return this.s.replicaSetState.secondaries[0].lastIsMaster();
      }
      return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;
    };
    ReplSet.prototype.connections = function() {
      var servers = this.s.replicaSetState.allServers();
      var connections = [];
      for (var i = 0; i < servers.length; i++) {
        connections = connections.concat(servers[i].connections());
      }
      return connections;
    };
    ReplSet.prototype.isConnected = function(options2) {
      options2 = options2 || {};
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.secondary)) {
        return this.s.replicaSetState.hasSecondary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.primary)) {
        return this.s.replicaSetState.hasPrimary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.primaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.secondaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {
        return true;
      }
      return this.s.replicaSetState.hasPrimary();
    };
    ReplSet.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    var SERVER_SELECTION_TIMEOUT_MS = 1e4;
    var SERVER_SELECTION_INTERVAL_MS = 1e3;
    ReplSet.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector;
      options2 = options2 || {};
      let readPreference;
      if (selector instanceof ReadPreference) {
        readPreference = selector;
      } else {
        readPreference = options2.readPreference || ReadPreference.primary;
      }
      let lastError;
      const start = now();
      const _selectServer = () => {
        if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {
          if (lastError != null) {
            callback(lastError, null);
          } else {
            callback(new MongoError("Server selection timed out"));
          }
          return;
        }
        const server = this.s.replicaSetState.pickServer(readPreference);
        if (server == null) {
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (!(server instanceof Server)) {
          lastError = server;
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (this.s.debug)
          this.emit("pickedServer", options2.readPreference, server);
        callback(null, server);
      };
      _selectServer();
    };
    ReplSet.prototype.getServers = function() {
      return this.s.replicaSetState.allServers();
    };
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const self2 = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      if (self2.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && options2.explain === void 0;
      if (!self2.s.replicaSetState.hasPrimary()) {
        if (self2.s.disconnectHandler) {
          return self2.s.disconnectHandler.add(op, ns, ops, options2, callback);
        } else if (!willRetryWrite) {
          return callback(new MongoError("no primary server found"));
        }
      }
      const handler = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          err = getMMAPError(err);
          return callback(err);
        }
        if (willRetryWrite) {
          const newArgs = Object.assign({}, args, { retrying: true });
          return executeWriteOperation(newArgs, options2, callback);
        }
        if (self2.s.replicaSetState.primary) {
          self2.s.replicaSetState.primary.destroy();
          self2.s.replicaSetState.remove(self2.s.replicaSetState.primary, { force: true });
        }
        return callback(err);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      self2.s.replicaSetState.primary[op](ns, ops, options2, handler);
    }
    ReplSet.prototype.insert = function(ns, ops, options2, callback) {
      executeWriteOperation({ self: this, op: "insert", ns, ops }, options2, callback);
    };
    ReplSet.prototype.update = function(ns, ops, options2, callback) {
      executeWriteOperation({ self: this, op: "update", ns, ops }, options2, callback);
    };
    ReplSet.prototype.remove = function(ns, ops, options2, callback) {
      executeWriteOperation({ self: this, op: "remove", ns, ops }, options2, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    ReplSet.prototype.command = function(ns, cmd, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED)
        return callback(new MongoError(f("topology was destroyed")));
      var self2 = this;
      var readPreference = options2.readPreference ? options2.readPreference : ReadPreference.primary;
      if (readPreference.preference === "primary" && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      } else if (readPreference.preference === "secondary" && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      } else if (readPreference.preference !== "primary" && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      }
      var server = this.s.replicaSetState.pickServer(readPreference);
      if (!(server instanceof Server))
        return callback(server);
      if (self2.s.debug)
        self2.emit("pickedServer", ReadPreference.primary, server);
      if (server == null) {
        return callback(new MongoError(f("no server found that matches the provided readPreference %s", readPreference)));
      }
      const willRetryWrite = !options2.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, options2, { retrying: true });
          return this.command(ns, cmd, newOptions, callback);
        }
        if (this.s.replicaSetState.primary) {
          this.s.replicaSetState.primary.destroy();
          this.s.replicaSetState.remove(this.s.replicaSetState.primary, { force: true });
        }
        return callback(err);
      };
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, options2, cb);
    };
    ReplSet.prototype.cursor = function(ns, cmd, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options2);
    };
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/core/topologies/mongos.js
var require_mongos = __commonJS({
  "node_modules/mongodb/lib/core/topologies/mongos.js"(exports2, module2) {
    init_shims();
    "use strict";
    var inherits2 = require("util").inherits;
    var f = require("util").format;
    var EventEmitter = require("events").EventEmitter;
    var CoreCursor = require_cursor().CoreCursor;
    var Logger = require_logger();
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var diff = require_shared2().diff;
    var cloneOptions = require_shared2().cloneOptions;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    function stateTransition(self2, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYING, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYING, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self2.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self2.state = newState;
      } else {
        self2.s.logger.error(f("Mongos with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers = ["connect", "close", "error", "timeout", "parseError"];
    var Mongos = function(seedlist, options2) {
      options2 = options2 || {};
      this.id = id++;
      if (Array.isArray(seedlist)) {
        seedlist = seedlist.reduce((seeds, seed) => {
          if (seeds.find((s2) => s2.host === seed.host && s2.port === seed.port)) {
            return seeds;
          }
          seeds.push(seed);
          return seeds;
        }, []);
      }
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options2) }, options2),
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        Cursor: options2.cursorFactory || CoreCursor,
        logger: Logger("Mongos", options2),
        seedlist,
        haInterval: options2.haInterval ? options2.haInterval : 1e4,
        disconnectHandler: options2.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options2.debug === "boolean" ? options2.debug : false,
        localThresholdMS: options2.localThresholdMS || 15
      };
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
      }
      this.state = DISCONNECTED;
      this.connectingProxies = [];
      this.connectedProxies = [];
      this.disconnectedProxies = [];
      this.index = 0;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.topologyDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.clusterTime = null;
      EventEmitter.call(this);
    };
    inherits2(Mongos, EventEmitter);
    Object.assign(Mongos.prototype, SessionMixins);
    Object.defineProperty(Mongos.prototype, "type", {
      enumerable: true,
      get: function() {
        return "mongos";
      }
    });
    Object.defineProperty(Mongos.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Mongos.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    var SERVER_EVENTS = ["serverDescriptionChanged", "error", "close", "timeout", "parseError"];
    function destroyServer(server, options2, callback) {
      options2 = options2 || {};
      SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options2, callback);
    }
    Mongos.prototype.connect = function(options2) {
      var self2 = this;
      this.s.connectOptions = options2 || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        const server = new Server(Object.assign({}, self2.s.options, x, options2, {
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
        relayEvents(server, self2, ["serverDescriptionChanged"]);
        return server;
      });
      emitSDAMEvent(this, "topologyOpening", { topologyId: this.id });
      connectProxies(self2, servers);
    };
    Mongos.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    function handleEvent(self2) {
      return function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING) {
          return;
        }
        moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, this);
        emitTopologyDescriptionChanged(self2);
        self2.emit("left", "mongos", this);
        self2.emit("serverClosed", {
          topologyId: self2.id,
          address: this.name
        });
      };
    }
    function handleInitialConnectEvent(self2, event) {
      return function() {
        var _this = this;
        if (self2.state === DESTROYED) {
          emitTopologyDescriptionChanged(self2);
          moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
          return this.destroy();
        }
        if (event === "connect") {
          self2.ismaster = _this.lastIsMaster();
          if (self2.ismaster.msg === "isdbgrid") {
            for (let i = 0; i < self2.connectedProxies.length; i++) {
              if (self2.connectedProxies[i].name === _this.name) {
                moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, _this);
                emitTopologyDescriptionChanged(self2);
                _this.destroy();
                return self2.emit("failed", _this);
              }
            }
            for (let i = 0; i < handlers.length; i++) {
              _this.removeAllListeners(handlers[i]);
            }
            _this.on("error", handleEvent(self2, "error"));
            _this.on("close", handleEvent(self2, "close"));
            _this.on("timeout", handleEvent(self2, "timeout"));
            _this.on("parseError", handleEvent(self2, "parseError"));
            moveServerFrom(self2.connectingProxies, self2.connectedProxies, _this);
            self2.emit("joined", "mongos", _this);
          } else {
            if (self2.s.logger.isWarn()) {
              var message = "expected mongos proxy, but found replicaset member mongod for server %s";
              if (!self2.ismaster.hosts) {
                message = "expected mongos proxy, but found standalone mongod for server %s";
              }
              self2.s.logger.warn(f(message, _this.name));
            }
            _this.destroy(true);
            removeProxyFrom(self2.connectingProxies, _this);
            self2.emit("left", "server", _this);
            self2.emit("failed", _this);
          }
        } else {
          moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
          self2.emit("left", "mongos", this);
          self2.emit("failed", this);
        }
        emitTopologyDescriptionChanged(self2);
        if (self2.connectingProxies.length === 0) {
          if (self2.connectedProxies.length > 0 && self2.state === CONNECTING) {
            stateTransition(self2, CONNECTED);
            self2.emit("connect", self2);
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          } else if (self2.disconnectedProxies.length === 0) {
            if (self2.s.logger.isWarn()) {
              self2.s.logger.warn(f("no mongos proxies found in seed list, did you mean to connect to a replicaset"));
            }
            return self2.emit("error", new MongoError("no mongos proxies found in seed list"));
          }
          topologyMonitor(self2, { firstConnect: true });
        }
      };
    }
    function connectProxies(self2, servers) {
      self2.connectingProxies = self2.connectingProxies.concat(servers);
      var timeoutInterval = 0;
      function connect(server, timeoutInterval2) {
        setTimeout(function() {
          self2.emit("serverOpening", {
            topologyId: self2.id,
            address: server.name
          });
          emitTopologyDescriptionChanged(self2);
          server.once("close", handleInitialConnectEvent(self2, "close"));
          server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
          server.once("error", handleInitialConnectEvent(self2, "error"));
          server.once("connect", handleInitialConnectEvent(self2, "connect"));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self2.s.connectOptions);
        }, timeoutInterval2);
      }
      servers.forEach((server) => connect(server, timeoutInterval++));
    }
    function pickProxy(self2, session) {
      const transaction = session && session.transaction;
      if (transaction && transaction.server) {
        if (transaction.server.isConnected()) {
          return transaction.server;
        } else {
          transaction.unpinServer();
        }
      }
      var connectedProxies = self2.connectedProxies.slice(0);
      var lowerBoundLatency = Number.MAX_VALUE;
      for (var i = 0; i < connectedProxies.length; i++) {
        if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
          lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
        }
      }
      connectedProxies = connectedProxies.filter(function(server) {
        if (server.lastIsMasterMS <= lowerBoundLatency + self2.s.localThresholdMS && server.isConnected()) {
          return true;
        }
      });
      let proxy;
      if (connectedProxies.length === 0) {
        proxy = self2.connectedProxies[0];
      } else {
        proxy = connectedProxies[self2.index % connectedProxies.length];
        self2.index = (self2.index + 1) % connectedProxies.length;
      }
      if (transaction && transaction.isActive && proxy && proxy.isConnected()) {
        transaction.pinServer(proxy);
      }
      return proxy;
    }
    function moveServerFrom(from, to, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
      for (i = 0; i < to.length; i++) {
        if (to[i].name === proxy.name) {
          to.splice(i, 1);
        }
      }
      to.push(proxy);
    }
    function removeProxyFrom(from, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
    }
    function reconnectProxies(self2, proxies, callback) {
      var count = proxies.length;
      var _handleEvent = function(self3, event) {
        return function() {
          var _self = this;
          count = count - 1;
          if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            return this.destroy();
          }
          if (event === "connect") {
            if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
              moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
              return _self.destroy();
            }
            for (var i2 = 0; i2 < handlers.length; i2++) {
              _self.removeAllListeners(handlers[i2]);
            }
            _self.on("error", handleEvent(self3, "error"));
            _self.on("close", handleEvent(self3, "close"));
            _self.on("timeout", handleEvent(self3, "timeout"));
            _self.on("parseError", handleEvent(self3, "parseError"));
            moveServerFrom(self3.connectingProxies, self3.connectedProxies, _self);
            emitTopologyDescriptionChanged(self3);
            self3.emit("joined", "mongos", _self);
          } else {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            this.destroy();
          }
          if (count === 0) {
            callback();
          }
        };
      };
      if (count === 0) {
        return callback();
      }
      function execute(_server, i2) {
        setTimeout(function() {
          if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
            return;
          }
          var server = new Server(Object.assign({}, self2.s.options, {
            host: _server.name.split(":")[0],
            port: parseInt(_server.name.split(":")[1], 10),
            reconnect: false,
            monitoring: false,
            parent: self2
          }));
          destroyServer(_server, { force: true });
          removeProxyFrom(self2.disconnectedProxies, _server);
          relayEvents(server, self2, ["serverDescriptionChanged"]);
          self2.emit("serverOpening", {
            topologyId: server.s.topologyId !== -1 ? server.s.topologyId : self2.id,
            address: server.name
          });
          server.once("connect", _handleEvent(self2, "connect"));
          server.once("close", _handleEvent(self2, "close"));
          server.once("timeout", _handleEvent(self2, "timeout"));
          server.once("error", _handleEvent(self2, "error"));
          server.once("parseError", _handleEvent(self2, "parseError"));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self2.connectingProxies.push(server);
          server.connect(self2.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < proxies.length; i++) {
        execute(proxies[i], i);
      }
    }
    function topologyMonitor(self2, options2) {
      options2 = options2 || {};
      if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
        return;
      }
      self2.haTimeoutId = setTimeout(function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
          return;
        }
        if (self2.isConnected() && self2.s.disconnectHandler) {
          self2.s.disconnectHandler.execute();
        }
        var proxies = self2.connectedProxies.slice(0);
        var count = proxies.length;
        function pingServer(_self, _server, cb) {
          var start = new Date().getTime();
          emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: _server.name });
          _server.command("admin.$cmd", {
            ismaster: true
          }, {
            monitoring: true,
            socketTimeout: self2.s.options.connectionTimeout || 2e3
          }, function(err, r) {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
              _server.destroy();
              return cb(err, r);
            }
            var latencyMS = new Date().getTime() - start;
            if (err) {
              emitSDAMEvent(self2, "serverHeartbeatFailed", {
                durationMS: latencyMS,
                failure: err,
                connectionId: _server.name
              });
              moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
            } else {
              _server.ismaster = r.result;
              _server.lastIsMasterMS = latencyMS;
              emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
                durationMS: latencyMS,
                reply: r.result,
                connectionId: _server.name
              });
            }
            cb(err, r);
          });
        }
        if (proxies.length === 0) {
          if (self2.listeners("close").length > 0 && self2.state === CONNECTING) {
            self2.emit("error", new MongoError("no mongos proxy available"));
          } else {
            self2.emit("close", self2);
          }
          return reconnectProxies(self2, self2.disconnectedProxies, function() {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              return;
            }
            if (self2.state === CONNECTING && options2.firstConnect) {
              self2.emit("connect", self2);
              self2.emit("fullsetup", self2);
              self2.emit("all", self2);
            } else if (self2.isConnected()) {
              self2.emit("reconnect", self2);
            } else if (!self2.isConnected() && self2.listeners("close").length > 0) {
              self2.emit("close", self2);
            }
            topologyMonitor(self2);
          });
        }
        for (var i = 0; i < proxies.length; i++) {
          pingServer(self2, proxies[i], function() {
            count = count - 1;
            if (count === 0) {
              if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                return;
              }
              reconnectProxies(self2, self2.disconnectedProxies, function() {
                if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                  return;
                }
                topologyMonitor(self2);
              });
            }
          });
        }
      }, self2.s.haInterval);
    }
    Mongos.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Mongos.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      var proxies = this.connectedProxies.concat(this.connectingProxies);
      proxies.forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    Mongos.prototype.destroy = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      stateTransition(this, DESTROYING);
      if (this.haTimeoutId) {
        clearTimeout(this.haTimeoutId);
      }
      const proxies = this.connectedProxies.concat(this.connectingProxies);
      let serverCount = proxies.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        emitTopologyDescriptionChanged(this);
        emitSDAMEvent(this, "topologyClosed", { topologyId: this.id });
        stateTransition(this, DESTROYED);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      proxies.forEach((server) => {
        this.emit("serverClosed", {
          topologyId: this.id,
          address: server.name
        });
        destroyServer(server, options2, serverDestroyed);
        moveServerFrom(this.connectedProxies, this.disconnectedProxies, server);
      });
    };
    Mongos.prototype.isConnected = function() {
      return this.connectedProxies.length > 0;
    };
    Mongos.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const self2 = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      let server = pickProxy(self2, options2.session);
      if (!server)
        return callback(new MongoError("no mongos proxy available"));
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && options2.explain === void 0;
      const handler = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2) || !willRetryWrite) {
          err = getMMAPError(err);
          return callback(err);
        }
        server = pickProxy(self2, options2.session);
        if (!server) {
          return callback(err);
        }
        const newArgs = Object.assign({}, args, { retrying: true });
        return executeWriteOperation(newArgs, options2, callback);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      server[op](ns, ops, options2, handler);
    }
    Mongos.prototype.insert = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("insert", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "insert", ns, ops }, options2, callback);
    };
    Mongos.prototype.update = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("update", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "update", ns, ops }, options2, callback);
    };
    Mongos.prototype.remove = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("remove", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "remove", ns, ops }, options2, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    Mongos.prototype.command = function(ns, cmd, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      var self2 = this;
      var server = pickProxy(self2, options2.session);
      if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      }
      if (server == null) {
        return callback(new MongoError("no mongos proxy available"));
      }
      var clonedOptions = cloneOptions(options2);
      clonedOptions.topology = self2;
      const willRetryWrite = !options2.retrying && options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, clonedOptions, { retrying: true });
          return this.command(ns, cmd, newOptions, callback);
        }
        return callback(err);
      };
      if (willRetryWrite) {
        clonedOptions.session.incrementTransactionNumber();
        clonedOptions.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, clonedOptions, cb);
    };
    Mongos.prototype.cursor = function(ns, cmd, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options2);
    };
    Mongos.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector, selector = void 0;
      options2 = options2 || {};
      const server = pickProxy(this, options2.session);
      if (server == null) {
        callback(new MongoError("server selection failed"));
        return;
      }
      if (this.s.debug)
        this.emit("pickedServer", null, server);
      callback(null, server);
    };
    Mongos.prototype.connections = function() {
      var connections = [];
      for (var i = 0; i < this.connectedProxies.length; i++) {
        connections = connections.concat(this.connectedProxies[i].connections());
      }
      return connections;
    };
    function emitTopologyDescriptionChanged(self2) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        if (self2.connectedProxies.length > 0) {
          topology = "Sharded";
        }
        var description = {
          topologyType: topology,
          servers: []
        };
        var proxies = self2.disconnectedProxies.concat(self2.connectingProxies);
        description.servers = description.servers.concat(proxies.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "Unknown";
          return description2;
        }));
        description.servers = description.servers.concat(self2.connectedProxies.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "Mongos";
          return description2;
        }));
        var diffResult = diff(self2.topologyDescription, description);
        var result = {
          topologyId: self2.id,
          previousDescription: self2.topologyDescription,
          newDescription: description,
          diff: diffResult
        };
        if (diffResult.servers.length > 0) {
          self2.emit("topologyDescriptionChanged", result);
        }
        self2.topologyDescription = description;
      }
    }
    module2.exports = Mongos;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    function Denque(array, options2) {
      var options2 = options2 || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options2.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque.prototype.peekAt = function peekAt(index2) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get2(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index2) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index2 < size / 2) {
        for (k = index2; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index2; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index2, count) {
      var i = index2;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index2 + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index2 === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index2 + count + len & this._capacityMask;
        for (k = index2; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index2 < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index2); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index2, count) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length *= 2;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque;
  }
});

// node_modules/mongodb/lib/core/sdam/events.js
var require_events = __commonJS({
  "node_modules/mongodb/lib/core/sdam/events.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ServerDescriptionChangedEvent = class {
      constructor(topologyId, address, previousDescription, newDescription) {
        Object.assign(this, { topologyId, address, previousDescription, newDescription });
      }
    };
    var ServerOpeningEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, { topologyId, address });
      }
    };
    var ServerClosedEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, { topologyId, address });
      }
    };
    var TopologyDescriptionChangedEvent = class {
      constructor(topologyId, previousDescription, newDescription) {
        Object.assign(this, { topologyId, previousDescription, newDescription });
      }
    };
    var TopologyOpeningEvent = class {
      constructor(topologyId) {
        Object.assign(this, { topologyId });
      }
    };
    var TopologyClosedEvent = class {
      constructor(topologyId) {
        Object.assign(this, { topologyId });
      }
    };
    var ServerHeartbeatStartedEvent = class {
      constructor(connectionId) {
        Object.assign(this, { connectionId });
      }
    };
    var ServerHeartbeatSucceededEvent = class {
      constructor(duration, reply, connectionId) {
        Object.assign(this, { connectionId, duration, reply });
      }
    };
    var ServerHeartbeatFailedEvent = class {
      constructor(duration, failure, connectionId) {
        Object.assign(this, { connectionId, duration, failure });
      }
    };
    module2.exports = {
      ServerDescriptionChangedEvent,
      ServerOpeningEvent,
      ServerClosedEvent,
      TopologyDescriptionChangedEvent,
      TopologyOpeningEvent,
      TopologyClosedEvent,
      ServerHeartbeatStartedEvent,
      ServerHeartbeatSucceededEvent,
      ServerHeartbeatFailedEvent
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    init_shims();
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    init_shims();
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports2, module2) {
    init_shims();
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    init_shims();
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d2) {
      return objectToString(d2) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError2(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError2;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive3(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive3;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    init_shims();
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    init_shims();
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    init_shims();
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer2().Buffer;
    var util = require("util");
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret2 = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret2;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s2) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret2 = "" + p.data;
        while (p = p.next) {
          ret2 += s2 + p.data;
        }
        return ret2;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret2 = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret2, i);
          i += p.data.length;
          p = p.next;
        }
        return ret2;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    init_shims();
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    init_shims();
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    init_shims();
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream2 = require_stream();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream2);
    function nop() {
    }
    function WritableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      var hwm = options2.highWaterMark;
      var writableHwm = options2.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options2);
      }
      this._writableState = new WritableState(options2, this);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream2.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    init_shims();
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      Readable2.call(this, options2);
      Writable.call(this, options2);
      if (options2 && options2.readable === false)
        this.readable = false;
      if (options2 && options2.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options2 && options2.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    init_shims();
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable2;
    var isArray = require_isarray();
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream2 = require_stream();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable2, Stream2);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      var hwm = options2.highWaterMark;
      var readableHwm = options2.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder)
          StringDecoder = require("string_decoder/").StringDecoder;
        this.decoder = new StringDecoder(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable2(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options2);
      this._readableState = new ReadableState(options2, this);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0)
        ret2 = fromList(n, state);
      else
        ret2 = null;
      if (ret2 === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret2 !== null)
        this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src2 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src2.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src2) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src2);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src2.removeListener("end", onend);
        src2.removeListener("end", unpipe);
        src2.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src2.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret2 = dest.write(chunk);
        if (ret2 === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src2._readableState.awaitDrain);
            src2._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src2.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src2.unpipe(dest);
      }
      dest.emit("pipe", src2);
      if (!state.flowing) {
        debug("pipe resume");
        src2.resume();
      }
      return dest;
    };
    function pipeOnDrain(src2) {
      return function() {
        var state = src2._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src2, "data")) {
          state.flowing = true;
          flow(src2);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index2 = indexOf(state.pipes, dest);
      if (index2 === -1)
        return this;
      state.pipes.splice(index2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret2 = _this.push(chunk);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret2;
      if (state.objectMode)
        ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret2 = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret2 = state.buffer.head.data;
        else
          ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret2;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret2;
      if (n < list.head.data.length) {
        ret2 = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret2 = list.shift();
      } else {
        ret2 = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret2;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret2 = p.data;
      n -= ret2.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret2 += str;
        else
          ret2 += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function copyFromBuffer(n, list) {
      var ret2 = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret2);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret2, ret2.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs2 = this._readableState;
      rs2.reading = false;
      if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
        this._read(rs2.highWaterMark);
      }
    }
    function Transform(options2) {
      if (!(this instanceof Transform))
        return new Transform(options2);
      Duplex.call(this, options2);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options2) {
        if (typeof options2.transform === "function")
          this._transform = options2.transform;
        if (typeof options2.flush === "function")
          this._flush = options2.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs2 = this._readableState;
        if (ts.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = PassThrough2;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough2, Transform);
    function PassThrough2(options2) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options2);
      Transform.call(this, options2);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    init_shims();
    var Stream2 = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream2) {
      module2.exports = Stream2;
      exports2 = module2.exports = Stream2.Readable;
      exports2.Readable = Stream2.Readable;
      exports2.Writable = Stream2.Writable;
      exports2.Duplex = Stream2.Duplex;
      exports2.Transform = Stream2.Transform;
      exports2.PassThrough = Stream2.PassThrough;
      exports2.Stream = Stream2;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream2 || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    init_shims();
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var util = require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    function BufferList(callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback);
      this._bufs = [];
      this.length = 0;
      if (typeof callback == "function") {
        this._callback = callback;
        var piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src2) {
          src2.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src2) {
          src2.removeListener("error", piper);
        });
      } else {
        this.append(callback);
      }
      DuplexStream.call(this);
    }
    util.inherits(BufferList, DuplexStream);
    BufferList.prototype._offset = function _offset(offset) {
      var tot = 0, i = 0, _t;
      if (offset === 0)
        return [0, 0];
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length;
        if (offset < _t || i == this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      var bufferId = blOffset[0];
      var offset = blOffset[1];
      for (var i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.append = function append(buf) {
      var i = 0;
      if (Buffer2.isBuffer(buf)) {
        this._appendBuffer(buf);
      } else if (Array.isArray(buf)) {
        for (; i < buf.length; i++)
          this.append(buf[i]);
      } else if (buf instanceof BufferList) {
        for (; i < buf._bufs.length; i++)
          this.append(buf._bufs[i]);
      } else if (buf != null) {
        if (typeof buf == "number")
          buf = buf.toString();
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback == "function")
        callback();
    };
    BufferList.prototype._read = function _read(size) {
      if (!this.length)
        return this.push(null);
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferList.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferList.prototype.get = function get2(index2) {
      if (index2 > this.length || index2 < 0) {
        return void 0;
      }
      var offset = this._offset(index2);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start == "number" && start < 0)
        start += this.length;
      if (typeof end == "number" && end < 0)
        end += this.length;
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != "number" || srcStart < 0)
        srcStart = 0;
      if (typeof srcEnd != "number" || srcEnd > this.length)
        srcEnd = this.length;
      if (srcStart >= this.length)
        return dst || Buffer2.alloc(0);
      if (srcEnd <= 0)
        return dst || Buffer2.alloc(0);
      var copy2 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy2 && dstStart || 0, start = off[1], l, i;
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2)
        dst = Buffer2.allocUnsafe(len);
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start)
          start = 0;
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0)
        start += this.length;
      if (end < 0)
        end += this.length;
      if (start === end) {
        return new BufferList();
      }
      var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] == 0)
        buffers.pop();
      else
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      if (startOffset[1] != 0)
        buffers[0] = buffers[0].slice(startOffset[1]);
      return new BufferList(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      var i = 0, copy = new BufferList();
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i]);
      return copy;
    };
    BufferList.prototype.destroy = function destroy() {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (search instanceof BufferList) {
        search = search.slice();
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      var blOffset = this._offset(offset);
      var blIndex = blOffset[0];
      var buffOffset = blOffset[1];
      for (blIndex; blIndex < this._bufs.length; blIndex++) {
        var buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          var availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            var nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            var revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (var searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      var methods = {
        "readDoubleBE": 8,
        "readDoubleLE": 8,
        "readFloatBE": 4,
        "readFloatLE": 4,
        "readInt32BE": 4,
        "readInt32LE": 4,
        "readUInt32BE": 4,
        "readUInt32LE": 4,
        "readInt16BE": 2,
        "readInt16LE": 2,
        "readUInt16BE": 2,
        "readUInt16LE": 2,
        "readInt8": 1,
        "readUInt8": 1,
        "readIntBE": null,
        "readIntLE": null,
        "readUIntBE": null,
        "readUIntLE": null
      };
      for (var m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    module2.exports = BufferList;
  }
});

// node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS({
  "node_modules/mongodb/lib/cmap/message_stream.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Duplex = require("stream").Duplex;
    var BufferList = require_bl();
    var MongoParseError = require_error().MongoParseError;
    var decompress = require_compression().decompress;
    var Response2 = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoError = require_error().MongoError;
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var Msg = require_msg().Msg;
    var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
    var kBuffer = Symbol("buffer");
    var MessageStream = class extends Duplex {
      constructor(options2) {
        options2 = options2 || {};
        super(options2);
        this.bson = options2.bson;
        this.maxBsonMessageSize = options2.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
        this[kBuffer] = new BufferList();
      }
      _write(chunk, _, callback) {
        const buffer = this[kBuffer];
        buffer.append(chunk);
        processIncomingData(this, callback);
      }
      _read() {
        return;
      }
      writeCommand(command, operationDescription) {
        const shouldCompress = operationDescription && !!operationDescription.agreedCompressor;
        if (!shouldCompress || !canCompress(command)) {
          const data = command.toBin();
          this.push(Array.isArray(data) ? Buffer.concat(data) : data);
          return;
        }
        const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
        compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {
          if (err) {
            operationDescription.cb(err, null);
            return;
          }
          const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
          msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
          msgHeader.writeInt32LE(command.requestId, 4);
          msgHeader.writeInt32LE(0, 8);
          msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
          const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
          compressionDetails.writeInt32LE(originalCommandOpCode, 0);
          compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
          compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8);
          this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
        });
      }
    };
    function canCompress(command) {
      const commandDoc = command instanceof Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function processIncomingData(stream, callback) {
      const buffer = stream[kBuffer];
      if (buffer.length < 4) {
        callback();
        return;
      }
      const sizeOfMessage = buffer.readInt32LE(0);
      if (sizeOfMessage < 0) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));
        return;
      }
      if (sizeOfMessage > stream.maxBsonMessageSize) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));
        return;
      }
      if (sizeOfMessage > buffer.length) {
        callback();
        return;
      }
      const message = buffer.slice(0, sizeOfMessage);
      buffer.consume(sizeOfMessage);
      const messageHeader = {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
      let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response2;
      const responseOptions = stream.responseOptions;
      if (messageHeader.opCode !== OP_COMPRESSED) {
        const messageBody = message.slice(MESSAGE_HEADER_SIZE);
        stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
        if (buffer.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
        return;
      }
      messageHeader.fromCompressed = true;
      messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
      messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
      const compressorID = message[MESSAGE_HEADER_SIZE + 8];
      const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
      ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response2;
      decompress(compressorID, compressedBuffer, (err, messageBody) => {
        if (err) {
          callback(err);
          return;
        }
        if (messageBody.length !== messageHeader.length) {
          callback(new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
          return;
        }
        stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
        if (buffer.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
      });
    }
    module2.exports = MessageStream;
  }
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS({
  "node_modules/mongodb/lib/cmap/stream_description.js"(exports2, module2) {
    init_shims();
    "use strict";
    var parseServerType = require_server_description().parseServerType;
    var RESPONSE_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "__nodejs_mock_server__"
    ];
    var StreamDescription = class {
      constructor(address, options2) {
        this.address = address;
        this.type = parseServerType(null);
        this.minWireVersion = void 0;
        this.maxWireVersion = void 0;
        this.maxBsonObjectSize = 16777216;
        this.maxMessageSizeBytes = 48e6;
        this.maxWriteBatchSize = 1e5;
        this.compressors = options2 && options2.compression && Array.isArray(options2.compression.compressors) ? options2.compression.compressors : [];
      }
      receiveResponse(response) {
        this.type = parseServerType(response);
        RESPONSE_FIELDS.forEach((field) => {
          if (typeof response[field] !== "undefined") {
            this[field] = response[field];
          }
        });
        if (response.compression) {
          this.compressor = this.compressors.filter((c) => response.compression.indexOf(c) !== -1)[0];
        }
      }
    };
    module2.exports = {
      StreamDescription
    };
  }
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection2 = __commonJS({
  "node_modules/mongodb/lib/cmap/connection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events");
    var MessageStream = require_message_stream();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var CommandResult = require_command_result();
    var StreamDescription = require_stream_description().StreamDescription;
    var wp = require_wireprotocol();
    var apm = require_apm();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var uuidV4 = require_utils2().uuidV4;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var kStream = Symbol("stream");
    var kQueue = Symbol("queue");
    var kMessageStream = Symbol("messageStream");
    var kGeneration = Symbol("generation");
    var kLastUseTime = Symbol("lastUseTime");
    var kClusterTime = Symbol("clusterTime");
    var kDescription = Symbol("description");
    var kIsMaster = Symbol("ismaster");
    var kAutoEncrypter = Symbol("autoEncrypter");
    var Connection = class extends EventEmitter {
      constructor(stream, options2) {
        super(options2);
        this.id = options2.id;
        this.address = streamIdentifier(stream);
        this.bson = options2.bson;
        this.socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        this.host = options2.host || "localhost";
        this.port = options2.port || 27017;
        this.monitorCommands = typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false;
        this.closed = false;
        this.destroyed = false;
        this[kDescription] = new StreamDescription(this.address, options2);
        this[kGeneration] = options2.generation;
        this[kLastUseTime] = now();
        if (options2.autoEncrypter) {
          this[kAutoEncrypter] = options2.autoEncrypter;
        }
        this[kQueue] = new Map();
        this[kMessageStream] = new MessageStream(options2);
        this[kMessageStream].on("message", messageHandler(this));
        this[kStream] = stream;
        stream.on("error", () => {
        });
        this[kMessageStream].on("error", (error2) => this.handleIssue({ destroy: error2 }));
        stream.on("close", () => this.handleIssue({ isClose: true }));
        stream.on("timeout", () => this.handleIssue({ isTimeout: true, destroy: true }));
        stream.pipe(this[kMessageStream]);
        this[kMessageStream].pipe(stream);
      }
      get description() {
        return this[kDescription];
      }
      get ismaster() {
        return this[kIsMaster];
      }
      set ismaster(response) {
        this[kDescription].receiveResponse(response);
        this[kIsMaster] = response;
      }
      get generation() {
        return this[kGeneration] || 0;
      }
      get idleTime() {
        return calculateDurationInMs(this[kLastUseTime]);
      }
      get clusterTime() {
        return this[kClusterTime];
      }
      get stream() {
        return this[kStream];
      }
      markAvailable() {
        this[kLastUseTime] = now();
      }
      handleIssue(issue) {
        if (this.closed) {
          return;
        }
        if (issue.destroy) {
          this[kStream].destroy(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
        }
        this.closed = true;
        for (const idAndOp of this[kQueue]) {
          const op = idAndOp[1];
          if (issue.isTimeout) {
            op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {
              beforeHandshake: this.ismaster == null
            }));
          } else if (issue.isClose) {
            op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));
          } else {
            op.cb(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
          }
        }
        this[kQueue].clear();
        this.emit("close");
      }
      destroy(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = Object.assign({ force: false }, options2);
        if (this[kStream] == null || this.destroyed) {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        if (options2.force) {
          this[kStream].destroy();
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        this[kStream].end((err) => {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      command(ns, cmd, options2, callback) {
        wp.command(makeServerTrampoline(this), ns, cmd, options2, callback);
      }
      query(ns, cmd, cursorState, options2, callback) {
        wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options2, callback);
      }
      getMore(ns, cursorState, batchSize, options2, callback) {
        wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options2, callback);
      }
      killCursors(ns, cursorState, callback) {
        wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);
      }
      insert(ns, ops, options2, callback) {
        wp.insert(makeServerTrampoline(this), ns, ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        wp.update(makeServerTrampoline(this), ns, ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        wp.remove(makeServerTrampoline(this), ns, ops, options2, callback);
      }
    };
    function makeServerTrampoline(connection) {
      const server = {
        description: connection.description,
        clusterTime: connection[kClusterTime],
        s: {
          bson: connection.bson,
          pool: { write: write.bind(connection), isConnected: () => true }
        }
      };
      if (connection[kAutoEncrypter]) {
        server.autoEncrypter = connection[kAutoEncrypter];
      }
      return server;
    }
    function messageHandler(conn) {
      return function messageHandler2(message) {
        conn.emit("message", message);
        if (!conn[kQueue].has(message.responseTo)) {
          return;
        }
        const operationDescription = conn[kQueue].get(message.responseTo);
        const callback = operationDescription.cb;
        conn[kQueue].delete(message.responseTo);
        if (message.moreToCome) {
          conn[kQueue].set(message.requestId, operationDescription);
        } else if (operationDescription.socketTimeoutOverride) {
          conn[kStream].setTimeout(conn.socketTimeout);
        }
        try {
          message.parse(operationDescription);
        } catch (err) {
          callback(new MongoError(err));
          return;
        }
        if (message.documents[0]) {
          const document2 = message.documents[0];
          const session = operationDescription.session;
          if (session) {
            updateSessionFromResponse(session, document2);
          }
          if (document2.$clusterTime) {
            conn[kClusterTime] = document2.$clusterTime;
            conn.emit("clusterTimeReceived", document2.$clusterTime);
          }
          if (operationDescription.command) {
            if (document2.writeConcernError) {
              callback(new MongoWriteConcernError(document2.writeConcernError, document2));
              return;
            }
            if (document2.ok === 0 || document2.$err || document2.errmsg || document2.code) {
              callback(new MongoError(document2));
              return;
            }
          }
        }
        callback(void 0, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));
      };
    }
    function streamIdentifier(stream) {
      if (typeof stream.address === "function") {
        return `${stream.remoteAddress}:${stream.remotePort}`;
      }
      return uuidV4().toString("hex");
    }
    function write(command, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
      }
      options2 = options2 || {};
      const operationDescription = {
        requestId: command.requestId,
        cb: callback,
        session: options2.session,
        fullResult: typeof options2.fullResult === "boolean" ? options2.fullResult : false,
        noResponse: typeof options2.noResponse === "boolean" ? options2.noResponse : false,
        documentsReturnedIn: options2.documentsReturnedIn,
        command: !!options2.command,
        promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
        promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
        promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false,
        bsonRegExp: typeof options2.bsonRegExp === "boolean" ? options2.bsonRegExp : false,
        raw: typeof options2.raw === "boolean" ? options2.raw : false
      };
      if (this[kDescription] && this[kDescription].compressor) {
        operationDescription.agreedCompressor = this[kDescription].compressor;
        if (this[kDescription].zlibCompressionLevel) {
          operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;
        }
      }
      if (typeof options2.socketTimeout === "number") {
        operationDescription.socketTimeoutOverride = true;
        this[kStream].setTimeout(options2.socketTimeout);
      }
      if (this.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
        operationDescription.started = now();
        operationDescription.cb = (err, reply) => {
          if (err) {
            this.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operationDescription.started));
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              this.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));
            } else {
              this.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));
            }
          }
          if (typeof callback === "function") {
            callback(err, reply);
          }
        };
      }
      if (!operationDescription.noResponse) {
        this[kQueue].set(operationDescription.requestId, operationDescription);
      }
      try {
        this[kMessageStream].writeCommand(command, operationDescription);
      } catch (e) {
        if (!operationDescription.noResponse) {
          this[kQueue].delete(operationDescription.requestId);
          operationDescription.cb(e);
          return;
        }
      }
      if (operationDescription.noResponse) {
        operationDescription.cb();
      }
    }
    module2.exports = {
      Connection
    };
  }
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors = __commonJS({
  "node_modules/mongodb/lib/cmap/errors.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_error().MongoError;
    var PoolClosedError = class extends MongoError {
      constructor(pool) {
        super("Attempted to check out a connection from closed connection pool");
        this.name = "MongoPoolClosedError";
        this.address = pool.address;
      }
    };
    var WaitQueueTimeoutError = class extends MongoError {
      constructor(pool) {
        super("Timed out while checking out a connection from connection pool");
        this.name = "MongoWaitQueueTimeoutError";
        this.address = pool.address;
      }
    };
    module2.exports = {
      PoolClosedError,
      WaitQueueTimeoutError
    };
  }
});

// node_modules/mongodb/lib/cmap/events.js
var require_events2 = __commonJS({
  "node_modules/mongodb/lib/cmap/events.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ConnectionPoolMonitoringEvent = class {
      constructor(pool) {
        this.time = new Date();
        this.address = pool.address;
      }
    };
    var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
        this.options = pool.options;
      }
    };
    var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection, reason) {
        super(pool);
        this.connectionId = connection.id;
        this.reason = reason || "unknown";
      }
    };
    var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, reason) {
        super(pool);
        this.reason = reason;
      }
    };
    var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection) {
        super(pool);
        this.connectionId = connection.id;
      }
    };
    var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var CMAP_EVENT_NAMES = [
      "connectionPoolCreated",
      "connectionPoolClosed",
      "connectionCreated",
      "connectionReady",
      "connectionClosed",
      "connectionCheckOutStarted",
      "connectionCheckOutFailed",
      "connectionCheckedOut",
      "connectionCheckedIn",
      "connectionPoolCleared"
    ];
    module2.exports = {
      CMAP_EVENT_NAMES,
      ConnectionPoolCreatedEvent,
      ConnectionPoolClosedEvent,
      ConnectionCreatedEvent,
      ConnectionReadyEvent,
      ConnectionClosedEvent,
      ConnectionCheckOutStartedEvent,
      ConnectionCheckOutFailedEvent,
      ConnectionCheckedOutEvent,
      ConnectionCheckedInEvent,
      ConnectionPoolClearedEvent
    };
  }
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS({
  "node_modules/mongodb/lib/cmap/connection_pool.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events").EventEmitter;
    var Logger = require_logger();
    var makeCounter = require_utils4().makeCounter;
    var MongoError = require_error().MongoError;
    var Connection = require_connection2().Connection;
    var eachAsync = require_utils2().eachAsync;
    var connect = require_connect();
    var relayEvents = require_utils2().relayEvents;
    var errors = require_errors();
    var PoolClosedError = errors.PoolClosedError;
    var WaitQueueTimeoutError = errors.WaitQueueTimeoutError;
    var events = require_events2();
    var ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;
    var ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;
    var ConnectionCreatedEvent = events.ConnectionCreatedEvent;
    var ConnectionReadyEvent = events.ConnectionReadyEvent;
    var ConnectionClosedEvent = events.ConnectionClosedEvent;
    var ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;
    var ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;
    var ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;
    var ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;
    var ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;
    var kLogger = Symbol("logger");
    var kConnections = Symbol("connections");
    var kPermits = Symbol("permits");
    var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
    var kGeneration = Symbol("generation");
    var kConnectionCounter = Symbol("connectionCounter");
    var kCancellationToken = Symbol("cancellationToken");
    var kWaitQueue = Symbol("waitQueue");
    var kCancelled = Symbol("cancelled");
    var VALID_POOL_OPTIONS = new Set([
      "ssl",
      "bson",
      "connectionType",
      "monitorCommands",
      "socketTimeout",
      "credentials",
      "compression",
      "host",
      "port",
      "localAddress",
      "localPort",
      "family",
      "hints",
      "lookup",
      "path",
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "passphrase",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "allowHalfOpen",
      "rejectUnauthorized",
      "pskCallback",
      "ALPNProtocols",
      "servername",
      "checkServerIdentity",
      "session",
      "minDHSize",
      "secureContext",
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ]);
    function resolveOptions(options2, defaults) {
      const newOptions = Array.from(VALID_POOL_OPTIONS).reduce((obj, key) => {
        if (Object.prototype.hasOwnProperty.call(options2, key)) {
          obj[key] = options2[key];
        }
        return obj;
      }, {});
      return Object.freeze(Object.assign({}, defaults, newOptions));
    }
    var ConnectionPool = class extends EventEmitter {
      constructor(options2) {
        super();
        options2 = options2 || {};
        this.closed = false;
        this.options = resolveOptions(options2, {
          connectionType: Connection,
          maxPoolSize: typeof options2.maxPoolSize === "number" ? options2.maxPoolSize : 100,
          minPoolSize: typeof options2.minPoolSize === "number" ? options2.minPoolSize : 0,
          maxIdleTimeMS: typeof options2.maxIdleTimeMS === "number" ? options2.maxIdleTimeMS : 0,
          waitQueueTimeoutMS: typeof options2.waitQueueTimeoutMS === "number" ? options2.waitQueueTimeoutMS : 0,
          autoEncrypter: options2.autoEncrypter,
          metadata: options2.metadata
        });
        if (options2.minSize > options2.maxSize) {
          throw new TypeError("Connection pool minimum size must not be greater than maxiumum pool size");
        }
        this[kLogger] = Logger("ConnectionPool", options2);
        this[kConnections] = new Denque();
        this[kPermits] = this.options.maxPoolSize;
        this[kMinPoolSizeTimer] = void 0;
        this[kGeneration] = 0;
        this[kConnectionCounter] = makeCounter(1);
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kWaitQueue] = new Denque();
        process.nextTick(() => {
          this.emit("connectionPoolCreated", new ConnectionPoolCreatedEvent(this));
          ensureMinPoolSize(this);
        });
      }
      get address() {
        return `${this.options.host}:${this.options.port}`;
      }
      get generation() {
        return this[kGeneration];
      }
      get totalConnectionCount() {
        return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);
      }
      get availableConnectionCount() {
        return this[kConnections].length;
      }
      get waitQueueSize() {
        return this[kWaitQueue].length;
      }
      checkOut(callback) {
        this.emit("connectionCheckOutStarted", new ConnectionCheckOutStartedEvent(this));
        if (this.closed) {
          this.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(this, "poolClosed"));
          callback(new PoolClosedError(this));
          return;
        }
        const waitQueueMember = { callback };
        const pool = this;
        const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
        if (waitQueueTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, "timeout"));
            waitQueueMember.callback(new WaitQueueTimeoutError(pool));
          }, waitQueueTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        process.nextTick(() => processWaitQueue(this));
      }
      checkIn(connection) {
        const poolClosed = this.closed;
        const stale = connectionIsStale(this, connection);
        const willDestroy = !!(poolClosed || stale || connection.closed);
        if (!willDestroy) {
          connection.markAvailable();
          this[kConnections].push(connection);
        }
        this.emit("connectionCheckedIn", new ConnectionCheckedInEvent(this, connection));
        if (willDestroy) {
          const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
          destroyConnection(this, connection, reason);
        }
        process.nextTick(() => processWaitQueue(this));
      }
      clear() {
        this[kGeneration] += 1;
        this.emit("connectionPoolCleared", new ConnectionPoolClearedEvent(this));
      }
      close(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
        }
        options2 = Object.assign({ force: false }, options2);
        if (this.closed) {
          return callback();
        }
        this[kCancellationToken].emit("cancel");
        while (this.waitQueueSize) {
          const waitQueueMember = this[kWaitQueue].pop();
          clearTimeout(waitQueueMember.timer);
          if (!waitQueueMember[kCancelled]) {
            waitQueueMember.callback(new MongoError("connection pool closed"));
          }
        }
        if (this[kMinPoolSizeTimer]) {
          clearTimeout(this[kMinPoolSizeTimer]);
        }
        if (typeof this[kConnectionCounter].return === "function") {
          this[kConnectionCounter].return();
        }
        this.closed = true;
        eachAsync(this[kConnections].toArray(), (conn, cb) => {
          this.emit("connectionClosed", new ConnectionClosedEvent(this, conn, "poolClosed"));
          conn.destroy(options2, cb);
        }, (err) => {
          this[kConnections].clear();
          this.emit("connectionPoolClosed", new ConnectionPoolClosedEvent(this));
          callback(err);
        });
      }
      withConnection(fn, callback) {
        this.checkOut((err, conn) => {
          fn(err, conn, (fnErr, result) => {
            if (typeof callback === "function") {
              if (fnErr) {
                callback(fnErr);
              } else {
                callback(void 0, result);
              }
            }
            if (conn) {
              this.checkIn(conn);
            }
          });
        });
      }
    };
    function ensureMinPoolSize(pool) {
      if (pool.closed || pool.options.minPoolSize === 0) {
        return;
      }
      const minPoolSize = pool.options.minPoolSize;
      for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {
        createConnection(pool);
      }
      pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);
    }
    function connectionIsStale(pool, connection) {
      return connection.generation !== pool[kGeneration];
    }
    function connectionIsIdle(pool, connection) {
      return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);
    }
    function createConnection(pool, callback) {
      const connectOptions = Object.assign({
        id: pool[kConnectionCounter].next().value,
        generation: pool[kGeneration]
      }, pool.options);
      pool[kPermits]--;
      connect(connectOptions, pool[kCancellationToken], (err, connection) => {
        if (err) {
          pool[kPermits]++;
          pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.closed) {
          connection.destroy({ force: true });
          return;
        }
        relayEvents(connection, pool, [
          "commandStarted",
          "commandFailed",
          "commandSucceeded",
          "clusterTimeReceived"
        ]);
        pool.emit("connectionCreated", new ConnectionCreatedEvent(pool, connection));
        connection.markAvailable();
        pool.emit("connectionReady", new ConnectionReadyEvent(pool, connection));
        if (typeof callback === "function") {
          callback(void 0, connection);
          return;
        }
        pool[kConnections].push(connection);
        process.nextTick(() => processWaitQueue(pool));
      });
    }
    function destroyConnection(pool, connection, reason) {
      pool.emit("connectionClosed", new ConnectionClosedEvent(pool, connection, reason));
      pool[kPermits]++;
      process.nextTick(() => connection.destroy());
    }
    function processWaitQueue(pool) {
      if (pool.closed) {
        return;
      }
      while (pool.waitQueueSize) {
        const waitQueueMember = pool[kWaitQueue].peekFront();
        if (waitQueueMember[kCancelled]) {
          pool[kWaitQueue].shift();
          continue;
        }
        if (!pool.availableConnectionCount) {
          break;
        }
        const connection = pool[kConnections].shift();
        const isStale = connectionIsStale(pool, connection);
        const isIdle = connectionIsIdle(pool, connection);
        if (!isStale && !isIdle && !connection.closed) {
          pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
          clearTimeout(waitQueueMember.timer);
          pool[kWaitQueue].shift();
          waitQueueMember.callback(void 0, connection);
          return;
        }
        const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
        destroyConnection(pool, connection, reason);
      }
      const maxPoolSize = pool.options.maxPoolSize;
      if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {
        createConnection(pool, (err, connection) => {
          const waitQueueMember = pool[kWaitQueue].shift();
          if (waitQueueMember == null || waitQueueMember[kCancelled]) {
            if (err == null) {
              pool[kConnections].push(connection);
            }
            return;
          }
          if (err) {
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, err));
          } else {
            pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection));
          }
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(err, connection);
        });
        return;
      }
    }
    module2.exports = {
      ConnectionPool
    };
  }
});

// node_modules/mongodb/lib/core/sdam/monitor.js
var require_monitor = __commonJS({
  "node_modules/mongodb/lib/core/sdam/monitor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ServerType = require_common().ServerType;
    var EventEmitter = require("events");
    var connect = require_connect();
    var Connection = require_connection2().Connection;
    var common = require_common();
    var makeStateMachine = require_utils2().makeStateMachine;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = require_utils3().retrieveBSON();
    var makeInterruptableAsyncInterval = require_utils4().makeInterruptableAsyncInterval;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var now = require_utils4().now;
    var sdamEvents = require_events();
    var ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;
    var ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;
    var ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;
    var kServer = Symbol("server");
    var kMonitorId = Symbol("monitorId");
    var kConnection = Symbol("connection");
    var kCancellationToken = Symbol("cancellationToken");
    var kRTTPinger = Symbol("rttPinger");
    var kRoundTripTime = Symbol("roundTripTime");
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_IDLE = "idle";
    var STATE_MONITORING = "monitoring";
    var stateTransition = makeStateMachine({
      [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],
      [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],
      [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],
      [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]
    });
    var INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);
    function isInCloseState(monitor) {
      return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;
    }
    var Monitor = class extends EventEmitter {
      constructor(server, options2) {
        super(options2);
        this[kServer] = server;
        this[kConnection] = void 0;
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kMonitorId] = null;
        this.s = {
          state: STATE_CLOSED
        };
        this.address = server.description.address;
        this.options = Object.freeze({
          connectTimeoutMS: typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : typeof options2.connectTimeoutMS === "number" ? options2.connectTimeoutMS : 1e4,
          heartbeatFrequencyMS: typeof options2.heartbeatFrequencyMS === "number" ? options2.heartbeatFrequencyMS : 1e4,
          minHeartbeatFrequencyMS: typeof options2.minHeartbeatFrequencyMS === "number" ? options2.minHeartbeatFrequencyMS : 500
        });
        const connectOptions = Object.assign({
          id: "<monitor>",
          host: server.description.host,
          port: server.description.port,
          bson: server.s.bson,
          connectionType: Connection
        }, server.s.options, this.options, {
          raw: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: true,
          bsonRegExp: true
        });
        delete connectOptions.credentials;
        delete connectOptions.autoEncrypter;
        this.connectOptions = Object.freeze(connectOptions);
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS,
          immediate: true
        });
      }
      requestCheck() {
        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
          return;
        }
        this[kMonitorId].wake();
      }
      reset() {
        const topologyVersion = this[kServer].description.topologyVersion;
        if (isInCloseState(this) || topologyVersion == null) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        stateTransition(this, STATE_IDLE);
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS
        });
      }
      close() {
        if (isInCloseState(this)) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        this.emit("close");
        stateTransition(this, STATE_CLOSED);
      }
    };
    function resetMonitorState(monitor) {
      if (monitor[kMonitorId]) {
        monitor[kMonitorId].stop();
        monitor[kMonitorId] = null;
      }
      if (monitor[kRTTPinger]) {
        monitor[kRTTPinger].close();
        monitor[kRTTPinger] = void 0;
      }
      monitor[kCancellationToken].emit("cancel");
      if (monitor[kMonitorId]) {
        clearTimeout(monitor[kMonitorId]);
        monitor[kMonitorId] = void 0;
      }
      if (monitor[kConnection]) {
        monitor[kConnection].destroy({ force: true });
      }
    }
    function checkServer(monitor, callback) {
      let start = now();
      monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
      function failureHandler(err) {
        if (monitor[kConnection]) {
          monitor[kConnection].destroy({ force: true });
          monitor[kConnection] = void 0;
        }
        monitor.emit("serverHeartbeatFailed", new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));
        monitor.emit("resetServer", err);
        monitor.emit("resetConnectionPool");
        callback(err);
      }
      if (monitor[kConnection] != null && !monitor[kConnection].closed) {
        const connectTimeoutMS = monitor.options.connectTimeoutMS;
        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
        const topologyVersion = monitor[kServer].description.topologyVersion;
        const isAwaitable = topologyVersion != null;
        const cmd = { ismaster: true };
        const options2 = { socketTimeout: connectTimeoutMS };
        if (isAwaitable) {
          cmd.maxAwaitTimeMS = maxAwaitTimeMS;
          cmd.topologyVersion = makeTopologyVersion(topologyVersion);
          if (connectTimeoutMS) {
            options2.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;
          }
          options2.exhaustAllowed = true;
          if (monitor[kRTTPinger] == null) {
            monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);
          }
        }
        monitor[kConnection].command("admin.$cmd", cmd, options2, (err, result) => {
          if (err) {
            failureHandler(err);
            return;
          }
          const isMaster = result.result;
          const rttPinger = monitor[kRTTPinger];
          const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);
          monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address));
          if (isAwaitable && isMaster.topologyVersion) {
            monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
            start = now();
          } else {
            if (monitor[kRTTPinger]) {
              monitor[kRTTPinger].close();
              monitor[kRTTPinger] = void 0;
            }
            callback(void 0, isMaster);
          }
        });
        return;
      }
      connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {
        if (conn && isInCloseState(monitor)) {
          conn.destroy({ force: true });
          return;
        }
        if (err) {
          monitor[kConnection] = void 0;
          if (!(err instanceof MongoNetworkError)) {
            monitor.emit("resetConnectionPool");
          }
          failureHandler(err);
          return;
        }
        monitor[kConnection] = conn;
        monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));
        callback(void 0, conn.ismaster);
      });
    }
    function monitorServer(monitor) {
      return (callback) => {
        stateTransition(monitor, STATE_MONITORING);
        function done() {
          if (!isInCloseState(monitor)) {
            stateTransition(monitor, STATE_IDLE);
          }
          callback();
        }
        process.nextTick(() => monitor.emit("monitoring", monitor[kServer]));
        checkServer(monitor, (err, isMaster) => {
          if (err) {
            if (monitor[kServer].description.type === ServerType.Unknown) {
              monitor.emit("resetServer", err);
              return done();
            }
          }
          if (isMaster && isMaster.topologyVersion) {
            setTimeout(() => {
              if (!isInCloseState(monitor)) {
                monitor[kMonitorId].wake();
              }
            });
          }
          done();
        });
      };
    }
    function makeTopologyVersion(tv) {
      return {
        processId: tv.processId,
        counter: BSON2.Long.fromNumber(tv.counter)
      };
    }
    var RTTPinger = class {
      constructor(cancellationToken, options2) {
        this[kConnection] = null;
        this[kCancellationToken] = cancellationToken;
        this[kRoundTripTime] = 0;
        this.closed = false;
        const heartbeatFrequencyMS = options2.heartbeatFrequencyMS;
        this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options2), heartbeatFrequencyMS);
      }
      get roundTripTime() {
        return this[kRoundTripTime];
      }
      close() {
        this.closed = true;
        clearTimeout(this[kMonitorId]);
        this[kMonitorId] = void 0;
        if (this[kConnection]) {
          this[kConnection].destroy({ force: true });
        }
      }
    };
    function measureRoundTripTime(rttPinger, options2) {
      const start = now();
      const cancellationToken = rttPinger[kCancellationToken];
      const heartbeatFrequencyMS = options2.heartbeatFrequencyMS;
      if (rttPinger.closed) {
        return;
      }
      function measureAndReschedule(conn) {
        if (rttPinger.closed) {
          conn.destroy({ force: true });
          return;
        }
        if (rttPinger[kConnection] == null) {
          rttPinger[kConnection] = conn;
        }
        rttPinger[kRoundTripTime] = calculateDurationInMs(start);
        rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options2), heartbeatFrequencyMS);
      }
      if (rttPinger[kConnection] == null) {
        connect(options2, cancellationToken, (err, conn) => {
          if (err) {
            rttPinger[kConnection] = void 0;
            rttPinger[kRoundTripTime] = 0;
            return;
          }
          measureAndReschedule(conn);
        });
        return;
      }
      rttPinger[kConnection].command("admin.$cmd", { ismaster: 1 }, (err) => {
        if (err) {
          rttPinger[kConnection] = void 0;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule();
      });
    }
    module2.exports = {
      Monitor
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server.js
var require_server2 = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events");
    var ConnectionPool = require_connection_pool().ConnectionPool;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var MongoError = require_error().MongoError;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = require_utils3().retrieveBSON();
    var Logger = require_logger();
    var ServerDescription = require_server_description().ServerDescription;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var ReadPreference = require_read_preference();
    var Monitor = require_monitor().Monitor;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var collationNotSupported = require_utils2().collationNotSupported;
    var debugOptions = require_utils3().debugOptions;
    var isSDAMUnrecoverableError = require_error().isSDAMUnrecoverableError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var isNodeShuttingDownError = require_error().isNodeShuttingDownError;
    var isNetworkErrorBeforeHandshake = require_error().isNetworkErrorBeforeHandshake;
    var maxWireVersion = require_utils2().maxWireVersion;
    var makeStateMachine = require_utils2().makeStateMachine;
    var extractCommand = require_command_utils().extractCommand;
    var common = require_common();
    var ServerType = common.ServerType;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var DEBUG_FIELDS = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "servername"
    ];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var kMonitor = Symbol("monitor");
    var Server = class extends EventEmitter {
      constructor(description, options2, topology) {
        super();
        this.s = {
          description,
          options: options2,
          logger: Logger("Server", options2),
          bson: options2.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          state: STATE_CLOSED,
          credentials: options2.credentials,
          topology
        };
        const poolOptions = Object.assign({ host: this.description.host, port: this.description.port, bson: this.s.bson }, options2);
        this.s.pool = new ConnectionPool(poolOptions);
        relayEvents(this.s.pool, this, ["commandStarted", "commandSucceeded", "commandFailed"].concat(CMAP_EVENT_NAMES));
        this.s.pool.on("clusterTimeReceived", (clusterTime) => {
          this.clusterTime = clusterTime;
        });
        this[kMonitor] = new Monitor(this, this.s.options);
        relayEvents(this[kMonitor], this, [
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "monitoring"
        ]);
        this[kMonitor].on("resetConnectionPool", () => {
          this.s.pool.clear();
        });
        this[kMonitor].on("resetServer", (error2) => markServerUnknown(this, error2));
        this[kMonitor].on("serverHeartbeatSucceeded", (event) => {
          this.emit("descriptionReceived", new ServerDescription(this.description.address, event.reply, {
            roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
          }));
          if (this.s.state === STATE_CONNECTING) {
            stateTransition(this, STATE_CONNECTED);
            this.emit("connect", this);
          }
        });
      }
      get description() {
        return this.s.description;
      }
      get supportsRetryableWrites() {
        return supportsRetryableWrites(this);
      }
      get name() {
        return this.s.description.address;
      }
      get autoEncrypter() {
        if (this.s.options && this.s.options.autoEncrypter) {
          return this.s.options.autoEncrypter;
        }
        return null;
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this[kMonitor].connect();
      }
      destroy(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = Object.assign({}, { force: false }, options2);
        if (this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        this[kMonitor].close();
        this.s.pool.close(options2, (err) => {
          stateTransition(this, STATE_CLOSED);
          this.emit("closed");
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      requestCheck() {
        this[kMonitor].requestCheck();
      }
      command(ns, cmd, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2, options2 = {}, options2 = options2 || {};
        }
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        const error2 = basicReadValidations(this, options2);
        if (error2) {
          return callback(error2);
        }
        options2 = Object.assign({}, options2, { wireProtocolCommand: false });
        if (this.s.logger.isDebug()) {
          const extractedCommand = extractCommand(cmd);
          this.s.logger.debug(`executing command [${JSON.stringify({
            ns,
            cmd: extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd,
            options: debugOptions(DEBUG_FIELDS, options2)
          })}] against ${this.name}`);
        }
        if (collationNotSupported(this, cmd)) {
          callback(new MongoError(`server ${this.name} does not support collation`));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.command(ns, cmd, options2, makeOperationHandler(this, conn, cmd, options2, cb));
        }, callback);
      }
      query(ns, cmd, cursorState, options2, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.query(ns, cmd, cursorState, options2, makeOperationHandler(this, conn, cmd, options2, cb));
        }, callback);
      }
      getMore(ns, cursorState, batchSize, options2, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.getMore(ns, cursorState, batchSize, options2, makeOperationHandler(this, conn, null, options2, cb));
        }, callback);
      }
      killCursors(ns, cursorState, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback(new MongoError("server is closed"));
          }
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, void 0, cb));
        }, callback);
      }
      insert(ns, ops, options2, callback) {
        executeWriteOperation({ server: this, op: "insert", ns, ops }, options2, callback);
      }
      update(ns, ops, options2, callback) {
        executeWriteOperation({ server: this, op: "update", ns, ops }, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        executeWriteOperation({ server: this, op: "remove", ns, ops }, options2, callback);
      }
    };
    Object.defineProperty(Server.prototype, "clusterTime", {
      get: function() {
        return this.s.topology.clusterTime;
      },
      set: function(clusterTime) {
        this.s.topology.clusterTime = clusterTime;
      }
    });
    function supportsRetryableWrites(server) {
      return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;
    }
    function calculateRoundTripTime(oldRtt, duration) {
      if (oldRtt === -1) {
        return duration;
      }
      const alpha = 0.2;
      return alpha * duration + (1 - alpha) * oldRtt;
    }
    function basicReadValidations(server, options2) {
      if (options2.readPreference && !(options2.readPreference instanceof ReadPreference)) {
        return new MongoError("readPreference must be an instance of ReadPreference");
      }
    }
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const server = args.server;
      const op = args.op;
      const ns = args.ns;
      const ops = Array.isArray(args.ops) ? args.ops : [args.ops];
      if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      if (collationNotSupported(server, options2)) {
        callback(new MongoError(`server ${server.name} does not support collation`));
        return;
      }
      const unacknowledgedWrite = options2.writeConcern && options2.writeConcern.w === 0;
      if (unacknowledgedWrite || maxWireVersion(server) < 5) {
        if ((op === "update" || op === "remove") && ops.find((o) => o.hint)) {
          callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));
          return;
        }
      }
      server.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(server, err);
          return cb(err);
        }
        conn[op](ns, ops, options2, makeOperationHandler(server, conn, ops, options2, cb));
      }, callback);
    }
    function markServerUnknown(server, error2) {
      if (error2 instanceof MongoNetworkError && !(error2 instanceof MongoNetworkTimeoutError)) {
        server[kMonitor].reset();
      }
      server.emit("descriptionReceived", new ServerDescription(server.description.address, null, {
        error: error2,
        topologyVersion: error2 && error2.topologyVersion ? error2.topologyVersion : server.description.topologyVersion
      }));
    }
    function connectionIsStale(pool, connection) {
      return connection.generation !== pool.generation;
    }
    function shouldHandleStateChangeError(server, err) {
      const etv = err.topologyVersion;
      const stv = server.description.topologyVersion;
      return compareTopologyVersion(stv, etv) < 0;
    }
    function inActiveTransaction(session, cmd) {
      return session && session.inTransaction() && !isTransactionCommand(cmd);
    }
    function makeOperationHandler(server, connection, cmd, options2, callback) {
      const session = options2 && options2.session;
      return function handleOperationResult(err, result) {
        if (err && !connectionIsStale(server.s.pool, connection)) {
          if (err instanceof MongoNetworkError) {
            if (session && !session.hasEnded) {
              session.serverSession.isDirty = true;
            }
            if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {
              markServerUnknown(server, err);
              server.s.pool.clear();
            }
          } else {
            if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (isSDAMUnrecoverableError(err)) {
              if (shouldHandleStateChangeError(server, err)) {
                if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {
                  server.s.pool.clear();
                }
                markServerUnknown(server, err);
                process.nextTick(() => server.requestCheck());
              }
            }
          }
        }
        callback(err, result);
      };
    }
    module2.exports = {
      Server
    };
  }
});

// node_modules/mongodb/lib/core/sdam/srv_polling.js
var require_srv_polling = __commonJS({
  "node_modules/mongodb/lib/core/sdam/srv_polling.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Logger = require_logger();
    var EventEmitter = require("events").EventEmitter;
    var dns = require("dns");
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    var SrvPollingEvent = class {
      constructor(srvRecords) {
        this.srvRecords = srvRecords;
      }
      addresses() {
        return new Set(this.srvRecords.map((record) => `${record.name}:${record.port}`));
      }
    };
    var SrvPoller = class extends EventEmitter {
      constructor(options2) {
        super();
        if (!options2 || !options2.srvHost) {
          throw new TypeError("options for SrvPoller must exist and include srvHost");
        }
        this.srvHost = options2.srvHost;
        this.rescanSrvIntervalMS = 6e4;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 1e4;
        this.logger = Logger("srvPoller", options2);
        this.haMode = false;
        this.generation = 0;
        this._timeout = null;
      }
      get srvAddress() {
        return `_mongodb._tcp.${this.srvHost}`;
      }
      get intervalMS() {
        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
      }
      start() {
        if (!this._timeout) {
          this.schedule();
        }
      }
      stop() {
        if (this._timeout) {
          clearTimeout(this._timeout);
          this.generation += 1;
          this._timeout = null;
        }
      }
      schedule() {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(() => this._poll(), this.intervalMS);
      }
      success(srvRecords) {
        this.haMode = false;
        this.schedule();
        this.emit("srvRecordDiscovery", new SrvPollingEvent(srvRecords));
      }
      failure(message, obj) {
        this.logger.warn(message, obj);
        this.haMode = true;
        this.schedule();
      }
      parentDomainMismatch(srvRecord) {
        this.logger.warn(`parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`, srvRecord);
      }
      _poll() {
        const generation = this.generation;
        dns.resolveSrv(this.srvAddress, (err, srvRecords) => {
          if (generation !== this.generation) {
            return;
          }
          if (err) {
            this.failure("DNS error", err);
            return;
          }
          const finalAddresses = [];
          srvRecords.forEach((record) => {
            if (matchesParentDomain(record.name, this.srvHost)) {
              finalAddresses.push(record);
            } else {
              this.parentDomainMismatch(record);
            }
          });
          if (!finalAddresses.length) {
            this.failure("No valid addresses found at host");
            return;
          }
          this.success(finalAddresses);
        });
      }
    };
    module2.exports.SrvPollingEvent = SrvPollingEvent;
    module2.exports.SrvPoller = SrvPoller;
  }
});

// node_modules/mongodb/lib/core/sdam/server_selection.js
var require_server_selection = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_selection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ServerType = require_common().ServerType;
    var TopologyType = require_common().TopologyType;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var IDLE_WRITE_PERIOD = 1e4;
    var SMALLEST_MAX_STALENESS_SECONDS = 90;
    function writableServerSelector() {
      return function(topologyDescription, servers) {
        return latencyWindowReducer(topologyDescription, servers.filter((s2) => s2.isWritable));
      };
    }
    function maxStalenessReducer(readPreference, topologyDescription, servers) {
      if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
        return servers;
      }
      const maxStaleness = readPreference.maxStalenessSeconds;
      const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
      if (maxStaleness < maxStalenessVariance) {
        throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);
      }
      if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
        throw new MongoError(`maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {
        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
        return servers.reduce((result, server) => {
          const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {
        if (servers.length === 0) {
          return servers;
        }
        const sMax = servers.reduce((max, s2) => s2.lastWriteDate > max.lastWriteDate ? s2 : max);
        return servers.reduce((result, server) => {
          const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      return servers;
    }
    function tagSetMatch(tagSet, serverTags) {
      const keys = Object.keys(tagSet);
      const serverTagKeys = Object.keys(serverTags);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
          return false;
        }
      }
      return true;
    }
    function tagSetReducer(readPreference, servers) {
      if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
        return servers;
      }
      for (let i = 0; i < readPreference.tags.length; ++i) {
        const tagSet = readPreference.tags[i];
        const serversMatchingTagset = servers.reduce((matched, server) => {
          if (tagSetMatch(tagSet, server.tags))
            matched.push(server);
          return matched;
        }, []);
        if (serversMatchingTagset.length) {
          return serversMatchingTagset;
        }
      }
      return [];
    }
    function latencyWindowReducer(topologyDescription, servers) {
      const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);
      const high = low + topologyDescription.localThresholdMS;
      return servers.reduce((result, server) => {
        if (server.roundTripTime <= high && server.roundTripTime >= low)
          result.push(server);
        return result;
      }, []);
    }
    function primaryFilter(server) {
      return server.type === ServerType.RSPrimary;
    }
    function secondaryFilter(server) {
      return server.type === ServerType.RSSecondary;
    }
    function nearestFilter(server) {
      return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;
    }
    function knownFilter(server) {
      return server.type !== ServerType.Unknown;
    }
    function readPreferenceServerSelector(readPreference) {
      if (!readPreference.isValid()) {
        throw new TypeError("Invalid read preference specified");
      }
      return function(topologyDescription, servers) {
        const commonWireVersion = topologyDescription.commonWireVersion;
        if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
          throw new MongoError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
        }
        if (topologyDescription.type === TopologyType.Unknown) {
          return [];
        }
        if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {
          return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
        }
        const mode = readPreference.mode;
        if (mode === ReadPreference.PRIMARY) {
          return servers.filter(primaryFilter);
        }
        if (mode === ReadPreference.PRIMARY_PREFERRED) {
          const result = servers.filter(primaryFilter);
          if (result.length) {
            return result;
          }
        }
        const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
        if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
          return servers.filter(primaryFilter);
        }
        return selectedServers;
      };
    }
    module2.exports = {
      writableServerSelector,
      readPreferenceServerSelector
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology.js
var require_topology = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events");
    var ServerDescription = require_server_description().ServerDescription;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var TopologyType = require_common().TopologyType;
    var events = require_events();
    var Server = require_server2().Server;
    var relayEvents = require_utils2().relayEvents;
    var ReadPreference = require_read_preference();
    var CoreCursor = require_cursor().CoreCursor;
    var deprecate = require("util").deprecate;
    var BSON2 = require_utils3().retrieveBSON();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var ClientSession = require_sessions().ClientSession;
    var MongoError = require_error().MongoError;
    var MongoServerSelectionError = require_error().MongoServerSelectionError;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SrvPoller = require_srv_polling().SrvPoller;
    var getMMAPError = require_shared2().getMMAPError;
    var makeStateMachine = require_utils2().makeStateMachine;
    var eachAsync = require_utils2().eachAsync;
    var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
    var ServerSessionPool = require_sessions().ServerSessionPool;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var emitWarning = require_utils4().emitWarning;
    var common = require_common();
    var drainTimerQueue = common.drainTimerQueue;
    var clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom;
    var serverSelection = require_server_selection();
    var readPreferenceServerSelector = serverSelection.readPreferenceServerSelector;
    var writableServerSelector = serverSelection.writableServerSelector;
    var globalTopologyCounter = 0;
    var SERVER_RELAY_EVENTS = [
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "monitoring"
    ].concat(CMAP_EVENT_NAMES);
    var LOCAL_SERVER_EVENTS = ["connect", "descriptionReceived", "close", "ended"];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var DEPRECATED_OPTIONS = new Set([
      "autoReconnect",
      "reconnectTries",
      "reconnectInterval",
      "bufferMaxEntries"
    ]);
    var kCancelled = Symbol("cancelled");
    var kWaitQueue = Symbol("waitQueue");
    var Topology = class extends EventEmitter {
      constructor(seedlist, options2) {
        super();
        if (typeof options2 === "undefined" && typeof seedlist !== "string") {
          options2 = seedlist;
          seedlist = [];
          if (options2.host) {
            seedlist.push({ host: options2.host, port: options2.port });
          }
        }
        seedlist = seedlist || [];
        if (typeof seedlist === "string") {
          seedlist = parseStringSeedlist(seedlist);
        }
        options2 = Object.assign({}, common.TOPOLOGY_DEFAULTS, options2);
        options2 = Object.freeze(Object.assign(options2, {
          metadata: makeClientMetadata(options2),
          compression: { compressors: createCompressionInfo(options2) }
        }));
        DEPRECATED_OPTIONS.forEach((optionName) => {
          if (options2[optionName]) {
            emitDeprecationWarning(`The option \`${optionName}\` is incompatible with the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
          }
        });
        const topologyType = topologyTypeFromSeedlist(seedlist, options2);
        const topologyId = globalTopologyCounter++;
        const serverDescriptions = seedlist.reduce((result, seed) => {
          if (seed.domain_socket)
            seed.host = seed.domain_socket;
          const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;
          result.set(address, new ServerDescription(address));
          return result;
        }, new Map());
        this[kWaitQueue] = new Denque();
        this.s = {
          id: topologyId,
          options: options2,
          seedlist,
          state: STATE_CLOSED,
          description: new TopologyDescription(topologyType, serverDescriptions, options2.replicaSet, null, null, null, options2),
          serverSelectionTimeoutMS: options2.serverSelectionTimeoutMS,
          heartbeatFrequencyMS: options2.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: options2.minHeartbeatFrequencyMS,
          Cursor: options2.cursorFactory || CoreCursor,
          bson: options2.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          servers: new Map(),
          sessionPool: new ServerSessionPool(this),
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise,
          credentials: options2.credentials,
          clusterTime: null,
          connectionTimers: new Set()
        };
        if (options2.srvHost) {
          this.s.srvPoller = options2.srvPoller || new SrvPoller({
            heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
            srvHost: options2.srvHost,
            logger: options2.logger,
            loggerLevel: options2.loggerLevel
          });
          this.s.detectTopologyDescriptionChange = (ev) => {
            const previousType = ev.previousDescription.type;
            const newType = ev.newDescription.type;
            if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {
              this.s.handleSrvPolling = srvPollingHandler(this);
              this.s.srvPoller.on("srvRecordDiscovery", this.s.handleSrvPolling);
              this.s.srvPoller.start();
            }
          };
          this.on("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
        }
        this.setMaxListeners(Infinity);
      }
      get description() {
        return this.s.description;
      }
      get parserType() {
        return BSON2.native ? "c++" : "js";
      }
      connect(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        if (this.s.state === STATE_CONNECTED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this.emit("topologyOpening", new events.TopologyOpeningEvent(this.s.id));
        this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, new TopologyDescription(TopologyType.Unknown), this.s.description));
        connectServers(this, Array.from(this.s.description.servers.values()));
        ReadPreference.translate(options2);
        const readPreference = options2.readPreference || ReadPreference.primary;
        const connectHandler = (err) => {
          if (err) {
            this.close();
            if (typeof callback === "function") {
              callback(err);
            } else {
              this.emit("error", err);
            }
            return;
          }
          stateTransition(this, STATE_CONNECTED);
          this.emit("open", err, this);
          this.emit("connect", this);
          if (typeof callback === "function")
            callback(err, this);
        };
        if (this.s.credentials) {
          this.command("admin.$cmd", { ping: 1 }, { readPreference }, connectHandler);
          return;
        }
        this.selectServer(readPreferenceServerSelector(readPreference), options2, connectHandler);
      }
      close(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        if (typeof options2 === "boolean") {
          options2 = { force: options2 };
        }
        options2 = options2 || {};
        if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        drainWaitQueue(this[kWaitQueue], new MongoError("Topology closed"));
        drainTimerQueue(this.s.connectionTimers);
        if (this.s.srvPoller) {
          this.s.srvPoller.stop();
          if (this.s.handleSrvPolling) {
            this.s.srvPoller.removeListener("srvRecordDiscovery", this.s.handleSrvPolling);
            delete this.s.handleSrvPolling;
          }
        }
        if (this.s.detectTopologyDescriptionChange) {
          this.removeListener("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
          delete this.s.detectTopologyDescriptionChange;
        }
        this.s.sessions.forEach((session) => session.endSession());
        this.s.sessionPool.endAllPooledSessions(() => {
          eachAsync(Array.from(this.s.servers.values()), (server, cb) => destroyServer(server, this, options2, cb), (err) => {
            this.s.servers.clear();
            this.emit("topologyClosed", new events.TopologyClosedEvent(this.s.id));
            stateTransition(this, STATE_CLOSED);
            if (typeof callback === "function") {
              callback(err);
            }
          });
        });
      }
      selectServer(selector, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          if (typeof selector !== "function") {
            options2 = selector;
            let readPreference;
            if (selector instanceof ReadPreference) {
              readPreference = selector;
            } else if (typeof selector === "string") {
              readPreference = new ReadPreference(selector);
            } else {
              ReadPreference.translate(options2);
              readPreference = options2.readPreference || ReadPreference.primary;
            }
            selector = readPreferenceServerSelector(readPreference);
          } else {
            options2 = {};
          }
        }
        options2 = Object.assign({}, { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS }, options2);
        const isSharded = this.description.type === TopologyType.Sharded;
        const session = options2.session;
        const transaction = session && session.transaction;
        if (isSharded && transaction && transaction.server) {
          callback(void 0, transaction.server);
          return;
        }
        let serverSelector = selector;
        if (typeof selector === "object") {
          const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;
          serverSelector = readPreferenceServerSelector(readPreference);
        }
        const waitQueueMember = {
          serverSelector,
          transaction,
          callback
        };
        const serverSelectionTimeoutMS = options2.serverSelectionTimeoutMS;
        if (serverSelectionTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            const timeoutError = new MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);
            waitQueueMember.callback(timeoutError);
          }, serverSelectionTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        processWaitQueue(this);
      }
      shouldCheckForSessionSupport() {
        if (this.description.type === TopologyType.Single) {
          return !this.description.hasKnownServers;
        }
        return !this.description.hasDataBearingServers;
      }
      hasSessionSupport() {
        return this.description.logicalSessionTimeoutMinutes != null;
      }
      startSession(options2, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options2, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command("admin.$cmd", { endSessions: sessions }, { readPreference: ReadPreference.primaryPreferred, noResponse: true }, () => {
          if (typeof callback === "function")
            callback();
        });
      }
      serverUpdateHandler(serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
          return;
        }
        if (isStaleServerDescription(this.s.description, serverDescription)) {
          return;
        }
        const previousTopologyDescription = this.s.description;
        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
        const clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
          resolveClusterTime(this, clusterTime);
        }
        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
          this.emit("error", new MongoError(this.s.description.compatibilityError));
          return;
        }
        if (!equalDescriptions) {
          this.emit("serverDescriptionChanged", new events.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, this.s.description.servers.get(serverDescription.address)));
        }
        updateServers(this, serverDescription);
        if (this[kWaitQueue].length > 0) {
          processWaitQueue(this);
        }
        if (!equalDescriptions) {
          this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
        }
      }
      auth(credentials, callback) {
        if (typeof credentials === "function")
          callback = credentials, credentials = null;
        if (typeof callback === "function")
          callback(null, true);
      }
      logout(callback) {
        if (typeof callback === "function")
          callback(null, true);
      }
      insert(ns, ops, options2, callback) {
        executeWriteOperation({ topology: this, op: "insert", ns, ops }, options2, callback);
      }
      update(ns, ops, options2, callback) {
        executeWriteOperation({ topology: this, op: "update", ns, ops }, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        executeWriteOperation({ topology: this, op: "remove", ns, ops }, options2, callback);
      }
      command(ns, cmd, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2, options2 = {}, options2 = options2 || {};
        }
        ReadPreference.translate(options2);
        const readPreference = options2.readPreference || ReadPreference.primary;
        this.selectServer(readPreferenceServerSelector(readPreference), options2, (err, server) => {
          if (err) {
            callback(err);
            return;
          }
          const notAlreadyRetrying = !options2.retrying;
          const retryWrites = !!options2.retryWrites;
          const hasSession = !!options2.session;
          const supportsRetryableWrites = server.supportsRetryableWrites;
          const notInTransaction = !hasSession || !options2.session.inTransaction();
          const willRetryWrite = notAlreadyRetrying && retryWrites && hasSession && supportsRetryableWrites && notInTransaction && isWriteCommand(cmd);
          const cb = (err2, result) => {
            if (!err2)
              return callback(null, result);
            if (!shouldRetryOperation(err2)) {
              return callback(err2);
            }
            if (willRetryWrite) {
              const newOptions = Object.assign({}, options2, { retrying: true });
              return this.command(ns, cmd, newOptions, callback);
            }
            return callback(err2);
          };
          if (willRetryWrite) {
            options2.session.incrementTransactionNumber();
            options2.willRetryWrite = willRetryWrite;
          }
          server.command(ns, cmd, options2, cb);
        });
      }
      cursor(ns, cmd, options2) {
        options2 = options2 || {};
        const topology = options2.topology || this;
        const CursorClass = options2.cursorFactory || this.s.Cursor;
        ReadPreference.translate(options2);
        return new CursorClass(topology, ns, cmd, options2);
      }
      get clientMetadata() {
        return this.s.options.metadata;
      }
      isConnected() {
        return this.s.state === STATE_CONNECTED;
      }
      isDestroyed() {
        return this.s.state === STATE_CLOSED;
      }
      unref() {
        emitWarning("not implemented: `unref`");
      }
      lastIsMaster() {
        const serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
          return {};
        const sd = serverDescriptions.filter((sd2) => sd2.type !== ServerType.Unknown)[0];
        const result = sd || { maxWireVersion: this.description.commonWireVersion };
        return result;
      }
      get logicalSessionTimeoutMinutes() {
        return this.description.logicalSessionTimeoutMinutes;
      }
      get bson() {
        return this.s.bson;
      }
    };
    Object.defineProperty(Topology.prototype, "clusterTime", {
      enumerable: true,
      get: function() {
        return this.s.clusterTime;
      },
      set: function(clusterTime) {
        this.s.clusterTime = clusterTime;
      }
    });
    Topology.prototype.destroy = deprecate(Topology.prototype.close, "destroy() is deprecated, please use close() instead");
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    function isStaleServerDescription(topologyDescription, incomingServerDescription) {
      const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
      const currentTopologyVersion = currentServerDescription.topologyVersion;
      return compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
    }
    function destroyServer(server, topology, options2, callback) {
      options2 = options2 || {};
      LOCAL_SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options2, () => {
        topology.emit("serverClosed", new events.ServerClosedEvent(topology.s.id, server.description.address));
        SERVER_RELAY_EVENTS.forEach((event) => server.removeAllListeners(event));
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    function parseStringSeedlist(seedlist) {
      return seedlist.split(",").map((seed) => ({
        host: seed.split(":")[0],
        port: seed.split(":")[1] || 27017
      }));
    }
    function topologyTypeFromSeedlist(seedlist, options2) {
      if (options2.directConnection) {
        return TopologyType.Single;
      }
      const replicaSet = options2.replicaSet || options2.setName || options2.rs_name;
      if (replicaSet == null) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function randomSelection(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    function createAndConnectServer(topology, serverDescription, connectDelay) {
      topology.emit("serverOpening", new events.ServerOpeningEvent(topology.s.id, serverDescription.address));
      const server = new Server(serverDescription, topology.s.options, topology);
      relayEvents(server, topology, SERVER_RELAY_EVENTS);
      server.on("descriptionReceived", topology.serverUpdateHandler.bind(topology));
      if (connectDelay) {
        const connectTimer = setTimeout(() => {
          clearAndRemoveTimerFrom(connectTimer, topology.s.connectionTimers);
          server.connect();
        }, connectDelay);
        topology.s.connectionTimers.add(connectTimer);
        return server;
      }
      server.connect();
      return server;
    }
    function connectServers(topology, serverDescriptions) {
      topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {
        const server = createAndConnectServer(topology, serverDescription);
        servers.set(serverDescription.address, server);
        return servers;
      }, new Map());
    }
    function updateServers(topology, incomingServerDescription) {
      if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        const server = topology.s.servers.get(incomingServerDescription.address);
        server.s.description = incomingServerDescription;
      }
      for (const serverDescription of topology.description.servers.values()) {
        if (!topology.s.servers.has(serverDescription.address)) {
          const server = createAndConnectServer(topology, serverDescription);
          topology.s.servers.set(serverDescription.address, server);
        }
      }
      for (const entry of topology.s.servers) {
        const serverAddress = entry[0];
        if (topology.description.hasServer(serverAddress)) {
          continue;
        }
        const server = topology.s.servers.get(serverAddress);
        topology.s.servers.delete(serverAddress);
        destroyServer(server, topology);
      }
    }
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const topology = args.topology;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      topology.selectServer(writableServerSelector(), options2, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const notAlreadyRetrying = !args.retrying;
        const retryWrites = !!options2.retryWrites;
        const hasSession = !!options2.session;
        const supportsRetryableWrites = server.supportsRetryableWrites;
        const notInTransaction = !hasSession || !options2.session.inTransaction();
        const notExplaining = options2.explain === void 0;
        const willRetryWrite = notAlreadyRetrying && retryWrites && hasSession && supportsRetryableWrites && notInTransaction && notExplaining;
        const handler = (err2, result) => {
          if (!err2)
            return callback(null, result);
          if (!shouldRetryOperation(err2)) {
            err2 = getMMAPError(err2);
            return callback(err2);
          }
          if (willRetryWrite) {
            const newArgs = Object.assign({}, args, { retrying: true });
            return executeWriteOperation(newArgs, options2, callback);
          }
          return callback(err2);
        };
        if (callback.operationId) {
          handler.operationId = callback.operationId;
        }
        if (willRetryWrite) {
          options2.session.incrementTransactionNumber();
          options2.willRetryWrite = willRetryWrite;
        }
        server[op](ns, ops, options2, handler);
      });
    }
    function shouldRetryOperation(err) {
      return err instanceof MongoError && err.hasErrorLabel("RetryableWriteError");
    }
    function srvPollingHandler(topology) {
      return function handleSrvPolling(ev) {
        const previousTopologyDescription = topology.s.description;
        topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);
        if (topology.s.description === previousTopologyDescription) {
          return;
        }
        updateServers(topology);
        topology.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(topology.s.id, previousTopologyDescription, topology.s.description));
      };
    }
    function drainWaitQueue(queue, err) {
      while (queue.length) {
        const waitQueueMember = queue.shift();
        clearTimeout(waitQueueMember.timer);
        if (!waitQueueMember[kCancelled]) {
          waitQueueMember.callback(err);
        }
      }
    }
    function processWaitQueue(topology) {
      if (topology.s.state === STATE_CLOSED) {
        drainWaitQueue(topology[kWaitQueue], new MongoError("Topology is closed, please connect"));
        return;
      }
      const serverDescriptions = Array.from(topology.description.servers.values());
      const membersToProcess = topology[kWaitQueue].length;
      for (let i = 0; i < membersToProcess && topology[kWaitQueue].length; ++i) {
        const waitQueueMember = topology[kWaitQueue].shift();
        if (waitQueueMember[kCancelled]) {
          continue;
        }
        let selectedDescriptions;
        try {
          const serverSelector = waitQueueMember.serverSelector;
          selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
        } catch (e) {
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(e);
          continue;
        }
        if (selectedDescriptions.length === 0) {
          topology[kWaitQueue].push(waitQueueMember);
          continue;
        }
        const selectedServerDescription = randomSelection(selectedDescriptions);
        const selectedServer = topology.s.servers.get(selectedServerDescription.address);
        const transaction = waitQueueMember.transaction;
        const isSharded = topology.description.type === TopologyType.Sharded;
        if (isSharded && transaction && transaction.isActive) {
          transaction.pinServer(selectedServer);
        }
        clearTimeout(waitQueueMember.timer);
        waitQueueMember.callback(void 0, selectedServer);
      }
      if (topology[kWaitQueue].length > 0) {
        topology.s.servers.forEach((server) => process.nextTick(() => server.requestCheck()));
      }
    }
    module2.exports = {
      Topology
    };
  }
});

// node_modules/mongodb/lib/core/uri_parser.js
var require_uri_parser = __commonJS({
  "node_modules/mongodb/lib/core/uri_parser.js"(exports2, module2) {
    init_shims();
    "use strict";
    var URL2 = require("url");
    var qs = require("querystring");
    var dns = require("dns");
    var MongoParseError = require_error().MongoParseError;
    var ReadPreference = require_read_preference();
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var HOSTS_RX = /(mongodb(?:\+srv|)):\/\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\/|)(.*)/;
    var FILE_PATH_OPTIONS = new Set(["sslCA", "sslCert", "sslKey", "tlsCAFile", "tlsCertificateKeyFile"].map((key) => key.toLowerCase()));
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    function parseSrvConnectionString(uri, options2, callback) {
      const result = URL2.parse(uri, true);
      if (options2.directConnection || options2.directconnection) {
        return callback(new MongoParseError("directConnection not supported with SRV URI"));
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new MongoParseError("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      const hostname = uri.substring("mongodb+srv://".length).split("/")[0];
      if (hostname.match(",")) {
        return callback(new MongoParseError("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new MongoParseError(`Ports not accepted with '${PROTOCOL_MONGODB_SRV}' URIs`));
      }
      const lookupAddress = result.host;
      dns.resolveSrv(`_mongodb._tcp.${lookupAddress}`, (err, addresses) => {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new MongoParseError("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new MongoParseError("Server record does not share hostname with parent URI"));
          }
        }
        result.protocol = "mongodb";
        result.host = addresses.map((address) => `${address.name}:${address.port}`).join(",");
        if (!("ssl" in options2) && (!result.search || !("ssl" in result.query) || result.query.ssl === null)) {
          result.query.ssl = true;
        }
        dns.resolveTxt(lookupAddress, (err2, record) => {
          if (err2) {
            if (err2.code !== "ENODATA" && err2.code !== "ENOTFOUND") {
              return callback(err2);
            }
            record = null;
          }
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = qs.parse(record[0].join(""));
            if (Object.keys(record).some((key) => key !== "authSource" && key !== "replicaSet")) {
              return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
            }
            result.query = Object.assign({}, record, result.query);
          }
          result.search = qs.stringify(result.query);
          const finalString = URL2.format(result);
          parseConnectionString(finalString, options2, (err3, ret2) => {
            if (err3) {
              callback(err3);
              return;
            }
            callback(null, Object.assign({}, ret2, { srvHost: lookupAddress }));
          });
        });
      });
    }
    function parseQueryStringItemValue(key, value) {
      if (Array.isArray(value)) {
        value = value.filter((v, idx) => value.indexOf(v) === idx);
        if (value.length === 1)
          value = value[0];
      } else if (value.indexOf(":") > 0) {
        value = value.split(",").reduce((result, pair) => {
          const parts = pair.split(":");
          result[parts[0]] = parseQueryStringItemValue(key, parts[1]);
          return result;
        }, {});
      } else if (value.indexOf(",") > 0) {
        value = value.split(",").map((v) => {
          return parseQueryStringItemValue(key, v);
        });
      } else if (value.toLowerCase() === "true" || value.toLowerCase() === "false") {
        value = value.toLowerCase() === "true";
      } else if (!Number.isNaN(value) && !STRING_OPTIONS.has(key)) {
        const numericValue = parseFloat(value);
        if (!Number.isNaN(numericValue)) {
          value = parseFloat(value);
        }
      }
      return value;
    }
    var BOOLEAN_OPTIONS = new Set([
      "slaveok",
      "slave_ok",
      "sslvalidate",
      "fsync",
      "safe",
      "retrywrites",
      "j"
    ]);
    var STRING_OPTIONS = new Set(["authsource", "replicaset"]);
    var AUTH_MECHANISMS = new Set([
      "GSSAPI",
      "MONGODB-AWS",
      "MONGODB-X509",
      "MONGODB-CR",
      "DEFAULT",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256",
      "PLAIN"
    ]);
    var CASE_TRANSLATION = {
      replicaset: "replicaSet",
      connecttimeoutms: "connectTimeoutMS",
      sockettimeoutms: "socketTimeoutMS",
      maxpoolsize: "maxPoolSize",
      minpoolsize: "minPoolSize",
      maxidletimems: "maxIdleTimeMS",
      waitqueuemultiple: "waitQueueMultiple",
      waitqueuetimeoutms: "waitQueueTimeoutMS",
      wtimeoutms: "wtimeoutMS",
      readconcern: "readConcern",
      readconcernlevel: "readConcernLevel",
      readpreference: "readPreference",
      maxstalenessseconds: "maxStalenessSeconds",
      readpreferencetags: "readPreferenceTags",
      authsource: "authSource",
      authmechanism: "authMechanism",
      authmechanismproperties: "authMechanismProperties",
      gssapiservicename: "gssapiServiceName",
      localthresholdms: "localThresholdMS",
      serverselectiontimeoutms: "serverSelectionTimeoutMS",
      serverselectiontryonce: "serverSelectionTryOnce",
      heartbeatfrequencyms: "heartbeatFrequencyMS",
      retrywrites: "retryWrites",
      uuidrepresentation: "uuidRepresentation",
      zlibcompressionlevel: "zlibCompressionLevel",
      tlsallowinvalidcertificates: "tlsAllowInvalidCertificates",
      tlsallowinvalidhostnames: "tlsAllowInvalidHostnames",
      tlsinsecure: "tlsInsecure",
      tlscafile: "tlsCAFile",
      tlscertificatekeyfile: "tlsCertificateKeyFile",
      tlscertificatekeyfilepassword: "tlsCertificateKeyFilePassword",
      wtimeout: "wTimeoutMS",
      j: "journal",
      directconnection: "directConnection"
    };
    function applyConnectionStringOption(obj, key, value, options2) {
      if (key === "journal") {
        key = "j";
      } else if (key === "wtimeoutms") {
        key = "wtimeout";
      }
      if (BOOLEAN_OPTIONS.has(key)) {
        value = value === "true" || value === true;
      } else if (key === "appname") {
        value = decodeURIComponent(value);
      } else if (key === "readconcernlevel") {
        obj["readConcernLevel"] = value;
        key = "readconcern";
        value = { level: value };
      }
      if (key === "compressors") {
        value = Array.isArray(value) ? value : [value];
        if (!value.every((c) => c === "snappy" || c === "zlib")) {
          throw new MongoParseError("Value for `compressors` must be at least one of: `snappy`, `zlib`");
        }
      }
      if (key === "authmechanism" && !AUTH_MECHANISMS.has(value)) {
        throw new MongoParseError(`Value for authMechanism must be one of: ${Array.from(AUTH_MECHANISMS).join(", ")}, found: ${value}`);
      }
      if (key === "readpreference" && !ReadPreference.isValid(value)) {
        throw new MongoParseError("Value for `readPreference` must be one of: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`");
      }
      if (key === "zlibcompressionlevel" && (value < -1 || value > 9)) {
        throw new MongoParseError("zlibCompressionLevel must be an integer between -1 and 9");
      }
      if (key === "compressors" || key === "zlibcompressionlevel") {
        obj.compression = obj.compression || {};
        obj = obj.compression;
      }
      if (key === "authmechanismproperties") {
        if (typeof value.SERVICE_NAME === "string")
          obj.gssapiServiceName = value.SERVICE_NAME;
        if (typeof value.SERVICE_REALM === "string")
          obj.gssapiServiceRealm = value.SERVICE_REALM;
        if (typeof value.CANONICALIZE_HOST_NAME !== "undefined") {
          obj.gssapiCanonicalizeHostName = value.CANONICALIZE_HOST_NAME;
        }
      }
      if (key === "readpreferencetags") {
        value = Array.isArray(value) ? splitArrayOfMultipleReadPreferenceTags(value) : [value];
      }
      if (options2.caseTranslate && CASE_TRANSLATION[key]) {
        obj[CASE_TRANSLATION[key]] = value;
        return;
      }
      obj[key] = value;
    }
    var USERNAME_REQUIRED_MECHANISMS = new Set([
      "GSSAPI",
      "MONGODB-CR",
      "PLAIN",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    function splitArrayOfMultipleReadPreferenceTags(value) {
      const parsedTags = [];
      for (let i = 0; i < value.length; i++) {
        parsedTags[i] = {};
        value[i].split(",").forEach((individualTag) => {
          const splitTag = individualTag.split(":");
          parsedTags[i][splitTag[0]] = splitTag[1];
        });
      }
      return parsedTags;
    }
    function applyAuthExpectations(parsed) {
      if (parsed.options == null) {
        return;
      }
      const options2 = parsed.options;
      const authSource = options2.authsource || options2.authSource;
      if (authSource != null) {
        parsed.auth = Object.assign({}, parsed.auth, { db: authSource });
      }
      const authMechanism = options2.authmechanism || options2.authMechanism;
      if (authMechanism != null) {
        if (USERNAME_REQUIRED_MECHANISMS.has(authMechanism) && (!parsed.auth || parsed.auth.username == null)) {
          throw new MongoParseError(`Username required for mechanism \`${authMechanism}\``);
        }
        if (authMechanism === "GSSAPI") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "MONGODB-AWS") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "MONGODB-X509") {
          if (parsed.auth && parsed.auth.password != null) {
            throw new MongoParseError(`Password not allowed for mechanism \`${authMechanism}\``);
          }
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "PLAIN") {
          if (parsed.auth && parsed.auth.db == null) {
            parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
          }
        }
      }
      if (parsed.auth && parsed.auth.db == null) {
        parsed.auth = Object.assign({}, parsed.auth, { db: "admin" });
      }
      return parsed;
    }
    function parseQueryString(query, options2) {
      const result = {};
      let parsedQueryString = qs.parse(query);
      checkTLSOptions(parsedQueryString);
      for (const key in parsedQueryString) {
        const value = parsedQueryString[key];
        if (value === "" || value == null) {
          throw new MongoParseError("Incomplete key value pair for option");
        }
        const normalizedKey = key.toLowerCase();
        const parsedValue = FILE_PATH_OPTIONS.has(normalizedKey) ? value : parseQueryStringItemValue(normalizedKey, value);
        applyConnectionStringOption(result, normalizedKey, parsedValue, options2);
      }
      if (result.wtimeout && result.wtimeoutms) {
        delete result.wtimeout;
        emitWarningOnce("Unsupported option `wtimeout` specified");
      }
      return Object.keys(result).length ? result : null;
    }
    function translateTLSOptions(queryString) {
      if (queryString.tls) {
        queryString.ssl = queryString.tls;
      }
      if (queryString.tlsInsecure) {
        queryString.checkServerIdentity = false;
        queryString.sslValidate = false;
      } else {
        Object.assign(queryString, {
          checkServerIdentity: queryString.tlsAllowInvalidHostnames ? false : true,
          sslValidate: queryString.tlsAllowInvalidCertificates ? false : true
        });
      }
      if (queryString.tlsCAFile) {
        queryString.ssl = true;
        queryString.sslCA = queryString.tlsCAFile;
      }
      if (queryString.tlsCertificateKeyFile) {
        queryString.ssl = true;
        if (queryString.tlsCertificateFile) {
          queryString.sslCert = queryString.tlsCertificateFile;
          queryString.sslKey = queryString.tlsCertificateKeyFile;
        } else {
          queryString.sslKey = queryString.tlsCertificateKeyFile;
          queryString.sslCert = queryString.tlsCertificateKeyFile;
        }
      }
      if (queryString.tlsCertificateKeyFilePassword) {
        queryString.ssl = true;
        queryString.sslPass = queryString.tlsCertificateKeyFilePassword;
      }
      return queryString;
    }
    function checkTLSOptions(queryString) {
      const queryStringKeys = Object.keys(queryString);
      if (queryStringKeys.indexOf("tlsInsecure") !== -1 && (queryStringKeys.indexOf("tlsAllowInvalidCertificates") !== -1 || queryStringKeys.indexOf("tlsAllowInvalidHostnames") !== -1)) {
        throw new MongoParseError("The `tlsInsecure` option cannot be used with `tlsAllowInvalidCertificates` or `tlsAllowInvalidHostnames`.");
      }
      const tlsValue = assertTlsOptionsAreEqual("tls", queryString, queryStringKeys);
      const sslValue = assertTlsOptionsAreEqual("ssl", queryString, queryStringKeys);
      if (tlsValue != null && sslValue != null) {
        if (tlsValue !== sslValue) {
          throw new MongoParseError("All values of `tls` and `ssl` must be the same.");
        }
      }
    }
    function assertTlsOptionsAreEqual(optionName, queryString, queryStringKeys) {
      const queryStringHasTLSOption = queryStringKeys.indexOf(optionName) !== -1;
      let optionValue;
      if (Array.isArray(queryString[optionName])) {
        optionValue = queryString[optionName][0];
      } else {
        optionValue = queryString[optionName];
      }
      if (queryStringHasTLSOption) {
        if (Array.isArray(queryString[optionName])) {
          const firstValue = queryString[optionName][0];
          queryString[optionName].forEach((tlsValue) => {
            if (tlsValue !== firstValue) {
              throw new MongoParseError(`All values of ${optionName} must be the same.`);
            }
          });
        }
      }
      return optionValue;
    }
    var PROTOCOL_MONGODB = "mongodb";
    var PROTOCOL_MONGODB_SRV = "mongodb+srv";
    var SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];
    function parseConnectionString(uri, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, { caseTranslate: true }, options2);
      try {
        URL2.parse(uri);
      } catch (e) {
        return callback(new MongoParseError("URI malformed, cannot be parsed"));
      }
      const cap = uri.match(HOSTS_RX);
      if (!cap) {
        return callback(new MongoParseError("Invalid connection string"));
      }
      const protocol = cap[1];
      if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) {
        return callback(new MongoParseError("Invalid protocol provided"));
      }
      const dbAndQuery = cap[4].split("?");
      const db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;
      const query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;
      let parsedOptions;
      try {
        parsedOptions = parseQueryString(query, options2);
      } catch (parseError) {
        return callback(parseError);
      }
      parsedOptions = Object.assign({}, parsedOptions, options2);
      if (protocol === PROTOCOL_MONGODB_SRV) {
        return parseSrvConnectionString(uri, parsedOptions, callback);
      }
      const auth = { username: null, password: null, db: db && db !== "" ? qs.unescape(db) : null };
      if (parsedOptions.auth) {
        if (parsedOptions.auth.username)
          auth.username = parsedOptions.auth.username;
        if (parsedOptions.auth.user)
          auth.username = parsedOptions.auth.user;
        if (parsedOptions.auth.password)
          auth.password = parsedOptions.auth.password;
      } else {
        if (parsedOptions.username)
          auth.username = parsedOptions.username;
        if (parsedOptions.user)
          auth.username = parsedOptions.user;
        if (parsedOptions.password)
          auth.password = parsedOptions.password;
      }
      if (cap[4].split("?")[0].indexOf("@") !== -1) {
        return callback(new MongoParseError("Unescaped slash in userinfo section"));
      }
      const authorityParts = cap[3].split("@");
      if (authorityParts.length > 2) {
        return callback(new MongoParseError("Unescaped at-sign in authority section"));
      }
      if (authorityParts[0] == null || authorityParts[0] === "") {
        return callback(new MongoParseError("No username provided in authority section"));
      }
      if (authorityParts.length > 1) {
        const authParts = authorityParts.shift().split(":");
        if (authParts.length > 2) {
          return callback(new MongoParseError("Unescaped colon in authority section"));
        }
        if (authParts[0] === "") {
          return callback(new MongoParseError("Invalid empty username provided"));
        }
        if (!auth.username)
          auth.username = qs.unescape(authParts[0]);
        if (!auth.password)
          auth.password = authParts[1] ? qs.unescape(authParts[1]) : null;
      }
      let hostParsingError = null;
      const hosts = authorityParts.shift().split(",").map((host) => {
        let parsedHost = URL2.parse(`mongodb://${host}`);
        if (parsedHost.path === "/:") {
          hostParsingError = new MongoParseError("Double colon in host identifier");
          return null;
        }
        if (host.match(/\.sock/)) {
          parsedHost.hostname = qs.unescape(host);
          parsedHost.port = null;
        }
        if (Number.isNaN(parsedHost.port)) {
          hostParsingError = new MongoParseError("Invalid port (non-numeric string)");
          return;
        }
        const result2 = {
          host: parsedHost.hostname,
          port: parsedHost.port ? parseInt(parsedHost.port) : 27017
        };
        if (result2.port === 0) {
          hostParsingError = new MongoParseError("Invalid port (zero) with hostname");
          return;
        }
        if (result2.port > 65535) {
          hostParsingError = new MongoParseError("Invalid port (larger than 65535) with hostname");
          return;
        }
        if (result2.port < 0) {
          hostParsingError = new MongoParseError("Invalid port (negative number)");
          return;
        }
        return result2;
      }).filter((host) => !!host);
      if (hostParsingError) {
        return callback(hostParsingError);
      }
      if (hosts.length === 0 || hosts[0].host === "" || hosts[0].host === null) {
        return callback(new MongoParseError("No hostname or hostnames provided in connection string"));
      }
      const directConnection = !!parsedOptions.directConnection;
      if (directConnection && hosts.length !== 1) {
        return callback(new MongoParseError("directConnection option requires exactly one host"));
      }
      if (parsedOptions.directConnection == null && hosts.length === 1 && parsedOptions.replicaSet == null) {
        parsedOptions.directConnection = true;
      }
      const result = {
        hosts,
        auth: auth.db || auth.username ? auth : null,
        options: Object.keys(parsedOptions).length ? parsedOptions : null
      };
      if (result.auth && result.auth.db) {
        result.defaultDatabase = result.auth.db;
      } else {
        result.defaultDatabase = "test";
      }
      result.options = translateTLSOptions(result.options);
      try {
        applyAuthExpectations(result);
      } catch (authError) {
        return callback(authError);
      }
      callback(null, result);
    }
    module2.exports = parseConnectionString;
  }
});

// node_modules/mongodb/lib/core/index.js
var require_core = __commonJS({
  "node_modules/mongodb/lib/core/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var BSON2 = require_bson2();
    var require_optional = require_optional_require()(require);
    var EJSON = require_utils2().retrieveEJSON();
    try {
      const BSONNative = require_optional("bson-ext");
      if (BSONNative) {
        BSON2 = BSONNative;
      }
    } catch (err) {
    }
    module2.exports = {
      MongoError: require_error().MongoError,
      MongoNetworkError: require_error().MongoNetworkError,
      MongoParseError: require_error().MongoParseError,
      MongoTimeoutError: require_error().MongoTimeoutError,
      MongoServerSelectionError: require_error().MongoServerSelectionError,
      MongoWriteConcernError: require_error().MongoWriteConcernError,
      Connection: require_connection(),
      Server: require_server(),
      ReplSet: require_replset(),
      Mongos: require_mongos(),
      Logger: require_logger(),
      Cursor: require_cursor().CoreCursor,
      ReadPreference: require_read_preference(),
      Sessions: require_sessions(),
      BSON: BSON2,
      EJSON,
      Topology: require_topology().Topology,
      Query: require_commands().Query,
      MongoCredentials: require_mongo_credentials().MongoCredentials,
      defaultAuthProviders: require_defaultAuthProviders().defaultAuthProviders,
      MongoCR: require_mongocr(),
      X509: require_x509(),
      Plain: require_plain(),
      GSSAPI: require_gssapi(),
      ScramSHA1: require_scram().ScramSHA1,
      ScramSHA256: require_scram().ScramSHA256,
      parseConnectionString: require_uri_parser()
    };
  }
});

// node_modules/mongodb/lib/apm.js
var require_apm2 = __commonJS({
  "node_modules/mongodb/lib/apm.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var Instrumentation = class extends EventEmitter {
      constructor() {
        super();
      }
      instrument(MongoClient, callback) {
        this.$MongoClient = MongoClient;
        const $prototypeConnect = this.$prototypeConnect = MongoClient.prototype.connect;
        const instrumentation = this;
        MongoClient.prototype.connect = function(callback2) {
          this.s.options.monitorCommands = true;
          this.on("commandStarted", (event) => instrumentation.emit("started", event));
          this.on("commandSucceeded", (event) => instrumentation.emit("succeeded", event));
          this.on("commandFailed", (event) => instrumentation.emit("failed", event));
          return $prototypeConnect.call(this, callback2);
        };
        if (typeof callback === "function")
          callback(null, this);
      }
      uninstrument() {
        this.$MongoClient.prototype.connect = this.$prototypeConnect;
      }
    };
    module2.exports = Instrumentation;
  }
});

// node_modules/mongodb/lib/error.js
var require_error2 = __commonJS({
  "node_modules/mongodb/lib/error.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoNetworkError = require_core().MongoNetworkError;
    var GET_MORE_RESUMABLE_CODES = new Set([
      6,
      7,
      89,
      91,
      189,
      262,
      9001,
      10107,
      11600,
      11602,
      13435,
      13436,
      63,
      150,
      13388,
      234,
      133,
      43
    ]);
    function isResumableError(error2, wireVersion) {
      if (error2 instanceof MongoNetworkError) {
        return true;
      }
      if (wireVersion >= 9) {
        if (error2.code === 43) {
          return true;
        }
        return error2.hasErrorLabel("ResumableChangeStreamError");
      }
      return GET_MORE_RESUMABLE_CODES.has(error2.code);
    }
    module2.exports = { GET_MORE_RESUMABLE_CODES, isResumableError };
  }
});

// node_modules/mongodb/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/mongodb/lib/constants.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = {
      SYSTEM_NAMESPACE_COLLECTION: "system.namespaces",
      SYSTEM_INDEX_COLLECTION: "system.indexes",
      SYSTEM_PROFILE_COLLECTION: "system.profile",
      SYSTEM_USER_COLLECTION: "system.users",
      SYSTEM_COMMAND_COLLECTION: "$cmd",
      SYSTEM_JS_COLLECTION: "system.js"
    };
  }
});

// node_modules/mongodb/lib/operations/db_ops.js
var require_db_ops = __commonJS({
  "node_modules/mongodb/lib/operations/db_ops.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var debugOptions = require_utils4().debugOptions;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils4().parseIndexOptions;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var extractCommand = require_command_utils().extractCommand;
    var CONSTANTS = require_constants2();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    function createIndex(db, name, fieldOrSpec, options2, callback) {
      let finalOptions = Object.assign({}, { readPreference: ReadPreference.PRIMARY }, options2);
      finalOptions = applyWriteConcern(finalOptions, { db }, options2);
      if (finalOptions.writeConcern && typeof callback !== "function") {
        throw MongoError.create({
          message: "Cannot use a writeConcern without a provided callback",
          driver: true
        });
      }
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {
        if (err == null)
          return handleCallback(callback, err, result);
        if (err.code === 67 || err.code === 11e3 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {
          return handleCallback(callback, err, result);
        }
        const doc = createCreateIndexCommand(db, name, fieldOrSpec, options2);
        finalOptions.checkKeys = false;
        db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc, finalOptions, (err2, result2) => {
          if (callback == null)
            return;
          if (err2)
            return handleCallback(callback, err2);
          if (result2 == null)
            return handleCallback(callback, null, null);
          if (result2.result.writeErrors)
            return handleCallback(callback, MongoError.create(result2.result.writeErrors[0]), null);
          handleCallback(callback, null, doc.name);
        });
      });
    }
    function createListener(db, e, object) {
      function listener(err) {
        if (object.listeners(e).length > 0) {
          object.emit(e, err, db);
          for (let i = 0; i < db.s.children.length; i++) {
            db.s.children[i].emit(e, err, db.s.children[i]);
          }
        }
      }
      return listener;
    }
    function ensureIndex(db, name, fieldOrSpec, options2, callback) {
      const finalOptions = applyWriteConcern({}, { db }, options2);
      const selector = createCreateIndexCommand(db, name, fieldOrSpec, options2);
      const index_name = selector.name;
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      finalOptions.readPreference = ReadPreference.PRIMARY;
      indexInformation(db, name, finalOptions, (err, indexInformation2) => {
        if (err != null && err.code !== 26)
          return handleCallback(callback, err, null);
        if (indexInformation2 == null || !indexInformation2[index_name]) {
          createIndex(db, name, fieldOrSpec, options2, callback);
        } else {
          if (typeof callback === "function")
            return handleCallback(callback, null, index_name);
        }
      });
    }
    function evaluate(db, code, parameters, options2, callback) {
      let finalCode = code;
      let finalParameters = [];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      if (!(finalCode && finalCode._bsontype === "Code"))
        finalCode = new Code2(finalCode);
      if (parameters != null && !Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = [parameters];
      } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = parameters;
      }
      let cmd = { $eval: finalCode, args: finalParameters };
      if (options2["nolock"]) {
        cmd["nolock"] = options2["nolock"];
      }
      options2.readPreference = new ReadPreference(ReadPreference.PRIMARY);
      executeCommand(db, cmd, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result && result.ok === 1)
          return handleCallback(callback, null, result.retval);
        if (result)
          return handleCallback(callback, MongoError.create({ message: `eval failed: ${result.errmsg}`, driver: true }), null);
        handleCallback(callback, err, result);
      });
    }
    function executeCommand(db, command, options2, callback) {
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      const dbName = options2.dbName || options2.authdb || db.databaseName;
      options2.readPreference = ReadPreference.resolve(db, options2);
      if (db.s.logger.isDebug()) {
        const extractedCommand = extractCommand(command);
        db.s.logger.debug(`executing command ${JSON.stringify(extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options2))}]`);
      }
      db.s.topology.command(db.s.namespace.withCollection("$cmd"), command, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (options2.full)
          return handleCallback(callback, null, result);
        handleCallback(callback, null, result.result);
      });
    }
    function executeDbAdminCommand(db, command, options2, callback) {
      const namespace = new MongoDBNamespace("admin", "$cmd");
      db.s.topology.command(namespace, command, options2, (err, result) => {
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, result.result);
      });
    }
    function indexInformation(db, name, options2, callback) {
      const full = options2["full"] == null ? false : options2["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index2 = indexes[i];
          info[index2.name] = [];
          for (let name2 in index2.key) {
            info[index2.name].push([name2, index2.key[name2]]);
          }
        }
        return info;
      }
      db.collection(name).listIndexes(options2).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function profilingInfo(db, options2, callback) {
      try {
        db.collection("system.profile").find({}, options2).toArray(callback);
      } catch (err) {
        return callback(err, null);
      }
    }
    function validateDatabaseName(databaseName) {
      if (typeof databaseName !== "string")
        throw MongoError.create({ message: "database name must be a string", driver: true });
      if (databaseName.length === 0)
        throw MongoError.create({ message: "database name cannot be the empty string", driver: true });
      if (databaseName === "$external")
        return;
      const invalidChars = [" ", ".", "$", "/", "\\"];
      for (let i = 0; i < invalidChars.length; i++) {
        if (databaseName.indexOf(invalidChars[i]) !== -1)
          throw MongoError.create({
            message: "database names cannot contain the character '" + invalidChars[i] + "'",
            driver: true
          });
      }
    }
    function createCreateIndexCommand(db, name, fieldOrSpec, options2) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const fieldHash = indexParameters.fieldHash;
      const indexName = typeof options2.name === "string" ? options2.name : indexParameters.name;
      const selector = {
        ns: db.s.namespace.withCollection(name).toString(),
        key: fieldHash,
        name: indexName
      };
      const finalUnique = options2 == null || typeof options2 === "object" ? false : options2;
      options2 = options2 == null || typeof options2 === "boolean" ? {} : options2;
      const keysToOmit = Object.keys(selector);
      for (let optionName in options2) {
        if (keysToOmit.indexOf(optionName) === -1) {
          selector[optionName] = options2[optionName];
        }
      }
      if (selector["unique"] == null)
        selector["unique"] = finalUnique;
      const removeKeys = ["w", "wtimeout", "j", "fsync", "readPreference", "session"];
      for (let i = 0; i < removeKeys.length; i++) {
        delete selector[removeKeys[i]];
      }
      return selector;
    }
    function createIndexUsingCreateIndexes(db, name, fieldOrSpec, options2, callback) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const indexName = typeof options2.name === "string" ? options2.name : indexParameters.name;
      const indexes = [{ name: indexName, key: indexParameters.fieldHash }];
      const keysToOmit = Object.keys(indexes[0]).concat([
        "writeConcern",
        "w",
        "wtimeout",
        "j",
        "fsync",
        "readPreference",
        "session"
      ]);
      for (let optionName in options2) {
        if (keysToOmit.indexOf(optionName) === -1) {
          indexes[0][optionName] = options2[optionName];
        }
      }
      const capabilities = db.s.topology.capabilities();
      if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
        const error2 = new MongoError("server/primary/mongos does not support collation");
        error2.code = 67;
        return callback(error2);
      }
      const cmd = applyWriteConcern({ createIndexes: name, indexes }, { db }, options2);
      options2.readPreference = ReadPreference.PRIMARY;
      executeCommand(db, cmd, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result.ok === 0)
          return handleCallback(callback, toError(result), null);
        handleCallback(callback, null, indexName);
      });
    }
    module2.exports = {
      createListener,
      createIndex,
      ensureIndex,
      evaluate,
      executeCommand,
      executeDbAdminCommand,
      indexInformation,
      profilingInfo,
      validateDatabaseName
    };
  }
});

// node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS({
  "node_modules/mongodb/lib/operations/common_functions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var CursorState = require_cursor().CursorState;
    var maxWireVersion = require_utils2().maxWireVersion;
    function buildCountCommand(collectionOrCursor, query, options2) {
      const skip = options2.skip;
      const limit = options2.limit;
      let hint = options2.hint;
      const maxTimeMS = options2.maxTimeMS;
      query = query || {};
      const cmd = {
        count: options2.collectionName,
        query
      };
      if (collectionOrCursor.s.numberOfRetries) {
        if (collectionOrCursor.options.hint) {
          hint = collectionOrCursor.options.hint;
        } else if (collectionOrCursor.cmd.hint) {
          hint = collectionOrCursor.cmd.hint;
        }
        decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);
      } else {
        decorateWithCollation(cmd, collectionOrCursor, options2);
      }
      if (typeof skip === "number")
        cmd.skip = skip;
      if (typeof limit === "number")
        cmd.limit = limit;
      if (typeof maxTimeMS === "number")
        cmd.maxTimeMS = maxTimeMS;
      if (hint)
        cmd.hint = hint;
      decorateWithReadConcern(cmd, collectionOrCursor);
      return cmd;
    }
    function findAndModify(coll, query, sort, doc, options2, callback) {
      const queryObject = {
        findAndModify: coll.collectionName,
        query
      };
      sort = formattedOrderClause(sort);
      if (sort) {
        queryObject.sort = sort;
      }
      queryObject.new = options2.new ? true : false;
      queryObject.remove = options2.remove ? true : false;
      queryObject.upsert = options2.upsert ? true : false;
      const projection = options2.projection || options2.fields;
      if (projection) {
        queryObject.fields = projection;
      }
      if (options2.arrayFilters) {
        queryObject.arrayFilters = options2.arrayFilters;
        delete options2.arrayFilters;
      }
      if (doc && !options2.remove) {
        queryObject.update = doc;
      }
      if (options2.maxTimeMS)
        queryObject.maxTimeMS = options2.maxTimeMS;
      options2.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      options2.checkKeys = false;
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options2);
      if (finalOptions.writeConcern) {
        queryObject.writeConcern = finalOptions.writeConcern;
      }
      if (finalOptions.bypassDocumentValidation === true) {
        queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
      }
      finalOptions.readPreference = ReadPreference.primary;
      try {
        decorateWithCollation(queryObject, coll, finalOptions);
      } catch (err) {
        return callback(err, null);
      }
      executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        return handleCallback(callback, null, result);
      });
    }
    function indexInformation(db, name, options2, callback) {
      const full = options2["full"] == null ? false : options2["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index2 = indexes[i];
          info[index2.name] = [];
          for (let name2 in index2.key) {
            info[index2.name].push([name2, index2.key[name2]]);
          }
        }
        return info;
      }
      db.collection(name).listIndexes(options2).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function prepareDocs(coll, docs, options2) {
      const forceServerObjectId = typeof options2.forceServerObjectId === "boolean" ? options2.forceServerObjectId : coll.s.db.options.forceServerObjectId;
      if (forceServerObjectId === true) {
        return docs;
      }
      return docs.map((doc) => {
        if (forceServerObjectId !== true && doc._id == null) {
          doc._id = coll.s.pkFactory.createPk();
        }
        return doc;
      });
    }
    function nextObject(cursor, callback) {
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
        return handleCallback(callback, MongoError.create({ message: "Cursor is closed", driver: true }));
      }
      if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {
        try {
          cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
        } catch (err) {
          return handleCallback(callback, err);
        }
      }
      cursor._next((err, doc) => {
        cursor.s.state = CursorState.OPEN;
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, doc);
      });
    }
    function insertDocuments(coll, docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      docs = Array.isArray(docs) ? docs : [docs];
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options2);
      if (finalOptions.keepGoing === true)
        finalOptions.ordered = false;
      finalOptions.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      docs = prepareDocs(coll, docs, options2);
      coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        result.ops = docs;
        handleCallback(callback, null, result);
      });
    }
    function removeDocuments(coll, selector, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {};
      } else if (typeof selector === "function") {
        callback = selector;
        options2 = {};
        selector = {};
      }
      options2 = options2 || {};
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options2);
      if (selector == null)
        selector = {};
      const op = { q: selector, limit: 0 };
      if (options2.single) {
        op.limit = 1;
      } else if (finalOptions.retryWrites) {
        finalOptions.retryWrites = false;
      }
      if (options2.hint) {
        op.hint = options2.hint;
      }
      try {
        decorateWithCollation(finalOptions, coll, options2);
      } catch (err) {
        return callback(err, null);
      }
      if (options2.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on remove`)) : void 0;
      }
      coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors) {
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        }
        handleCallback(callback, null, result);
      });
    }
    function updateDocuments(coll, selector, document2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = null;
      if (options2 == null)
        options2 = {};
      if (!(typeof callback === "function"))
        callback = null;
      if (selector == null || typeof selector !== "object")
        return callback(toError("selector must be a valid JavaScript object"));
      if (document2 == null || typeof document2 !== "object")
        return callback(toError("document must be a valid JavaScript object"));
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options2);
      finalOptions.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      const op = { q: selector, u: document2 };
      op.upsert = options2.upsert !== void 0 ? !!options2.upsert : false;
      op.multi = options2.multi !== void 0 ? !!options2.multi : false;
      if (options2.hint) {
        op.hint = options2.hint;
      }
      if (finalOptions.arrayFilters) {
        op.arrayFilters = finalOptions.arrayFilters;
        delete finalOptions.arrayFilters;
      }
      if (finalOptions.retryWrites && op.multi) {
        finalOptions.retryWrites = false;
      }
      try {
        decorateWithCollation(finalOptions, coll, options2);
      } catch (err) {
        return callback(err, null);
      }
      if (options2.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on update`)) : void 0;
      }
      coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      buildCountCommand,
      findAndModify,
      indexInformation,
      nextObject,
      prepareDocs,
      insertDocuments,
      removeDocuments,
      updateDocuments
    };
  }
});

// node_modules/mongodb/lib/operations/collection_ops.js
var require_collection_ops = __commonJS({
  "node_modules/mongodb/lib/operations/collection_ops.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var createIndexDb = require_db_ops().createIndex;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var ensureIndexDb = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var insertDocuments = require_common_functions().insertDocuments;
    var updateDocuments = require_common_functions().updateDocuments;
    var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
    function createIndex(coll, fieldOrSpec, options2, callback) {
      createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options2, callback);
    }
    function createIndexes(coll, indexSpecs, options2, callback) {
      const capabilities = coll.s.topology.capabilities();
      for (let i = 0; i < indexSpecs.length; i++) {
        if (indexSpecs[i].name == null) {
          const keys = [];
          if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
            return callback(new MongoError("server/primary/mongos does not support collation"));
          }
          for (let name in indexSpecs[i].key) {
            keys.push(`${name}_${indexSpecs[i].key[name]}`);
          }
          indexSpecs[i].name = keys.join("_");
        }
      }
      options2 = Object.assign({}, options2, { readPreference: ReadPreference.PRIMARY });
      executeCommand(coll.s.db, {
        createIndexes: coll.collectionName,
        indexes: indexSpecs
      }, options2, callback);
    }
    function ensureIndex(coll, fieldOrSpec, options2, callback) {
      ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options2, callback);
    }
    function group(coll, keys, condition, initial, reduce, finalize, command, options2, callback) {
      if (command) {
        const reduceFunction = reduce && reduce._bsontype === "Code" ? reduce : new Code2(reduce);
        const selector = {
          group: {
            ns: coll.collectionName,
            $reduce: reduceFunction,
            cond: condition,
            initial,
            out: "inline"
          }
        };
        if (finalize != null)
          selector.group["finalize"] = finalize;
        if (typeof keys === "function" || keys && keys._bsontype === "Code") {
          selector.group.$keyf = keys && keys._bsontype === "Code" ? keys : new Code2(keys);
        } else {
          const hash2 = {};
          keys.forEach((key) => {
            hash2[key] = 1;
          });
          selector.group.key = hash2;
        }
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        decorateWithReadConcern(selector, coll, options2);
        try {
          decorateWithCollation(selector, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        executeCommand(coll.s.db, selector, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result.retval);
        });
      } else {
        const scope = reduce != null && reduce._bsontype === "Code" ? reduce.scope : {};
        scope.ns = coll.collectionName;
        scope.keys = keys;
        scope.condition = condition;
        scope.initial = initial;
        const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ";");
        evaluate(coll.s.db, new Code2(groupfn, scope), null, options2, (err, results) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, results.result || results);
        });
      }
    }
    function indexes(coll, options2, callback) {
      options2 = Object.assign({}, { full: true }, options2);
      indexInformationDb(coll.s.db, coll.collectionName, options2, callback);
    }
    function indexExists(coll, indexes2, options2, callback) {
      indexInformation(coll, options2, (err, indexInformation2) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (!Array.isArray(indexes2))
          return handleCallback(callback, null, indexInformation2[indexes2] != null);
        for (let i = 0; i < indexes2.length; i++) {
          if (indexInformation2[indexes2[i]] == null) {
            return handleCallback(callback, null, false);
          }
        }
        return handleCallback(callback, null, true);
      });
    }
    function indexInformation(coll, options2, callback) {
      indexInformationDb(coll.s.db, coll.collectionName, options2, callback);
    }
    function parallelCollectionScan(coll, options2, callback) {
      const commandObject = {
        parallelCollectionScan: coll.collectionName,
        numCursors: options2.numCursors
      };
      decorateWithReadConcern(commandObject, coll, options2);
      const raw = options2.raw;
      delete options2["raw"];
      executeCommand(coll.s.db, commandObject, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
        options2 = Object.assign({ explicitlyIgnoreSession: true }, options2);
        const cursors = [];
        if (raw)
          options2.raw = raw;
        for (let i = 0; i < result.cursors.length; i++) {
          const rawId = result.cursors[i].cursor.id;
          const cursorId = typeof rawId === "number" ? Long2.fromNumber(rawId) : rawId;
          cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options2));
        }
        handleCallback(callback, null, cursors);
      });
    }
    function save(coll, doc, options2, callback) {
      const finalOptions = applyWriteConcern(Object.assign({}, options2), { db: coll.s.db, collection: coll }, options2);
      if (doc._id != null) {
        finalOptions.upsert = true;
        return updateDocuments(coll, { _id: doc._id }, doc, finalOptions, callback);
      }
      insertDocuments(coll, [doc], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (doc == null)
          return handleCallback(callback, null, null);
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      createIndex,
      createIndexes,
      ensureIndex,
      group,
      indexes,
      indexExists,
      indexInformation,
      parallelCollectionScan,
      save
    };
  }
});

// node_modules/mongodb/lib/operations/cursor_ops.js
var require_cursor_ops = __commonJS({
  "node_modules/mongodb/lib/operations/cursor_ops.js"(exports2, module2) {
    init_shims();
    "use strict";
    var buildCountCommand = require_collection_ops().buildCountCommand;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var push = Array.prototype.push;
    var CursorState = require_cursor().CursorState;
    function count(cursor, applySkipLimit, opts, callback) {
      if (applySkipLimit) {
        if (typeof cursor.cursorSkip() === "number")
          opts.skip = cursor.cursorSkip();
        if (typeof cursor.cursorLimit() === "number")
          opts.limit = cursor.cursorLimit();
      }
      if (opts.readPreference) {
        cursor.setReadPreference(opts.readPreference);
      }
      if (typeof opts.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
        opts.maxTimeMS = cursor.cmd.maxTimeMS;
      }
      let options2 = {};
      options2.skip = opts.skip;
      options2.limit = opts.limit;
      options2.hint = opts.hint;
      options2.maxTimeMS = opts.maxTimeMS;
      options2.collectionName = cursor.namespace.collection;
      let command;
      try {
        command = buildCountCommand(cursor, cursor.cmd.query, options2);
      } catch (err) {
        return callback(err);
      }
      cursor.server = cursor.topology.s.coreTopology;
      cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
        callback(err, result ? result.result.n : null);
      });
    }
    function each2(cursor, callback) {
      if (!callback)
        throw MongoError.create({ message: "callback is mandatory", driver: true });
      if (cursor.isNotified())
        return;
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {
        return handleCallback(callback, MongoError.create({ message: "Cursor is closed", driver: true }));
      }
      if (cursor.s.state === CursorState.INIT) {
        cursor.s.state = CursorState.OPEN;
      }
      let fn = null;
      if (cursor.bufferedCount() > 0) {
        while (fn = loop(cursor, callback))
          fn(cursor, callback);
        each2(cursor, callback);
      } else {
        cursor.next((err, item) => {
          if (err)
            return handleCallback(callback, err);
          if (item == null) {
            return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, null));
          }
          if (handleCallback(callback, null, item) === false)
            return;
          each2(cursor, callback);
        });
      }
    }
    function loop(cursor, callback) {
      if (cursor.bufferedCount() === 0)
        return;
      cursor._next(callback);
      return loop;
    }
    function toArray(cursor, callback) {
      const items = [];
      cursor.rewind();
      cursor.s.state = CursorState.INIT;
      const fetchDocs = () => {
        cursor._next((err, doc) => {
          if (err) {
            return handleCallback(callback, err);
          }
          if (doc == null) {
            return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, items));
          }
          items.push(doc);
          if (cursor.bufferedCount() > 0) {
            let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
            if (cursor.s.transforms && typeof cursor.s.transforms.doc === "function") {
              docs = docs.map(cursor.s.transforms.doc);
            }
            push.apply(items, docs);
          }
          fetchDocs();
        });
      };
      fetchDocs();
    }
    module2.exports = { count, each: each2, toArray };
  }
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS({
  "node_modules/mongodb/lib/operations/count.js"(exports2, module2) {
    init_shims();
    "use strict";
    var buildCountCommand = require_common_functions().buildCountCommand;
    var OperationBase = require_operation().OperationBase;
    var CountOperation = class extends OperationBase {
      constructor(cursor, applySkipLimit, options2) {
        super(options2);
        this.cursor = cursor;
        this.applySkipLimit = applySkipLimit;
      }
      execute(callback) {
        const cursor = this.cursor;
        const applySkipLimit = this.applySkipLimit;
        const options2 = this.options;
        if (applySkipLimit) {
          if (typeof cursor.cursorSkip() === "number")
            options2.skip = cursor.cursorSkip();
          if (typeof cursor.cursorLimit() === "number")
            options2.limit = cursor.cursorLimit();
        }
        if (options2.readPreference) {
          cursor.setReadPreference(options2.readPreference);
        }
        if (typeof options2.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
          options2.maxTimeMS = cursor.cmd.maxTimeMS;
        }
        let finalOptions = {};
        finalOptions.skip = options2.skip;
        finalOptions.limit = options2.limit;
        finalOptions.hint = options2.hint;
        finalOptions.maxTimeMS = options2.maxTimeMS;
        finalOptions.collectionName = cursor.namespace.collection;
        let command;
        try {
          command = buildCountCommand(cursor, cursor.cmd.query, finalOptions);
        } catch (err) {
          return callback(err);
        }
        cursor.server = cursor.topology.s.coreTopology;
        cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
          callback(err, result ? result.result.n : null);
        });
      }
    };
    module2.exports = CountOperation;
  }
});

// node_modules/mongodb/lib/cursor.js
var require_cursor2 = __commonJS({
  "node_modules/mongodb/lib/cursor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Transform = require("stream").Transform;
    var PassThrough2 = require("stream").PassThrough;
    var deprecate = require("util").deprecate;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var CoreCursor = require_cursor().CoreCursor;
    var CursorState = require_cursor().CursorState;
    var Map2 = require_core().BSON.Map;
    var maybePromise = require_utils4().maybePromise;
    var executeOperation = require_execute_operation();
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var Explain = require_explain().Explain;
    var Aspect = require_operation().Aspect;
    var each2 = require_cursor_ops().each;
    var CountOperation = require_count();
    var flags = ["tailable", "oplogReplay", "noCursorTimeout", "awaitData", "exhaust", "partial"];
    var fields = ["numberOfRetries", "tailableRetryInterval"];
    var Cursor = class extends CoreCursor {
      constructor(topology, ns, cmd, options2) {
        super(topology, ns, cmd, options2);
        if (this.operation) {
          options2 = this.operation.options;
        }
        const numberOfRetries = options2.numberOfRetries || 5;
        const tailableRetryInterval = options2.tailableRetryInterval || 500;
        const currentNumberOfRetries = numberOfRetries;
        const promiseLibrary = options2.promiseLibrary || Promise;
        this.s = {
          numberOfRetries,
          tailableRetryInterval,
          currentNumberOfRetries,
          state: CursorState.INIT,
          promiseLibrary,
          explicitlyIgnoreSession: !!options2.explicitlyIgnoreSession
        };
        if (!options2.explicitlyIgnoreSession && options2.session) {
          this.cursorState.session = options2.session;
        }
        if (this.options.noCursorTimeout === true) {
          this.addCursorFlag("noCursorTimeout", true);
        }
        let batchSize = 1e3;
        if (this.cmd.cursor && this.cmd.cursor.batchSize) {
          batchSize = this.cmd.cursor.batchSize;
        } else if (options2.cursor && options2.cursor.batchSize) {
          batchSize = options2.cursor.batchSize;
        } else if (typeof options2.batchSize === "number") {
          batchSize = options2.batchSize;
        }
        this.setCursorBatchSize(batchSize);
      }
      get readPreference() {
        if (this.operation) {
          return this.operation.readPreference;
        }
        return this.options.readPreference;
      }
      get sortValue() {
        return this.cmd.sort;
      }
      _initializeCursor(callback) {
        if (this.operation && this.operation.session != null) {
          this.cursorState.session = this.operation.session;
        } else {
          if (!this.s.explicitlyIgnoreSession && !this.cursorState.session && this.topology.hasSessionSupport()) {
            this.cursorState.session = this.topology.startSession({ owner: this });
            if (this.operation) {
              this.operation.session = this.cursorState.session;
            }
          }
        }
        super._initializeCursor(callback);
      }
      hasNext(callback) {
        if (this.s.state === CursorState.CLOSED || this.isDead && this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.isNotified()) {
            return cb(null, false);
          }
          cursor._next((err, doc) => {
            if (err)
              return cb(err);
            if (doc == null || cursor.s.state === Cursor.CLOSED || cursor.isDead()) {
              return cb(null, false);
            }
            cursor.s.state = CursorState.OPEN;
            cursor.cursorState.cursorIndex--;
            if (cursor.cursorState.limit > 0) {
              cursor.cursorState.currentLimit--;
            }
            cb(null, true);
          });
        });
      }
      next(callback) {
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
            cb(MongoError.create({ message: "Cursor is closed", driver: true }));
            return;
          }
          if (cursor.s.state === CursorState.INIT && cursor.cmd.sort) {
            try {
              cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
            } catch (err) {
              return cb(err);
            }
          }
          cursor._next((err, doc) => {
            if (err)
              return cb(err);
            cursor.s.state = CursorState.OPEN;
            cb(null, doc);
          });
        });
      }
      filter(filter) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.query = filter;
        return this;
      }
      maxScan(maxScan) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxScan = maxScan;
        return this;
      }
      hint(hint) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.hint = hint;
        return this;
      }
      min(min) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.min = min;
        return this;
      }
      max(max) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.max = max;
        return this;
      }
      returnKey(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.returnKey = value;
        return this;
      }
      showRecordId(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.showDiskLoc = value;
        return this;
      }
      snapshot(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.snapshot = value;
        return this;
      }
      setCursorOption(field, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (fields.indexOf(field) === -1) {
          throw MongoError.create({
            message: `option ${field} is not a supported option ${fields}`,
            driver: true
          });
        }
        this.s[field] = value;
        if (field === "numberOfRetries")
          this.s.currentNumberOfRetries = value;
        return this;
      }
      addCursorFlag(flag, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (flags.indexOf(flag) === -1) {
          throw MongoError.create({
            message: `flag ${flag} is not a supported flag ${flags}`,
            driver: true
          });
        }
        if (typeof value !== "boolean") {
          throw MongoError.create({ message: `flag ${flag} must be a boolean value`, driver: true });
        }
        this.cmd[flag] = value;
        return this;
      }
      addQueryModifier(name, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (name[0] !== "$") {
          throw MongoError.create({ message: `${name} is not a valid query modifier`, driver: true });
        }
        const field = name.substr(1);
        this.cmd[field] = value;
        if (field === "orderby")
          this.cmd.sort = this.cmd[field];
        return this;
      }
      comment(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.comment = value;
        return this;
      }
      maxAwaitTimeMS(value) {
        if (typeof value !== "number") {
          throw MongoError.create({ message: "maxAwaitTimeMS must be a number", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxAwaitTimeMS = value;
        return this;
      }
      maxTimeMS(value) {
        if (typeof value !== "number") {
          throw MongoError.create({ message: "maxTimeMS must be a number", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxTimeMS = value;
        return this;
      }
      project(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.fields = value;
        return this;
      }
      sort(keyOrList, direction) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support sorting", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        let order = keyOrList;
        if (Array.isArray(order) && Array.isArray(order[0])) {
          order = new Map2(order.map((x) => {
            const value = [x[0], null];
            if (x[1] === "asc") {
              value[1] = 1;
            } else if (x[1] === "desc") {
              value[1] = -1;
            } else if (x[1] === 1 || x[1] === -1 || x[1].$meta) {
              value[1] = x[1];
            } else {
              throw new MongoError("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
            }
            return value;
          }));
        }
        if (direction != null) {
          order = [[keyOrList, direction]];
        }
        this.cmd.sort = order;
        return this;
      }
      batchSize(value) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor doesn't support batchSize",
            driver: true
          });
        }
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        this.cmd.batchSize = value;
        this.setCursorBatchSize(value);
        return this;
      }
      collation(value) {
        this.cmd.collation = value;
        return this;
      }
      limit(value) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support limit", driver: true });
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "limit requires an integer", driver: true });
        }
        this.cmd.limit = value;
        this.setCursorLimit(value);
        return this;
      }
      skip(value) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support skip", driver: true });
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "skip requires an integer", driver: true });
        }
        this.cmd.skip = value;
        this.setCursorSkip(value);
        return this;
      }
      each(callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        each2(this, callback);
      }
      forEach(iterator, callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        if (typeof callback === "function") {
          each2(this, (err, doc) => {
            if (err) {
              callback(err);
              return false;
            }
            if (doc != null) {
              try {
                iterator(doc);
              } catch (error2) {
                callback(error2);
                return false;
              }
              return true;
            }
            if (doc == null && callback) {
              const internalCallback = callback;
              callback = null;
              internalCallback(null);
              return false;
            }
          });
        } else {
          return new this.s.promiseLibrary((fulfill, reject) => {
            each2(this, (err, doc) => {
              if (err) {
                reject(err);
                return false;
              } else if (doc == null) {
                fulfill(null);
                return false;
              } else {
                try {
                  iterator(doc);
                } catch (error2) {
                  reject(error2);
                  return false;
                }
                return true;
              }
            });
          });
        }
      }
      setReadPreference(readPreference) {
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      toArray(callback) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor cannot be converted to array",
            driver: true
          });
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          const items = [];
          cursor.rewind();
          cursor.s.state = CursorState.INIT;
          const fetchDocs = () => {
            cursor._next((err, doc) => {
              if (err) {
                return handleCallback(cb, err);
              }
              if (doc == null) {
                return cursor.close({ skipKillCursors: true }, () => handleCallback(cb, null, items));
              }
              items.push(doc);
              if (cursor.bufferedCount() > 0) {
                let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
                Array.prototype.push.apply(items, docs);
              }
              fetchDocs();
            });
          };
          fetchDocs();
        });
      }
      count(applySkipLimit, opts, callback) {
        if (this.cmd.query == null)
          throw MongoError.create({
            message: "count can only be used with find command",
            driver: true
          });
        if (typeof opts === "function")
          callback = opts, opts = {};
        opts = opts || {};
        if (typeof applySkipLimit === "function") {
          callback = applySkipLimit;
          applySkipLimit = true;
        }
        if (this.cursorState.session) {
          opts = Object.assign({}, opts, { session: this.cursorState.session });
        }
        const countOperation = new CountOperation(this, applySkipLimit, opts);
        return executeOperation(this.topology, countOperation, callback);
      }
      close(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = Object.assign({}, { skipKillCursors: false }, options2);
        return maybePromise(this, callback, (cb) => {
          this.s.state = CursorState.CLOSED;
          if (!options2.skipKillCursors) {
            this.kill();
          }
          this._endSession(() => {
            this.emit("close");
            cb(null, this);
          });
        });
      }
      map(transform) {
        if (this.cursorState.transforms && this.cursorState.transforms.doc) {
          const oldTransform = this.cursorState.transforms.doc;
          this.cursorState.transforms.doc = (doc) => {
            return transform(oldTransform(doc));
          };
        } else {
          this.cursorState.transforms = { doc: transform };
        }
        return this;
      }
      isClosed() {
        return this.isDead();
      }
      destroy(err) {
        if (err)
          this.emit("error", err);
        this.pause();
        this.close();
      }
      stream(options2) {
        this.cursorState.streamOptions = options2 || {};
        return this;
      }
      transformStream(options2) {
        const streamOptions = options2 || {};
        if (typeof streamOptions.transform === "function") {
          const stream = new Transform({
            objectMode: true,
            transform: function(chunk, encoding, callback) {
              this.push(streamOptions.transform(chunk));
              callback();
            }
          });
          return this.pipe(stream);
        }
        return this.pipe(new PassThrough2({ objectMode: true }));
      }
      explain(verbosity, callback) {
        if (typeof verbosity === "function")
          callback = verbosity, verbosity = true;
        if (verbosity === void 0)
          verbosity = true;
        if (!this.operation || !this.operation.hasAspect(Aspect.EXPLAINABLE)) {
          throw new MongoError("This command cannot be explained");
        }
        this.operation.explain = new Explain(verbosity);
        return maybePromise(this, callback, (cb) => {
          CoreCursor.prototype._next.apply(this, [cb]);
        });
      }
      getLogger() {
        return this.logger;
      }
    };
    Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
    deprecate(Cursor.prototype.each, "Cursor.each is deprecated. Use Cursor.forEach instead.");
    deprecate(Cursor.prototype.maxScan, "Cursor.maxScan is deprecated, and will be removed in a later version");
    deprecate(Cursor.prototype.snapshot, "Cursor Snapshot is deprecated, and will be removed in a later version");
    module2.exports = Cursor;
  }
});

// node_modules/mongodb/lib/operations/command_v2.js
var require_command_v2 = __commonJS({
  "node_modules/mongodb/lib/operations/command_v2.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var maxWireVersion = require_utils2().maxWireVersion;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var commandSupportsReadConcern = require_sessions().commandSupportsReadConcern;
    var MongoError = require_error().MongoError;
    var extractCommand = require_command_utils().extractCommand;
    var SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;
    var CommandOperationV2 = class extends OperationBase {
      constructor(parent, options2, operationOptions) {
        super(options2);
        this.ns = parent.s.namespace.withCollection("$cmd");
        const propertyProvider = this.hasAspect(Aspect.NO_INHERIT_OPTIONS) ? void 0 : parent;
        this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION) ? ReadPreference.primary : ReadPreference.resolve(propertyProvider, this.options);
        this.readConcern = resolveReadConcern(propertyProvider, this.options);
        this.writeConcern = resolveWriteConcern(propertyProvider, this.options);
        if (operationOptions && typeof operationOptions.fullResponse === "boolean") {
          this.fullResponse = true;
        }
        this.options.readPreference = this.readPreference;
        if (parent.s.logger) {
          this.logger = parent.s.logger;
        } else if (parent.s.db && parent.s.db.logger) {
          this.logger = parent.s.db.logger;
        }
      }
      executeCommand(server, cmd, callback) {
        this.server = server;
        const options2 = this.options;
        const serverWireVersion = maxWireVersion(server);
        const inTransaction = this.session && this.session.inTransaction();
        if (this.readConcern && commandSupportsReadConcern(cmd) && !inTransaction) {
          Object.assign(cmd, { readConcern: this.readConcern });
        }
        if (options2.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
          return;
        }
        if (serverWireVersion >= SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          if (this.writeConcern && this.hasAspect(Aspect.WRITE_OPERATION)) {
            Object.assign(cmd, { writeConcern: this.writeConcern });
          }
          if (options2.collation && typeof options2.collation === "object") {
            Object.assign(cmd, { collation: options2.collation });
          }
        }
        if (typeof options2.maxTimeMS === "number") {
          cmd.maxTimeMS = options2.maxTimeMS;
        }
        if (typeof options2.comment === "string") {
          cmd.comment = options2.comment;
        }
        if (this.hasAspect(Aspect.EXPLAINABLE) && this.explain) {
          if (serverWireVersion < 6 && cmd.aggregate) {
            cmd.explain = true;
          } else {
            cmd = decorateWithExplain(cmd, this.explain);
          }
        }
        if (this.logger && this.logger.isDebug()) {
          const extractedCommand = extractCommand(cmd);
          this.logger.debug(`executing command ${JSON.stringify(extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : cmd)} against ${this.ns}`);
        }
        server.command(this.ns.toString(), cmd, this.options, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          if (this.fullResponse) {
            callback(null, result);
            return;
          }
          callback(null, result.result);
        });
      }
    };
    function resolveWriteConcern(parent, options2) {
      return WriteConcern.fromOptions(options2) || parent && parent.writeConcern;
    }
    function resolveReadConcern(parent, options2) {
      return ReadConcern.fromOptions(options2) || parent && parent.readConcern;
    }
    module2.exports = CommandOperationV2;
  }
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/mongodb/lib/operations/aggregate.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var ReadPreference = require_core().ReadPreference;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DB_AGGREGATE_COLLECTION = 1;
    var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
    var AggregateOperation = class extends CommandOperationV2 {
      constructor(parent, pipeline2, options2) {
        super(parent, options2, { fullResponse: true });
        this.target = parent.s.namespace && parent.s.namespace.collection ? parent.s.namespace.collection : DB_AGGREGATE_COLLECTION;
        this.pipeline = pipeline2;
        this.hasWriteStage = false;
        if (typeof options2.out === "string") {
          this.pipeline = this.pipeline.concat({ $out: options2.out });
          this.hasWriteStage = true;
        } else if (pipeline2.length > 0) {
          const finalStage = pipeline2[pipeline2.length - 1];
          if (finalStage.$out || finalStage.$merge) {
            this.hasWriteStage = true;
          }
        }
        if (this.hasWriteStage) {
          this.readPreference = ReadPreference.primary;
        }
        if (this.explain && this.writeConcern) {
          throw new MongoError('"explain" cannot be used on an aggregate call with writeConcern');
        }
        if (options2.cursor != null && typeof options2.cursor !== "object") {
          throw new MongoError("cursor options must be an object");
        }
      }
      get canRetryRead() {
        return !this.hasWriteStage;
      }
      addToPipeline(stage) {
        this.pipeline.push(stage);
      }
      execute(server, callback) {
        const options2 = this.options;
        const serverWireVersion = maxWireVersion(server);
        const command = { aggregate: this.target, pipeline: this.pipeline };
        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
          this.readConcern = null;
        }
        if (serverWireVersion >= 5) {
          if (this.hasWriteStage && this.writeConcern) {
            Object.assign(command, { writeConcern: this.writeConcern });
          }
        }
        if (options2.bypassDocumentValidation === true) {
          command.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        if (typeof options2.allowDiskUse === "boolean") {
          command.allowDiskUse = options2.allowDiskUse;
        }
        if (options2.hint) {
          command.hint = options2.hint;
        }
        if (this.explain) {
          options2.full = false;
        }
        command.cursor = options2.cursor || {};
        if (options2.batchSize && !this.hasWriteStage) {
          command.cursor.batchSize = options2.batchSize;
        }
        super.executeCommand(server, command, callback);
      }
    };
    defineAspects(AggregateOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = AggregateOperation;
  }
});

// node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS({
  "node_modules/mongodb/lib/bulk/common.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().BSON.ObjectID;
    var BSON2 = require_core().BSON;
    var MongoWriteConcernError = require_core().MongoWriteConcernError;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var toError = require_utils4().toError;
    var handleCallback = require_utils4().handleCallback;
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var isPromiseLike = require_utils4().isPromiseLike;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var maxWireVersion = require_utils2().maxWireVersion;
    var WRITE_CONCERN_ERROR = 64;
    var INSERT = 1;
    var UPDATE = 2;
    var REMOVE = 3;
    var bson = new BSON2([
      BSON2.Binary,
      BSON2.Code,
      BSON2.DBRef,
      BSON2.Decimal128,
      BSON2.Double,
      BSON2.Int32,
      BSON2.Long,
      BSON2.Map,
      BSON2.MaxKey,
      BSON2.MinKey,
      BSON2.ObjectId,
      BSON2.BSONRegExp,
      BSON2.Symbol,
      BSON2.Timestamp
    ]);
    var Batch = class {
      constructor(batchType, originalZeroIndex) {
        this.originalZeroIndex = originalZeroIndex;
        this.currentIndex = 0;
        this.originalIndexes = [];
        this.batchType = batchType;
        this.operations = [];
        this.size = 0;
        this.sizeBytes = 0;
      }
    };
    var kUpsertedIds = Symbol("upsertedIds");
    var kInsertedIds = Symbol("insertedIds");
    var BulkWriteResult = class {
      constructor(bulkResult) {
        this.result = bulkResult;
        this[kUpsertedIds] = void 0;
        this[kInsertedIds] = void 0;
      }
      get insertedCount() {
        return typeof this.result.nInserted !== "number" ? 0 : this.result.nInserted;
      }
      get matchedCount() {
        return typeof this.result.nMatched !== "number" ? 0 : this.result.nMatched;
      }
      get modifiedCount() {
        return typeof this.result.nModified !== "number" ? 0 : this.result.nModified;
      }
      get deletedCount() {
        return typeof this.result.nRemoved !== "number" ? 0 : this.result.nRemoved;
      }
      get upsertedCount() {
        return !this.result.upserted ? 0 : this.result.upserted.length;
      }
      get upsertedIds() {
        if (this[kUpsertedIds]) {
          return this[kUpsertedIds];
        }
        this[kUpsertedIds] = {};
        for (const doc of this.result.upserted || []) {
          this[kUpsertedIds][doc.index] = doc._id;
        }
        return this[kUpsertedIds];
      }
      get insertedIds() {
        if (this[kInsertedIds]) {
          return this[kInsertedIds];
        }
        this[kInsertedIds] = {};
        for (const doc of this.result.insertedIds || []) {
          this[kInsertedIds][doc.index] = doc._id;
        }
        return this[kInsertedIds];
      }
      get n() {
        return this.result.insertedCount;
      }
      get ok() {
        return this.result.ok;
      }
      get nInserted() {
        return this.result.nInserted;
      }
      get nUpserted() {
        return this.result.nUpserted;
      }
      get nMatched() {
        return this.result.nMatched;
      }
      get nModified() {
        return this.result.nModified;
      }
      get nRemoved() {
        return this.result.nRemoved;
      }
      getInsertedIds() {
        return this.result.insertedIds;
      }
      getUpsertedIds() {
        return this.result.upserted;
      }
      getUpsertedIdAt(index2) {
        return this.result.upserted[index2];
      }
      getRawResponse() {
        return this.result;
      }
      hasWriteErrors() {
        return this.result.writeErrors.length > 0;
      }
      getWriteErrorCount() {
        return this.result.writeErrors.length;
      }
      getWriteErrorAt(index2) {
        if (index2 < this.result.writeErrors.length) {
          return this.result.writeErrors[index2];
        }
        return null;
      }
      getWriteErrors() {
        return this.result.writeErrors;
      }
      getLastOp() {
        return this.result.lastOp;
      }
      getWriteConcernError() {
        if (this.result.writeConcernErrors.length === 0) {
          return null;
        } else if (this.result.writeConcernErrors.length === 1) {
          return this.result.writeConcernErrors[0];
        } else {
          let errmsg = "";
          for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
            const err = this.result.writeConcernErrors[i];
            errmsg = errmsg + err.errmsg;
            if (i === 0)
              errmsg = errmsg + " and ";
          }
          return new WriteConcernError({ errmsg, code: WRITE_CONCERN_ERROR });
        }
      }
      toJSON() {
        return this.result;
      }
      toString() {
        return `BulkWriteResult(${this.toJSON(this.result)})`;
      }
      isOk() {
        return this.result.ok === 1;
      }
    };
    var WriteConcernError = class {
      constructor(err) {
        this.err = err;
      }
      get code() {
        return this.err.code;
      }
      get errmsg() {
        return this.err.errmsg;
      }
      toJSON() {
        return { code: this.err.code, errmsg: this.err.errmsg };
      }
      toString() {
        return `WriteConcernError(${this.err.errmsg})`;
      }
    };
    var WriteError = class {
      constructor(err) {
        this.err = err;
      }
      get code() {
        return this.err.code;
      }
      get index() {
        return this.err.index;
      }
      get errmsg() {
        return this.err.errmsg;
      }
      getOperation() {
        return this.err.op;
      }
      toJSON() {
        return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
      }
      toString() {
        return `WriteError(${JSON.stringify(this.toJSON())})`;
      }
    };
    function mergeBatchResults(batch, bulkResult, err, result) {
      if (err) {
        result = err;
      } else if (result && result.result) {
        result = result.result;
      } else if (result == null) {
        return;
      }
      if (result.ok === 0 && bulkResult.ok === 1) {
        bulkResult.ok = 0;
        const writeError = {
          index: 0,
          code: result.code || 0,
          errmsg: result.message,
          op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
      } else if (result.ok === 0 && bulkResult.ok === 0) {
        return;
      }
      if (result.opTime || result.lastOp) {
        const opTime = result.lastOp || result.opTime;
        let lastOpTS = null;
        let lastOpT = null;
        if (opTime && opTime._bsontype === "Timestamp") {
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTime.greaterThan(bulkResult.lastOp)) {
            bulkResult.lastOp = opTime;
          }
        } else {
          if (bulkResult.lastOp) {
            lastOpTS = typeof bulkResult.lastOp.ts === "number" ? Long2.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;
            lastOpT = typeof bulkResult.lastOp.t === "number" ? Long2.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;
          }
          const opTimeTS = typeof opTime.ts === "number" ? Long2.fromNumber(opTime.ts) : opTime.ts;
          const opTimeT = typeof opTime.t === "number" ? Long2.fromNumber(opTime.t) : opTime.t;
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.greaterThan(lastOpTS)) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.equals(lastOpTS)) {
            if (opTimeT.greaterThan(lastOpT)) {
              bulkResult.lastOp = opTime;
            }
          }
        }
      }
      if (batch.batchType === INSERT && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
      }
      if (batch.batchType === REMOVE && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
      }
      let nUpserted = 0;
      if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (let i = 0; i < result.upserted.length; i++) {
          bulkResult.upserted.push({
            index: result.upserted[i].index + batch.originalZeroIndex,
            _id: result.upserted[i]._id
          });
        }
      } else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
          index: batch.originalZeroIndex,
          _id: result.upserted
        });
      }
      if (batch.batchType === UPDATE && result.n) {
        const nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified === "number") {
          bulkResult.nModified = bulkResult.nModified + nModified;
        } else {
          bulkResult.nModified = null;
        }
      }
      if (Array.isArray(result.writeErrors)) {
        for (let i = 0; i < result.writeErrors.length; i++) {
          const writeError = {
            index: batch.originalIndexes[result.writeErrors[i].index],
            code: result.writeErrors[i].code,
            errmsg: result.writeErrors[i].errmsg,
            op: batch.operations[result.writeErrors[i].index]
          };
          bulkResult.writeErrors.push(new WriteError(writeError));
        }
      }
      if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
      }
    }
    function executeCommands(bulkOperation, options2, callback) {
      if (bulkOperation.s.batches.length === 0) {
        return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));
      }
      const batch = bulkOperation.s.batches.shift();
      function resultHandler(err, result) {
        if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {
          return handleCallback(callback, err);
        }
        if (err)
          err.ok = 0;
        if (err instanceof MongoWriteConcernError) {
          return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
        }
        const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
        const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
        if (mergeResult != null) {
          return handleCallback(callback, null, writeResult);
        }
        if (bulkOperation.handleWriteError(callback, writeResult))
          return;
        executeCommands(bulkOperation, options2, callback);
      }
      bulkOperation.finalOptionsHandler({ options: options2, batch, resultHandler }, callback);
    }
    function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
      mergeBatchResults(batch, bulkResult, null, err.result);
      const wrappedWriteConcernError = new WriteConcernError({
        errmsg: err.result.writeConcernError.errmsg,
        code: err.result.writeConcernError.result
      });
      return handleCallback(callback, new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)), null);
    }
    var BulkWriteError = class extends MongoError {
      constructor(error2, result) {
        const message = error2.err || error2.errmsg || error2.errMessage || error2;
        super(message);
        Object.assign(this, error2);
        this.name = "BulkWriteError";
        this.result = result;
      }
      get insertedCount() {
        return this.result.insertedCount;
      }
      get matchedCount() {
        return this.result.matchedCount;
      }
      get modifiedCount() {
        return this.result.modifiedCount;
      }
      get deletedCount() {
        return this.result.deletedCount;
      }
      get upsertedCount() {
        return this.result.upsertedCount;
      }
      get insertedIds() {
        return this.result.insertedIds;
      }
      get upsertedIds() {
        return this.result.upsertedIds;
      }
    };
    var FindOperators = class {
      constructor(bulkOperation) {
        this.s = bulkOperation.s;
      }
      update(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: true,
          upsert
        };
        if (updateDocument.hint) {
          document2.hint = updateDocument.hint;
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      updateOne(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: false,
          upsert
        };
        if (updateDocument.hint) {
          document2.hint = updateDocument.hint;
        }
        if (!hasAtomicOperators(updateDocument)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      replaceOne(replacement) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: replacement,
          multi: false,
          upsert
        };
        if (replacement.hint) {
          document2.hint = replacement.hint;
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not use atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      upsert() {
        this.s.currentOp.upsert = true;
        return this;
      }
      deleteOne() {
        const document2 = {
          q: this.s.currentOp.selector,
          limit: 1
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document2);
      }
      delete() {
        const document2 = {
          q: this.s.currentOp.selector,
          limit: 0
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document2);
      }
      removeOne() {
        emitWarningOnce("bulk operation `removeOne` has been deprecated, please use `deleteOne`");
        return this.deleteOne();
      }
      remove() {
        emitWarningOnce("bulk operation `remove` has been deprecated, please use `delete`");
        return this.delete();
      }
    };
    var BulkOperationBase = class {
      constructor(topology, collection, options2, isOrdered) {
        this.isOrdered = isOrdered;
        options2 = options2 == null ? {} : options2;
        const namespace = collection.s.namespace;
        const executed = false;
        const currentOp = null;
        const bson2 = topology.bson;
        const isMaster = topology.lastIsMaster();
        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
        const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;
        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
        const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1e3;
        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
        let finalOptions = Object.assign({}, options2);
        finalOptions = applyRetryableWrites(finalOptions, collection.s.db);
        finalOptions = applyWriteConcern(finalOptions, { collection }, options2);
        const writeConcern = finalOptions.writeConcern;
        const promiseLibrary = options2.promiseLibrary || Promise;
        const bulkResult = {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        };
        this.s = {
          bulkResult,
          currentBatch: null,
          currentIndex: 0,
          currentBatchSize: 0,
          currentBatchSizeBytes: 0,
          currentInsertBatch: null,
          currentUpdateBatch: null,
          currentRemoveBatch: null,
          batches: [],
          writeConcern,
          maxBsonObjectSize,
          maxBatchSizeBytes,
          maxWriteBatchSize,
          maxKeySize,
          namespace,
          bson: bson2,
          topology,
          options: finalOptions,
          currentOp,
          executed,
          collection,
          promiseLibrary,
          err: null,
          checkKeys: typeof options2.checkKeys === "boolean" ? options2.checkKeys : true
        };
        if (options2.bypassDocumentValidation === true) {
          this.s.bypassDocumentValidation = true;
        }
      }
      insert(document2) {
        if (this.s.collection.s.db.options.forceServerObjectId !== true && document2._id == null)
          document2._id = new ObjectID2();
        return this.s.options.addToOperationsList(this, INSERT, document2);
      }
      find(selector) {
        if (!selector) {
          throw toError("Bulk find operation must specify a selector");
        }
        this.s.currentOp = {
          selector
        };
        return new FindOperators(this);
      }
      raw(op) {
        const key = Object.keys(op)[0];
        const forceServerObjectId = typeof this.s.options.forceServerObjectId === "boolean" ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
        if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {
          op[key].multi = op.updateOne || op.replaceOne ? false : true;
          return this.s.options.addToOperationsList(this, UPDATE, op[key]);
        }
        if (op.updateOne || op.updateMany || op.replaceOne) {
          if (op.replaceOne && hasAtomicOperators(op[key].replacement)) {
            throw new TypeError("Replacement document must not use atomic operators");
          } else if ((op.updateOne || op.updateMany) && !hasAtomicOperators(op[key].update)) {
            throw new TypeError("Update document requires atomic operators");
          }
          const multi = op.updateOne || op.replaceOne ? false : true;
          const operation = {
            q: op[key].filter,
            u: op[key].update || op[key].replacement,
            multi
          };
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            operation.upsert = op[key].upsert ? true : false;
            if (op.collation)
              operation.collation = op.collation;
          } else {
            if (op[key].upsert)
              operation.upsert = true;
          }
          if (op[key].arrayFilters) {
            if (maxWireVersion(this.s.topology) < 6) {
              throw new TypeError("arrayFilters are only supported on MongoDB 3.6+");
            }
            operation.arrayFilters = op[key].arrayFilters;
          }
          return this.s.options.addToOperationsList(this, UPDATE, operation);
        }
        if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {
          op[key].limit = op.removeOne ? 1 : 0;
          return this.s.options.addToOperationsList(this, REMOVE, op[key]);
        }
        if (op.deleteOne || op.deleteMany) {
          const limit = op.deleteOne ? 1 : 0;
          const operation = { q: op[key].filter, limit };
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            if (op.collation)
              operation.collation = op.collation;
          }
          return this.s.options.addToOperationsList(this, REMOVE, operation);
        }
        if (op.insertOne && op.insertOne.document == null) {
          if (forceServerObjectId !== true && op.insertOne._id == null)
            op.insertOne._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne);
        } else if (op.insertOne && op.insertOne.document) {
          if (forceServerObjectId !== true && op.insertOne.document._id == null)
            op.insertOne.document._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);
        }
        if (op.insertMany) {
          emitWarningOnce("bulk operation `insertMany` has been deprecated; use multiple `insertOne` ops instead");
          for (let i = 0; i < op.insertMany.length; i++) {
            if (forceServerObjectId !== true && op.insertMany[i]._id == null)
              op.insertMany[i]._id = new ObjectID2();
            this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);
          }
          return;
        }
        throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
      }
      _handleEarlyError(err, callback) {
        if (typeof callback === "function") {
          callback(err, null);
          return;
        }
        return this.s.promiseLibrary.reject(err);
      }
      bulkExecute(_writeConcern, options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        if (typeof _writeConcern === "function") {
          callback = _writeConcern;
        } else if (_writeConcern && typeof _writeConcern === "object") {
          this.s.writeConcern = _writeConcern;
        }
        if (this.s.executed) {
          const executedError = toError("batch cannot be re-executed");
          return this._handleEarlyError(executedError, callback);
        }
        if (this.isOrdered) {
          if (this.s.currentBatch)
            this.s.batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            this.s.batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            this.s.batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            this.s.batches.push(this.s.currentRemoveBatch);
        }
        if (this.s.batches.length === 0) {
          const emptyBatchError = toError("Invalid Operation, no operations specified");
          return this._handleEarlyError(emptyBatchError, callback);
        }
        return { options: options2, callback };
      }
      execute(_writeConcern, options2, callback) {
        const ret2 = this.bulkExecute(_writeConcern, options2, callback);
        if (!ret2 || isPromiseLike(ret2)) {
          return ret2;
        }
        options2 = ret2.options;
        callback = ret2.callback;
        return executeLegacyOperation(this.s.topology, executeCommands, [this, options2, callback]);
      }
      finalOptionsHandler(config, callback) {
        const finalOptions = Object.assign({ ordered: this.isOrdered }, config.options);
        if (this.s.writeConcern != null) {
          finalOptions.writeConcern = this.s.writeConcern;
        }
        if (finalOptions.bypassDocumentValidation !== true) {
          delete finalOptions.bypassDocumentValidation;
        }
        if (this.operationId) {
          config.resultHandler.operationId = this.operationId;
        }
        if (this.s.options.serializeFunctions) {
          finalOptions.serializeFunctions = true;
        }
        if (this.s.options.ignoreUndefined) {
          finalOptions.ignoreUndefined = true;
        }
        if (this.s.bypassDocumentValidation === true) {
          finalOptions.bypassDocumentValidation = true;
        }
        if (this.s.checkKeys === false) {
          finalOptions.checkKeys = false;
        }
        if (finalOptions.retryWrites) {
          if (config.batch.batchType === UPDATE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.multi);
          }
          if (config.batch.batchType === REMOVE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.limit === 0);
          }
        }
        try {
          if (config.batch.batchType === INSERT) {
            this.s.topology.insert(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          } else if (config.batch.batchType === UPDATE) {
            this.s.topology.update(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          } else if (config.batch.batchType === REMOVE) {
            this.s.topology.remove(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          }
        } catch (err) {
          err.ok = 0;
          handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));
        }
      }
      handleWriteError(callback, writeResult) {
        if (this.s.bulkResult.writeErrors.length > 0) {
          const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
          handleCallback(callback, new BulkWriteError(toError({
            message: msg,
            code: this.s.bulkResult.writeErrors[0].code,
            writeErrors: this.s.bulkResult.writeErrors
          }), writeResult), null);
          return true;
        }
        if (writeResult.getWriteConcernError()) {
          handleCallback(callback, new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult), null);
          return true;
        }
      }
    };
    Object.defineProperty(BulkOperationBase.prototype, "length", {
      enumerable: true,
      get: function() {
        return this.s.currentIndex;
      }
    });
    module2.exports = {
      Batch,
      BulkOperationBase,
      bson,
      INSERT,
      UPDATE,
      REMOVE,
      BulkWriteError,
      BulkWriteResult
    };
  }
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS({
  "node_modules/mongodb/lib/bulk/unordered.js"(exports2, module2) {
    init_shims();
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils4();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document2) {
      const bsonSize = bson.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      bulkOperation.s.currentBatch = null;
      if (docType === common.INSERT) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;
      }
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      if (bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      }
      if (Array.isArray(document2)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.operations.push(document2);
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;
      if (docType === common.INSERT) {
        bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.bulkResult.insertedIds.length,
          _id: document2._id
        });
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;
      }
      bulkOperation.s.currentBatch.size += 1;
      bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return bulkOperation;
    }
    var UnorderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options2) {
        options2 = options2 || {};
        options2 = Object.assign(options2, { addToOperationsList });
        super(topology, collection, options2, false);
      }
      handleWriteError(callback, writeResult) {
        if (this.s.batches.length) {
          return false;
        }
        return super.handleWriteError(callback, writeResult);
      }
    };
    function initializeUnorderedBulkOp(topology, collection, options2) {
      return new UnorderedBulkOperation(topology, collection, options2);
    }
    initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
    module2.exports = initializeUnorderedBulkOp;
    module2.exports.Bulk = UnorderedBulkOperation;
  }
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS({
  "node_modules/mongodb/lib/bulk/ordered.js"(exports2, module2) {
    init_shims();
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils4();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document2) {
      const bsonSize = bson.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatchSize > 0 && bulkOperation.s.currentBatchSizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
        bulkOperation.s.currentBatchSize = 0;
        bulkOperation.s.currentBatchSizeBytes = 0;
      }
      if (docType === common.INSERT) {
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.currentIndex,
          _id: document2._id
        });
      }
      if (Array.isArray(document2)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentBatch.operations.push(document2);
      bulkOperation.s.currentBatchSize += 1;
      bulkOperation.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      bulkOperation.s.currentIndex += 1;
      return bulkOperation;
    }
    var OrderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options2) {
        options2 = options2 || {};
        options2 = Object.assign(options2, { addToOperationsList });
        super(topology, collection, options2, true);
      }
    };
    function initializeOrderedBulkOp(topology, collection, options2) {
      return new OrderedBulkOperation(topology, collection, options2);
    }
    initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
    module2.exports = initializeOrderedBulkOp;
    module2.exports.Bulk = OrderedBulkOperation;
  }
});

// node_modules/mongodb/lib/aggregation_cursor.js
var require_aggregation_cursor = __commonJS({
  "node_modules/mongodb/lib/aggregation_cursor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var AggregationCursor = class extends Cursor {
      constructor(topology, operation, options2) {
        super(topology, operation, options2);
      }
      batchSize(value) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        this.operation.options.batchSize = value;
        this.setCursorBatchSize(value);
        return this;
      }
      geoNear(document2) {
        this.operation.addToPipeline({ $geoNear: document2 });
        return this;
      }
      group(document2) {
        this.operation.addToPipeline({ $group: document2 });
        return this;
      }
      limit(value) {
        this.operation.addToPipeline({ $limit: value });
        return this;
      }
      match(document2) {
        this.operation.addToPipeline({ $match: document2 });
        return this;
      }
      maxTimeMS(value) {
        this.operation.options.maxTimeMS = value;
        return this;
      }
      out(destination) {
        this.operation.addToPipeline({ $out: destination });
        return this;
      }
      project(document2) {
        this.operation.addToPipeline({ $project: document2 });
        return this;
      }
      lookup(document2) {
        this.operation.addToPipeline({ $lookup: document2 });
        return this;
      }
      redact(document2) {
        this.operation.addToPipeline({ $redact: document2 });
        return this;
      }
      skip(value) {
        this.operation.addToPipeline({ $skip: value });
        return this;
      }
      sort(document2) {
        this.operation.addToPipeline({ $sort: document2 });
        return this;
      }
      unwind(field) {
        this.operation.addToPipeline({ $unwind: field });
        return this;
      }
      getLogger() {
        return this.logger;
      }
    };
    AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
    module2.exports = AggregationCursor;
  }
});

// node_modules/mongodb/lib/command_cursor.js
var require_command_cursor = __commonJS({
  "node_modules/mongodb/lib/command_cursor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var CommandCursor = class extends Cursor {
      constructor(topology, ns, cmd, options2) {
        super(topology, ns, cmd, options2);
      }
      setReadPreference(readPreference) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      batchSize(value) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        if (this.cmd.cursor) {
          this.cmd.cursor.batchSize = value;
        }
        this.setCursorBatchSize(value);
        return this;
      }
      maxTimeMS(value) {
        if (this.topology.lastIsMaster().minWireVersion > 2) {
          this.cmd.maxTimeMS = value;
        }
        return this;
      }
      getLogger() {
        return this.logger;
      }
    };
    CommandCursor.prototype.get = CommandCursor.prototype.toArray;
    module2.exports = CommandCursor;
  }
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS({
  "node_modules/mongodb/lib/operations/bulk_write.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = class extends OperationBase {
      constructor(collection, operations, options2) {
        super(options2);
        this.collection = collection;
        this.operations = operations;
      }
      execute(callback) {
        const coll = this.collection;
        const operations = this.operations;
        let options2 = this.options;
        if (coll.s.options.ignoreUndefined) {
          options2 = Object.assign({}, options2);
          options2.ignoreUndefined = coll.s.options.ignoreUndefined;
        }
        const bulk = options2.ordered === true || options2.ordered == null ? coll.initializeOrderedBulkOp(options2) : coll.initializeUnorderedBulkOp(options2);
        let collation = false;
        try {
          for (let i = 0; i < operations.length; i++) {
            const key = Object.keys(operations[i])[0];
            if (operations[i][key].collation) {
              collation = true;
            }
            bulk.raw(operations[i]);
          }
        } catch (err) {
          return callback(err, null);
        }
        let finalOptions = Object.assign({}, options2);
        finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
        finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options2);
        const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
        const capabilities = coll.s.topology.capabilities();
        if (collation && capabilities && !capabilities.commandsTakeCollation) {
          return callback(new MongoError("server/primary/mongos does not support collation"));
        }
        bulk.execute(writeCon, finalOptions, (err, r) => {
          if (!r && err) {
            return callback(err, null);
          }
          callback(null, r);
        });
      }
    };
    module2.exports = BulkWriteOperation;
  }
});

// node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS({
  "node_modules/mongodb/lib/operations/count_documents.js"(exports2, module2) {
    init_shims();
    "use strict";
    var AggregateOperation = require_aggregate();
    var CountDocumentsOperation = class extends AggregateOperation {
      constructor(collection, query, options2) {
        const pipeline2 = [{ $match: query }];
        if (typeof options2.skip === "number") {
          pipeline2.push({ $skip: options2.skip });
        }
        if (typeof options2.limit === "number") {
          pipeline2.push({ $limit: options2.limit });
        }
        pipeline2.push({ $group: { _id: 1, n: { $sum: 1 } } });
        super(collection, pipeline2, options2);
      }
      execute(server, callback) {
        super.execute(server, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          const response = result.result;
          if (response.cursor == null || response.cursor.firstBatch == null) {
            callback(null, 0);
            return;
          }
          const docs = response.cursor.firstBatch;
          callback(null, docs.length ? docs[0].n : 0);
        });
      }
    };
    module2.exports = CountDocumentsOperation;
  }
});

// node_modules/mongodb/lib/operations/create_indexes.js
var require_create_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/create_indexes.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils4().parseIndexOptions;
    var maxWireVersion = require_utils2().maxWireVersion;
    var VALID_INDEX_OPTIONS = new Set([
      "background",
      "unique",
      "name",
      "partialFilterExpression",
      "sparse",
      "expireAfterSeconds",
      "storageEngine",
      "collation",
      "weights",
      "default_language",
      "language_override",
      "textIndexVersion",
      "2dsphereIndexVersion",
      "bits",
      "min",
      "max",
      "bucketSize",
      "wildcardProjection"
    ]);
    var CreateIndexesOperation = class extends CommandOperationV2 {
      constructor(parent, collection, indexes, options2) {
        super(parent, options2);
        this.collection = collection;
        if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {
          this.onlyReturnNameOfCreatedIndex = true;
          const indexParameters = parseIndexOptions(indexes);
          const name = typeof options2.name === "string" ? options2.name : indexParameters.name;
          const indexSpec = { name, key: indexParameters.fieldHash };
          for (let optionName in options2) {
            if (VALID_INDEX_OPTIONS.has(optionName)) {
              indexSpec[optionName] = options2[optionName];
            }
          }
          this.indexes = [indexSpec];
          return;
        }
        this.indexes = indexes;
      }
      execute(server, callback) {
        const options2 = this.options;
        const indexes = this.indexes;
        const serverWireVersion = maxWireVersion(server);
        for (let i = 0; i < indexes.length; i++) {
          if (indexes[i].collation && serverWireVersion < 5) {
            callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
            return;
          }
          if (indexes[i].name == null) {
            const keys = [];
            for (let name in indexes[i].key) {
              keys.push(`${name}_${indexes[i].key[name]}`);
            }
            indexes[i].name = keys.join("_");
          }
        }
        const cmd = { createIndexes: this.collection, indexes };
        if (options2.commitQuorum != null) {
          if (serverWireVersion < 9) {
            callback(new MongoError("`commitQuorum` option for `createIndexes` not supported on servers < 4.4"));
            return;
          }
          cmd.commitQuorum = options2.commitQuorum;
        }
        this.options.collation = void 0;
        super.executeCommand(server, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);
        });
      }
    };
    defineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = CreateIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_many.js
var require_delete_many = __commonJS({
  "node_modules/mongodb/lib/operations/delete_many.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteManyOperation = class extends OperationBase {
      constructor(collection, filter, options2) {
        super(options2);
        this.collection = collection;
        this.filter = filter;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const options2 = this.options;
        options2.single = false;
        removeDocuments(coll, filter, options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteManyOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_one.js
var require_delete_one = __commonJS({
  "node_modules/mongodb/lib/operations/delete_one.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteOneOperation = class extends OperationBase {
      constructor(collection, filter, options2) {
        super(options2);
        this.collection = collection;
        this.filter = filter;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const options2 = this.options;
        options2.single = true;
        removeDocuments(coll, filter, options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteOneOperation;
  }
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS({
  "node_modules/mongodb/lib/operations/distinct.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var DistinctOperation = class extends CommandOperationV2 {
      constructor(collection, key, query, options2) {
        super(collection, options2);
        this.collection = collection;
        this.key = key;
        this.query = query;
      }
      execute(server, callback) {
        const coll = this.collection;
        const key = this.key;
        const query = this.query;
        const options2 = this.options;
        const cmd = {
          distinct: coll.collectionName,
          key,
          query
        };
        if (typeof options2.maxTimeMS === "number") {
          cmd.maxTimeMS = options2.maxTimeMS;
        }
        decorateWithReadConcern(cmd, coll, options2);
        try {
          decorateWithCollation(cmd, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain && maxWireVersion(server) < 4) {
          callback(new MongoError(`server does not support explain on distinct`));
          return;
        }
        super.executeCommand(server, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.options.full || this.explain ? result : result.values);
        });
      }
    };
    defineAspects(DistinctOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = DistinctOperation;
  }
});

// node_modules/mongodb/lib/operations/command.js
var require_command2 = __commonJS({
  "node_modules/mongodb/lib/operations/command.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var debugOptions = require_utils4().debugOptions;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var extractCommand = require_command_utils().extractCommand;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    var CommandOperation = class extends OperationBase {
      constructor(db, options2, collection, command) {
        super(options2);
        if (!this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (collection != null) {
            this.options.readPreference = ReadPreference.resolve(collection, options2);
          } else {
            this.options.readPreference = ReadPreference.resolve(db, options2);
          }
        } else {
          if (collection != null) {
            applyWriteConcern(this.options, { db, coll: collection }, this.options);
          } else {
            applyWriteConcern(this.options, { db }, this.options);
          }
          this.options.readPreference = ReadPreference.primary;
        }
        this.db = db;
        if (command != null) {
          this.command = command;
        }
        if (collection != null) {
          this.collection = collection;
        }
      }
      _buildCommand() {
        if (this.command != null) {
          return this.command;
        }
      }
      execute(callback) {
        const db = this.db;
        const options2 = Object.assign({}, this.options);
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        let command;
        try {
          command = this._buildCommand();
        } catch (e) {
          return callback(e);
        }
        const dbName = options2.dbName || options2.authdb || db.databaseName;
        if (this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (options2.writeConcern && (!options2.session || !options2.session.inTransaction())) {
            command.writeConcern = options2.writeConcern;
          }
        }
        if (db.s.logger.isDebug()) {
          const extractedCommand = extractCommand(command);
          db.s.logger.debug(`executing command ${JSON.stringify(extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options2))}]`);
        }
        const namespace = this.namespace != null ? this.namespace : new MongoDBNamespace(dbName, "$cmd");
        db.s.topology.command(namespace, command, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (options2.full)
            return handleCallback(callback, null, result);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = CommandOperation;
  }
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS({
  "node_modules/mongodb/lib/operations/drop.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils4().handleCallback;
    var DropOperation = class extends CommandOperation {
      constructor(db, options2) {
        const finalOptions = Object.assign({}, options2, db.s.options);
        if (options2.session) {
          finalOptions.session = options2.session;
        }
        super(db, finalOptions);
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok)
            return handleCallback(callback, null, true);
          handleCallback(callback, null, false);
        });
      }
    };
    defineAspects(DropOperation, Aspect.WRITE_OPERATION);
    var DropCollectionOperation = class extends DropOperation {
      constructor(db, name, options2) {
        super(db, options2);
        this.name = name;
        this.namespace = `${db.namespace}.${name}`;
      }
      _buildCommand() {
        return { drop: this.name };
      }
    };
    var DropDatabaseOperation = class extends DropOperation {
      _buildCommand() {
        return { dropDatabase: 1 };
      }
    };
    module2.exports = {
      DropOperation,
      DropCollectionOperation,
      DropDatabaseOperation
    };
  }
});

// node_modules/mongodb/lib/operations/drop_index.js
var require_drop_index = __commonJS({
  "node_modules/mongodb/lib/operations/drop_index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var handleCallback = require_utils4().handleCallback;
    var DropIndexOperation = class extends CommandOperation {
      constructor(collection, indexName, options2) {
        super(collection.s.db, options2, collection);
        this.collection = collection;
        this.indexName = indexName;
      }
      _buildCommand() {
        const collection = this.collection;
        const indexName = this.indexName;
        const options2 = this.options;
        let cmd = { dropIndexes: collection.collectionName, index: indexName };
        cmd = applyWriteConcern(cmd, { db: collection.s.db, collection }, options2);
        return cmd;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (typeof callback !== "function")
            return;
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(DropIndexOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/drop_indexes.js
var require_drop_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/drop_indexes.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DropIndexOperation = require_drop_index();
    var handleCallback = require_utils4().handleCallback;
    var DropIndexesOperation = class extends DropIndexOperation {
      constructor(collection, options2) {
        super(collection, "*", options2);
      }
      execute(callback) {
        super.execute((err) => {
          if (err)
            return handleCallback(callback, err, false);
          handleCallback(callback, null, true);
        });
      }
    };
    defineAspects(DropIndexesOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS({
  "node_modules/mongodb/lib/operations/estimated_document_count.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var EstimatedDocumentCountOperation = class extends CommandOperationV2 {
      constructor(collection, query, options2) {
        if (typeof options2 === "undefined") {
          options2 = query;
          query = void 0;
        }
        super(collection, options2);
        this.collectionName = collection.s.namespace.collection;
        if (query) {
          this.query = query;
        }
      }
      execute(server, callback) {
        const options2 = this.options;
        const cmd = { count: this.collectionName };
        if (this.query) {
          cmd.query = this.query;
        }
        if (typeof options2.skip === "number") {
          cmd.skip = options2.skip;
        }
        if (typeof options2.limit === "number") {
          cmd.limit = options2.limit;
        }
        if (options2.hint) {
          cmd.hint = options2.hint;
        }
        super.executeCommand(server, cmd, (err, response) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, response.n);
        });
      }
    };
    defineAspects(EstimatedDocumentCountOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = EstimatedDocumentCountOperation;
  }
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS({
  "node_modules/mongodb/lib/operations/find.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error().MongoError;
    var FindOperation = class extends OperationBase {
      constructor(collection, ns, command, options2) {
        super(options2);
        this.ns = ns;
        this.cmd = command;
        this.readPreference = ReadPreference.resolve(collection, this.options);
      }
      execute(server, callback) {
        this.server = server;
        this.readPreference = ReadPreference.resolve(this, this.options);
        if (typeof this.cmd.allowDiskUse !== "undefined" && maxWireVersion(server) < 4) {
          callback(new MongoError("The `allowDiskUse` option is not supported on MongoDB < 3.2"));
          return;
        }
        if (this.explain) {
          this.options.explain = this.explain.verbosity;
        }
        const cursorState = this.cursorState || {};
        server.query(this.ns.toString(), this.cmd, cursorState, this.options, callback);
      }
    };
    defineAspects(FindOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = FindOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one.js
var require_find_one = __commonJS({
  "node_modules/mongodb/lib/operations/find_one.js"(exports2, module2) {
    init_shims();
    "use strict";
    var handleCallback = require_utils4().handleCallback;
    var OperationBase = require_operation().OperationBase;
    var toError = require_utils4().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var FindOneOperation = class extends OperationBase {
      constructor(collection, query, options2) {
        super(options2);
        this.collection = collection;
        this.query = query;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const options2 = this.options;
        try {
          const cursor = coll.find(query, options2).limit(-1).batchSize(1);
          cursor.next((err, item) => {
            if (err != null)
              return handleCallback(callback, toError(err), null);
            handleCallback(callback, null, item);
          });
        } catch (e) {
          callback(e);
        }
      }
    };
    defineAspects(FindOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindOneOperation;
  }
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS({
  "node_modules/mongodb/lib/operations/find_and_modify.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var FindAndModifyOperation = class extends OperationBase {
      constructor(collection, query, sort, doc, options2) {
        super(options2);
        this.collection = collection;
        this.query = query;
        this.sort = sort;
        this.doc = doc;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const sort = formattedOrderClause(this.sort);
        const doc = this.doc;
        let options2 = this.options;
        let queryObject = {
          findAndModify: coll.collectionName,
          query
        };
        if (sort) {
          queryObject.sort = sort;
        }
        queryObject.new = options2.new ? true : false;
        queryObject.remove = options2.remove ? true : false;
        queryObject.upsert = options2.upsert ? true : false;
        const projection = options2.projection || options2.fields;
        if (projection) {
          queryObject.fields = projection;
        }
        if (options2.arrayFilters) {
          queryObject.arrayFilters = options2.arrayFilters;
        }
        if (doc && !options2.remove) {
          queryObject.update = doc;
        }
        if (options2.maxTimeMS)
          queryObject.maxTimeMS = options2.maxTimeMS;
        options2.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
        options2.checkKeys = false;
        options2 = applyRetryableWrites(options2, coll.s.db);
        options2 = applyWriteConcern(options2, { db: coll.s.db, collection: coll }, options2);
        if (options2.writeConcern) {
          queryObject.writeConcern = options2.writeConcern;
        }
        if (options2.bypassDocumentValidation === true) {
          queryObject.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        options2.readPreference = ReadPreference.primary;
        try {
          decorateWithCollation(queryObject, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (options2.hint) {
          const unacknowledgedWrite = options2.writeConcern && options2.writeConcern.w === 0;
          if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {
            callback(new MongoError("The current topology does not support a hint on findAndModify commands"));
            return;
          }
          queryObject.hint = options2.hint;
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 4) {
            callback(new MongoError(`server does not support explain on findAndModify`));
            return;
          }
          queryObject = decorateWithExplain(queryObject, this.explain);
        }
        executeCommand(coll.s.db, queryObject, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          return handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(FindAndModifyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindAndModifyOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_delete.js
var require_find_one_and_delete = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_delete.js"(exports2, module2) {
    init_shims();
    "use strict";
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, options2) {
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.remove = true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        super(collection, filter, finalOptions.sort, null, finalOptions);
      }
    };
    module2.exports = FindOneAndDeleteOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_replace.js
var require_find_one_and_replace = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_replace.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, replacement, options2) {
        if ("returnDocument" in options2 && "returnOriginal" in options2) {
          throw new MongoError("findOneAndReplace option returnOriginal is deprecated in favor of returnDocument and cannot be combined");
        }
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.update = true;
        finalOptions.new = options2.returnDocument === "after" || options2.returnOriginal === false;
        finalOptions.upsert = options2.upsert === true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (replacement == null || typeof replacement !== "object") {
          throw new TypeError("Replacement parameter must be an object");
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        super(collection, filter, finalOptions.sort, replacement, finalOptions);
      }
    };
    module2.exports = FindOneAndReplaceOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_update.js
var require_find_one_and_update = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_update.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, update, options2) {
        if ("returnDocument" in options2 && "returnOriginal" in options2) {
          throw new MongoError("findOneAndUpdate option returnOriginal is deprecated in favor of returnDocument and cannot be combined");
        }
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.update = true;
        finalOptions.new = options2.returnDocument === "after" || options2.returnOriginal === false;
        finalOptions.upsert = options2.upsert === true;
        if (filter == null || typeof filter !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (update == null || typeof update !== "object") {
          throw new TypeError("Update parameter must be an object");
        }
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        super(collection, filter, finalOptions.sort, update, finalOptions);
      }
    };
    module2.exports = FindOneAndUpdateOperation;
  }
});

// node_modules/mongodb/lib/operations/geo_haystack_search.js
var require_geo_haystack_search = __commonJS({
  "node_modules/mongodb/lib/operations/geo_haystack_search.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var OperationBase = require_operation().OperationBase;
    var decorateCommand = require_utils4().decorateCommand;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var GeoHaystackSearchOperation = class extends OperationBase {
      constructor(collection, x, y, options2) {
        super(options2);
        this.collection = collection;
        this.x = x;
        this.y = y;
      }
      execute(callback) {
        const coll = this.collection;
        const x = this.x;
        const y = this.y;
        let options2 = this.options;
        let commandObject = {
          geoSearch: coll.collectionName,
          near: [x, y]
        };
        commandObject = decorateCommand(commandObject, options2, ["readPreference", "session"]);
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        decorateWithReadConcern(commandObject, coll, options2);
        executeCommand(coll.s.db, commandObject, options2, (err, res) => {
          if (err)
            return handleCallback(callback, err);
          if (res.err || res.errmsg)
            handleCallback(callback, toError(res));
          handleCallback(callback, null, res);
        });
      }
    };
    defineAspects(GeoHaystackSearchOperation, Aspect.READ_OPERATION);
    module2.exports = GeoHaystackSearchOperation;
  }
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/indexes.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexesOperation = class extends OperationBase {
      constructor(collection, options2) {
        super(options2);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        let options2 = this.options;
        options2 = Object.assign({}, { full: true }, options2);
        indexInformation(coll.s.db, coll.collectionName, options2, callback);
      }
    };
    module2.exports = IndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/index_exists.js
var require_index_exists = __commonJS({
  "node_modules/mongodb/lib/operations/index_exists.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var IndexExistsOperation = class extends OperationBase {
      constructor(collection, indexes, options2) {
        super(options2);
        this.collection = collection;
        this.indexes = indexes;
      }
      execute(callback) {
        const coll = this.collection;
        const indexes = this.indexes;
        const options2 = this.options;
        indexInformationDb(coll.s.db, coll.collectionName, options2, (err, indexInformation) => {
          if (err != null)
            return handleCallback(callback, err, null);
          if (!Array.isArray(indexes))
            return handleCallback(callback, null, indexInformation[indexes] != null);
          for (let i = 0; i < indexes.length; i++) {
            if (indexInformation[indexes[i]] == null) {
              return handleCallback(callback, null, false);
            }
          }
          return handleCallback(callback, null, true);
        });
      }
    };
    module2.exports = IndexExistsOperation;
  }
});

// node_modules/mongodb/lib/operations/index_information.js
var require_index_information = __commonJS({
  "node_modules/mongodb/lib/operations/index_information.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexInformationOperation = class extends OperationBase {
      constructor(db, name, options2) {
        super(options2);
        this.db = db;
        this.name = name;
      }
      execute(callback) {
        const db = this.db;
        const name = this.name;
        const options2 = this.options;
        indexInformation(db, name, options2, callback);
      }
    };
    module2.exports = IndexInformationOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_many.js
var require_insert_many = __commonJS({
  "node_modules/mongodb/lib/operations/insert_many.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = require_bulk_write();
    var MongoError = require_core().MongoError;
    var prepareDocs = require_common_functions().prepareDocs;
    var InsertManyOperation = class extends OperationBase {
      constructor(collection, docs, options2) {
        super(options2);
        this.collection = collection;
        this.docs = docs;
      }
      execute(callback) {
        const coll = this.collection;
        let docs = this.docs;
        const options2 = this.options;
        if (!Array.isArray(docs)) {
          return callback(MongoError.create({ message: "docs parameter must be an array of documents", driver: true }));
        }
        options2["serializeFunctions"] = options2["serializeFunctions"] || coll.s.serializeFunctions;
        docs = prepareDocs(coll, docs, options2);
        const operations = docs.map((document2) => ({ insertOne: { document: document2 } }));
        const bulkWriteOperation = new BulkWriteOperation(coll, operations, options2);
        bulkWriteOperation.execute((err, result) => {
          if (err)
            return callback(err, null);
          callback(null, mapInsertManyResults(docs, result));
        });
      }
    };
    function mapInsertManyResults(docs, r) {
      const finalResult = {
        result: { ok: 1, n: r.insertedCount },
        ops: docs,
        insertedCount: r.insertedCount,
        insertedIds: r.insertedIds
      };
      if (r.getLastOp()) {
        finalResult.result.opTime = r.getLastOp();
      }
      return finalResult;
    }
    module2.exports = InsertManyOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_one.js
var require_insert_one = __commonJS({
  "node_modules/mongodb/lib/operations/insert_one.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var insertDocuments = require_common_functions().insertDocuments;
    var InsertOneOperation = class extends OperationBase {
      constructor(collection, doc, options2) {
        super(options2);
        this.collection = collection;
        this.doc = doc;
      }
      execute(callback) {
        const coll = this.collection;
        const doc = this.doc;
        const options2 = this.options;
        if (Array.isArray(doc)) {
          return callback(MongoError.create({ message: "doc parameter must be an object", driver: true }));
        }
        insertDocuments(coll, [doc], options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          r.insertedCount = r.result.n;
          r.insertedId = doc._id;
          if (callback)
            callback(null, r);
        });
      }
    };
    module2.exports = InsertOneOperation;
  }
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS({
  "node_modules/mongodb/lib/operations/options_operation.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var OptionsOperation = class extends OperationBase {
      constructor(collection, options2) {
        super(options2);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        const opts = this.options;
        coll.s.db.listCollections({ name: coll.collectionName }, opts).toArray((err, collections) => {
          if (err)
            return handleCallback(callback, err);
          if (collections.length === 0) {
            return handleCallback(callback, MongoError.create({ message: `collection ${coll.namespace} not found`, driver: true }));
          }
          handleCallback(callback, err, collections[0].options || null);
        });
      }
    };
    module2.exports = OptionsOperation;
  }
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS({
  "node_modules/mongodb/lib/operations/is_capped.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OptionsOperation = require_options_operation();
    var handleCallback = require_utils4().handleCallback;
    var IsCappedOperation = class extends OptionsOperation {
      constructor(collection, options2) {
        super(collection, options2);
      }
      execute(callback) {
        super.execute((err, document2) => {
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, !!(document2 && document2.capped));
        });
      }
    };
    module2.exports = IsCappedOperation;
  }
});

// node_modules/mongodb/lib/operations/list_indexes.js
var require_list_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/list_indexes.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils2().maxWireVersion;
    var LIST_INDEXES_WIRE_VERSION = 3;
    var ListIndexesOperation = class extends CommandOperationV2 {
      constructor(collection, options2) {
        super(collection, options2, { fullResponse: true });
        this.collectionNamespace = collection.s.namespace;
      }
      execute(server, callback) {
        const serverWireVersion = maxWireVersion(server);
        if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {
          const systemIndexesNS = this.collectionNamespace.withCollection("system.indexes").toString();
          const collectionNS = this.collectionNamespace.toString();
          server.query(systemIndexesNS, { query: { ns: collectionNS } }, {}, this.options, callback);
          return;
        }
        const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
        super.executeCommand(server, { listIndexes: this.collectionNamespace.collection, cursor }, callback);
      }
    };
    defineAspects(ListIndexesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/add_user.js
var require_add_user = __commonJS({
  "node_modules/mongodb/lib/operations/add_user.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var crypto = require("crypto");
    var handleCallback = require_utils4().handleCallback;
    var toError = require_utils4().toError;
    var emitWarning = require_utils4().emitWarning;
    var AddUserOperation = class extends CommandOperation {
      constructor(db, username, password, options2) {
        super(db, options2);
        this.username = username;
        this.password = password;
      }
      _buildCommand() {
        const db = this.db;
        const username = this.username;
        const password = this.password;
        const options2 = this.options;
        let roles = [];
        if (Array.isArray(options2.roles))
          roles = options2.roles;
        if (typeof options2.roles === "string")
          roles = [options2.roles];
        if (roles.length === 0) {
          emitWarning("Creating a user without roles is deprecated in MongoDB >= 2.6");
        }
        if ((db.databaseName.toLowerCase() === "admin" || options2.dbName === "admin") && !Array.isArray(options2.roles)) {
          roles = ["root"];
        } else if (!Array.isArray(options2.roles)) {
          roles = ["dbOwner"];
        }
        const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;
        let userPassword = password;
        if (!digestPassword) {
          const md5 = crypto.createHash("md5");
          md5.update(username + ":mongo:" + password);
          userPassword = md5.digest("hex");
        }
        const command = {
          createUser: username,
          customData: options2.customData || {},
          roles,
          digestPassword
        };
        if (typeof password === "string") {
          command.pwd = userPassword;
        }
        return command;
      }
      execute(callback) {
        const options2 = this.options;
        if (options2.digestPassword != null) {
          return callback(toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."));
        }
        super.execute((err, r) => {
          if (!err) {
            return handleCallback(callback, err, r);
          }
          return handleCallback(callback, err, null);
        });
      }
    };
    defineAspects(AddUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = AddUserOperation;
  }
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS({
  "node_modules/mongodb/lib/operations/collections.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var collection;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    var CollectionsOperation = class extends OperationBase {
      constructor(db, options2) {
        super(options2);
        this.db = db;
      }
      execute(callback) {
        const db = this.db;
        let options2 = this.options;
        let Collection = loadCollection();
        options2 = Object.assign({}, options2, { nameOnly: true });
        db.listCollections({}, options2).toArray((err, documents) => {
          if (err != null)
            return handleCallback(callback, err, null);
          documents = documents.filter((doc) => {
            return doc.name.indexOf("$") === -1;
          });
          handleCallback(callback, null, documents.map((d2) => {
            return new Collection(db, db.s.topology, db.databaseName, d2.name, db.s.pkFactory, db.s.options);
          }));
        });
      }
    };
    module2.exports = CollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS({
  "node_modules/mongodb/lib/operations/run_command.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var defineAspects = require_operation().defineAspects;
    var Aspect = require_operation().Aspect;
    var RunCommandOperation = class extends CommandOperationV2 {
      constructor(parent, command, options2) {
        super(parent, options2);
        this.command = command;
      }
      execute(server, callback) {
        const command = this.command;
        this.executeCommand(server, command, callback);
      }
    };
    defineAspects(RunCommandOperation, [Aspect.EXECUTE_WITH_SELECTION, Aspect.NO_INHERIT_OPTIONS]);
    module2.exports = RunCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS({
  "node_modules/mongodb/lib/operations/create_collection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var ILLEGAL_COMMAND_FIELDS = new Set([
      "w",
      "wtimeout",
      "j",
      "fsync",
      "autoIndexId",
      "strict",
      "serializeFunctions",
      "pkFactory",
      "raw",
      "readPreference",
      "session",
      "readConcern",
      "writeConcern"
    ]);
    var CreateCollectionOperation = class extends CommandOperation {
      constructor(db, name, options2) {
        super(db, options2);
        this.name = name;
      }
      _buildCommand() {
        const name = this.name;
        const options2 = this.options;
        const cmd = { create: name };
        for (let n in options2) {
          if (options2[n] != null && typeof options2[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd[n] = options2[n];
          }
        }
        return cmd;
      }
      execute(callback) {
        const db = this.db;
        const name = this.name;
        const options2 = this.options;
        const Collection = loadCollection();
        let listCollectionOptions = Object.assign({ nameOnly: true, strict: false }, options2);
        listCollectionOptions = applyWriteConcern(listCollectionOptions, { db }, listCollectionOptions);
        function done(err) {
          if (err) {
            return callback(err);
          }
          try {
            callback(null, new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options2));
          } catch (err2) {
            callback(err2);
          }
        }
        const strictMode = listCollectionOptions.strict;
        if (strictMode) {
          db.listCollections({ name }, listCollectionOptions).setReadPreference(ReadPreference.PRIMARY).toArray((err, collections) => {
            if (err) {
              return callback(err);
            }
            if (collections.length > 0) {
              return callback(new MongoError(`Collection ${name} already exists. Currently in strict mode.`));
            }
            super.execute(done);
          });
          return;
        }
        super.execute(done);
      }
    };
    defineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);
    module2.exports = CreateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/execute_db_admin_command.js
var require_execute_db_admin_command = __commonJS({
  "node_modules/mongodb/lib/operations/execute_db_admin_command.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ExecuteDbAdminCommandOperation = class extends OperationBase {
      constructor(db, selector, options2) {
        super(options2);
        this.db = db;
        this.selector = selector;
      }
      execute(callback) {
        const db = this.db;
        const selector = this.selector;
        const options2 = this.options;
        const namespace = new MongoDBNamespace("admin", "$cmd");
        db.s.topology.command(namespace, selector, options2, (err, result) => {
          if (db.serverConfig && db.serverConfig.isDestroyed()) {
            return callback(new MongoError("topology was destroyed"));
          }
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = ExecuteDbAdminCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS({
  "node_modules/mongodb/lib/operations/list_collections.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils2().maxWireVersion;
    var CONSTANTS = require_constants2();
    var LIST_COLLECTIONS_WIRE_VERSION = 3;
    function listCollectionsTransforms(databaseName) {
      const matching = `${databaseName}.`;
      return {
        doc: (doc) => {
          const index2 = doc.name.indexOf(matching);
          if (doc.name && index2 === 0) {
            doc.name = doc.name.substr(index2 + matching.length);
          }
          return doc;
        }
      };
    }
    var ListCollectionsOperation = class extends CommandOperationV2 {
      constructor(db, filter, options2) {
        super(db, options2, { fullResponse: true });
        this.db = db;
        this.filter = filter;
        this.nameOnly = !!this.options.nameOnly;
        if (typeof this.options.batchSize === "number") {
          this.batchSize = this.options.batchSize;
        }
      }
      execute(server, callback) {
        if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {
          let filter = this.filter;
          const databaseName = this.db.s.namespace.db;
          if (typeof filter.name === "string" && !new RegExp("^" + databaseName + "\\.").test(filter.name)) {
            filter = Object.assign({}, filter);
            filter.name = this.db.s.namespace.withCollection(filter.name).toString();
          }
          if (filter == null) {
            filter.name = `/${databaseName}/`;
          }
          if (filter.name) {
            filter = { $and: [{ name: filter.name }, { name: /^((?!\$).)*$/ }] };
          } else {
            filter = { name: /^((?!\$).)*$/ };
          }
          const transforms = listCollectionsTransforms(databaseName);
          server.query(`${databaseName}.${CONSTANTS.SYSTEM_NAMESPACE_COLLECTION}`, { query: filter }, { batchSize: this.batchSize || 1e3 }, {}, (err, result) => {
            if (result && result.message && result.message.documents && Array.isArray(result.message.documents)) {
              result.message.documents = result.message.documents.map(transforms.doc);
            }
            callback(err, result);
          });
          return;
        }
        const command = {
          listCollections: 1,
          filter: this.filter,
          cursor: this.batchSize ? { batchSize: this.batchSize } : {},
          nameOnly: this.nameOnly
        };
        return super.executeCommand(server, command, callback);
      }
    };
    defineAspects(ListCollectionsOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListCollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/profiling_level.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperation = require_command2();
    var ProfilingLevelOperation = class extends CommandOperation {
      constructor(db, command, options2) {
        super(db, options2);
      }
      _buildCommand() {
        const command = { profile: -1 };
        return command;
      }
      execute(callback) {
        super.execute((err, doc) => {
          if (err == null && doc.ok === 1) {
            const was = doc.was;
            if (was === 0)
              return callback(null, "off");
            if (was === 1)
              return callback(null, "slow_only");
            if (was === 2)
              return callback(null, "all");
            return callback(new Error("Error: illegal profiling level value " + was), null);
          } else {
            err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
          }
        });
      }
    };
    module2.exports = ProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS({
  "node_modules/mongodb/lib/operations/remove_user.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils4().handleCallback;
    var WriteConcern = require_write_concern();
    var RemoveUserOperation = class extends CommandOperation {
      constructor(db, username, options2) {
        const commandOptions = {};
        const writeConcern = WriteConcern.fromOptions(options2);
        if (writeConcern != null) {
          commandOptions.writeConcern = writeConcern;
        }
        if (options2.dbName) {
          commandOptions.dbName = options2.dbName;
        }
        if (typeof options2.maxTimeMS === "number") {
          commandOptions.maxTimeMS = options2.maxTimeMS;
        }
        super(db, commandOptions);
        this.username = username;
      }
      _buildCommand() {
        const username = this.username;
        const command = { dropUser: username };
        return command;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, err, result.ok ? true : false);
        });
      }
    };
    defineAspects(RemoveUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = RemoveUserOperation;
  }
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS({
  "node_modules/mongodb/lib/operations/rename.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var checkCollectionName = require_utils4().checkCollectionName;
    var executeDbAdminCommand = require_db_ops().executeDbAdminCommand;
    var handleCallback = require_utils4().handleCallback;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var toError = require_utils4().toError;
    var RenameOperation = class extends OperationBase {
      constructor(collection, newName, options2) {
        super(options2);
        this.collection = collection;
        this.newName = newName;
      }
      execute(callback) {
        const coll = this.collection;
        const newName = this.newName;
        const options2 = this.options;
        let Collection = loadCollection();
        checkCollectionName(newName);
        const renameCollection = coll.namespace;
        const toCollection = coll.s.namespace.withCollection(newName).toString();
        const dropTarget = typeof options2.dropTarget === "boolean" ? options2.dropTarget : false;
        const cmd = { renameCollection, to: toCollection, dropTarget };
        applyWriteConcern(cmd, { db: coll.s.db, collection: coll }, options2);
        executeDbAdminCommand(coll.s.db.admin().s.db, cmd, options2, (err, doc) => {
          if (err)
            return handleCallback(callback, err, null);
          if (doc.errmsg)
            return handleCallback(callback, toError(doc), null);
          try {
            return handleCallback(callback, null, new Collection(coll.s.db, coll.s.topology, coll.s.namespace.db, newName, coll.s.pkFactory, coll.s.options));
          } catch (err2) {
            return handleCallback(callback, toError(err2), null);
          }
        });
      }
    };
    module2.exports = RenameOperation;
  }
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/set_profiling_level.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperation = require_command2();
    var levelValues = new Set(["off", "slow_only", "all"]);
    var SetProfilingLevelOperation = class extends CommandOperation {
      constructor(db, level, options2) {
        let profile = 0;
        if (level === "off") {
          profile = 0;
        } else if (level === "slow_only") {
          profile = 1;
        } else if (level === "all") {
          profile = 2;
        }
        super(db, options2);
        this.level = level;
        this.profile = profile;
      }
      _buildCommand() {
        const profile = this.profile;
        const command = { profile };
        return command;
      }
      execute(callback) {
        const level = this.level;
        if (!levelValues.has(level)) {
          return callback(new Error("Error: illegal profiling level value " + level));
        }
        super.execute((err, doc) => {
          if (err == null && doc.ok === 1)
            return callback(null, level);
          return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
        });
      }
    };
    module2.exports = SetProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS({
  "node_modules/mongodb/lib/operations/validate_collection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperation = require_command2();
    var ValidateCollectionOperation = class extends CommandOperation {
      constructor(admin, collectionName, options2) {
        let command = { validate: collectionName };
        const keys = Object.keys(options2);
        for (let i = 0; i < keys.length; i++) {
          if (Object.prototype.hasOwnProperty.call(options2, keys[i]) && keys[i] !== "session") {
            command[keys[i]] = options2[keys[i]];
          }
        }
        super(admin.s.db, options2, null, command);
        this.collectionName = collectionName;
      }
      execute(callback) {
        const collectionName = this.collectionName;
        super.execute((err, doc) => {
          if (err != null)
            return callback(err, null);
          if (doc.ok === 0)
            return callback(new Error("Error with validate command"), null);
          if (doc.result != null && doc.result.constructor !== String)
            return callback(new Error("Error with validation data"), null);
          if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          if (doc.valid != null && !doc.valid)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          return callback(null, doc);
        });
      }
    };
    module2.exports = ValidateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS({
  "node_modules/mongodb/lib/operations/list_databases.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ListDatabasesOperation = class extends CommandOperationV2 {
      constructor(db, options2) {
        super(db, options2);
        this.ns = new MongoDBNamespace("admin", "$cmd");
      }
      execute(server, callback) {
        const cmd = { listDatabases: 1 };
        if (this.options.nameOnly) {
          cmd.nameOnly = Number(cmd.nameOnly);
        }
        if (this.options.filter) {
          cmd.filter = this.options.filter;
        }
        if (typeof this.options.authorizedDatabases === "boolean") {
          cmd.authorizedDatabases = this.options.authorizedDatabases;
        }
        super.executeCommand(server, cmd, callback);
      }
    };
    defineAspects(ListDatabasesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListDatabasesOperation;
  }
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS({
  "node_modules/mongodb/lib/admin.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var AddUserOperation = require_add_user();
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var RemoveUserOperation = require_remove_user();
    var ValidateCollectionOperation = require_validate_collection();
    var ListDatabasesOperation = require_list_databases();
    var executeOperation = require_execute_operation();
    function Admin(db, topology, promiseLibrary) {
      if (!(this instanceof Admin))
        return new Admin(db, topology);
      this.s = {
        db,
        topology,
        promiseLibrary
      };
    }
    Admin.prototype.command = function(command, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      const commandOperation = new ExecuteDbAdminCommandOperation(this.s.db, command, options2);
      return executeOperation(this.s.db.s.topology, commandOperation, callback);
    };
    Admin.prototype.buildInfo = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd = { buildinfo: 1 };
      const buildInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options2);
      return executeOperation(this.s.db.s.topology, buildInfoOperation, callback);
    };
    Admin.prototype.serverInfo = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd = { buildinfo: 1 };
      const serverInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options2);
      return executeOperation(this.s.db.s.topology, serverInfoOperation, callback);
    };
    Admin.prototype.serverStatus = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const serverStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, { serverStatus: 1 }, options2);
      return executeOperation(this.s.db.s.topology, serverStatusOperation, callback);
    };
    Admin.prototype.ping = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd = { ping: 1 };
      const pingOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options2);
      return executeOperation(this.s.db.s.topology, pingOperation, callback);
    };
    Admin.prototype.addUser = function(username, password, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      if (typeof username === "string" && password != null && typeof password === "object") {
        options2 = password;
        password = null;
      }
      options2 = args.length ? args.shift() : {};
      options2 = Object.assign({}, options2);
      options2 = applyWriteConcern(options2, { db: this.s.db });
      options2.dbName = "admin";
      const addUserOperation = new AddUserOperation(this.s.db, username, password, options2);
      return executeOperation(this.s.db.s.topology, addUserOperation, callback);
    };
    Admin.prototype.removeUser = function(username, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      options2 = Object.assign({}, options2);
      options2 = applyWriteConcern(options2, { db: this.s.db });
      options2.dbName = "admin";
      const removeUserOperation = new RemoveUserOperation(this.s.db, username, options2);
      return executeOperation(this.s.db.s.topology, removeUserOperation, callback);
    };
    Admin.prototype.validateCollection = function(collectionName, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const validateCollectionOperation = new ValidateCollectionOperation(this, collectionName, options2);
      return executeOperation(this.s.db.s.topology, validateCollectionOperation, callback);
    };
    Admin.prototype.listDatabases = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeOperation(this.s.db.s.topology, new ListDatabasesOperation(this.s.db, options2), callback);
    };
    Admin.prototype.replSetGetStatus = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const replSetGetStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, { replSetGetStatus: 1 }, options2);
      return executeOperation(this.s.db.s.topology, replSetGetStatusOperation, callback);
    };
    module2.exports = Admin;
  }
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS({
  "node_modules/mongodb/lib/db.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var inherits2 = require("util").inherits;
    var getSingleProperty = require_utils4().getSingleProperty;
    var CommandCursor = require_command_cursor();
    var handleCallback = require_utils4().handleCallback;
    var filterOptions = require_utils4().filterOptions;
    var toError = require_utils4().toError;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().ObjectID;
    var Logger = require_core().Logger;
    var Collection = require_collection();
    var conditionallyMergeWriteConcern = require_utils4().conditionallyMergeWriteConcern;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var ChangeStream = require_change_stream();
    var deprecate = require("util").deprecate;
    var deprecateOptions = require_utils4().deprecateOptions;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var CONSTANTS = require_constants2();
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var AggregationCursor = require_aggregation_cursor();
    var createListener = require_db_ops().createListener;
    var ensureIndex = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var profilingInfo = require_db_ops().profilingInfo;
    var validateDatabaseName = require_db_ops().validateDatabaseName;
    var AggregateOperation = require_aggregate();
    var AddUserOperation = require_add_user();
    var CollectionsOperation = require_collections();
    var CommandOperation = require_command2();
    var RunCommandOperation = require_run_command();
    var CreateCollectionOperation = require_create_collection();
    var CreateIndexesOperation = require_create_indexes();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropDatabaseOperation = require_drop().DropDatabaseOperation;
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var IndexInformationOperation = require_index_information();
    var ListCollectionsOperation = require_list_collections();
    var ProfilingLevelOperation = require_profiling_level();
    var RemoveUserOperation = require_remove_user();
    var RenameOperation = require_rename();
    var SetProfilingLevelOperation = require_set_profiling_level();
    var executeOperation = require_execute_operation();
    var legalOptionNames = [
      "w",
      "wtimeout",
      "fsync",
      "j",
      "writeConcern",
      "readPreference",
      "readPreferenceTags",
      "native_parser",
      "forceServerObjectId",
      "pkFactory",
      "serializeFunctions",
      "raw",
      "bufferMaxEntries",
      "authSource",
      "ignoreUndefined",
      "promiseLibrary",
      "readConcern",
      "retryMiliSeconds",
      "numberOfRetries",
      "parentDb",
      "noListener",
      "loggerLevel",
      "logger",
      "promoteBuffers",
      "promoteLongs",
      "promoteValues",
      "bsonRegExp",
      "compression",
      "retryWrites"
    ];
    function Db(databaseName, topology, options2) {
      options2 = options2 || {};
      if (!(this instanceof Db))
        return new Db(databaseName, topology, options2);
      EventEmitter.call(this);
      const promiseLibrary = options2.promiseLibrary || Promise;
      options2 = filterOptions(options2, legalOptionNames);
      options2.promiseLibrary = promiseLibrary;
      this.s = {
        dbCache: {},
        children: [],
        topology,
        options: options2,
        logger: Logger("Db", options2),
        bson: topology ? topology.bson : null,
        readPreference: ReadPreference.fromOptions(options2),
        bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : -1,
        parentDb: options2.parentDb || null,
        pkFactory: options2.pkFactory || ObjectID2,
        nativeParser: options2.nativeParser || options2.native_parser,
        promiseLibrary,
        noListener: typeof options2.noListener === "boolean" ? options2.noListener : false,
        readConcern: ReadConcern.fromOptions(options2),
        writeConcern: WriteConcern.fromOptions(options2),
        namespace: new MongoDBNamespace(databaseName)
      };
      validateDatabaseName(databaseName);
      getSingleProperty(this, "serverConfig", this.s.topology);
      getSingleProperty(this, "bufferMaxEntries", this.s.bufferMaxEntries);
      getSingleProperty(this, "databaseName", this.s.namespace.db);
      if (options2.parentDb)
        return;
      if (this.s.noListener)
        return;
      topology.on("error", createListener(this, "error", this));
      topology.on("timeout", createListener(this, "timeout", this));
      topology.on("close", createListener(this, "close", this));
      topology.on("parseError", createListener(this, "parseError", this));
      topology.once("open", createListener(this, "open", this));
      topology.once("fullsetup", createListener(this, "fullsetup", this));
      topology.once("all", createListener(this, "all", this));
      topology.on("reconnect", createListener(this, "reconnect", this));
    }
    inherits2(Db, EventEmitter);
    Db.prototype.on = deprecate(function() {
      return Db.super_.prototype.on.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Db.prototype.once = deprecate(function() {
      return Db.super_.prototype.once.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Object.defineProperty(Db.prototype, "topology", {
      enumerable: true,
      get: function() {
        return this.s.topology;
      }
    });
    Object.defineProperty(Db.prototype, "options", {
      enumerable: true,
      get: function() {
        return this.s.options;
      }
    });
    Object.defineProperty(Db.prototype, "slaveOk", {
      enumerable: true,
      get: function() {
        if (this.s.options.readPreference != null && (this.s.options.readPreference !== "primary" || this.s.options.readPreference.mode !== "primary")) {
          return true;
        }
        return false;
      }
    });
    Object.defineProperty(Db.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Db.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return ReadPreference.primary;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Db.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Db.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Db.prototype.command = function(command, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      const commandOperation = new RunCommandOperation(this, command, options2);
      return executeOperation(this.s.topology, commandOperation, callback);
    };
    Db.prototype.aggregate = function(pipeline2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      if (options2 == null && callback == null) {
        options2 = {};
      }
      const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline2, options2), options2);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Db.prototype.admin = function() {
      const Admin = require_admin();
      return new Admin(this, this.s.topology, this.s.promiseLibrary);
    };
    var COLLECTION_OPTION_KEYS = [
      "pkFactory",
      "readPreference",
      "serializeFunctions",
      "strict",
      "readConcern",
      "ignoreUndefined",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs",
      "bsonRegExp"
    ];
    Db.prototype.collection = deprecateOptions({
      name: "Db.collection",
      deprecatedOptions: ["strict"],
      optionsIndex: 1
    }, function(name, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2 = Object.assign({}, options2);
      options2.promiseLibrary = this.s.promiseLibrary;
      options2.readConcern = options2.readConcern ? new ReadConcern(options2.readConcern.level) : this.readConcern;
      if (this.s.options.ignoreUndefined) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      for (const collectionOptionKey of COLLECTION_OPTION_KEYS) {
        if (!(collectionOptionKey in options2) && this.s.options[collectionOptionKey] !== void 0) {
          options2[collectionOptionKey] = this.s.options[collectionOptionKey];
        }
      }
      options2 = conditionallyMergeWriteConcern(options2, this.s.options);
      if (options2 == null || !options2.strict) {
        try {
          const collection = new Collection(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options2);
          if (callback)
            callback(null, collection);
          return collection;
        } catch (err) {
          if (err instanceof MongoError && callback)
            return callback(err);
          throw err;
        }
      }
      if (typeof callback !== "function") {
        throw toError(`A callback is required in strict mode. While getting collection ${name}`);
      }
      if (this.serverConfig && this.serverConfig.isDestroyed()) {
        return callback(new MongoError("topology was destroyed"));
      }
      const listCollectionOptions = Object.assign({}, options2, { nameOnly: true });
      this.listCollections({ name }, listCollectionOptions).toArray((err, collections) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (collections.length === 0)
          return handleCallback(callback, toError(`Collection ${name} does not exist. Currently in strict mode.`), null);
        try {
          return handleCallback(callback, null, new Collection(this, this.s.topology, this.databaseName, name, this.s.pkFactory, options2));
        } catch (err2) {
          return handleCallback(callback, err2, null);
        }
      });
    });
    Db.prototype.createCollection = deprecateOptions({
      name: "Db.createCollection",
      deprecatedOptions: ["autoIndexId", "strict", "w", "wtimeout", "j"],
      optionsIndex: 1
    }, function(name, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2.promiseLibrary = options2.promiseLibrary || this.s.promiseLibrary;
      options2.readConcern = options2.readConcern ? new ReadConcern(options2.readConcern.level) : this.readConcern;
      const createCollectionOperation = new CreateCollectionOperation(this, name, options2);
      return executeOperation(this.s.topology, createCollectionOperation, callback);
    });
    Db.prototype.stats = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const commandObject = { dbStats: true };
      if (options2["scale"] != null)
        commandObject["scale"] = options2["scale"];
      if (options2.readPreference == null && this.s.readPreference) {
        options2.readPreference = this.s.readPreference;
      }
      const statsOperation = new CommandOperation(this, options2, null, commandObject);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Db.prototype.listCollections = function(filter, options2) {
      filter = filter || {};
      options2 = options2 || {};
      return new CommandCursor(this.s.topology, new ListCollectionsOperation(this, filter, options2), options2);
    };
    Db.prototype.eval = deprecate(function(code, parameters, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      parameters = args.length ? args.shift() : parameters;
      options2 = args.length ? args.shift() || {} : {};
      return executeLegacyOperation(this.s.topology, evaluate, [
        this,
        code,
        parameters,
        options2,
        callback
      ]);
    }, "Db.eval is deprecated as of MongoDB version 3.2");
    Db.prototype.renameCollection = function(fromCollection, toCollection, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2, { readPreference: ReadPreference.PRIMARY });
      options2.new_collection = true;
      const renameOperation = new RenameOperation(this.collection(fromCollection), toCollection, options2);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Db.prototype.dropCollection = function(name, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropCollectionOperation = new DropCollectionOperation(this, name, options2);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Db.prototype.dropDatabase = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropDatabaseOperation = new DropDatabaseOperation(this, options2);
      return executeOperation(this.s.topology, dropDatabaseOperation, callback);
    };
    Db.prototype.collections = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const collectionsOperation = new CollectionsOperation(this, options2);
      return executeOperation(this.s.topology, collectionsOperation, callback);
    };
    Db.prototype.executeDbAdminCommand = function(selector, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2.readPreference = ReadPreference.resolve(this, options2);
      const executeDbAdminCommandOperation = new ExecuteDbAdminCommandOperation(this, selector, options2);
      return executeOperation(this.s.topology, executeDbAdminCommandOperation, callback);
    };
    Db.prototype.createIndex = function(name, fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      const createIndexesOperation = new CreateIndexesOperation(this, name, fieldOrSpec, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Db.prototype.ensureIndex = deprecate(function(name, fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        name,
        fieldOrSpec,
        options2,
        callback
      ]);
    }, "Db.ensureIndex is deprecated as of MongoDB version 3.0 / driver version 2.0");
    Db.prototype.addChild = function(db) {
      if (this.s.parentDb)
        return this.s.parentDb.addChild(db);
      this.s.children.push(db);
    };
    Db.prototype.addUser = function(username, password, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (typeof username === "string" && password != null && typeof password === "object") {
        options2 = password;
        password = null;
      }
      const addUserOperation = new AddUserOperation(this, username, password, options2);
      return executeOperation(this.s.topology, addUserOperation, callback);
    };
    Db.prototype.removeUser = function(username, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const removeUserOperation = new RemoveUserOperation(this, username, options2);
      return executeOperation(this.s.topology, removeUserOperation, callback);
    };
    Db.prototype.setProfilingLevel = function(level, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const setProfilingLevelOperation = new SetProfilingLevelOperation(this, level, options2);
      return executeOperation(this.s.topology, setProfilingLevelOperation, callback);
    };
    Db.prototype.profilingInfo = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, profilingInfo, [this, options2, callback]);
    }, "Db.profilingInfo is deprecated. Query the system.profile collection directly.");
    Db.prototype.profilingLevel = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const profilingLevelOperation = new ProfilingLevelOperation(this, options2);
      return executeOperation(this.s.topology, profilingLevelOperation, callback);
    };
    Db.prototype.indexInformation = function(name, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexInformationOperation = new IndexInformationOperation(this, name, options2);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Db.prototype.unref = function() {
      this.s.topology.unref();
    };
    Db.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    Db.prototype.getLogger = function() {
      return this.s.logger;
    };
    Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
    Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
    Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
    Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
    Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
    Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
    module2.exports = Db;
  }
});

// node_modules/mongodb/lib/dynamic_loaders.js
var require_dynamic_loaders = __commonJS({
  "node_modules/mongodb/lib/dynamic_loaders.js"(exports2, module2) {
    init_shims();
    "use strict";
    var collection;
    var cursor;
    var db;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    function loadCursor() {
      if (!cursor) {
        cursor = require_cursor2();
      }
      return cursor;
    }
    function loadDb() {
      if (!db) {
        db = require_db();
      }
      return db;
    }
    module2.exports = {
      loadCollection,
      loadCursor,
      loadDb
    };
  }
});

// node_modules/mongodb/lib/operations/map_reduce.js
var require_map_reduce = __commonJS({
  "node_modules/mongodb/lib/operations/map_reduce.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var isObject2 = require_utils4().isObject;
    var loadDb = require_dynamic_loaders().loadDb;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var exclusionList = [
      "explain",
      "readPreference",
      "session",
      "bypassDocumentValidation",
      "w",
      "wtimeout",
      "j",
      "writeConcern"
    ];
    var MapReduceOperation = class extends OperationBase {
      constructor(collection, map, reduce, options2) {
        super(options2);
        this.collection = collection;
        this.map = map;
        this.reduce = reduce;
      }
      execute(callback) {
        const coll = this.collection;
        const map = this.map;
        const reduce = this.reduce;
        let options2 = this.options;
        let mapCommandHash = {
          mapReduce: coll.collectionName,
          map,
          reduce
        };
        for (let n in options2) {
          if (n === "scope") {
            mapCommandHash[n] = processScope(options2[n]);
          } else {
            if (exclusionList.indexOf(n) === -1) {
              mapCommandHash[n] = options2[n];
            }
          }
        }
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        if (options2.readPreference !== false && options2.readPreference !== "primary" && options2["out"] && options2["out"].inline !== 1 && options2["out"] !== "inline") {
          options2.readPreference = "primary";
          applyWriteConcern(mapCommandHash, { db: coll.s.db, collection: coll }, options2);
        } else {
          decorateWithReadConcern(mapCommandHash, coll, options2);
        }
        if (options2.bypassDocumentValidation === true) {
          mapCommandHash.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        try {
          decorateWithCollation(mapCommandHash, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 9) {
            callback(new MongoError(`server does not support explain on mapReduce`));
            return;
          }
          mapCommandHash = decorateWithExplain(mapCommandHash, this.explain);
        }
        executeCommand(coll.s.db, mapCommandHash, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok !== 1 || result.err || result.errmsg) {
            return handleCallback(callback, toError(result));
          }
          if (this.explain)
            return callback(void 0, result);
          const stats = {};
          if (result.timeMillis)
            stats["processtime"] = result.timeMillis;
          if (result.counts)
            stats["counts"] = result.counts;
          if (result.timing)
            stats["timing"] = result.timing;
          if (result.results) {
            if (options2["verbose"] == null || !options2["verbose"]) {
              return handleCallback(callback, null, result.results);
            }
            return handleCallback(callback, null, { results: result.results, stats });
          }
          let collection = null;
          if (result.result != null && typeof result.result === "object") {
            const doc = result.result;
            let Db = loadDb();
            collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(doc.collection);
          } else {
            collection = coll.s.db.collection(result.result);
          }
          if (options2["verbose"] == null || !options2["verbose"]) {
            return handleCallback(callback, err, collection);
          }
          handleCallback(callback, err, { collection, stats });
        });
      }
    };
    function processScope(scope) {
      if (!isObject2(scope) || scope._bsontype === "ObjectID") {
        return scope;
      }
      const keys = Object.keys(scope);
      let key;
      const new_scope = {};
      for (let i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        if (typeof scope[key] === "function") {
          new_scope[key] = new Code2(String(scope[key]));
        } else {
          new_scope[key] = processScope(scope[key]);
        }
      }
      return new_scope;
    }
    defineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);
    module2.exports = MapReduceOperation;
  }
});

// node_modules/mongodb/lib/operations/re_index.js
var require_re_index = __commonJS({
  "node_modules/mongodb/lib/operations/re_index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var serverType = require_common().serverType;
    var ServerType = require_common().ServerType;
    var MongoError = require_core().MongoError;
    var ReIndexOperation = class extends CommandOperationV2 {
      constructor(collection, options2) {
        super(collection, options2);
        this.collectionName = collection.collectionName;
      }
      execute(server, callback) {
        if (serverType(server) !== ServerType.Standalone) {
          callback(new MongoError(`reIndex can only be executed on standalone servers.`));
          return;
        }
        super.executeCommand(server, { reIndex: this.collectionName }, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, !!result.ok);
        });
      }
    };
    defineAspects(ReIndexOperation, [Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = ReIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/replace_one.js
var require_replace_one = __commonJS({
  "node_modules/mongodb/lib/operations/replace_one.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var ReplaceOneOperation = class extends OperationBase {
      constructor(collection, filter, replacement, options2) {
        super(options2);
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.replacement = replacement;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const replacement = this.replacement;
        const options2 = this.options;
        options2.multi = false;
        updateDocuments(coll, filter, replacement, options2, (err, r) => replaceCallback(err, r, replacement, callback));
      }
    };
    function replaceCallback(err, r, doc, callback) {
      if (callback == null)
        return;
      if (err && callback)
        return callback(err);
      if (r == null)
        return callback(null, { result: { ok: 1 } });
      r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
      r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
      r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
      r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
      r.ops = [doc];
      if (callback)
        callback(null, r);
    }
    module2.exports = ReplaceOneOperation;
  }
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS({
  "node_modules/mongodb/lib/operations/stats.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var StatsOperation = class extends CommandOperation {
      constructor(collection, options2) {
        super(collection.s.db, options2, collection);
      }
      _buildCommand() {
        const collection = this.collection;
        const options2 = this.options;
        const command = {
          collStats: collection.collectionName
        };
        if (options2["scale"] != null) {
          command["scale"] = options2["scale"];
        }
        return command;
      }
    };
    defineAspects(StatsOperation, Aspect.READ_OPERATION);
    module2.exports = StatsOperation;
  }
});

// node_modules/mongodb/lib/operations/update_many.js
var require_update_many = __commonJS({
  "node_modules/mongodb/lib/operations/update_many.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateManyOperation = class extends OperationBase {
      constructor(collection, filter, update, options2) {
        super(options2);
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.update = update;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const update = this.update;
        const options2 = this.options;
        options2.multi = true;
        updateDocuments(coll, filter, update, options2, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateManyOperation;
  }
});

// node_modules/mongodb/lib/operations/update_one.js
var require_update_one = __commonJS({
  "node_modules/mongodb/lib/operations/update_one.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateOneOperation = class extends OperationBase {
      constructor(collection, filter, update, options2) {
        super(options2);
        if (!hasAtomicOperators(update)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter;
        this.update = update;
      }
      execute(callback) {
        const coll = this.collection;
        const filter = this.filter;
        const update = this.update;
        const options2 = this.options;
        options2.multi = false;
        updateDocuments(coll, filter, update, options2, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateOneOperation;
  }
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS({
  "node_modules/mongodb/lib/collection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var deprecate = require("util").deprecate;
    var deprecateOptions = require_utils4().deprecateOptions;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var checkCollectionName = require_utils4().checkCollectionName;
    var ObjectID2 = require_core().BSON.ObjectID;
    var MongoError = require_core().MongoError;
    var normalizeHintField = require_utils4().normalizeHintField;
    var decorateCommand = require_utils4().decorateCommand;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var ReadPreference = require_core().ReadPreference;
    var unordered = require_unordered();
    var ordered = require_ordered();
    var ChangeStream = require_change_stream();
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var AggregationCursor = require_aggregation_cursor();
    var CommandCursor = require_command_cursor();
    var ensureIndex = require_collection_ops().ensureIndex;
    var group = require_collection_ops().group;
    var parallelCollectionScan = require_collection_ops().parallelCollectionScan;
    var removeDocuments = require_common_functions().removeDocuments;
    var save = require_collection_ops().save;
    var updateDocuments = require_common_functions().updateDocuments;
    var AggregateOperation = require_aggregate();
    var BulkWriteOperation = require_bulk_write();
    var CountDocumentsOperation = require_count_documents();
    var CreateIndexesOperation = require_create_indexes();
    var DeleteManyOperation = require_delete_many();
    var DeleteOneOperation = require_delete_one();
    var DistinctOperation = require_distinct();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropIndexOperation = require_drop_index();
    var DropIndexesOperation = require_drop_indexes();
    var EstimatedDocumentCountOperation = require_estimated_document_count();
    var FindOperation = require_find();
    var FindOneOperation = require_find_one();
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = require_find_one_and_delete();
    var FindOneAndReplaceOperation = require_find_one_and_replace();
    var FindOneAndUpdateOperation = require_find_one_and_update();
    var GeoHaystackSearchOperation = require_geo_haystack_search();
    var IndexesOperation = require_indexes();
    var IndexExistsOperation = require_index_exists();
    var IndexInformationOperation = require_index_information();
    var InsertManyOperation = require_insert_many();
    var InsertOneOperation = require_insert_one();
    var IsCappedOperation = require_is_capped();
    var ListIndexesOperation = require_list_indexes();
    var MapReduceOperation = require_map_reduce();
    var OptionsOperation = require_options_operation();
    var RenameOperation = require_rename();
    var ReIndexOperation = require_re_index();
    var ReplaceOneOperation = require_replace_one();
    var StatsOperation = require_stats();
    var UpdateManyOperation = require_update_many();
    var UpdateOneOperation = require_update_one();
    var executeOperation = require_execute_operation();
    var mergeKeys = ["ignoreUndefined"];
    function Collection(db, topology, dbName, name, pkFactory, options2) {
      checkCollectionName(name);
      const internalHint = null;
      const slaveOk = options2 == null || options2.slaveOk == null ? db.slaveOk : options2.slaveOk;
      const serializeFunctions = options2 == null || options2.serializeFunctions == null ? db.s.options.serializeFunctions : options2.serializeFunctions;
      const raw = options2 == null || options2.raw == null ? db.s.options.raw : options2.raw;
      const promoteLongs = options2 == null || options2.promoteLongs == null ? db.s.options.promoteLongs : options2.promoteLongs;
      const promoteValues = options2 == null || options2.promoteValues == null ? db.s.options.promoteValues : options2.promoteValues;
      const promoteBuffers = options2 == null || options2.promoteBuffers == null ? db.s.options.promoteBuffers : options2.promoteBuffers;
      const bsonRegExp = options2 == null || options2.bsonRegExp == null ? db.s.options.bsonRegExp : options2.bsonRegExp;
      const collectionHint = null;
      const namespace = new MongoDBNamespace(dbName, name);
      const promiseLibrary = options2.promiseLibrary || Promise;
      pkFactory = pkFactory == null ? ObjectID2 : pkFactory;
      this.s = {
        pkFactory,
        db,
        topology,
        options: options2,
        namespace,
        readPreference: ReadPreference.fromOptions(options2),
        slaveOk,
        serializeFunctions,
        raw,
        promoteLongs,
        promoteValues,
        promoteBuffers,
        bsonRegExp,
        internalHint,
        collectionHint,
        promiseLibrary,
        readConcern: ReadConcern.fromOptions(options2),
        writeConcern: WriteConcern.fromOptions(options2)
      };
    }
    Object.defineProperty(Collection.prototype, "dbName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.db;
      }
    });
    Object.defineProperty(Collection.prototype, "collectionName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.collection;
      }
    });
    Object.defineProperty(Collection.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Object.defineProperty(Collection.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        if (this.s.readConcern == null) {
          return this.s.db.readConcern;
        }
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return this.s.db.readPreference;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Collection.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        if (this.s.writeConcern == null) {
          return this.s.db.writeConcern;
        }
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "hint", {
      enumerable: true,
      get: function() {
        return this.s.collectionHint;
      },
      set: function(v) {
        this.s.collectionHint = normalizeHintField(v);
      }
    });
    var DEPRECATED_FIND_OPTIONS = ["maxScan", "fields", "snapshot", "oplogReplay"];
    Collection.prototype.find = deprecateOptions({
      name: "collection.find",
      deprecatedOptions: DEPRECATED_FIND_OPTIONS,
      optionsIndex: 1
    }, function(query, options2, callback) {
      if (typeof callback === "object") {
        emitWarningOnce("Third parameter to `find()` must be a callback or undefined");
      }
      let selector = query;
      if (typeof callback !== "function") {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = void 0;
        } else if (options2 == null) {
          callback = typeof selector === "function" ? selector : void 0;
          selector = typeof selector === "object" ? selector : void 0;
        }
      }
      selector = selector == null ? {} : selector;
      const object = selector;
      if (Buffer.isBuffer(object)) {
        const object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
        if (object_size !== object.length) {
          const error2 = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
          error2.name = "MongoError";
          throw error2;
        }
      }
      if (selector != null && selector._bsontype === "ObjectID") {
        selector = { _id: selector };
      }
      if (!options2)
        options2 = {};
      let projection = options2.projection || options2.fields;
      if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
        projection = projection.length ? projection.reduce((result, field) => {
          result[field] = 1;
          return result;
        }, {}) : { _id: 1 };
      }
      let newOptions = Object.assign({}, options2);
      for (let key in this.s.options) {
        if (mergeKeys.indexOf(key) !== -1) {
          newOptions[key] = this.s.options[key];
        }
      }
      newOptions.skip = options2.skip ? options2.skip : 0;
      newOptions.limit = options2.limit ? options2.limit : 0;
      newOptions.raw = typeof options2.raw === "boolean" ? options2.raw : this.s.raw;
      newOptions.hint = options2.hint != null ? normalizeHintField(options2.hint) : this.s.collectionHint;
      newOptions.timeout = typeof options2.timeout === "undefined" ? void 0 : options2.timeout;
      newOptions.slaveOk = options2.slaveOk != null ? options2.slaveOk : this.s.db.slaveOk;
      newOptions.readPreference = ReadPreference.resolve(this, newOptions);
      if (newOptions.readPreference != null && (newOptions.readPreference !== "primary" || newOptions.readPreference.mode !== "primary")) {
        newOptions.slaveOk = true;
      }
      if (selector != null && typeof selector !== "object") {
        throw MongoError.create({ message: "query selector must be an object", driver: true });
      }
      const findCommand = {
        find: this.s.namespace.toString(),
        limit: newOptions.limit,
        skip: newOptions.skip,
        query: selector
      };
      if (typeof options2.allowDiskUse === "boolean") {
        findCommand.allowDiskUse = options2.allowDiskUse;
      }
      if (typeof newOptions.awaitdata === "boolean") {
        newOptions.awaitData = newOptions.awaitdata;
      }
      if (typeof newOptions.timeout === "boolean")
        newOptions.noCursorTimeout = !newOptions.timeout;
      decorateCommand(findCommand, newOptions, ["session", "collation"]);
      if (projection)
        findCommand.fields = projection;
      newOptions.db = this.s.db;
      newOptions.promiseLibrary = this.s.promiseLibrary;
      if (newOptions.raw == null && typeof this.s.raw === "boolean")
        newOptions.raw = this.s.raw;
      if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === "boolean")
        newOptions.promoteLongs = this.s.promoteLongs;
      if (newOptions.promoteValues == null && typeof this.s.promoteValues === "boolean")
        newOptions.promoteValues = this.s.promoteValues;
      if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === "boolean")
        newOptions.promoteBuffers = this.s.promoteBuffers;
      if (newOptions.bsonRegExp == null && typeof this.s.bsonRegExp === "boolean")
        newOptions.bsonRegExp = this.s.bsonRegExp;
      if (findCommand.sort) {
        findCommand.sort = formattedOrderClause(findCommand.sort);
      }
      decorateWithReadConcern(findCommand, this, options2);
      try {
        decorateWithCollation(findCommand, this, options2);
      } catch (err) {
        if (typeof callback === "function")
          return callback(err, null);
        throw err;
      }
      const cursor = this.s.topology.cursor(new FindOperation(this, this.s.namespace, findCommand, newOptions), newOptions);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    });
    Collection.prototype.insertOne = function(doc, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const insertOneOperation = new InsertOneOperation(this, doc, options2);
      return executeOperation(this.s.topology, insertOneOperation, callback);
    };
    Collection.prototype.insertMany = function(docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : { ordered: true };
      const insertManyOperation = new InsertManyOperation(this, docs, options2);
      return executeOperation(this.s.topology, insertManyOperation, callback);
    };
    Collection.prototype.bulkWrite = function(operations, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || { ordered: true };
      if (!Array.isArray(operations)) {
        throw MongoError.create({ message: "operations must be an array of documents", driver: true });
      }
      const bulkWriteOperation = new BulkWriteOperation(this, operations, options2);
      return executeOperation(this.s.topology, bulkWriteOperation, callback);
    };
    Collection.prototype.insert = deprecate(function(docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || { ordered: false };
      docs = !Array.isArray(docs) ? [docs] : docs;
      if (options2.keepGoing === true) {
        options2.ordered = false;
      }
      return this.insertMany(docs, options2, callback);
    }, "collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.");
    Collection.prototype.updateOne = function(filter, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new UpdateOneOperation(this, filter, update, options2), callback);
    };
    Collection.prototype.replaceOne = function(filter, doc, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new ReplaceOneOperation(this, filter, doc, options2), callback);
    };
    Collection.prototype.updateMany = function(filter, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new UpdateManyOperation(this, filter, update, options2), callback);
    };
    Collection.prototype.update = deprecate(function(selector, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, updateDocuments, [
        this,
        selector,
        update,
        options2,
        callback
      ]);
    }, "collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.");
    Collection.prototype.deleteOne = function(filter, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteOneOperation = new DeleteOneOperation(this, filter, options2);
      return executeOperation(this.s.topology, deleteOneOperation, callback);
    };
    Collection.prototype.removeOne = Collection.prototype.deleteOne;
    Collection.prototype.deleteMany = function(filter, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteManyOperation = new DeleteManyOperation(this, filter, options2);
      return executeOperation(this.s.topology, deleteManyOperation, callback);
    };
    Collection.prototype.removeMany = Collection.prototype.deleteMany;
    Collection.prototype.remove = deprecate(function(selector, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, removeDocuments, [
        this,
        selector,
        options2,
        callback
      ]);
    }, "collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.");
    Collection.prototype.save = deprecate(function(doc, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, save, [this, doc, options2, callback]);
    }, "collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.");
    Collection.prototype.findOne = deprecateOptions({
      name: "collection.find",
      deprecatedOptions: DEPRECATED_FIND_OPTIONS,
      optionsIndex: 1
    }, function(query, options2, callback) {
      if (typeof callback === "object") {
        emitWarningOnce("Third parameter to `findOne()` must be a callback or undefined");
      }
      if (typeof query === "function")
        callback = query, query = {}, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      query = query || {};
      options2 = options2 || {};
      const findOneOperation = new FindOneOperation(this, query, options2);
      return executeOperation(this.s.topology, findOneOperation, callback);
    });
    Collection.prototype.rename = function(newName, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2, { readPreference: ReadPreference.PRIMARY });
      const renameOperation = new RenameOperation(this, newName, options2);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Collection.prototype.drop = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropCollectionOperation = new DropCollectionOperation(this.s.db, this.collectionName, options2);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Collection.prototype.options = function(opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      opts = opts || {};
      const optionsOperation = new OptionsOperation(this, opts);
      return executeOperation(this.s.topology, optionsOperation, callback);
    };
    Collection.prototype.isCapped = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const isCappedOperation = new IsCappedOperation(this, options2);
      return executeOperation(this.s.topology, isCappedOperation, callback);
    };
    Collection.prototype.createIndex = function(fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, fieldOrSpec, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.createIndexes = function(indexSpecs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      if (typeof options2.maxTimeMS !== "number")
        delete options2.maxTimeMS;
      const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, indexSpecs, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.dropIndex = function(indexName, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      options2.readPreference = ReadPreference.PRIMARY;
      const dropIndexOperation = new DropIndexOperation(this, indexName, options2);
      return executeOperation(this.s.topology, dropIndexOperation, callback);
    };
    Collection.prototype.dropIndexes = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      if (typeof options2.maxTimeMS !== "number")
        delete options2.maxTimeMS;
      const dropIndexesOperation = new DropIndexesOperation(this, options2);
      return executeOperation(this.s.topology, dropIndexesOperation, callback);
    };
    Collection.prototype.dropAllIndexes = deprecate(Collection.prototype.dropIndexes, "collection.dropAllIndexes is deprecated. Use dropIndexes instead.");
    Collection.prototype.reIndex = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const reIndexOperation = new ReIndexOperation(this, options2);
      return executeOperation(this.s.topology, reIndexOperation, callback);
    }, "collection.reIndex is deprecated. Use db.command instead.");
    Collection.prototype.listIndexes = function(options2) {
      const cursor = new CommandCursor(this.s.topology, new ListIndexesOperation(this, options2), options2);
      return cursor;
    };
    Collection.prototype.ensureIndex = deprecate(function(fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        fieldOrSpec,
        options2,
        callback
      ]);
    }, "collection.ensureIndex is deprecated. Use createIndexes instead.");
    Collection.prototype.indexExists = function(indexes, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexExistsOperation = new IndexExistsOperation(this, indexes, options2);
      return executeOperation(this.s.topology, indexExistsOperation, callback);
    };
    Collection.prototype.indexInformation = function(options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const indexInformationOperation = new IndexInformationOperation(this.s.db, this.collectionName, options2);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Collection.prototype.count = deprecate(function(query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options2 = args.length ? args.shift() || {} : {};
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeOperation(this.s.topology, new EstimatedDocumentCountOperation(this, query, options2), callback);
    }, "collection.count is deprecated, and will be removed in a future version. Use Collection.countDocuments or Collection.estimatedDocumentCount instead");
    Collection.prototype.estimatedDocumentCount = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const estimatedDocumentCountOperation = new EstimatedDocumentCountOperation(this, options2);
      return executeOperation(this.s.topology, estimatedDocumentCountOperation, callback);
    };
    Collection.prototype.countDocuments = function(query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options2 = args.length ? args.shift() || {} : {};
      const countDocumentsOperation = new CountDocumentsOperation(this, query, options2);
      return executeOperation(this.s.topology, countDocumentsOperation, callback);
    };
    Collection.prototype.distinct = function(key, query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      const queryOption = args.length ? args.shift() || {} : {};
      const optionsOption = args.length ? args.shift() || {} : {};
      const distinctOperation = new DistinctOperation(this, key, queryOption, optionsOption);
      return executeOperation(this.s.topology, distinctOperation, callback);
    };
    Collection.prototype.indexes = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexesOperation = new IndexesOperation(this, options2);
      return executeOperation(this.s.topology, indexesOperation, callback);
    };
    Collection.prototype.stats = function(options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const statsOperation = new StatsOperation(this, options2);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Collection.prototype.findOneAndDelete = function(filter, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndDeleteOperation(this, filter, options2), callback);
    };
    Collection.prototype.findOneAndReplace = deprecateOptions({
      name: "collection.findOneAndReplace",
      deprecatedOptions: ["returnOriginal"],
      optionsIndex: 2
    }, function(filter, replacement, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndReplaceOperation(this, filter, replacement, options2), callback);
    });
    Collection.prototype.findOneAndUpdate = deprecateOptions({
      name: "collection.findOneAndUpdate",
      deprecatedOptions: ["returnOriginal"],
      optionsIndex: 2
    }, function(filter, update, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndUpdateOperation(this, filter, update, options2), callback);
    });
    Collection.prototype.findAndModify = deprecate(_findAndModify, "collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.");
    Collection.prototype._findAndModify = _findAndModify;
    function _findAndModify(query, sort, doc, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      doc = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() || {} : {};
      options2 = Object.assign({}, options2);
      options2.readPreference = ReadPreference.PRIMARY;
      return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, doc, options2), callback);
    }
    Collection.prototype.findAndRemove = deprecate(function(query, sort, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      options2 = args.length ? args.shift() || {} : {};
      options2.remove = true;
      return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, null, options2), callback);
    }, "collection.findAndRemove is deprecated. Use findOneAndDelete instead.");
    Collection.prototype.aggregate = function(pipeline2, options2, callback) {
      if (Array.isArray(pipeline2)) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        if (options2 == null && callback == null) {
          options2 = {};
        }
      } else {
        const args = Array.prototype.slice.call(arguments, 0);
        callback = args.pop();
        const opts = args[args.length - 1];
        options2 = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.hint || opts.allowDiskUse) ? args.pop() : {};
        pipeline2 = args;
      }
      const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline2, options2), options2);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Collection.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    Collection.prototype.parallelCollectionScan = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = { numCursors: 1 };
      options2.numCursors = options2.numCursors || 1;
      options2.batchSize = options2.batchSize || 1e3;
      options2 = Object.assign({}, options2);
      options2.readPreference = ReadPreference.resolve(this, options2);
      options2.promiseLibrary = this.s.promiseLibrary;
      if (options2.session) {
        options2.session = void 0;
      }
      return executeLegacyOperation(this.s.topology, parallelCollectionScan, [this, options2, callback], { skipSessions: true });
    }, "parallelCollectionScan is deprecated in MongoDB v4.1");
    Collection.prototype.geoHaystackSearch = deprecate(function(x, y, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const geoHaystackSearchOperation = new GeoHaystackSearchOperation(this, x, y, options2);
      return executeOperation(this.s.topology, geoHaystackSearchOperation, callback);
    }, "geoHaystackSearch is deprecated, and will be removed in a future version.");
    Collection.prototype.group = deprecate(function(keys, condition, initial, reduce, finalize, command, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 3);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      reduce = args.length ? args.shift() : null;
      finalize = args.length ? args.shift() : null;
      command = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() || {} : {};
      if (!(typeof finalize === "function")) {
        command = finalize;
        finalize = null;
      }
      if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== "function" && !(keys._bsontype === "Code")) {
        keys = Object.keys(keys);
      }
      if (typeof reduce === "function") {
        reduce = reduce.toString();
      }
      if (typeof finalize === "function") {
        finalize = finalize.toString();
      }
      command = command == null ? true : command;
      return executeLegacyOperation(this.s.topology, group, [
        this,
        keys,
        condition,
        initial,
        reduce,
        finalize,
        command,
        options2,
        callback
      ]);
    }, "MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.");
    Collection.prototype.mapReduce = function(map, reduce, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      if (options2.out == null) {
        throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
      }
      if (typeof map === "function") {
        map = map.toString();
      }
      if (typeof reduce === "function") {
        reduce = reduce.toString();
      }
      if (typeof options2.finalize === "function") {
        options2.finalize = options2.finalize.toString();
      }
      const mapReduceOperation = new MapReduceOperation(this, map, reduce, options2);
      return executeOperation(this.s.topology, mapReduceOperation, callback);
    };
    Collection.prototype.initializeUnorderedBulkOp = function(options2) {
      options2 = options2 || {};
      if (options2.ignoreUndefined == null) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options2.promiseLibrary = this.s.promiseLibrary;
      return unordered(this.s.topology, this, options2);
    };
    Collection.prototype.initializeOrderedBulkOp = function(options2) {
      options2 = options2 || {};
      if (options2.ignoreUndefined == null) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options2.promiseLibrary = this.s.promiseLibrary;
      return ordered(this.s.topology, this, options2);
    };
    Collection.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    module2.exports = Collection;
  }
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS({
  "node_modules/mongodb/lib/change_stream.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Denque = require_denque();
    var EventEmitter = require("events");
    var isResumableError = require_error2().isResumableError;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var relayEvents = require_utils2().relayEvents;
    var maxWireVersion = require_utils2().maxWireVersion;
    var maybePromise = require_utils4().maybePromise;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var AggregateOperation = require_aggregate();
    var kResumeQueue = Symbol("resumeQueue");
    var CHANGE_STREAM_OPTIONS = ["resumeAfter", "startAfter", "startAtOperationTime", "fullDocument"];
    var CURSOR_OPTIONS = ["batchSize", "maxAwaitTimeMS", "collation", "readPreference"].concat(CHANGE_STREAM_OPTIONS);
    var CHANGE_DOMAIN_TYPES = {
      COLLECTION: Symbol("Collection"),
      DATABASE: Symbol("Database"),
      CLUSTER: Symbol("Cluster")
    };
    var ChangeStream = class extends EventEmitter {
      constructor(parent, pipeline2, options2) {
        super();
        const Collection = require_collection();
        const Db = require_db();
        const MongoClient = require_mongo_client();
        this.pipeline = pipeline2 || [];
        this.options = options2 || {};
        this.parent = parent;
        this.namespace = parent.s.namespace;
        if (parent instanceof Collection) {
          this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
          this.topology = parent.s.db.serverConfig;
        } else if (parent instanceof Db) {
          this.type = CHANGE_DOMAIN_TYPES.DATABASE;
          this.topology = parent.serverConfig;
        } else if (parent instanceof MongoClient) {
          this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
          this.topology = parent.topology;
        } else {
          throw new TypeError("parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient");
        }
        this.promiseLibrary = parent.s.promiseLibrary;
        if (!this.options.readPreference && parent.s.readPreference) {
          this.options.readPreference = parent.s.readPreference;
        }
        this[kResumeQueue] = new Denque();
        this.cursor = createChangeStreamCursor(this, options2);
        this.closed = false;
        this.on("newListener", (eventName) => {
          if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
            this.cursor.on("data", (change) => processNewChange(this, change));
          }
        });
        this.on("removeListener", (eventName) => {
          if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
            this.cursor.removeAllListeners("data");
          }
        });
      }
      get resumeToken() {
        return this.cursor.resumeToken;
      }
      hasNext(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.hasNext(cb);
          });
        });
      }
      next(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.next((error2, change) => {
              if (error2) {
                this[kResumeQueue].push(() => this.next(cb));
                processError(this, error2, cb);
                return;
              }
              processNewChange(this, change, cb);
            });
          });
        });
      }
      isClosed() {
        return this.closed || this.cursor && this.cursor.isClosed();
      }
      close(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          if (this.closed)
            return cb();
          this.closed = true;
          if (!this.cursor)
            return cb();
          const cursor = this.cursor;
          return cursor.close((err) => {
            ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
            this.cursor = void 0;
            return cb(err);
          });
        });
      }
      pipe(destination, options2) {
        if (!this.pipeDestinations) {
          this.pipeDestinations = [];
        }
        this.pipeDestinations.push(destination);
        return this.cursor.pipe(destination, options2);
      }
      unpipe(destination) {
        if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {
          this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
        }
        return this.cursor.unpipe(destination);
      }
      stream(options2) {
        this.streamOptions = options2;
        return this.cursor.stream(options2);
      }
      pause() {
        return this.cursor.pause();
      }
      resume() {
        return this.cursor.resume();
      }
    };
    var ChangeStreamCursor = class extends Cursor {
      constructor(topology, operation, options2) {
        super(topology, operation, options2);
        options2 = options2 || {};
        this._resumeToken = null;
        this.startAtOperationTime = options2.startAtOperationTime;
        if (options2.startAfter) {
          this.resumeToken = options2.startAfter;
        } else if (options2.resumeAfter) {
          this.resumeToken = options2.resumeAfter;
        }
      }
      set resumeToken(token2) {
        this._resumeToken = token2;
        this.emit("resumeTokenChanged", token2);
      }
      get resumeToken() {
        return this._resumeToken;
      }
      get resumeOptions() {
        const result = {};
        for (const optionName of CURSOR_OPTIONS) {
          if (this.options[optionName])
            result[optionName] = this.options[optionName];
        }
        if (this.resumeToken || this.startAtOperationTime) {
          ["resumeAfter", "startAfter", "startAtOperationTime"].forEach((key) => delete result[key]);
          if (this.resumeToken) {
            const resumeKey = this.options.startAfter && !this.hasReceived ? "startAfter" : "resumeAfter";
            result[resumeKey] = this.resumeToken;
          } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {
            result.startAtOperationTime = this.startAtOperationTime;
          }
        }
        return result;
      }
      cacheResumeToken(resumeToken) {
        if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {
          this.resumeToken = this.cursorState.postBatchResumeToken;
        } else {
          this.resumeToken = resumeToken;
        }
        this.hasReceived = true;
      }
      _processBatch(batchName, response) {
        const cursor = response.cursor;
        if (cursor.postBatchResumeToken) {
          this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;
          if (cursor[batchName].length === 0) {
            this.resumeToken = cursor.postBatchResumeToken;
          }
        }
      }
      _initializeCursor(callback) {
        super._initializeCursor((err, result) => {
          if (err || result == null) {
            callback(err, result);
            return;
          }
          const response = result.documents[0];
          if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {
            this.startAtOperationTime = response.operationTime;
          }
          this._processBatch("firstBatch", response);
          this.emit("init", result);
          this.emit("response");
          callback(err, result);
        });
      }
      _getMore(callback) {
        super._getMore((err, response) => {
          if (err) {
            callback(err);
            return;
          }
          this._processBatch("nextBatch", response);
          this.emit("more", response);
          this.emit("response");
          callback(err, response);
        });
      }
    };
    function createChangeStreamCursor(self2, options2) {
      const changeStreamStageOptions = { fullDocument: options2.fullDocument || "default" };
      applyKnownOptions(changeStreamStageOptions, options2, CHANGE_STREAM_OPTIONS);
      if (self2.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }
      const pipeline2 = [{ $changeStream: changeStreamStageOptions }].concat(self2.pipeline);
      const cursorOptions = applyKnownOptions({}, options2, CURSOR_OPTIONS);
      const changeStreamCursor = new ChangeStreamCursor(self2.topology, new AggregateOperation(self2.parent, pipeline2, options2), cursorOptions);
      relayEvents(changeStreamCursor, self2, ["resumeTokenChanged", "end", "close"]);
      if (self2.listenerCount("change") > 0) {
        changeStreamCursor.on("data", function(change) {
          processNewChange(self2, change);
        });
      }
      changeStreamCursor.on("error", function(error2) {
        processError(self2, error2);
      });
      if (self2.pipeDestinations) {
        const cursorStream = changeStreamCursor.stream(self2.streamOptions);
        for (let pipeDestination of self2.pipeDestinations) {
          cursorStream.pipe(pipeDestination);
        }
      }
      return changeStreamCursor;
    }
    function applyKnownOptions(target, source, optionNames) {
      optionNames.forEach((name) => {
        if (source[name]) {
          target[name] = source[name];
        }
      });
      return target;
    }
    var SELECTION_TIMEOUT = 3e4;
    function waitForTopologyConnected(topology, options2, callback) {
      setTimeout(() => {
        if (options2 && options2.start == null) {
          options2.start = now();
        }
        const start = options2.start || now();
        const timeout = options2.timeout || SELECTION_TIMEOUT;
        const readPreference = options2.readPreference;
        if (topology.isConnected({ readPreference })) {
          return callback();
        }
        if (calculateDurationInMs(start) > timeout) {
          return callback(new MongoError("Timed out waiting for connection"));
        }
        waitForTopologyConnected(topology, options2, callback);
      }, 500);
    }
    function processNewChange(changeStream, change, callback) {
      const cursor = changeStream.cursor;
      if (change == null) {
        changeStream.closed = true;
      }
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      if (change && !change._id) {
        const noResumeTokenError = new Error("A change stream document has been received that lacks a resume token (_id).");
        if (!callback)
          return changeStream.emit("error", noResumeTokenError);
        return callback(noResumeTokenError);
      }
      cursor.cacheResumeToken(change._id);
      changeStream.options.startAtOperationTime = void 0;
      if (!callback)
        return changeStream.emit("change", change);
      return callback(void 0, change);
    }
    function processError(changeStream, error2, callback) {
      const topology = changeStream.topology;
      const cursor = changeStream.cursor;
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      function resumeWithCursor(newCursor) {
        changeStream.cursor = newCursor;
        processResumeQueue(changeStream);
      }
      function unresumableError(err) {
        if (!callback) {
          changeStream.emit("error", err);
          changeStream.emit("close");
        }
        processResumeQueue(changeStream, err);
        changeStream.closed = true;
      }
      if (cursor && isResumableError(error2, maxWireVersion(cursor.server))) {
        changeStream.cursor = void 0;
        ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
        cursor.close();
        waitForTopologyConnected(topology, { readPreference: cursor.options.readPreference }, (err) => {
          if (err)
            return unresumableError(err);
          const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);
          if (!callback)
            return resumeWithCursor(newCursor);
          newCursor.hasNext((err2) => {
            if (err2)
              return unresumableError(err2);
            resumeWithCursor(newCursor);
          });
        });
        return;
      }
      if (!callback)
        return changeStream.emit("error", error2);
      return callback(error2);
    }
    function getCursor(changeStream, callback) {
      if (changeStream.isClosed()) {
        callback(new MongoError("ChangeStream is closed."));
        return;
      }
      if (changeStream.cursor) {
        callback(void 0, changeStream.cursor);
        return;
      }
      changeStream[kResumeQueue].push(callback);
    }
    function processResumeQueue(changeStream, err) {
      while (changeStream[kResumeQueue].length) {
        const request = changeStream[kResumeQueue].pop();
        if (changeStream.isClosed() && !err) {
          request(new MongoError("Change Stream is not open."));
          return;
        }
        request(err, changeStream.cursor);
      }
    }
    module2.exports = ChangeStream;
  }
});

// node_modules/mongodb/lib/topologies/topology_base.js
var require_topology_base = __commonJS({
  "node_modules/mongodb/lib/topologies/topology_base.js"(exports2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events");
    var MongoError = require_core().MongoError;
    var f = require("util").format;
    var ReadPreference = require_core().ReadPreference;
    var ClientSession = require_core().Sessions.ClientSession;
    var Store = function(topology, storeOptions) {
      var self2 = this;
      var storedOps = [];
      storeOptions = storeOptions || { force: false, bufferMaxEntries: -1 };
      this.s = {
        storedOps,
        storeOptions,
        topology
      };
      Object.defineProperty(this, "length", {
        enumerable: true,
        get: function() {
          return self2.s.storedOps.length;
        }
      });
    };
    Store.prototype.add = function(opType, ns, ops, options2, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({ message: "db closed by application", driver: true }));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(MongoError.create({
            message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
            driver: true
          }));
        }
        return;
      }
      this.s.storedOps.push({ t: opType, n: ns, o: ops, op: options2, c: callback });
    };
    Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({ message: "db closed by application", driver: true }));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(MongoError.create({
            message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
            driver: true
          }));
        }
        return;
      }
      this.s.storedOps.push({ t: opType, m: method, o: object, p: params, c: callback });
    };
    Store.prototype.flush = function(err) {
      while (this.s.storedOps.length > 0) {
        this.s.storedOps.shift().c(err || MongoError.create({ message: f("no connection available for operation"), driver: true }));
      }
    };
    var primaryOptions = ["primary", "primaryPreferred", "nearest", "secondaryPreferred"];
    var secondaryOptions = ["secondary", "secondaryPreferred"];
    Store.prototype.execute = function(options2) {
      options2 = options2 || {};
      var ops = this.s.storedOps;
      this.s.storedOps = [];
      var executePrimary = typeof options2.executePrimary === "boolean" ? options2.executePrimary : true;
      var executeSecondary = typeof options2.executeSecondary === "boolean" ? options2.executeSecondary : true;
      while (ops.length > 0) {
        var op = ops.shift();
        if (op.t === "cursor") {
          if (executePrimary && executeSecondary) {
            op.o[op.m].apply(op.o, op.p);
          } else if (executePrimary && op.o.options && op.o.options.readPreference && primaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          } else if (!executePrimary && executeSecondary && op.o.options && op.o.options.readPreference && secondaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          }
        } else if (op.t === "auth") {
          this.s.topology[op.t].apply(this.s.topology, op.o);
        } else {
          if (executePrimary && executeSecondary) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (executePrimary && op.op && op.op.readPreference && primaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (!executePrimary && executeSecondary && op.op && op.op.readPreference && secondaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          }
        }
      }
    };
    Store.prototype.all = function() {
      return this.s.storedOps;
    };
    var ServerCapabilities = function(ismaster) {
      var setup_get_property = function(object, name, value) {
        Object.defineProperty(object, name, {
          enumerable: true,
          get: function() {
            return value;
          }
        });
      };
      var aggregationCursor = false;
      var writeCommands = false;
      var textSearch = false;
      var authCommands = false;
      var listCollections = false;
      var listIndexes = false;
      var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1e3;
      var commandsTakeWriteConcern = false;
      var commandsTakeCollation = false;
      if (ismaster.minWireVersion >= 0) {
        textSearch = true;
      }
      if (ismaster.maxWireVersion >= 1) {
        aggregationCursor = true;
        authCommands = true;
      }
      if (ismaster.maxWireVersion >= 2) {
        writeCommands = true;
      }
      if (ismaster.maxWireVersion >= 3) {
        listCollections = true;
        listIndexes = true;
      }
      if (ismaster.maxWireVersion >= 5) {
        commandsTakeWriteConcern = true;
        commandsTakeCollation = true;
      }
      if (ismaster.minWireVersion == null) {
        ismaster.minWireVersion = 0;
      }
      if (ismaster.maxWireVersion == null) {
        ismaster.maxWireVersion = 0;
      }
      setup_get_property(this, "hasAggregationCursor", aggregationCursor);
      setup_get_property(this, "hasWriteCommands", writeCommands);
      setup_get_property(this, "hasTextSearch", textSearch);
      setup_get_property(this, "hasAuthCommands", authCommands);
      setup_get_property(this, "hasListCollectionsCommand", listCollections);
      setup_get_property(this, "hasListIndexesCommand", listIndexes);
      setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
      setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
      setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
      setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
      setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
    };
    var TopologyBase = class extends EventEmitter {
      constructor() {
        super();
        this.setMaxListeners(Infinity);
      }
      hasSessionSupport() {
        return this.logicalSessionTimeoutMinutes != null;
      }
      startSession(options2, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options2, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        return this.s.coreTopology.endSessions(sessions, callback);
      }
      get clientMetadata() {
        return this.s.coreTopology.s.options.metadata;
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.s.coreTopology.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.s.coreTopology.lastIsMaster());
        return this.s.sCapabilities;
      }
      command(ns, cmd, options2, callback) {
        this.s.coreTopology.command(ns.toString(), cmd, ReadPreference.translate(options2), callback);
      }
      insert(ns, ops, options2, callback) {
        this.s.coreTopology.insert(ns.toString(), ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        this.s.coreTopology.update(ns.toString(), ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        this.s.coreTopology.remove(ns.toString(), ops, options2, callback);
      }
      isConnected(options2) {
        options2 = options2 || {};
        options2 = ReadPreference.translate(options2);
        return this.s.coreTopology.isConnected(options2);
      }
      isDestroyed() {
        return this.s.coreTopology.isDestroyed();
      }
      cursor(ns, cmd, options2) {
        options2 = options2 || {};
        options2 = ReadPreference.translate(options2);
        options2.disconnectHandler = this.s.store;
        options2.topology = this;
        return this.s.coreTopology.cursor(ns, cmd, options2);
      }
      lastIsMaster() {
        return this.s.coreTopology.lastIsMaster();
      }
      selectServer(selector, options2, callback) {
        return this.s.coreTopology.selectServer(selector, options2, callback);
      }
      unref() {
        return this.s.coreTopology.unref();
      }
      connections() {
        return this.s.coreTopology.connections();
      }
      close(forceClosed, callback) {
        this.s.sessions.forEach((session) => session.endSession());
        if (this.s.sessionPool) {
          this.s.sessionPool.endAllPooledSessions();
        }
        if (forceClosed === true) {
          this.s.storeOptions.force = forceClosed;
          this.s.store.flush();
        }
        this.s.coreTopology.destroy({
          force: typeof forceClosed === "boolean" ? forceClosed : false
        }, callback);
      }
    };
    Object.defineProperty(TopologyBase.prototype, "bson", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.bson;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.parserType;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.logicalSessionTimeoutMinutes;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "type", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.type;
      }
    });
    exports2.Store = Store;
    exports2.ServerCapabilities = ServerCapabilities;
    exports2.TopologyBase = TopologyBase;
  }
});

// node_modules/mongodb/lib/topologies/native_topology.js
var require_native_topology = __commonJS({
  "node_modules/mongodb/lib/topologies/native_topology.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Topology = require_core().Topology;
    var ServerCapabilities = require_topology_base().ServerCapabilities;
    var Cursor = require_cursor2();
    var translateOptions = require_utils4().translateOptions;
    var NativeTopology = class extends Topology {
      constructor(servers, options2) {
        options2 = options2 || {};
        let clonedOptions = Object.assign({}, {
          cursorFactory: Cursor,
          reconnect: false,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          maxPoolSize: typeof options2.maxPoolSize === "number" ? options2.maxPoolSize : typeof options2.poolSize === "number" ? options2.poolSize : 10,
          minPoolSize: typeof options2.minPoolSize === "number" ? options2.minPoolSize : typeof options2.minSize === "number" ? options2.minSize : 0,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        super(servers, clonedOptions);
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.lastIsMaster());
        return this.s.sCapabilities;
      }
      command(ns, cmd, options2, callback) {
        super.command(ns.toString(), cmd, options2, callback);
      }
      insert(ns, ops, options2, callback) {
        super.insert(ns.toString(), ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        super.update(ns.toString(), ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        super.remove(ns.toString(), ops, options2, callback);
      }
    };
    module2.exports = NativeTopology;
  }
});

// node_modules/mongodb/lib/topologies/server.js
var require_server3 = __commonJS({
  "node_modules/mongodb/lib/topologies/server.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CServer = require_core().Server;
    var Cursor = require_cursor2();
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var MongoError = require_core().MongoError;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "reconnectInterval",
      "monitoring",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "compression",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Server = class extends TopologyBase {
      constructor(host, port, options2) {
        super();
        var self2 = this;
        options2 = filterOptions(options2, legalOptionNames);
        const promiseLibrary = options2.promiseLibrary;
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self2, storeOptions);
        if (host.indexOf("/") !== -1) {
          if (port != null && typeof port === "object") {
            options2 = port;
            port = null;
          }
        } else if (port == null) {
          throw MongoError.create({ message: "port must be specified", driver: true });
        }
        var reconnect = typeof options2.auto_reconnect === "boolean" ? options2.auto_reconnect : true;
        reconnect = typeof options2.autoReconnect === "boolean" ? options2.autoReconnect : reconnect;
        var clonedOptions = mergeOptions({}, {
          host,
          port,
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          coreTopology: new CServer(clonedOptions),
          sCapabilities: null,
          clonedOptions,
          reconnect: clonedOptions.reconnect,
          emitError: clonedOptions.emitError,
          poolSize: clonedOptions.size,
          storeOptions,
          store,
          host,
          port,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: promiseLibrary || Promise
        };
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = this.s.clonedOptions;
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events = ["timeout", "error", "close"];
            events.forEach(function(e) {
              self2.s.coreTopology.removeListener(e, connectHandlers[e]);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self2.emit("reconnect", self2);
          self2.s.store.execute();
        };
        var reconnectFailedHandler = function(err) {
          self2.emit("reconnectFailed", err);
          self2.s.store.flush(err);
        };
        var destroyHandler = function() {
          self2.s.store.flush();
        };
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var connectHandler = function() {
          ["timeout", "error", "close", "destroy"].forEach(function(e) {
            self2.s.coreTopology.removeAllListeners(e);
          });
          self2.s.coreTopology.on("timeout", errorHandler("timeout"));
          self2.s.coreTopology.once("error", errorHandler("error"));
          self2.s.coreTopology.on("close", errorHandler("close"));
          self2.s.coreTopology.on("destroy", destroyHandler);
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectHandlers = {
          timeout: connectErrorHandler("timeout"),
          error: connectErrorHandler("error"),
          close: connectErrorHandler("close")
        };
        [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ].forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.once("timeout", connectHandlers.timeout);
        self2.s.coreTopology.once("error", connectHandlers.error);
        self2.s.coreTopology.once("close", connectHandlers.close);
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.on("reconnect", reconnectHandler);
        self2.s.coreTopology.on("reconnectFailed", reconnectFailedHandler);
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.on("attemptReconnect", relay("attemptReconnect"));
        self2.s.coreTopology.on("monitoring", relay("monitoring"));
        self2.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Server.prototype, "poolSize", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.connections().length;
      }
    });
    Object.defineProperty(Server.prototype, "autoReconnect", {
      enumerable: true,
      get: function() {
        return this.s.reconnect;
      }
    });
    Object.defineProperty(Server.prototype, "host", {
      enumerable: true,
      get: function() {
        return this.s.host;
      }
    });
    Object.defineProperty(Server.prototype, "port", {
      enumerable: true,
      get: function() {
        return this.s.port;
      }
    });
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/topologies/mongos.js
var require_mongos2 = __commonJS({
  "node_modules/mongodb/lib/topologies/mongos.js"(exports2, module2) {
    init_shims();
    "use strict";
    var TopologyBase = require_topology_base().TopologyBase;
    var MongoError = require_core().MongoError;
    var CMongos = require_core().Mongos;
    var Cursor = require_cursor2();
    var Server = require_server3();
    var Store = require_topology_base().Store;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Mongos = class extends TopologyBase {
      constructor(servers, options2) {
        super();
        options2 = options2 || {};
        var self2 = this;
        options2 = filterOptions(options2, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self2, storeOptions);
        var seedlist = servers.map(function(x) {
          return { host: x.host, port: x.port };
        });
        var reconnect = typeof options2.auto_reconnect === "boolean" ? options2.auto_reconnect : true;
        reconnect = typeof options2.autoReconnect === "boolean" ? options2.autoReconnect : reconnect;
        var clonedOptions = mergeOptions({}, {
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          coreTopology: new CMongos(seedlist, clonedOptions),
          sCapabilities: null,
          debug: clonedOptions.debug,
          storeOptions,
          clonedOptions,
          store,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise
        };
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events2 = ["timeout", "error", "close"];
            events2.forEach(function(e) {
              self2.removeListener(e, connectErrorHandler);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            self2.close(true);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self2.emit("reconnect");
          self2.s.store.execute();
        };
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var connectHandler = function() {
          var events2 = ["timeout", "error", "close", "fullsetup"];
          events2.forEach(function(e) {
            self2.s.coreTopology.removeAllListeners(e);
          });
          self2.s.coreTopology.on("timeout", errorHandler("timeout"));
          self2.s.coreTopology.on("error", errorHandler("error"));
          self2.s.coreTopology.on("close", errorHandler("close"));
          self2.s.coreTopology.on("fullsetup", function() {
            self2.emit("fullsetup", self2);
          });
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ];
        events.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self2.s.coreTopology.once("error", connectErrorHandler("error"));
        self2.s.coreTopology.once("close", connectErrorHandler("close"));
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.on("joined", relay("joined"));
        self2.s.coreTopology.on("left", relay("left"));
        self2.s.coreTopology.on("reconnect", reconnectHandler);
        self2.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Mongos.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = Mongos;
  }
});

// node_modules/mongodb/lib/topologies/replset.js
var require_replset2 = __commonJS({
  "node_modules/mongodb/lib/topologies/replset.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Server = require_server3();
    var Cursor = require_cursor2();
    var MongoError = require_core().MongoError;
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var CReplSet = require_core().ReplSet;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "replicaSet",
      "rs_name",
      "secondaryAcceptableLatencyMS",
      "connectWithNoPrimary",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslCRL",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "strategy",
      "debug",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "maxStalenessSeconds",
      "promiseLibrary",
      "minSize",
      "monitorCommands"
    ];
    var ReplSet = class extends TopologyBase {
      constructor(servers, options2) {
        super();
        options2 = options2 || {};
        var self2 = this;
        options2 = filterOptions(options2, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self2, storeOptions);
        var seedlist = servers.map(function(x) {
          return { host: x.host, port: x.port };
        });
        var clonedOptions = mergeOptions({}, {
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect: false,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        var coreTopology = new CReplSet(seedlist, clonedOptions);
        coreTopology.on("reconnect", function() {
          self2.emit("reconnect");
          store.execute();
        });
        this.s = {
          coreTopology,
          sCapabilities: null,
          tag: options2.tag,
          storeOptions,
          clonedOptions,
          store,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise
        };
        if (clonedOptions.debug) {
          Object.defineProperty(this, "replset", {
            enumerable: true,
            get: function() {
              return coreTopology;
            }
          });
        }
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed",
          "joined",
          "left",
          "ping",
          "ha"
        ];
        events.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var replsetRelay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server.lastIsMaster(), server);
          };
        };
        var relayHa = function(t, state) {
          self2.emit("ha", t, state);
          if (t === "start") {
            self2.emit("ha_connect", t, state);
          } else if (t === "end") {
            self2.emit("ha_ismaster", t, state);
          }
        };
        self2.s.coreTopology.on("joined", replsetRelay("joined"));
        self2.s.coreTopology.on("left", relay("left"));
        self2.s.coreTopology.on("ping", relay("ping"));
        self2.s.coreTopology.on("ha", relayHa);
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.on("fullsetup", function() {
          self2.emit("fullsetup", self2, self2);
        });
        self2.s.coreTopology.on("all", function() {
          self2.emit("all", null, self2);
        });
        var connectHandler = function() {
          self2.s.coreTopology.once("timeout", errorHandler("timeout"));
          self2.s.coreTopology.once("error", errorHandler("error"));
          self2.s.coreTopology.once("close", errorHandler("close"));
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectErrorHandler = function() {
          return function(err) {
            ["timeout", "error", "close"].forEach(function(e) {
              self2.s.coreTopology.removeListener(e, connectErrorHandler);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            self2.s.coreTopology.destroy();
            try {
              callback(err);
            } catch (err2) {
              if (!self2.s.coreTopology.isConnected())
                process.nextTick(function() {
                  throw err2;
                });
            }
          };
        };
        self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self2.s.coreTopology.once("error", connectErrorHandler("error"));
        self2.s.coreTopology.once("close", connectErrorHandler("close"));
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.connect(_options);
      }
      close(forceClosed, callback) {
        ["timeout", "error", "close", "joined", "left"].forEach((e) => this.removeAllListeners(e));
        super.close(forceClosed, callback);
      }
    };
    Object.defineProperty(ReplSet.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/url_parser.js
var require_url_parser = __commonJS({
  "node_modules/mongodb/lib/url_parser.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var parser = require("url");
    var f = require("util").format;
    var Logger = require_core().Logger;
    var dns = require("dns");
    var ReadConcern = require_read_concern();
    var qs = require("querystring");
    var MongoParseError = require_error().MongoParseError;
    module2.exports = function(url, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      let result;
      try {
        result = parser.parse(url, true);
      } catch (e) {
        return callback(new Error("URL malformed, cannot be parsed"));
      }
      if (result.protocol !== "mongodb:" && result.protocol !== "mongodb+srv:") {
        return callback(new Error("Invalid schema, expected `mongodb` or `mongodb+srv`"));
      }
      if (result.protocol === "mongodb:") {
        return parseHandler(url, options2, callback);
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new Error("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      const hostname = url.substring("mongodb+srv://".length).split("/")[0];
      if (hostname.match(",")) {
        return callback(new Error("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new Error("Ports not accepted with `mongodb+srv` URIs"));
      }
      let srvAddress = `_mongodb._tcp.${result.host}`;
      dns.resolveSrv(srvAddress, function(err, addresses) {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new Error("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new Error("Server record does not share hostname with parent URI"));
          }
        }
        let base = result.auth ? `mongodb://${result.auth}@` : `mongodb://`;
        let connectionStrings = addresses.map(function(address, i) {
          if (i === 0)
            return `${base}${address.name}:${address.port}`;
          else
            return `${address.name}:${address.port}`;
        });
        let connectionString = connectionStrings.join(",") + "/";
        let connectionStringOptions = [];
        if (result.path) {
          let defaultDb = result.path.slice(1);
          if (defaultDb.indexOf("?") !== -1) {
            defaultDb = defaultDb.slice(0, defaultDb.indexOf("?"));
          }
          connectionString += defaultDb;
        }
        if (!options2.ssl && !result.search) {
          connectionStringOptions.push("ssl=true");
        } else if (!options2.ssl && result.search && !result.search.match("ssl")) {
          connectionStringOptions.push("ssl=true");
        }
        if (result.search) {
          connectionStringOptions.push(result.search.replace("?", ""));
        }
        dns.resolveTxt(result.host, function(err2, record) {
          if (err2 && err2.code !== "ENODATA" && err2.code !== "ENOTFOUND")
            return callback(err2);
          if (err2 && err2.code === "ENODATA")
            record = null;
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = record[0].join("");
            const parsedRecord = qs.parse(record);
            const items = Object.keys(parsedRecord);
            if (items.some((item) => item !== "authSource" && item !== "replicaSet")) {
              return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
            }
            if (items.length > 0) {
              connectionStringOptions.push(record);
            }
          }
          if (connectionStringOptions.length) {
            connectionString += `?${connectionStringOptions.join("&")}`;
          }
          parseHandler(connectionString, options2, callback);
        });
      });
    };
    function matchesParentDomain(srvAddress, parentDomain) {
      let regex = /^.*?\./;
      let srv = `.${srvAddress.replace(regex, "")}`;
      let parent = `.${parentDomain.replace(regex, "")}`;
      if (srv.endsWith(parent))
        return true;
      else
        return false;
    }
    function parseHandler(address, options2, callback) {
      let result, err;
      try {
        result = parseConnectionString(address, options2);
      } catch (e) {
        err = e;
      }
      return err ? callback(err, null) : callback(null, result);
    }
    function parseConnectionString(url, options2) {
      let connection_part = "";
      let auth_part = "";
      let query_string_part = "";
      let dbName = "admin";
      let result = parser.parse(url, true);
      if ((result.hostname == null || result.hostname === "") && url.indexOf(".sock") === -1) {
        throw new Error("No hostname or hostnames provided in connection string");
      }
      if (result.port === "0") {
        throw new Error("Invalid port (zero) with hostname");
      }
      if (!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
        throw new Error("Invalid port (larger than 65535) with hostname");
      }
      if (result.path && result.path.length > 0 && result.path[0] !== "/" && url.indexOf(".sock") === -1) {
        throw new Error("Missing delimiting slash between hosts and options");
      }
      if (result.query) {
        for (let name in result.query) {
          if (name.indexOf("::") !== -1) {
            throw new Error("Double colon in host identifier");
          }
          if (result.query[name] === "") {
            throw new Error("Query parameter " + name + " is an incomplete value pair");
          }
        }
      }
      if (result.auth) {
        let parts = result.auth.split(":");
        if (url.indexOf(result.auth) !== -1 && parts.length > 2) {
          throw new Error("Username with password containing an unescaped colon");
        }
        if (url.indexOf(result.auth) !== -1 && result.auth.indexOf("@") !== -1) {
          throw new Error("Username containing an unescaped at-sign");
        }
      }
      let clean = url.split("?").shift();
      let strings = clean.split(",");
      let hosts = [];
      for (let i = 0; i < strings.length; i++) {
        let hostString = strings[i];
        if (hostString.indexOf("mongodb") !== -1) {
          if (hostString.indexOf("@") !== -1) {
            hosts.push(hostString.split("@").pop());
          } else {
            hosts.push(hostString.substr("mongodb://".length));
          }
        } else if (hostString.indexOf("/") !== -1) {
          hosts.push(hostString.split("/").shift());
        } else if (hostString.indexOf("/") === -1) {
          hosts.push(hostString.trim());
        }
      }
      for (let i = 0; i < hosts.length; i++) {
        let r = parser.parse(f("mongodb://%s", hosts[i].trim()));
        if (r.path && r.path.indexOf(".sock") !== -1)
          continue;
        if (r.path && r.path.indexOf(":") !== -1) {
          if (r.path.split("/").length > 1 && r.path.indexOf("::") === -1) {
            throw new Error("Slash in host identifier");
          } else {
            throw new Error("Double colon in host identifier");
          }
        }
      }
      if (url.indexOf("?") !== -1) {
        query_string_part = url.substr(url.indexOf("?") + 1);
        connection_part = url.substring("mongodb://".length, url.indexOf("?"));
      } else {
        connection_part = url.substring("mongodb://".length);
      }
      if (connection_part.indexOf("@") !== -1) {
        auth_part = connection_part.split("@")[0];
        connection_part = connection_part.split("@")[1];
      }
      if (connection_part.split("/").length > 2) {
        throw new Error("Unsupported host '" + connection_part.split("?")[0] + "', hosts must be URL encoded and contain at most one unencoded slash");
      }
      if (connection_part.indexOf(".sock") !== -1) {
        if (connection_part.indexOf(".sock/") !== -1) {
          dbName = connection_part.split(".sock/")[1];
          if (dbName.indexOf("/") !== -1) {
            if (dbName.split("/").length === 2 && dbName.split("/")[1].length === 0) {
              throw new Error("Illegal trailing backslash after database name");
            }
            throw new Error("More than 1 database name in URL");
          }
          connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
        }
      } else if (connection_part.indexOf("/") !== -1) {
        if (connection_part.split("/").length > 2) {
          if (connection_part.split("/")[2].length === 0) {
            throw new Error("Illegal trailing backslash after database name");
          }
          throw new Error("More than 1 database name in URL");
        }
        dbName = connection_part.split("/")[1];
        connection_part = connection_part.split("/")[0];
      }
      connection_part = decodeURIComponent(connection_part);
      let object = {};
      let authPart = auth_part || "";
      let auth = authPart.split(":", 2);
      let user2 = decodeURIComponent(auth[0]);
      if (auth[0] !== encodeURIComponent(user2)) {
        throw new Error("Username contains an illegal unescaped character");
      }
      auth[0] = user2;
      if (auth[1]) {
        let pass = decodeURIComponent(auth[1]);
        if (auth[1] !== encodeURIComponent(pass)) {
          throw new Error("Password contains an illegal unescaped character");
        }
        auth[1] = pass;
      }
      if (auth.length === 2)
        object.auth = { user: auth[0], password: auth[1] };
      if (options2 && options2.auth != null)
        object.auth = options2.auth;
      let hostPart;
      let urlOptions;
      let servers;
      let compression;
      let serverOptions = { socketOptions: {} };
      let dbOptions = { read_preference_tags: [] };
      let replSetServersOptions = { socketOptions: {} };
      let mongosOptions = { socketOptions: {} };
      object.server_options = serverOptions;
      object.db_options = dbOptions;
      object.rs_options = replSetServersOptions;
      object.mongos_options = mongosOptions;
      if (url.match(/\.sock/)) {
        let domainSocket = url.substring(url.indexOf("mongodb://") + "mongodb://".length, url.lastIndexOf(".sock") + ".sock".length);
        if (domainSocket.indexOf("@") !== -1)
          domainSocket = domainSocket.split("@")[1];
        domainSocket = decodeURIComponent(domainSocket);
        servers = [{ domain_socket: domainSocket }];
      } else {
        hostPart = connection_part;
        let deduplicatedServers = {};
        servers = hostPart.split(",").map(function(h) {
          let _host, _port, ipv6match;
          if (ipv6match = /\[([^\]]+)\](?::(.+))?/.exec(h)) {
            _host = ipv6match[1];
            _port = parseInt(ipv6match[2], 10) || 27017;
          } else {
            let hostPort = h.split(":", 2);
            _host = hostPort[0] || "localhost";
            _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
            if (_host.indexOf("?") !== -1)
              _host = _host.split(/\?/)[0];
          }
          if (deduplicatedServers[_host + "_" + _port])
            return null;
          deduplicatedServers[_host + "_" + _port] = 1;
          return { host: _host, port: _port };
        }).filter(function(x) {
          return x != null;
        });
      }
      object.dbName = dbName || "admin";
      urlOptions = (query_string_part || "").split(/[&;]/);
      urlOptions.forEach(function(opt) {
        if (!opt)
          return;
        var splitOpt = opt.split("="), name = splitOpt[0], value = splitOpt[1];
        switch (name) {
          case "slaveOk":
          case "slave_ok":
            serverOptions.slave_ok = value === "true";
            dbOptions.slaveOk = value === "true";
            break;
          case "maxPoolSize":
          case "poolSize":
            serverOptions.poolSize = parseInt(value, 10);
            replSetServersOptions.poolSize = parseInt(value, 10);
            break;
          case "appname":
            object.appname = decodeURIComponent(value);
            break;
          case "autoReconnect":
          case "auto_reconnect":
            serverOptions.auto_reconnect = value === "true";
            break;
          case "ssl":
            if (value === "prefer") {
              serverOptions.ssl = value;
              replSetServersOptions.ssl = value;
              mongosOptions.ssl = value;
              break;
            }
            serverOptions.ssl = value === "true";
            replSetServersOptions.ssl = value === "true";
            mongosOptions.ssl = value === "true";
            break;
          case "sslValidate":
            serverOptions.sslValidate = value === "true";
            replSetServersOptions.sslValidate = value === "true";
            mongosOptions.sslValidate = value === "true";
            break;
          case "replicaSet":
          case "rs_name":
            replSetServersOptions.rs_name = value;
            break;
          case "reconnectWait":
            replSetServersOptions.reconnectWait = parseInt(value, 10);
            break;
          case "retries":
            replSetServersOptions.retries = parseInt(value, 10);
            break;
          case "readSecondary":
          case "read_secondary":
            replSetServersOptions.read_secondary = value === "true";
            break;
          case "fsync":
            dbOptions.fsync = value === "true";
            break;
          case "journal":
            dbOptions.j = value === "true";
            break;
          case "safe":
            dbOptions.safe = value === "true";
            break;
          case "nativeParser":
          case "native_parser":
            dbOptions.native_parser = value === "true";
            break;
          case "readConcernLevel":
            dbOptions.readConcern = new ReadConcern(value);
            break;
          case "connectTimeoutMS":
            serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            break;
          case "socketTimeoutMS":
            serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            break;
          case "w":
            dbOptions.w = parseInt(value, 10);
            if (isNaN(dbOptions.w))
              dbOptions.w = value;
            break;
          case "authSource":
            dbOptions.authSource = value;
            break;
          case "gssapiServiceName":
            dbOptions.gssapiServiceName = value;
            break;
          case "authMechanism":
            if (value === "GSSAPI") {
              if (object.auth == null) {
                let urlDecodeAuthPart = decodeURIComponent(authPart);
                if (urlDecodeAuthPart.indexOf("@") === -1)
                  throw new Error("GSSAPI requires a provided principal");
                object.auth = { user: urlDecodeAuthPart, password: null };
              } else {
                object.auth.user = decodeURIComponent(object.auth.user);
              }
            } else if (value === "MONGODB-X509") {
              object.auth = { user: decodeURIComponent(authPart) };
            }
            if (value !== "GSSAPI" && value !== "MONGODB-X509" && value !== "MONGODB-CR" && value !== "DEFAULT" && value !== "SCRAM-SHA-1" && value !== "SCRAM-SHA-256" && value !== "PLAIN")
              throw new Error("Only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, or SCRAM-SHA-1 is supported by authMechanism");
            dbOptions.authMechanism = value;
            break;
          case "authMechanismProperties":
            {
              let values = value.split(",");
              let o = {};
              values.forEach(function(x) {
                let v = x.split(":");
                o[v[0]] = v[1];
              });
              dbOptions.authMechanismProperties = o;
              if (typeof o.SERVICE_NAME === "string")
                dbOptions.gssapiServiceName = o.SERVICE_NAME;
              if (typeof o.SERVICE_REALM === "string")
                dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
              if (typeof o.CANONICALIZE_HOST_NAME === "string")
                dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME === "true" ? true : false;
            }
            break;
          case "wtimeoutMS":
            dbOptions.wtimeout = parseInt(value, 10);
            break;
          case "readPreference":
            if (!ReadPreference.isValid(value))
              throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
            dbOptions.readPreference = value;
            break;
          case "maxStalenessSeconds":
            dbOptions.maxStalenessSeconds = parseInt(value, 10);
            break;
          case "readPreferenceTags":
            {
              value = decodeURIComponent(value);
              let tagObject = {};
              if (value == null || value === "") {
                dbOptions.read_preference_tags.push(tagObject);
                break;
              }
              let tags = value.split(/,/);
              for (let i = 0; i < tags.length; i++) {
                let parts = tags[i].trim().split(/:/);
                tagObject[parts[0]] = parts[1];
              }
              dbOptions.read_preference_tags.push(tagObject);
            }
            break;
          case "compressors":
            {
              compression = serverOptions.compression || {};
              let compressors = value.split(",");
              if (!compressors.every(function(compressor) {
                return compressor === "snappy" || compressor === "zlib";
              })) {
                throw new Error("Compressors must be at least one of snappy or zlib");
              }
              compression.compressors = compressors;
              serverOptions.compression = compression;
            }
            break;
          case "zlibCompressionLevel":
            {
              compression = serverOptions.compression || {};
              let zlibCompressionLevel = parseInt(value, 10);
              if (zlibCompressionLevel < -1 || zlibCompressionLevel > 9) {
                throw new Error("zlibCompressionLevel must be an integer between -1 and 9");
              }
              compression.zlibCompressionLevel = zlibCompressionLevel;
              serverOptions.compression = compression;
            }
            break;
          case "retryWrites":
            dbOptions.retryWrites = value === "true";
            break;
          case "minSize":
            dbOptions.minSize = parseInt(value, 10);
            break;
          default:
            {
              let logger = Logger("URL Parser");
              logger.warn(`${name} is not supported as a connection string option`);
            }
            break;
        }
      });
      if (dbOptions.read_preference_tags.length === 0) {
        dbOptions.read_preference_tags = null;
      }
      if ((dbOptions.w === -1 || dbOptions.w === 0) && (dbOptions.journal === true || dbOptions.fsync === true || dbOptions.safe === true))
        throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync");
      if (!dbOptions.readPreference) {
        dbOptions.readPreference = "primary";
      }
      dbOptions = Object.assign(dbOptions, options2);
      object.servers = servers;
      return object;
    }
  }
});

// node_modules/mongodb-client-encryption/lib/common.js
var require_common3 = __commonJS({
  "node_modules/mongodb-client-encryption/lib/common.js"(exports2, module2) {
    init_shims();
    "use strict";
    function debug(msg) {
      if (process.env.MONGODB_CRYPT_DEBUG) {
        console.log(msg);
      }
    }
    function databaseNamespace(ns) {
      return ns.split(".")[0];
    }
    function collectionNamespace(ns) {
      return ns.split(".").slice(1).join(".");
    }
    var MongoCryptError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "MongoCryptError";
        Error.captureStackTrace(this, this.constructor);
      }
    };
    function promiseOrCallback(callback, fn) {
      if (typeof callback === "function") {
        fn(function(err) {
          if (err != null) {
            try {
              callback(err);
            } catch (error2) {
              return process.nextTick(() => {
                throw error2;
              });
            }
            return;
          }
          callback.apply(this, arguments);
        });
        return;
      }
      return new Promise((resolve2, reject) => {
        fn(function(err, res) {
          if (err != null) {
            return reject(err);
          }
          if (arguments.length > 2) {
            return resolve2(Array.prototype.slice.call(arguments, 1));
          }
          resolve2(res);
        });
      });
    }
    module2.exports = {
      debug,
      databaseNamespace,
      collectionNamespace,
      MongoCryptError,
      promiseOrCallback
    };
  }
});

// node_modules/mongodb-client-encryption/lib/stateMachine.js
var require_stateMachine = __commonJS({
  "node_modules/mongodb-client-encryption/lib/stateMachine.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(modules) {
      const tls = require("tls");
      const MongoNetworkTimeoutError = modules.mongodb.MongoNetworkTimeoutError || modules.mongodb.MongoTimeoutError;
      const common = require_common3();
      const debug = common.debug;
      const databaseNamespace = common.databaseNamespace;
      const collectionNamespace = common.collectionNamespace;
      const MongoCryptError = common.MongoCryptError;
      const BufferList = require_bl();
      const MONGOCRYPT_CTX_ERROR = 0;
      const MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
      const MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
      const MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
      const MONGOCRYPT_CTX_NEED_KMS = 4;
      const MONGOCRYPT_CTX_READY = 5;
      const MONGOCRYPT_CTX_DONE = 6;
      const HTTPS_PORT = 443;
      const stateToString = new Map([
        [MONGOCRYPT_CTX_ERROR, "MONGOCRYPT_CTX_ERROR"],
        [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, "MONGOCRYPT_CTX_NEED_MONGO_COLLINFO"],
        [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, "MONGOCRYPT_CTX_NEED_MONGO_MARKINGS"],
        [MONGOCRYPT_CTX_NEED_MONGO_KEYS, "MONGOCRYPT_CTX_NEED_MONGO_KEYS"],
        [MONGOCRYPT_CTX_NEED_KMS, "MONGOCRYPT_CTX_NEED_KMS"],
        [MONGOCRYPT_CTX_READY, "MONGOCRYPT_CTX_READY"],
        [MONGOCRYPT_CTX_DONE, "MONGOCRYPT_CTX_DONE"]
      ]);
      class StateMachine {
        constructor(options2) {
          this.options = options2 || {};
          this.bson = options2.bson;
        }
        execute(autoEncrypter, context, callback) {
          const bson = this.bson;
          const keyVaultNamespace = autoEncrypter._keyVaultNamespace;
          const keyVaultClient = autoEncrypter._keyVaultClient;
          const metaDataClient = autoEncrypter._metaDataClient;
          const mongocryptdClient = autoEncrypter._mongocryptdClient;
          const mongocryptdManager = autoEncrypter._mongocryptdManager;
          debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);
          switch (context.state) {
            case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
              const filter = bson.deserialize(context.nextMongoOperation());
              this.fetchCollectionInfo(metaDataClient, context.ns, filter, (err, collInfo) => {
                if (err) {
                  return callback(err, null);
                }
                if (collInfo) {
                  context.addMongoOperationResponse(collInfo);
                }
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
              const command = context.nextMongoOperation();
              this.markCommand(mongocryptdClient, context.ns, command, (err, markedCommand) => {
                if (err) {
                  if (err instanceof MongoNetworkTimeoutError && mongocryptdManager && !mongocryptdManager.bypassSpawn) {
                    mongocryptdManager.spawn(() => {
                      this.markCommand(mongocryptdClient, context.ns, command, (err2, markedCommand2) => {
                        if (err2)
                          return callback(err2, null);
                        context.addMongoOperationResponse(markedCommand2);
                        context.finishMongoOperation();
                        this.execute(autoEncrypter, context, callback);
                      });
                    });
                    return;
                  }
                  return callback(err, null);
                }
                context.addMongoOperationResponse(markedCommand);
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
              const filter = context.nextMongoOperation();
              this.fetchKeys(keyVaultClient, keyVaultNamespace, filter, (err, keys) => {
                if (err)
                  return callback(err, null);
                keys.forEach((key) => {
                  context.addMongoOperationResponse(bson.serialize(key));
                });
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_KMS: {
              const promises = [];
              let request;
              while (request = context.nextKMSRequest()) {
                promises.push(this.kmsRequest(request));
              }
              Promise.all(promises).then(() => {
                context.finishKMSRequests();
                this.execute(autoEncrypter, context, callback);
              }).catch((err) => {
                callback(err, null);
              });
              return;
            }
            case MONGOCRYPT_CTX_READY: {
              const finalizedContext = context.finalize();
              if (context.state === MONGOCRYPT_CTX_ERROR) {
                const message = context.status.message || "Finalization error";
                callback(new MongoCryptError(message));
                return;
              }
              callback(null, bson.deserialize(finalizedContext, this.options));
              return;
            }
            case MONGOCRYPT_CTX_ERROR: {
              const message = context.status.message;
              callback(new MongoCryptError(message));
              return;
            }
            case MONGOCRYPT_CTX_DONE:
              return;
            default:
              callback(new MongoCryptError(`Unknown state: ${context.state}`));
              return;
          }
        }
        kmsRequest(request) {
          const parsedUrl = request.endpoint.split(":");
          const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
          const options2 = { host: parsedUrl[0], servername: parsedUrl[0], port };
          const message = request.message;
          return new Promise((resolve2, reject) => {
            const buffer = new BufferList();
            const socket = tls.connect(options2, () => {
              socket.write(message);
            });
            socket.once("timeout", () => {
              socket.removeAllListeners();
              socket.destroy();
              reject(new MongoCryptError("KMS request timed out"));
            });
            socket.once("error", (err) => {
              socket.removeAllListeners();
              socket.destroy();
              const mcError = new MongoCryptError("KMS request failed");
              mcError.originalError = err;
              reject(mcError);
            });
            socket.on("data", (data) => {
              buffer.append(data);
              while (request.bytesNeeded > 0 && buffer.length) {
                const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);
                request.addResponse(buffer.slice(0, bytesNeeded));
                buffer.consume(bytesNeeded);
              }
              if (request.bytesNeeded <= 0) {
                socket.end(resolve2);
              }
            });
          });
        }
        fetchCollectionInfo(client, ns, filter, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(ns);
          client.db(dbName).listCollections(filter).toArray((err, collections) => {
            if (err) {
              callback(err, null);
              return;
            }
            const info = collections.length > 0 ? bson.serialize(collections[0]) : null;
            callback(null, info);
          });
        }
        markCommand(client, ns, command, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(ns);
          const rawCommand = bson.deserialize(command, { promoteLongs: false, promoteValues: false });
          client.db(dbName).command(rawCommand, (err, response) => {
            if (err) {
              callback(err, null);
              return;
            }
            callback(err, bson.serialize(response, this.options));
          });
        }
        fetchKeys(client, keyVaultNamespace, filter, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(keyVaultNamespace);
          const collectionName = collectionNamespace(keyVaultNamespace);
          filter = bson.deserialize(filter);
          client.db(dbName).collection(collectionName, { readConcern: { level: "majority" } }).find(filter).toArray((err, keys) => {
            if (err) {
              callback(err, null);
              return;
            }
            callback(null, keys);
          });
        }
      }
      return { StateMachine };
    };
  }
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "node_modules/file-uri-to-path/index.js"(exports2, module2) {
    init_shims();
    var sep = require("path").sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if (host == "localhost")
        host = "";
      if (host) {
        host = sep + sep + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host + path;
    }
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "node_modules/bindings/bindings.js"(exports2, module2) {
    init_shims();
    var fs = require("fs");
    var path = require("path");
    var fileURLToPath = require_file_uri_to_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        ["module_root", "build", "bindings"],
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        ["module_root", "build", "default", "bindings"],
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i2) {
        if (!(i2 in opts))
          opts[i2] = defaults[i2];
      });
      if (!opts.module_root) {
        opts.module_root = exports2.getRoot(exports2.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join.apply(null, opts.try[i].map(function(p) {
          return opts[p] || p;
        }));
        tries.push(n);
        try {
          b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
        return opts.arrow + a;
      }).join("\n"));
      err.tries = tries;
      throw err;
    }
    module2.exports = exports2 = bindings;
    exports2.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    };
    exports2.getRoot = function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
        }
        prev = dir;
        dir = join(dir, "..");
      }
    };
  }
});

// node_modules/mongodb-client-encryption/lib/mongocryptdManager.js
var require_mongocryptdManager = __commonJS({
  "node_modules/mongodb-client-encryption/lib/mongocryptdManager.js"(exports2, module2) {
    init_shims();
    "use strict";
    var spawn = require("child_process").spawn;
    var MongocryptdManager = class {
      constructor(extraOptions) {
        extraOptions = extraOptions || {};
        if (extraOptions.mongocryptdURI) {
          this.uri = extraOptions.mongocryptdURI;
        } else {
          this.uri = "mongodb://localhost:27020/?serverSelectionTimeoutMS=1000";
        }
        this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;
        this.spawnPath = extraOptions.mongocryptdSpawnPath || "";
        this.spawnArgs = [];
        if (Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
          this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
        }
        if (this.spawnArgs.filter((arg) => typeof arg === "string").every((arg) => arg.indexOf("--idleShutdownTimeoutSecs") < 0)) {
          this.spawnArgs.push("--idleShutdownTimeoutSecs", 60);
        }
      }
      spawn(callback) {
        const cmdName = this.spawnPath || "mongocryptd";
        this._child = spawn(cmdName, this.spawnArgs, {
          stdio: "ignore",
          detached: true
        });
        this._child.on("error", () => {
        });
        this._child.unref();
        process.nextTick(callback);
      }
    };
    module2.exports = { MongocryptdManager };
  }
});

// node_modules/mongodb-client-encryption/lib/cryptoCallbacks.js
var require_cryptoCallbacks = __commonJS({
  "node_modules/mongodb-client-encryption/lib/cryptoCallbacks.js"(exports2, module2) {
    init_shims();
    "use strict";
    var crypto = require("crypto");
    function aes256CbcEncryptHook(key, iv, input, output) {
      let result;
      try {
        let cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function aes256CbcDecryptHook(key, iv, input, output) {
      let result;
      try {
        let cipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function randomHook(buffer, count) {
      try {
        crypto.randomFillSync(buffer, 0, count);
      } catch (e) {
        return e;
      }
      return count;
    }
    function randomHookNode4(buffer, count) {
      let result;
      try {
        result = crypto.randomBytes(count);
      } catch (e) {
        return e;
      }
      result.copy(buffer);
      return count;
    }
    function sha256Hook(input, output) {
      let result;
      try {
        result = crypto.createHash("sha256").update(input).digest();
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function makeHmacHook(algorithm) {
      return (key, input, output) => {
        let result;
        try {
          result = crypto.createHmac(algorithm, key).update(input).digest();
        } catch (e) {
          return e;
        }
        result.copy(output);
        return result.length;
      };
    }
    function signRsaSha256Hook(key, input, output) {
      let result;
      try {
        const signer = crypto.createSign("sha256WithRSAEncryption");
        const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----
${key.toString("base64")}
-----END PRIVATE KEY-----
`);
        result = signer.update(input).end().sign(privateKey);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    module2.exports = {
      aes256CbcEncryptHook,
      aes256CbcDecryptHook,
      randomHook: typeof crypto.randomFillSync === "function" ? randomHook : randomHookNode4,
      hmacSha512Hook: makeHmacHook("sha512"),
      hmacSha256Hook: makeHmacHook("sha256"),
      sha256Hook,
      signRsaSha256Hook
    };
  }
});

// node_modules/mongodb-client-encryption/lib/autoEncrypter.js
var require_autoEncrypter = __commonJS({
  "node_modules/mongodb-client-encryption/lib/autoEncrypter.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(modules) {
      const mc = require_bindings()("mongocrypt");
      const common = require_common3();
      const databaseNamespace = common.databaseNamespace;
      const StateMachine = modules.stateMachine.StateMachine;
      const MongocryptdManager = require_mongocryptdManager().MongocryptdManager;
      const MongoClient = modules.mongodb.MongoClient;
      const MongoError = modules.mongodb.MongoError;
      const cryptoCallbacks = require_cryptoCallbacks();
      class AutoEncrypter {
        constructor(client, options2) {
          this._client = client;
          this._bson = options2.bson || client.topology.bson;
          this._mongocryptdManager = new MongocryptdManager(options2.extraOptions);
          this._mongocryptdClient = new MongoClient(this._mongocryptdManager.uri, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            serverSelectionTimeoutMS: 1e3
          });
          this._keyVaultNamespace = options2.keyVaultNamespace || "admin.datakeys";
          this._keyVaultClient = options2.keyVaultClient || client;
          this._metaDataClient = options2.metadataClient || client;
          this._bypassEncryption = typeof options2.bypassAutoEncryption === "boolean" ? options2.bypassAutoEncryption : false;
          const mongoCryptOptions = {};
          if (options2.schemaMap) {
            mongoCryptOptions.schemaMap = Buffer.isBuffer(options2.schemaMap) ? options2.schemaMap : this._bson.serialize(options2.schemaMap);
          }
          if (options2.kmsProviders) {
            mongoCryptOptions.kmsProviders = !Buffer.isBuffer(options2.kmsProviders) ? this._bson.serialize(options2.kmsProviders) : options2.kmsProviders;
          }
          if (options2.logger) {
            mongoCryptOptions.logger = options2.logger;
          }
          Object.assign(mongoCryptOptions, { cryptoCallbacks });
          this._mongocrypt = new mc.MongoCrypt(mongoCryptOptions);
          this._contextCounter = 0;
        }
        init(callback) {
          const _callback = (err, res) => {
            if (err && err.message && (err.message.match(/timed out after/) || err.message.match(/ENOTFOUND/))) {
              callback(new MongoError("Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn"));
              return;
            }
            callback(err, res);
          };
          if (this._mongocryptdManager.bypassSpawn) {
            return this._mongocryptdClient.connect(_callback);
          }
          this._mongocryptdManager.spawn(() => this._mongocryptdClient.connect(_callback));
        }
        teardown(force, callback) {
          this._mongocryptdClient.close(force, callback);
        }
        encrypt(ns, cmd, options2, callback) {
          if (typeof ns !== "string") {
            throw new TypeError("Parameter `ns` must be a string");
          }
          if (typeof cmd !== "object") {
            throw new TypeError("Parameter `cmd` must be an object");
          }
          if (typeof options2 === "function" && callback == null) {
            callback = options2;
            options2 = {};
          }
          if (this._bypassEncryption) {
            callback(void 0, cmd);
            return;
          }
          const bson = this._bson;
          const commandBuffer = Buffer.isBuffer(cmd) ? cmd : bson.serialize(cmd, options2);
          let context;
          try {
            context = this._mongocrypt.makeEncryptionContext(databaseNamespace(ns), commandBuffer);
          } catch (err) {
            callback(err, null);
            return;
          }
          context.id = this._contextCounter++;
          context.ns = ns;
          context.document = cmd;
          const stateMachine = new StateMachine(Object.assign({ bson }, options2));
          stateMachine.execute(this, context, callback);
        }
        decrypt(response, options2, callback) {
          if (typeof options2 === "function" && callback == null) {
            callback = options2;
            options2 = {};
          }
          const bson = this._bson;
          const buffer = Buffer.isBuffer(response) ? response : bson.serialize(response, options2);
          let context;
          try {
            context = this._mongocrypt.makeDecryptionContext(buffer);
          } catch (err) {
            callback(err, null);
            return;
          }
          context.id = this._contextCounter++;
          const stateMachine = new StateMachine(Object.assign({ bson }, options2));
          stateMachine.execute(this, context, callback);
        }
      }
      return { AutoEncrypter };
    };
  }
});

// node_modules/mongodb-client-encryption/lib/clientEncryption.js
var require_clientEncryption = __commonJS({
  "node_modules/mongodb-client-encryption/lib/clientEncryption.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(modules) {
      const mc = require_bindings()("mongocrypt");
      const common = require_common3();
      const databaseNamespace = common.databaseNamespace;
      const collectionNamespace = common.collectionNamespace;
      const promiseOrCallback = common.promiseOrCallback;
      const StateMachine = modules.stateMachine.StateMachine;
      const cryptoCallbacks = require_cryptoCallbacks();
      class ClientEncryption {
        constructor(client, options2) {
          this._client = client;
          this._bson = options2.bson || client.topology.bson;
          if (options2.keyVaultNamespace == null) {
            throw new TypeError("Missing required option `keyVaultNamespace`");
          }
          Object.assign(options2, { cryptoCallbacks });
          if (options2.kmsProviders && !Buffer.isBuffer(options2.kmsProviders)) {
            options2.kmsProviders = this._bson.serialize(options2.kmsProviders);
          }
          this._keyVaultNamespace = options2.keyVaultNamespace;
          this._keyVaultClient = options2.keyVaultClient || client;
          this._mongoCrypt = new mc.MongoCrypt(options2);
        }
        createDataKey(provider, options2, callback) {
          if (typeof options2 === "function") {
            callback = options2;
            options2 = {};
          }
          if (typeof options2 === "undefined") {
            options2 = {};
          }
          const bson = this._bson;
          const dataKey = Object.assign({ provider }, options2.masterKey);
          if (options2.keyAltNames && !Array.isArray(options2.keyAltNames)) {
            throw new TypeError(`Option "keyAltNames" must be an array of strings, but was of type ${typeof options2.keyAltNames}.`);
          }
          let keyAltNames = void 0;
          if (options2.keyAltNames && options2.keyAltNames.length > 0) {
            keyAltNames = options2.keyAltNames.map((keyAltName, i) => {
              if (typeof keyAltName !== "string") {
                throw new TypeError(`Option "keyAltNames" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`);
              }
              return bson.serialize({ keyAltName });
            });
          }
          const dataKeyBson = bson.serialize(dataKey);
          const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, { keyAltNames });
          const stateMachine = new StateMachine({ bson });
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, dataKey2) => {
              if (err) {
                cb(err, null);
                return;
              }
              const dbName = databaseNamespace(this._keyVaultNamespace);
              const collectionName = collectionNamespace(this._keyVaultNamespace);
              this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey2, { writeConcern: { w: "majority" } }, (err2, result) => {
                if (err2) {
                  cb(err2, null);
                  return;
                }
                cb(null, result.insertedId);
              });
            });
          });
        }
        encrypt(value, options2, callback) {
          const bson = this._bson;
          const valueBuffer = bson.serialize({ v: value });
          const contextOptions = Object.assign({}, options2);
          if (options2.keyId) {
            contextOptions.keyId = options2.keyId.buffer;
          }
          if (options2.keyAltName) {
            const keyAltName = options2.keyAltName;
            if (options2.keyId) {
              throw new TypeError(`"options" cannot contain both "keyId" and "keyAltName"`);
            }
            const keyAltNameType = typeof keyAltName;
            if (keyAltNameType !== "string") {
              throw new TypeError(`"options.keyAltName" must be of type string, but was of type ${keyAltNameType}`);
            }
            contextOptions.keyAltName = bson.serialize({ keyAltName });
          }
          const stateMachine = new StateMachine({ bson });
          const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, result) => {
              if (err) {
                cb(err, null);
                return;
              }
              cb(null, result.v);
            });
          });
        }
        decrypt(value, callback) {
          const bson = this._bson;
          const valueBuffer = bson.serialize({ v: value });
          const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);
          const stateMachine = new StateMachine({ bson });
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, result) => {
              if (err) {
                cb(err, null);
                return;
              }
              cb(null, result.v);
            });
          });
        }
      }
      return { ClientEncryption };
    };
  }
});

// node_modules/mongodb-client-encryption/index.js
var require_mongodb_client_encryption = __commonJS({
  "node_modules/mongodb-client-encryption/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var defaultModule;
    function loadDefaultModule() {
      if (!defaultModule) {
        defaultModule = extension(require_mongodb());
      }
      return defaultModule;
    }
    var MongoCryptError = require_common3().MongoCryptError;
    function extension(mongodb) {
      const modules = { mongodb };
      modules.stateMachine = require_stateMachine()(modules);
      modules.autoEncrypter = require_autoEncrypter()(modules);
      modules.clientEncryption = require_clientEncryption()(modules);
      return {
        AutoEncrypter: modules.autoEncrypter.AutoEncrypter,
        ClientEncryption: modules.clientEncryption.ClientEncryption,
        MongoCryptError
      };
    }
    module2.exports = {
      extension,
      MongoCryptError,
      get AutoEncrypter() {
        const m = loadDefaultModule();
        delete module2.exports.AutoEncrypter;
        module2.exports.AutoEncrypter = m.AutoEncrypter;
        return m.AutoEncrypter;
      },
      get ClientEncryption() {
        const m = loadDefaultModule();
        delete module2.exports.ClientEncryption;
        module2.exports.ClientEncryption = m.ClientEncryption;
        return m.ClientEncryption;
      }
    };
  }
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/mongodb/lib/encrypter.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoClient = require_mongo_client();
    var BSON2 = require_utils3().retrieveBSON();
    var MongoError = require_error().MongoError;
    try {
      require.resolve("mongodb-client-encryption");
    } catch (err) {
      throw new MongoError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project");
    }
    var mongodbClientEncryption = require_mongodb_client_encryption();
    if (typeof mongodbClientEncryption.extension !== "function") {
      throw new MongoError("loaded version of `mongodb-client-encryption` does not have property `extension`. Please make sure you are loading the correct version of `mongodb-client-encryption`");
    }
    var AutoEncrypter = mongodbClientEncryption.extension(require_mongodb()).AutoEncrypter;
    var kInternalClient = Symbol("internalClient");
    var Encrypter = class {
      constructor(client, options2) {
        this.bypassAutoEncryption = !!options2.autoEncryption.bypassAutoEncryption;
        this.needsConnecting = false;
        if (options2.maxPoolSize === 0 && options2.autoEncryption.keyVaultClient == null) {
          options2.autoEncryption.keyVaultClient = client;
        } else if (options2.autoEncryption.keyVaultClient == null) {
          options2.autoEncryption.keyVaultClient = this.getInternalClient(client);
        }
        if (this.bypassAutoEncryption) {
          options2.autoEncryption.metadataClient = void 0;
        } else if (options2.maxPoolSize === 0) {
          options2.autoEncryption.metadataClient = client;
        } else {
          options2.autoEncryption.metadataClient = this.getInternalClient(client);
        }
        options2.autoEncryption.bson = Encrypter.makeBSON(options2);
        this.autoEncrypter = new AutoEncrypter(client, options2.autoEncryption);
      }
      getInternalClient(client) {
        if (!this[kInternalClient]) {
          const clonedOptions = {};
          for (const key of Object.keys(client.s.options)) {
            if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].indexOf(key) !== -1)
              continue;
            clonedOptions[key] = client.s.options[key];
          }
          clonedOptions.minPoolSize = 0;
          const allEvents = [
            "commandStarted",
            "commandSucceeded",
            "commandFailed",
            "serverOpening",
            "serverClosed",
            "serverDescriptionChanged",
            "serverHeartbeatStarted",
            "serverHeartbeatSucceeded",
            "serverHeartbeatFailed",
            "topologyOpening",
            "topologyClosed",
            "topologyDescriptionChanged",
            "joined",
            "left",
            "ping",
            "ha",
            "connectionPoolCreated",
            "connectionPoolClosed",
            "connectionCreated",
            "connectionReady",
            "connectionClosed",
            "connectionCheckOutStarted",
            "connectionCheckOutFailed",
            "connectionCheckedOut",
            "connectionCheckedIn",
            "connectionPoolCleared"
          ];
          this[kInternalClient] = new MongoClient(client.s.url, clonedOptions);
          for (const eventName of allEvents) {
            for (const listener of client.listeners(eventName)) {
              this[kInternalClient].on(eventName, listener);
            }
          }
          client.on("newListener", (eventName, listener) => {
            this[kInternalClient].on(eventName, listener);
          });
          this.needsConnecting = true;
        }
        return this[kInternalClient];
      }
      connectInternalClient(callback) {
        if (this.needsConnecting) {
          this.needsConnecting = false;
          return this[kInternalClient].connect(callback);
        }
        return callback();
      }
      close(client, force, callback) {
        this.autoEncrypter.teardown((e) => {
          if (this[kInternalClient] && client !== this[kInternalClient]) {
            return this[kInternalClient].close(force, callback);
          }
          callback(e);
        });
      }
      static makeBSON(options2) {
        return (options2 || {}).bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]);
      }
    };
    module2.exports = { Encrypter };
  }
});

// node_modules/mongodb/lib/operations/connect.js
var require_connect2 = __commonJS({
  "node_modules/mongodb/lib/operations/connect.js"(exports2, module2) {
    init_shims();
    "use strict";
    var deprecate = require("util").deprecate;
    var Logger = require_core().Logger;
    var MongoCredentials = require_core().MongoCredentials;
    var MongoError = require_core().MongoError;
    var Mongos = require_mongos2();
    var NativeTopology = require_native_topology();
    var parse = require_core().parseConnectionString;
    var ReadConcern = require_read_concern();
    var ReadPreference = require_core().ReadPreference;
    var ReplSet = require_replset2();
    var Server = require_server3();
    var ServerSessionPool = require_core().Sessions.ServerSessionPool;
    var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var fs = require("fs");
    var WriteConcern = require_write_concern();
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var client;
    function loadClient() {
      if (!client) {
        client = require_mongo_client();
      }
      return client;
    }
    var legacyParse = deprecate(require_url_parser(), "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.");
    var AUTH_MECHANISM_INTERNAL_MAP = {
      DEFAULT: "default",
      PLAIN: "plain",
      GSSAPI: "gssapi",
      "MONGODB-CR": "mongocr",
      "MONGODB-X509": "x509",
      "MONGODB-AWS": "mongodb-aws",
      "SCRAM-SHA-1": "scram-sha-1",
      "SCRAM-SHA-256": "scram-sha-256"
    };
    var monitoringEvents = [
      "timeout",
      "close",
      "serverOpening",
      "serverDescriptionChanged",
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "serverClosed",
      "topologyOpening",
      "topologyClosed",
      "topologyDescriptionChanged",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ];
    var VALID_AUTH_MECHANISMS = new Set([
      "DEFAULT",
      "PLAIN",
      "GSSAPI",
      "MONGODB-CR",
      "MONGODB-X509",
      "MONGODB-AWS",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    var validOptionNames = [
      "poolSize",
      "ssl",
      "sslValidate",
      "sslCA",
      "sslCert",
      "sslKey",
      "sslPass",
      "sslCRL",
      "autoReconnect",
      "noDelay",
      "keepAlive",
      "keepAliveInitialDelay",
      "connectTimeoutMS",
      "family",
      "socketTimeoutMS",
      "reconnectTries",
      "reconnectInterval",
      "ha",
      "haInterval",
      "replicaSet",
      "secondaryAcceptableLatencyMS",
      "acceptableLatencyMS",
      "connectWithNoPrimary",
      "authSource",
      "w",
      "wtimeout",
      "j",
      "writeConcern",
      "forceServerObjectId",
      "serializeFunctions",
      "ignoreUndefined",
      "raw",
      "bufferMaxEntries",
      "readPreference",
      "pkFactory",
      "promiseLibrary",
      "readConcern",
      "maxStalenessSeconds",
      "loggerLevel",
      "logger",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs",
      "bsonRegExp",
      "domainsEnabled",
      "checkServerIdentity",
      "validateOptions",
      "appname",
      "auth",
      "user",
      "password",
      "authMechanism",
      "compression",
      "fsync",
      "readPreferenceTags",
      "numberOfRetries",
      "auto_reconnect",
      "minSize",
      "monitorCommands",
      "retryWrites",
      "retryReads",
      "useNewUrlParser",
      "useUnifiedTopology",
      "serverSelectionTimeoutMS",
      "useRecoveryToken",
      "autoEncryption",
      "driverInfo",
      "tls",
      "tlsInsecure",
      "tlsinsecure",
      "tlsAllowInvalidCertificates",
      "tlsAllowInvalidHostnames",
      "tlsCAFile",
      "tlsCertificateFile",
      "tlsCertificateKeyFile",
      "tlsCertificateKeyFilePassword",
      "minHeartbeatFrequencyMS",
      "heartbeatFrequencyMS",
      "directConnection",
      "appName",
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ];
    var ignoreOptionNames = ["native_parser"];
    var legacyOptionNames = ["server", "replset", "replSet", "mongos", "db"];
    function validOptions(options2) {
      const _validOptions = validOptionNames.concat(legacyOptionNames);
      for (const name in options2) {
        if (ignoreOptionNames.indexOf(name) !== -1) {
          continue;
        }
        if (_validOptions.indexOf(name) === -1) {
          if (options2.validateOptions) {
            return new MongoError(`option ${name} is not supported`);
          } else {
            emitWarningOnce(`the options [${name}] is not supported`);
          }
        }
        if (legacyOptionNames.indexOf(name) !== -1) {
          emitWarningOnce(`the server/replset/mongos/db options are deprecated, all their options are supported at the top level of the options object [${validOptionNames}]`);
        }
      }
    }
    var LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {
      obj[name.toLowerCase()] = name;
      return obj;
    }, {});
    function addListeners(mongoClient, topology) {
      topology.on("authenticated", createListener(mongoClient, "authenticated"));
      topology.on("error", createListener(mongoClient, "error"));
      topology.on("timeout", createListener(mongoClient, "timeout"));
      topology.on("close", createListener(mongoClient, "close"));
      topology.on("parseError", createListener(mongoClient, "parseError"));
      topology.once("open", createListener(mongoClient, "open"));
      topology.once("fullsetup", createListener(mongoClient, "fullsetup"));
      topology.once("all", createListener(mongoClient, "all"));
      topology.on("reconnect", createListener(mongoClient, "reconnect"));
    }
    function assignTopology(client2, topology) {
      client2.topology = topology;
      if (!(topology instanceof NativeTopology)) {
        topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);
      }
    }
    function clearAllEvents(topology) {
      monitoringEvents.forEach((event) => topology.removeAllListeners(event));
    }
    function collectEvents(mongoClient, topology) {
      let MongoClient = loadClient();
      const collectedEvents = [];
      if (mongoClient instanceof MongoClient) {
        monitoringEvents.forEach((event) => {
          topology.on(event, (object1, object2) => {
            if (event === "open") {
              collectedEvents.push({ event, object1: mongoClient });
            } else {
              collectedEvents.push({ event, object1, object2 });
            }
          });
        });
      }
      return collectedEvents;
    }
    function resolveTLSOptions(options2) {
      if (options2.tls == null) {
        return;
      }
      ["sslCA", "sslKey", "sslCert"].forEach((optionName) => {
        if (options2[optionName]) {
          options2[optionName] = fs.readFileSync(options2[optionName]);
        }
      });
    }
    function connect(mongoClient, url, options2, callback) {
      options2 = Object.assign({}, options2);
      if (callback == null) {
        throw new Error("no callback function provided");
      }
      let didRequestAuthentication = false;
      const logger = Logger("MongoClient", options2);
      if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {
        return connectWithUrl(mongoClient, url, options2, connectCallback);
      }
      const useNewUrlParser = options2.useNewUrlParser !== false;
      const parseFn = useNewUrlParser ? parse : legacyParse;
      const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;
      parseFn(url, options2, (err, _object) => {
        if (err)
          return callback(err);
        const object = transform(_object);
        const _finalOptions = createUnifiedOptions(object, options2);
        if (_finalOptions.socketTimeoutMS == null)
          _finalOptions.socketTimeoutMS = 0;
        if (_finalOptions.connectTimeoutMS == null)
          _finalOptions.connectTimeoutMS = 1e4;
        if (_finalOptions.retryWrites == null)
          _finalOptions.retryWrites = true;
        if (_finalOptions.useRecoveryToken == null)
          _finalOptions.useRecoveryToken = true;
        if (_finalOptions.readPreference == null)
          _finalOptions.readPreference = "primary";
        if (_finalOptions.db_options && _finalOptions.db_options.auth) {
          delete _finalOptions.db_options.auth;
        }
        resolveTLSOptions(_finalOptions);
        mongoClient.s.options = _finalOptions;
        mongoClient.s.readPreference = ReadPreference.fromOptions(_finalOptions);
        mongoClient.s.writeConcern = WriteConcern.fromOptions(_finalOptions);
        if (object.servers.length === 0) {
          return callback(new Error("connection string must contain at least one seed host"));
        }
        if (_finalOptions.auth && !_finalOptions.credentials) {
          try {
            didRequestAuthentication = true;
            _finalOptions.credentials = generateCredentials(mongoClient, _finalOptions.auth.user, _finalOptions.auth.password, _finalOptions);
          } catch (err2) {
            return callback(err2);
          }
        }
        if (_finalOptions.useUnifiedTopology) {
          return createTopology(mongoClient, "unified", _finalOptions, connectCallback);
        }
        emitWarningOnce("Current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.");
        if (_finalOptions.replicaSet || _finalOptions.rs_name) {
          return createTopology(mongoClient, "replicaset", _finalOptions, connectCallback);
        } else if (object.servers.length > 1) {
          return createTopology(mongoClient, "mongos", _finalOptions, connectCallback);
        } else {
          return createServer(mongoClient, _finalOptions, connectCallback);
        }
      });
      function connectCallback(err, topology) {
        const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;
        if (err && err.message === "no mongos proxies found in seed list") {
          if (logger.isWarn()) {
            logger.warn(warningMessage);
          }
          return callback(new MongoError(warningMessage));
        }
        if (didRequestAuthentication) {
          mongoClient.emit("authenticated", null, true);
        }
        callback(err, topology);
      }
    }
    function connectWithUrl(mongoClient, url, options2, connectCallback) {
      assignTopology(mongoClient, url);
      addListeners(mongoClient, url);
      relayEvents(mongoClient, url);
      let finalOptions = Object.assign({}, options2);
      if (typeof options2.readPreference === "string" || typeof options2.read_preference === "string") {
        finalOptions.readPreference = new ReadPreference(options2.readPreference || options2.read_preference);
      }
      const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;
      if (isDoingAuth && !finalOptions.credentials) {
        try {
          finalOptions.credentials = generateCredentials(mongoClient, finalOptions.user, finalOptions.password, finalOptions);
        } catch (err) {
          return connectCallback(err, url);
        }
      }
      return url.connect(finalOptions, connectCallback);
    }
    function createListener(mongoClient, event) {
      const eventSet = new Set(["all", "fullsetup", "open", "reconnect"]);
      return (v1, v2) => {
        if (eventSet.has(event)) {
          return mongoClient.emit(event, mongoClient);
        }
        mongoClient.emit(event, v1, v2);
      };
    }
    function createServer(mongoClient, options2, callback) {
      options2.promiseLibrary = mongoClient.s.promiseLibrary;
      const servers = translateOptions(options2);
      const server = servers[0];
      const collectedEvents = collectEvents(mongoClient, server);
      server.connect(options2, (err, topology) => {
        if (err) {
          server.close(true);
          return callback(err);
        }
        clearAllEvents(server);
        relayEvents(mongoClient, server);
        addListeners(mongoClient, server);
        const ismaster = topology.lastIsMaster();
        assignTopology(mongoClient, topology);
        if (ismaster && ismaster.msg === "isdbgrid") {
          topology.close();
          return createTopology(mongoClient, "mongos", options2, callback);
        }
        replayEvents(mongoClient, collectedEvents);
        callback(err, topology);
      });
    }
    var DEPRECATED_UNIFIED_EVENTS = new Set([
      "reconnect",
      "reconnectFailed",
      "attemptReconnect",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ]);
    function registerDeprecatedEventNotifiers(client2) {
      client2.on("newListener", (eventName) => {
        if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {
          emitDeprecationWarning(`The \`${eventName}\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
        }
      });
    }
    function createTopology(mongoClient, topologyType, options2, callback) {
      options2.promiseLibrary = mongoClient.s.promiseLibrary;
      const translationOptions = {};
      if (topologyType === "unified")
        translationOptions.createServers = false;
      const servers = translateOptions(options2, translationOptions);
      if (options2.autoEncryption != null) {
        const Encrypter = require_encrypter().Encrypter;
        options2.encrypter = new Encrypter(mongoClient, options2);
        options2.autoEncrypter = options2.encrypter.autoEncrypter;
      }
      let topology;
      if (topologyType === "mongos") {
        topology = new Mongos(servers, options2);
      } else if (topologyType === "replicaset") {
        topology = new ReplSet(servers, options2);
      } else if (topologyType === "unified") {
        topology = new NativeTopology(options2.servers, options2);
        registerDeprecatedEventNotifiers(mongoClient);
      }
      addListeners(mongoClient, topology);
      relayEvents(mongoClient, topology);
      assignTopology(mongoClient, topology);
      if (options2.autoEncrypter) {
        options2.autoEncrypter.init((err) => {
          if (err) {
            callback(err);
            return;
          }
          topology.connect(options2, (err2) => {
            if (err2) {
              topology.close(true);
              callback(err2);
              return;
            }
            options2.encrypter.connectInternalClient((error2) => {
              if (error2)
                return callback(error2);
              callback(void 0, topology);
            });
          });
        });
        return;
      }
      topology.connect(options2, (err) => {
        if (err) {
          topology.close(true);
          return callback(err);
        }
        callback(void 0, topology);
        return;
      });
    }
    function createUnifiedOptions(finalOptions, options2) {
      const childOptions = [
        "mongos",
        "server",
        "db",
        "replset",
        "db_options",
        "server_options",
        "rs_options",
        "mongos_options"
      ];
      const noMerge = ["readconcern", "compression", "autoencryption"];
      const skip = ["w", "wtimeout", "j", "journal", "fsync", "writeconcern"];
      for (const name in options2) {
        if (skip.indexOf(name.toLowerCase()) !== -1) {
          continue;
        } else if (noMerge.indexOf(name.toLowerCase()) !== -1) {
          finalOptions[name] = options2[name];
        } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {
          finalOptions = mergeOptions(finalOptions, options2[name], false);
        } else {
          if (options2[name] && typeof options2[name] === "object" && !Buffer.isBuffer(options2[name]) && !Array.isArray(options2[name])) {
            finalOptions = mergeOptions(finalOptions, options2[name], true);
          } else {
            finalOptions[name] = options2[name];
          }
        }
      }
      const optionsWriteConcern = WriteConcern.fromOptions(options2);
      if (optionsWriteConcern) {
        finalOptions.writeConcern = Object.assign({}, finalOptions.writeConcern, optionsWriteConcern);
      }
      return finalOptions;
    }
    function generateCredentials(client2, username, password, options2) {
      options2 = Object.assign({}, options2);
      const source = options2.authSource || options2.authdb || options2.dbName;
      const authMechanismRaw = options2.authMechanism || "DEFAULT";
      const authMechanism = authMechanismRaw.toUpperCase();
      const mechanismProperties = options2.authMechanismProperties;
      if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {
        throw MongoError.create({
          message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,
          driver: true
        });
      }
      return new MongoCredentials({
        mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],
        mechanismProperties,
        source,
        username,
        password
      });
    }
    function legacyTransformUrlOptions(object) {
      return mergeOptions(createUnifiedOptions({}, object), object, false);
    }
    function mergeOptions(target, source, flatten) {
      for (const name in source) {
        if (source[name] && typeof source[name] === "object" && flatten) {
          target = mergeOptions(target, source[name], flatten);
        } else {
          target[name] = source[name];
        }
      }
      return target;
    }
    function relayEvents(mongoClient, topology) {
      const serverOrCommandEvents = [
        "commandStarted",
        "commandSucceeded",
        "commandFailed",
        "serverOpening",
        "serverClosed",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "joined",
        "left",
        "ping",
        "ha"
      ].concat(CMAP_EVENT_NAMES);
      serverOrCommandEvents.forEach((event) => {
        topology.on(event, (object1, object2) => {
          mongoClient.emit(event, object1, object2);
        });
      });
    }
    function replayEvents(mongoClient, events) {
      for (let i = 0; i < events.length; i++) {
        mongoClient.emit(events[i].event, events[i].object1, events[i].object2);
      }
    }
    function transformUrlOptions(_object) {
      let object = Object.assign({ servers: _object.hosts }, _object.options);
      for (let name in object) {
        const camelCaseName = LEGACY_OPTIONS_MAP[name];
        if (camelCaseName) {
          object[camelCaseName] = object[name];
        }
      }
      const hasUsername = _object.auth && _object.auth.username;
      const hasAuthMechanism = _object.options && _object.options.authMechanism;
      if (hasUsername || hasAuthMechanism) {
        object.auth = Object.assign({}, _object.auth);
        if (object.auth.db) {
          object.authSource = object.authSource || object.auth.db;
        }
        if (object.auth.username) {
          object.auth.user = object.auth.username;
        }
      }
      if (_object.defaultDatabase) {
        object.dbName = _object.defaultDatabase;
      }
      if (object.maxPoolSize) {
        object.poolSize = object.maxPoolSize;
      }
      if (object.readConcernLevel) {
        object.readConcern = new ReadConcern(object.readConcernLevel);
      }
      if (object.wTimeoutMS) {
        object.wtimeout = object.wTimeoutMS;
        object.wTimeoutMS = void 0;
      }
      if (_object.srvHost) {
        object.srvHost = _object.srvHost;
      }
      const wcKeys = ["w", "wtimeout", "j", "journal", "fsync"];
      for (const key of wcKeys) {
        if (object[key] !== void 0) {
          if (object.writeConcern === void 0)
            object.writeConcern = {};
          object.writeConcern[key] = object[key];
          object[key] = void 0;
        }
      }
      return object;
    }
    function translateOptions(options2, translationOptions) {
      translationOptions = Object.assign({}, { createServers: true }, translationOptions);
      if (typeof options2.readPreference === "string" || typeof options2.read_preference === "string") {
        options2.readPreference = new ReadPreference(options2.readPreference || options2.read_preference);
      }
      if (options2.readPreference && (options2.readPreferenceTags || options2.read_preference_tags)) {
        options2.readPreference.tags = options2.readPreferenceTags || options2.read_preference_tags;
      }
      if (options2.maxStalenessSeconds) {
        options2.readPreference.maxStalenessSeconds = options2.maxStalenessSeconds;
      }
      if (options2.socketTimeoutMS == null)
        options2.socketTimeoutMS = 0;
      if (options2.connectTimeoutMS == null)
        options2.connectTimeoutMS = 1e4;
      if (!translationOptions.createServers) {
        return;
      }
      return options2.servers.map((serverObj) => {
        return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options2) : new Server(serverObj.host, serverObj.port, options2);
      });
    }
    module2.exports = { validOptions, connect };
  }
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS({
  "node_modules/mongodb/lib/mongo_client.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ChangeStream = require_change_stream();
    var Db = require_db();
    var EventEmitter = require("events").EventEmitter;
    var inherits2 = require("util").inherits;
    var MongoError = require_core().MongoError;
    var deprecate = require("util").deprecate;
    var WriteConcern = require_write_concern();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils4().maybePromise;
    var NativeTopology = require_native_topology();
    var connect = require_connect2().connect;
    var validOptions = require_connect2().validOptions;
    function MongoClient(url, options2) {
      if (!(this instanceof MongoClient))
        return new MongoClient(url, options2);
      EventEmitter.call(this);
      if (options2 && options2.autoEncryption)
        require_encrypter();
      this.s = {
        url,
        options: options2 || {},
        promiseLibrary: options2 && options2.promiseLibrary || Promise,
        dbCache: new Map(),
        sessions: new Set(),
        writeConcern: WriteConcern.fromOptions(options2),
        readPreference: ReadPreference.fromOptions(options2) || ReadPreference.primary,
        namespace: new MongoDBNamespace("admin")
      };
    }
    inherits2(MongoClient, EventEmitter);
    Object.defineProperty(MongoClient.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(MongoClient.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        return this.s.readPreference;
      }
    });
    MongoClient.prototype.connect = function(callback) {
      if (typeof callback === "string") {
        throw new TypeError("`connect` only accepts a callback");
      }
      const client = this;
      return maybePromise(this, callback, (cb) => {
        const err = validOptions(client.s.options);
        if (err)
          return cb(err);
        connect(client, client.s.url, client.s.options, (err2) => {
          if (err2)
            return cb(err2);
          cb(null, client);
        });
      });
    };
    MongoClient.prototype.logout = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      if (typeof callback === "function")
        callback(null, true);
    }, "Multiple authentication is prohibited on a connected client, please only authenticate once per MongoClient");
    MongoClient.prototype.close = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      const client = this;
      return maybePromise(this, callback, (cb) => {
        const completeClose = (err) => {
          client.emit("close", client);
          if (!(client.topology instanceof NativeTopology)) {
            for (const item of client.s.dbCache) {
              item[1].emit("close", client);
            }
          }
          client.removeAllListeners("close");
          cb(err);
        };
        if (client.topology == null) {
          completeClose();
          return;
        }
        client.topology.close(force, (err) => {
          const encrypter = client.topology.s.options.encrypter;
          if (encrypter) {
            return encrypter.close(client, force, (err2) => {
              completeClose(err || err2);
            });
          }
          completeClose(err);
        });
      });
    };
    MongoClient.prototype.db = function(dbName, options2) {
      options2 = options2 || {};
      if (!dbName) {
        dbName = this.s.options.dbName;
      }
      const finalOptions = Object.assign({}, this.s.options, options2);
      if (this.s.dbCache.has(dbName) && finalOptions.returnNonCachedInstance !== true) {
        return this.s.dbCache.get(dbName);
      }
      finalOptions.promiseLibrary = this.s.promiseLibrary;
      if (!this.topology) {
        throw new MongoError("MongoClient must be connected before calling MongoClient.prototype.db");
      }
      const db = new Db(dbName, this.topology, finalOptions);
      this.s.dbCache.set(dbName, db);
      return db;
    };
    MongoClient.prototype.isConnected = function(options2) {
      options2 = options2 || {};
      if (!this.topology)
        return false;
      return this.topology.isConnected(options2);
    };
    MongoClient.connect = function(url, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      const mongoClient = new MongoClient(url, options2);
      return mongoClient.connect(callback);
    };
    MongoClient.prototype.startSession = function(options2) {
      options2 = Object.assign({ explicit: true }, options2);
      if (!this.topology) {
        throw new MongoError("Must connect to a server before calling this method");
      }
      return this.topology.startSession(options2, this.s.options);
    };
    MongoClient.prototype.withSession = function(options2, operation) {
      if (typeof options2 === "function")
        operation = options2, options2 = void 0;
      const session = this.startSession(options2);
      let cleanupHandler = (err, result, opts) => {
        cleanupHandler = () => {
          throw new ReferenceError("cleanupHandler was called too many times");
        };
        opts = Object.assign({ throw: true }, opts);
        session.endSession();
        if (err) {
          if (opts.throw)
            throw err;
          return Promise.reject(err);
        }
      };
      try {
        const result = operation(session);
        return Promise.resolve(result).then((result2) => cleanupHandler(null, result2)).catch((err) => cleanupHandler(err, null, { throw: true }));
      } catch (err) {
        return cleanupHandler(err, null, { throw: false });
      }
    };
    MongoClient.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    MongoClient.prototype.getLogger = function() {
      return this.s.options.logger;
    };
    module2.exports = MongoClient;
  }
});

// node_modules/mongodb/lib/gridfs/chunk.js
var require_chunk = __commonJS({
  "node_modules/mongodb/lib/gridfs/chunk.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Binary2 = require_core().BSON.Binary;
    var ObjectID2 = require_core().BSON.ObjectID;
    var Buffer2 = require_safe_buffer().Buffer;
    var Chunk = function(file, mongoObject, writeConcern) {
      if (!(this instanceof Chunk))
        return new Chunk(file, mongoObject);
      this.file = file;
      var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
      this.writeConcern = writeConcern || { w: 1 };
      this.objectId = mongoObjectFinal._id == null ? new ObjectID2() : mongoObjectFinal._id;
      this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
      this.data = new Binary2();
      if (typeof mongoObjectFinal.data === "string") {
        var buffer = Buffer2.alloc(mongoObjectFinal.data.length);
        buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, "binary");
        this.data = new Binary2(buffer);
      } else if (Array.isArray(mongoObjectFinal.data)) {
        buffer = Buffer2.alloc(mongoObjectFinal.data.length);
        var data = mongoObjectFinal.data.join("");
        buffer.write(data, 0, data.length, "binary");
        this.data = new Binary2(buffer);
      } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === "Binary") {
        this.data = mongoObjectFinal.data;
      } else if (!Buffer2.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {
        throw Error("Illegal chunk format");
      }
      this.internalPosition = 0;
    };
    Chunk.prototype.write = function(data, callback) {
      this.data.write(data, this.internalPosition, data.length, "binary");
      this.internalPosition = this.data.length();
      if (callback != null)
        return callback(null, this);
      return this;
    };
    Chunk.prototype.read = function(length) {
      length = length == null || length === 0 ? this.length() : length;
      if (this.length() - this.internalPosition + 1 >= length) {
        var data = this.data.read(this.internalPosition, length);
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return "";
      }
    };
    Chunk.prototype.readSlice = function(length) {
      if (this.length() - this.internalPosition >= length) {
        var data = null;
        if (this.data.buffer != null) {
          data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
        } else {
          data = Buffer2.alloc(length);
          length = this.data.readInto(data, this.internalPosition);
        }
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return null;
      }
    };
    Chunk.prototype.eof = function() {
      return this.internalPosition === this.length() ? true : false;
    };
    Chunk.prototype.getc = function() {
      return this.read(1);
    };
    Chunk.prototype.rewind = function() {
      this.internalPosition = 0;
      this.data = new Binary2();
    };
    Chunk.prototype.save = function(options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      self2.file.chunkCollection(function(err, collection) {
        if (err)
          return callback(err);
        var writeOptions = { upsert: true };
        for (var name in options2)
          writeOptions[name] = options2[name];
        for (name in self2.writeConcern)
          writeOptions[name] = self2.writeConcern[name];
        if (self2.data.length() > 0) {
          self2.buildMongoObject(function(mongoObject) {
            var options3 = { forceServerObjectId: true };
            for (var name2 in self2.writeConcern) {
              options3[name2] = self2.writeConcern[name2];
            }
            collection.replaceOne({ _id: self2.objectId }, mongoObject, writeOptions, function(err2) {
              callback(err2, self2);
            });
          });
        } else {
          callback(null, self2);
        }
      });
    };
    Chunk.prototype.buildMongoObject = function(callback) {
      var mongoObject = {
        files_id: this.file.fileId,
        n: this.chunkNumber,
        data: this.data
      };
      if (this.objectId != null)
        mongoObject._id = this.objectId;
      callback(mongoObject);
    };
    Chunk.prototype.length = function() {
      return this.data.length();
    };
    Object.defineProperty(Chunk.prototype, "position", {
      enumerable: true,
      get: function() {
        return this.internalPosition;
      },
      set: function(value) {
        this.internalPosition = value;
      }
    });
    Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
    module2.exports = Chunk;
  }
});

// node_modules/mongodb/lib/gridfs/grid_store.js
var require_grid_store = __commonJS({
  "node_modules/mongodb/lib/gridfs/grid_store.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Chunk = require_chunk();
    var ObjectID2 = require_core().BSON.ObjectID;
    var ReadPreference = require_core().ReadPreference;
    var Buffer2 = require_safe_buffer().Buffer;
    var fs = require("fs");
    var f = require("util").format;
    var util = require("util");
    var MongoError = require_core().MongoError;
    var inherits2 = util.inherits;
    var Duplex = require("stream").Duplex;
    var shallowClone = require_utils4().shallowClone;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var deprecate = require("util").deprecate;
    var REFERENCE_BY_FILENAME = 0;
    var REFERENCE_BY_ID = 1;
    var deprecationFn = deprecate(() => {
    }, "GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead");
    var GridStore = function GridStore2(db, id, filename, mode, options2) {
      deprecationFn();
      if (!(this instanceof GridStore2))
        return new GridStore2(db, id, filename, mode, options2);
      this.db = db;
      if (typeof options2 === "undefined")
        options2 = {};
      if (typeof mode === "undefined") {
        mode = filename;
        filename = void 0;
      } else if (typeof mode === "object") {
        options2 = mode;
        mode = filename;
        filename = void 0;
      }
      if (id && id._bsontype === "ObjectID") {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      } else if (typeof filename === "undefined") {
        this.referenceBy = REFERENCE_BY_FILENAME;
        this.filename = id;
        if (mode.indexOf("w") != null) {
          this.fileId = new ObjectID2();
        }
      } else {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      }
      this.mode = mode == null ? "r" : mode;
      this.options = options2 || {};
      this.isOpen = false;
      this.root = this.options["root"] == null ? GridStore2.DEFAULT_ROOT_COLLECTION : this.options["root"];
      this.position = 0;
      this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.primary;
      this.writeConcern = _getWriteConcern(db, this.options);
      this.internalChunkSize = this.options["chunkSize"] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options["chunkSize"];
      var promiseLibrary = this.options.promiseLibrary || Promise;
      this.promiseLibrary = promiseLibrary;
      Object.defineProperty(this, "chunkSize", {
        enumerable: true,
        get: function() {
          return this.internalChunkSize;
        },
        set: function(value) {
          if (!(this.mode[0] === "w" && this.position === 0 && this.uploadDate == null)) {
            this.internalChunkSize = this.internalChunkSize;
          } else {
            this.internalChunkSize = value;
          }
        }
      });
      Object.defineProperty(this, "md5", {
        enumerable: true,
        get: function() {
          return this.internalMd5;
        }
      });
      Object.defineProperty(this, "chunkNumber", {
        enumerable: true,
        get: function() {
          return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
        }
      });
    };
    GridStore.prototype.open = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.mode !== "w" && this.mode !== "w+" && this.mode !== "r") {
        throw MongoError.create({ message: "Illegal mode " + this.mode, driver: true });
      }
      return executeLegacyOperation(this.db.s.topology, open, [this, options2, callback], {
        skipSessions: true
      });
    };
    var open = function(self2, options2, callback) {
      var writeConcern = _getWriteConcern(self2.db, self2.options);
      if (self2.mode === "w" || self2.mode === "w+") {
        var collection = self2.collection();
        collection.ensureIndex([["filename", 1]], writeConcern, function() {
          var chunkCollection = self2.chunkCollection();
          var chunkIndexOptions = shallowClone(writeConcern);
          chunkIndexOptions.unique = true;
          chunkCollection.ensureIndex([
            ["files_id", 1],
            ["n", 1]
          ], chunkIndexOptions, function() {
            _open(self2, writeConcern, function(err, r) {
              if (err)
                return callback(err);
              self2.isOpen = true;
              callback(err, r);
            });
          });
        });
      } else {
        _open(self2, writeConcern, function(err, r) {
          if (err)
            return callback(err);
          self2.isOpen = true;
          callback(err, r);
        });
      }
    };
    GridStore.prototype.eof = function() {
      return this.position === this.length ? true : false;
    };
    GridStore.prototype.getc = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, getc, [this, options2, callback], {
        skipSessions: true
      });
    };
    var getc = function(self2, options2, callback) {
      if (self2.eof()) {
        callback(null, null);
      } else if (self2.currentChunk.eof()) {
        nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
          self2.currentChunk = chunk;
          self2.position = self2.position + 1;
          callback(err, self2.currentChunk.getc());
        });
      } else {
        self2.position = self2.position + 1;
        callback(null, self2.currentChunk.getc());
      }
    };
    GridStore.prototype.puts = function(string, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      var finalString = string.match(/\n$/) == null ? string + "\n" : string;
      return executeLegacyOperation(this.db.s.topology, this.write.bind(this), [finalString, options2, callback], { skipSessions: true });
    };
    GridStore.prototype.stream = function() {
      return new GridStoreStream(this);
    };
    GridStore.prototype.write = function write(data, close2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, _writeNormal, [this, data, close2, options2, callback], { skipSessions: true });
    };
    GridStore.prototype.destroy = function destroy() {
      if (!this.writable)
        return;
      this.readable = false;
      if (this.writable) {
        this.writable = false;
        this._q.length = 0;
        this.emit("close");
      }
    };
    GridStore.prototype.writeFile = function(file, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, writeFile, [this, file, options2, callback], {
        skipSessions: true
      });
    };
    var writeFile = function(self2, file, options2, callback) {
      if (typeof file === "string") {
        fs.open(file, "r", function(err, fd) {
          if (err)
            return callback(err);
          self2.writeFile(fd, callback);
        });
        return;
      }
      self2.open(function(err, self3) {
        if (err)
          return callback(err, self3);
        fs.fstat(file, function(err2, stats) {
          if (err2)
            return callback(err2, self3);
          var offset = 0;
          var index2 = 0;
          var writeChunk = function() {
            var _buffer = Buffer2.alloc(self3.chunkSize);
            fs.read(file, _buffer, 0, _buffer.length, offset, function(err3, bytesRead, data) {
              if (err3)
                return callback(err3, self3);
              offset = offset + bytesRead;
              var chunk = new Chunk(self3, { n: index2++ }, self3.writeConcern);
              chunk.write(data.slice(0, bytesRead), function(err4, chunk2) {
                if (err4)
                  return callback(err4, self3);
                chunk2.save({}, function(err5) {
                  if (err5)
                    return callback(err5, self3);
                  self3.position = self3.position + bytesRead;
                  self3.currentChunk = chunk2;
                  if (offset >= stats.size) {
                    fs.close(file, function(err6) {
                      if (err6)
                        return callback(err6);
                      self3.close(function(err7) {
                        if (err7)
                          return callback(err7, self3);
                        return callback(null, self3);
                      });
                    });
                  } else {
                    return process.nextTick(writeChunk);
                  }
                });
              });
            });
          };
          process.nextTick(writeChunk);
        });
      });
    };
    GridStore.prototype.close = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, close, [this, options2, callback], {
        skipSessions: true
      });
    };
    var close = function(self2, options2, callback) {
      if (self2.mode[0] === "w") {
        options2 = Object.assign({}, self2.writeConcern, options2);
        if (self2.currentChunk != null && self2.currentChunk.position > 0) {
          self2.currentChunk.save({}, function(err) {
            if (err && typeof callback === "function")
              return callback(err);
            self2.collection(function(err2, files) {
              if (err2 && typeof callback === "function")
                return callback(err2);
              if (self2.uploadDate != null) {
                buildMongoObject(self2, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options2, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              } else {
                self2.uploadDate = new Date();
                buildMongoObject(self2, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options2, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              }
            });
          });
        } else {
          self2.collection(function(err, files) {
            if (err && typeof callback === "function")
              return callback(err);
            self2.uploadDate = new Date();
            buildMongoObject(self2, function(err2, mongoObject) {
              if (err2) {
                if (typeof callback === "function")
                  return callback(err2);
                else
                  throw err2;
              }
              files.save(mongoObject, options2, function(err3) {
                if (typeof callback === "function")
                  callback(err3, mongoObject);
              });
            });
          });
        }
      } else if (self2.mode[0] === "r") {
        if (typeof callback === "function")
          callback(null, null);
      } else {
        if (typeof callback === "function")
          callback(MongoError.create({ message: f("Illegal mode %s", self2.mode), driver: true }));
      }
    };
    GridStore.prototype.chunkCollection = function(callback) {
      if (typeof callback === "function")
        return this.db.collection(this.root + ".chunks", callback);
      return this.db.collection(this.root + ".chunks");
    };
    GridStore.prototype.unlink = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, unlink, [this, options2, callback], {
        skipSessions: true
      });
    };
    var unlink = function(self2, options2, callback) {
      deleteChunks(self2, function(err) {
        if (err !== null) {
          err.message = "at deleteChunks: " + err.message;
          return callback(err);
        }
        self2.collection(function(err2, collection) {
          if (err2 !== null) {
            err2.message = "at collection: " + err2.message;
            return callback(err2);
          }
          collection.remove({ _id: self2.fileId }, self2.writeConcern, function(err3) {
            callback(err3, self2);
          });
        });
      });
    };
    GridStore.prototype.collection = function(callback) {
      if (typeof callback === "function")
        this.db.collection(this.root + ".files", callback);
      return this.db.collection(this.root + ".files");
    };
    GridStore.prototype.readlines = function(separator, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : "\n";
      separator = separator || "\n";
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, readlines, [this, separator, options2, callback], { skipSessions: true });
    };
    var readlines = function(self2, separator, options2, callback) {
      self2.read(function(err, data) {
        if (err)
          return callback(err);
        var items = data.toString().split(separator);
        items = items.length > 0 ? items.splice(0, items.length - 1) : [];
        for (var i = 0; i < items.length; i++) {
          items[i] = items[i] + separator;
        }
        callback(null, items);
      });
    };
    GridStore.prototype.rewind = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, rewind, [this, options2, callback], {
        skipSessions: true
      });
    };
    var rewind = function(self2, options2, callback) {
      if (self2.currentChunk.chunkNumber !== 0) {
        if (self2.mode[0] === "w") {
          deleteChunks(self2, function(err) {
            if (err)
              return callback(err);
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.position = 0;
            callback(null, self2);
          });
        } else {
          self2.currentChunk(0, function(err, chunk) {
            if (err)
              return callback(err);
            self2.currentChunk = chunk;
            self2.currentChunk.rewind();
            self2.position = 0;
            callback(null, self2);
          });
        }
      } else {
        self2.currentChunk.rewind();
        self2.position = 0;
        callback(null, self2);
      }
    };
    GridStore.prototype.read = function(length, buffer, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      buffer = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, read2, [this, length, buffer, options2, callback], { skipSessions: true });
    };
    var read2 = function(self2, length, buffer, options2, callback) {
      var finalLength = length == null ? self2.length - self2.position : length;
      var finalBuffer = buffer == null ? Buffer2.alloc(finalLength) : buffer;
      finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
      if (self2.currentChunk.length() - self2.currentChunk.position + finalBuffer._index >= finalLength) {
        var slice = self2.currentChunk.readSlice(finalLength - finalBuffer._index);
        slice.copy(finalBuffer, finalBuffer._index);
        self2.position = self2.position + finalBuffer.length;
        if (finalLength === 0 && finalBuffer.length === 0)
          return callback(MongoError.create({ message: "File does not exist", driver: true }), null);
        return callback(null, finalBuffer);
      }
      slice = self2.currentChunk.readSlice(self2.currentChunk.length() - self2.currentChunk.position);
      slice.copy(finalBuffer, finalBuffer._index);
      finalBuffer._index += slice.length;
      nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
        if (err)
          return callback(err);
        if (chunk.length() > 0) {
          self2.currentChunk = chunk;
          self2.read(length, finalBuffer, callback);
        } else {
          if (finalBuffer._index > 0) {
            callback(null, finalBuffer);
          } else {
            callback(MongoError.create({
              message: "no chunks found for file, possibly corrupt",
              driver: true
            }), null);
          }
        }
      });
    };
    GridStore.prototype.tell = function(callback) {
      var self2 = this;
      if (typeof callback === "function")
        return callback(null, this.position);
      return new self2.promiseLibrary(function(resolve2) {
        resolve2(self2.position);
      });
    };
    GridStore.prototype.seek = function(position, seekLocation, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      seekLocation = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, seek, [this, position, seekLocation, options2, callback], { skipSessions: true });
    };
    var seek = function(self2, position, seekLocation, options2, callback) {
      if (self2.mode !== "r") {
        return callback(MongoError.create({ message: "seek is only supported for mode r", driver: true }));
      }
      var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
      var finalPosition = position;
      var targetPosition = 0;
      if (seekLocationFinal === GridStore.IO_SEEK_CUR) {
        targetPosition = self2.position + finalPosition;
      } else if (seekLocationFinal === GridStore.IO_SEEK_END) {
        targetPosition = self2.length + finalPosition;
      } else {
        targetPosition = finalPosition;
      }
      var newChunkNumber = Math.floor(targetPosition / self2.chunkSize);
      var seekChunk = function() {
        nthChunk(self2, newChunkNumber, function(err, chunk) {
          if (err)
            return callback(err, null);
          if (chunk == null)
            return callback(new Error("no chunk found"));
          self2.currentChunk = chunk;
          self2.position = targetPosition;
          self2.currentChunk.position = self2.position % self2.chunkSize;
          callback(err, self2);
        });
      };
      seekChunk();
    };
    var _open = function(self2, options2, callback) {
      var collection = self2.collection();
      var query = self2.referenceBy === REFERENCE_BY_ID ? { _id: self2.fileId } : { filename: self2.filename };
      query = self2.fileId == null && self2.filename == null ? null : query;
      options2.readPreference = self2.readPreference;
      if (query != null) {
        collection.findOne(query, options2, function(err, doc) {
          if (err) {
            return error2(err);
          }
          if (doc != null) {
            self2.fileId = doc._id;
            self2.filename = self2.mode === "r" || self2.filename === void 0 ? doc.filename : self2.filename;
            self2.contentType = doc.contentType;
            self2.internalChunkSize = doc.chunkSize;
            self2.uploadDate = doc.uploadDate;
            self2.aliases = doc.aliases;
            self2.length = doc.length;
            self2.metadata = doc.metadata;
            self2.internalMd5 = doc.md5;
          } else if (self2.mode !== "r") {
            self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
            self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
            self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
            self2.length = 0;
          } else {
            self2.length = 0;
            var txtId = self2.fileId._bsontype === "ObjectID" ? self2.fileId.toHexString() : self2.fileId;
            return error2(MongoError.create({
              message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? txtId : self2.filename),
              driver: true
            }), self2);
          }
          if (self2.mode === "r") {
            nthChunk(self2, 0, options2, function(err2, chunk) {
              if (err2)
                return error2(err2);
              self2.currentChunk = chunk;
              self2.position = 0;
              callback(null, self2);
            });
          } else if (self2.mode === "w" && doc) {
            deleteChunks(self2, options2, function(err2) {
              if (err2)
                return error2(err2);
              self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
              self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
              self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
              self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
              self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
              self2.position = 0;
              callback(null, self2);
            });
          } else if (self2.mode === "w") {
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          } else if (self2.mode === "w+") {
            nthChunk(self2, lastChunkNumber(self2), options2, function(err2, chunk) {
              if (err2)
                return error2(err2);
              self2.currentChunk = chunk == null ? new Chunk(self2, { n: 0 }, self2.writeConcern) : chunk;
              self2.currentChunk.position = self2.currentChunk.data.length();
              self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
              self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
              self2.position = self2.length;
              callback(null, self2);
            });
          }
        });
      } else {
        self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
        self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
        self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
        self2.length = 0;
        if (self2.mode === "w") {
          deleteChunks(self2, options2, function(err) {
            if (err)
              return error2(err);
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          });
        } else if (self2.mode === "w+") {
          nthChunk(self2, lastChunkNumber(self2), options2, function(err, chunk) {
            if (err)
              return error2(err);
            self2.currentChunk = chunk == null ? new Chunk(self2, { n: 0 }, self2.writeConcern) : chunk;
            self2.currentChunk.position = self2.currentChunk.data.length();
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = self2.length;
            callback(null, self2);
          });
        }
      }
      function error2(err) {
        if (error2.err)
          return;
        callback(error2.err = err);
      }
    };
    var writeBuffer = function(self2, buffer, close2, callback) {
      if (typeof close2 === "function") {
        callback = close2;
        close2 = null;
      }
      var finalClose = typeof close2 === "boolean" ? close2 : false;
      if (self2.mode !== "w") {
        callback(MongoError.create({
          message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? self2.referenceBy : self2.filename),
          driver: true
        }), null);
      } else {
        if (self2.currentChunk.position + buffer.length >= self2.chunkSize) {
          var previousChunkNumber = self2.currentChunk.chunkNumber;
          var leftOverDataSize = self2.chunkSize - self2.currentChunk.position;
          var firstChunkData = buffer.slice(0, leftOverDataSize);
          var leftOverData = buffer.slice(leftOverDataSize);
          var chunksToWrite = [self2.currentChunk.write(firstChunkData)];
          while (leftOverData.length >= self2.chunkSize) {
            var newChunk = new Chunk(self2, { n: previousChunkNumber + 1 }, self2.writeConcern);
            firstChunkData = leftOverData.slice(0, self2.chunkSize);
            leftOverData = leftOverData.slice(self2.chunkSize);
            previousChunkNumber = previousChunkNumber + 1;
            newChunk.write(firstChunkData);
            chunksToWrite.push(newChunk);
          }
          self2.currentChunk = new Chunk(self2, { n: previousChunkNumber + 1 }, self2.writeConcern);
          if (leftOverData.length > 0)
            self2.currentChunk.write(leftOverData);
          self2.position = self2.position + buffer.length;
          var numberOfChunksToWrite = chunksToWrite.length;
          for (var i = 0; i < chunksToWrite.length; i++) {
            chunksToWrite[i].save({}, function(err) {
              if (err)
                return callback(err);
              numberOfChunksToWrite = numberOfChunksToWrite - 1;
              if (numberOfChunksToWrite <= 0) {
                if (finalClose) {
                  return self2.close(function(err2) {
                    callback(err2, self2);
                  });
                }
                return callback(null, self2);
              }
            });
          }
        } else {
          self2.position = self2.position + buffer.length;
          self2.currentChunk.write(buffer);
          if (finalClose) {
            return self2.close(function(err) {
              callback(err, self2);
            });
          }
          return callback(null, self2);
        }
      }
    };
    var buildMongoObject = function(self2, callback) {
      var mongoObject = {
        _id: self2.fileId,
        filename: self2.filename,
        contentType: self2.contentType,
        length: self2.position ? self2.position : 0,
        chunkSize: self2.chunkSize,
        uploadDate: self2.uploadDate,
        aliases: self2.aliases,
        metadata: self2.metadata
      };
      var md5Command = { filemd5: self2.fileId, root: self2.root };
      self2.db.command(md5Command, function(err, results) {
        if (err)
          return callback(err);
        mongoObject.md5 = results.md5;
        callback(null, mongoObject);
      });
    };
    var nthChunk = function(self2, chunkNumber, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || self2.writeConcern;
      options2.readPreference = self2.readPreference;
      self2.chunkCollection().findOne({ files_id: self2.fileId, n: chunkNumber }, options2, function(err, chunk) {
        if (err)
          return callback(err);
        var finalChunk = chunk == null ? {} : chunk;
        callback(null, new Chunk(self2, finalChunk, self2.writeConcern));
      });
    };
    var lastChunkNumber = function(self2) {
      return Math.floor((self2.length ? self2.length - 1 : 0) / self2.chunkSize);
    };
    var deleteChunks = function(self2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || self2.writeConcern;
      if (self2.fileId != null) {
        self2.chunkCollection().remove({ files_id: self2.fileId }, options2, function(err) {
          if (err)
            return callback(err, false);
          callback(null, true);
        });
      } else {
        callback(null, true);
      }
    };
    GridStore.DEFAULT_ROOT_COLLECTION = "fs";
    GridStore.DEFAULT_CONTENT_TYPE = "binary/octet-stream";
    GridStore.IO_SEEK_SET = 0;
    GridStore.IO_SEEK_CUR = 1;
    GridStore.IO_SEEK_END = 2;
    GridStore.exist = function(db, fileIdObject, rootCollection, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, exists, [db, fileIdObject, rootCollection, options2, callback], { skipSessions: true });
    };
    var exists = function(db, fileIdObject, rootCollection, options2, callback) {
      var readPreference = options2.readPreference || ReadPreference.PRIMARY;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        var query = typeof fileIdObject === "string" || Object.prototype.toString.call(fileIdObject) === "[object RegExp]" ? { filename: fileIdObject } : { _id: fileIdObject };
        if (fileIdObject != null && typeof fileIdObject === "object" && Object.prototype.toString.call(fileIdObject) !== "[object RegExp]") {
          query = fileIdObject;
        }
        collection.findOne(query, { readPreference }, function(err2, item) {
          if (err2)
            return callback(err2);
          callback(null, item == null ? false : true);
        });
      });
    };
    GridStore.list = function(db, rootCollection, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, list, [db, rootCollection, options2, callback], {
        skipSessions: true
      });
    };
    var list = function(db, rootCollection, options2, callback) {
      if (rootCollection != null && typeof rootCollection === "object") {
        options2 = rootCollection;
        rootCollection = null;
      }
      var readPreference = options2.readPreference || ReadPreference.primary;
      var byId = options2["id"] != null ? options2["id"] : false;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      var items = [];
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        collection.find({}, { readPreference }, function(err2, cursor) {
          if (err2)
            return callback(err2);
          cursor.each(function(err3, item) {
            if (item != null) {
              items.push(byId ? item._id : item.filename);
            } else {
              callback(err3, items);
            }
          });
        });
      });
    };
    GridStore.read = function(db, name, length, offset, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      offset = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, readStatic, [db, name, length, offset, options2, callback], { skipSessions: true });
    };
    var readStatic = function(db, name, length, offset, options2, callback) {
      new GridStore(db, name, "r", options2).open(function(err, gridStore) {
        if (err)
          return callback(err);
        if (offset && offset >= gridStore.length)
          return callback("offset larger than size of file", null);
        if (length && length > gridStore.length)
          return callback("length is larger than the size of the file", null);
        if (offset && length && offset + length > gridStore.length)
          return callback("offset and length is larger than the size of the file", null);
        if (offset != null) {
          gridStore.seek(offset, function(err2, gridStore2) {
            if (err2)
              return callback(err2);
            gridStore2.read(length, callback);
          });
        } else {
          gridStore.read(length, callback);
        }
      });
    };
    GridStore.readlines = function(db, name, separator, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, readlinesStatic, [db, name, separator, options2, callback], { skipSessions: true });
    };
    var readlinesStatic = function(db, name, separator, options2, callback) {
      var finalSeperator = separator == null ? "\n" : separator;
      new GridStore(db, name, "r", options2).open(function(err, gridStore) {
        if (err)
          return callback(err);
        gridStore.readlines(finalSeperator, callback);
      });
    };
    GridStore.unlink = function(db, names, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, unlinkStatic, [this, db, names, options2, callback], {
        skipSessions: true
      });
    };
    var unlinkStatic = function(self2, db, names, options2, callback) {
      var writeConcern = _getWriteConcern(db, options2);
      if (names.constructor === Array) {
        var tc = 0;
        for (var i = 0; i < names.length; i++) {
          ++tc;
          GridStore.unlink(db, names[i], options2, function() {
            if (--tc === 0) {
              callback(null, self2);
            }
          });
        }
      } else {
        new GridStore(db, names, "w", options2).open(function(err, gridStore) {
          if (err)
            return callback(err);
          deleteChunks(gridStore, function(err2) {
            if (err2)
              return callback(err2);
            gridStore.collection(function(err3, collection) {
              if (err3)
                return callback(err3);
              collection.remove({ _id: gridStore.fileId }, writeConcern, function(err4) {
                callback(err4, self2);
              });
            });
          });
        });
      }
    };
    var _writeNormal = function(self2, data, close2, options2, callback) {
      if (Buffer2.isBuffer(data)) {
        return writeBuffer(self2, data, close2, callback);
      } else {
        return writeBuffer(self2, Buffer2.from(data, "binary"), close2, callback);
      }
    };
    var _setWriteConcernHash = function(options2) {
      const baseOptions = Object.assign(options2, options2.writeConcern);
      var finalOptions = {};
      if (baseOptions.w != null)
        finalOptions.w = baseOptions.w;
      if (baseOptions.journal === true)
        finalOptions.j = baseOptions.journal;
      if (baseOptions.j === true)
        finalOptions.j = baseOptions.j;
      if (baseOptions.fsync === true)
        finalOptions.fsync = baseOptions.fsync;
      if (baseOptions.wtimeout != null)
        finalOptions.wtimeout = baseOptions.wtimeout;
      return finalOptions;
    };
    var _getWriteConcern = function(self2, options2) {
      var finalOptions = { w: 1 };
      options2 = options2 || {};
      if (options2.writeConcern != null || options2.w != null || typeof options2.j === "boolean" || typeof options2.journal === "boolean" || typeof options2.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(options2);
      } else if (options2.safe != null && typeof options2.safe === "object") {
        finalOptions = _setWriteConcernHash(options2.safe);
      } else if (typeof options2.safe === "boolean") {
        finalOptions = { w: options2.safe ? 1 : 0 };
      } else if (self2.options.writeConcern != null || self2.options.w != null || typeof self2.options.j === "boolean" || typeof self2.options.journal === "boolean" || typeof self2.options.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(self2.options);
      } else if (self2.safe && (self2.safe.w != null || typeof self2.safe.j === "boolean" || typeof self2.safe.journal === "boolean" || typeof self2.safe.fsync === "boolean")) {
        finalOptions = _setWriteConcernHash(self2.safe);
      } else if (typeof self2.safe === "boolean") {
        finalOptions = { w: self2.safe ? 1 : 0 };
      }
      if (finalOptions.w < 1 && (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true))
        throw MongoError.create({
          message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true",
          driver: true
        });
      return finalOptions;
    };
    var GridStoreStream = function(gs) {
      Duplex.call(this);
      this.gs = gs;
      this.endCalled = false;
      this.totalBytesToRead = this.gs.length - this.gs.position;
      this.seekPosition = this.gs.position;
    };
    inherits2(GridStoreStream, Duplex);
    GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
    GridStoreStream.prototype.pipe = function(destination) {
      var self2 = this;
      if (!self2.gs.isOpen) {
        self2.gs.open(function(err) {
          if (err)
            return self2.emit("error", err);
          self2.totalBytesToRead = self2.gs.length - self2.gs.position;
          self2._pipe.apply(self2, [destination]);
        });
      } else {
        self2.totalBytesToRead = self2.gs.length - self2.gs.position;
        self2._pipe.apply(self2, [destination]);
      }
      return destination;
    };
    GridStoreStream.prototype._read = function() {
      var self2 = this;
      var read3 = function() {
        self2.gs.read(length, function(err, buffer) {
          if (err && !self2.endCalled)
            return self2.emit("error", err);
          if (self2.endCalled || buffer == null)
            return self2.push(null);
          if (buffer.length <= self2.totalBytesToRead) {
            self2.totalBytesToRead = self2.totalBytesToRead - buffer.length;
            self2.push(buffer);
          } else if (buffer.length > self2.totalBytesToRead) {
            self2.totalBytesToRead = self2.totalBytesToRead - buffer._index;
            self2.push(buffer.slice(0, buffer._index));
          }
          if (self2.totalBytesToRead <= 0) {
            self2.endCalled = true;
          }
        });
      };
      var length = self2.gs.length < self2.gs.chunkSize ? self2.gs.length - self2.seekPosition : self2.gs.chunkSize;
      if (!self2.gs.isOpen) {
        self2.gs.open(function(err) {
          self2.totalBytesToRead = self2.gs.length - self2.gs.position;
          if (err)
            return self2.emit("error", err);
          read3();
        });
      } else {
        read3();
      }
    };
    GridStoreStream.prototype.destroy = function() {
      this.pause();
      this.endCalled = true;
      this.gs.close();
      this.emit("end");
    };
    GridStoreStream.prototype.write = function(chunk) {
      var self2 = this;
      if (self2.endCalled)
        return self2.emit("error", MongoError.create({ message: "attempting to write to stream after end called", driver: true }));
      if (!self2.gs.isOpen) {
        self2.gs.open(function() {
          self2.gs.isOpen = true;
          self2.gs.write(chunk, function() {
            process.nextTick(function() {
              self2.emit("drain");
            });
          });
        });
        return false;
      } else {
        self2.gs.write(chunk, function() {
          self2.emit("drain");
        });
        return true;
      }
    };
    GridStoreStream.prototype.end = function(chunk, encoding, callback) {
      var self2 = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      chunk = args.length ? args.shift() : null;
      encoding = args.length ? args.shift() : null;
      self2.endCalled = true;
      if (chunk) {
        self2.gs.write(chunk, function() {
          self2.gs.close(function() {
            if (typeof callback === "function")
              callback();
            self2.emit("end");
          });
        });
      }
      self2.gs.close(function() {
        if (typeof callback === "function")
          callback();
        self2.emit("end");
      });
    };
    module2.exports = GridStore;
  }
});

// node_modules/mongodb/lib/gridfs-stream/download.js
var require_download = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/download.js"(exports2, module2) {
    init_shims();
    "use strict";
    var stream = require("stream");
    var util = require("util");
    module2.exports = GridFSBucketReadStream;
    function GridFSBucketReadStream(chunks, files, readPreference, filter, options2) {
      this.s = {
        bytesRead: 0,
        chunks,
        cursor: null,
        expected: 0,
        files,
        filter,
        init: false,
        expectedEnd: 0,
        file: null,
        options: options2,
        readPreference
      };
      stream.Readable.call(this);
    }
    util.inherits(GridFSBucketReadStream, stream.Readable);
    GridFSBucketReadStream.prototype._read = function() {
      var _this = this;
      if (this.destroyed) {
        return;
      }
      waitForFile(_this, function() {
        doRead(_this);
      });
    };
    GridFSBucketReadStream.prototype.start = function(start) {
      throwIfInitialized(this);
      this.s.options.start = start;
      return this;
    };
    GridFSBucketReadStream.prototype.end = function(end) {
      throwIfInitialized(this);
      this.s.options.end = end;
      return this;
    };
    GridFSBucketReadStream.prototype.abort = function(callback) {
      var _this = this;
      this.push(null);
      this.destroyed = true;
      if (this.s.cursor) {
        this.s.cursor.close(function(error2) {
          _this.emit("close");
          callback && callback(error2);
        });
      } else {
        if (!this.s.init) {
          _this.emit("close");
        }
        callback && callback();
      }
    };
    function throwIfInitialized(self2) {
      if (self2.s.init) {
        throw new Error("You cannot change options after the stream has enteredflowing mode!");
      }
    }
    function doRead(_this) {
      if (_this.destroyed) {
        return;
      }
      _this.s.cursor.next(function(error2, doc) {
        if (_this.destroyed) {
          return;
        }
        if (error2) {
          return __handleError(_this, error2);
        }
        if (!doc) {
          _this.push(null);
          process.nextTick(() => {
            _this.s.cursor.close(function(error3) {
              if (error3) {
                __handleError(_this, error3);
                return;
              }
              _this.emit("close");
            });
          });
          return;
        }
        var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
        var expectedN = _this.s.expected++;
        var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);
        if (doc.n > expectedN) {
          var errmsg = "ChunkIsMissing: Got unexpected n: " + doc.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        if (doc.n < expectedN) {
          errmsg = "ExtraChunk: Got unexpected n: " + doc.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
        if (buf.length !== expectedLength) {
          if (bytesRemaining <= 0) {
            errmsg = "ExtraChunk: Got unexpected n: " + doc.n;
            return __handleError(_this, new Error(errmsg));
          }
          errmsg = "ChunkIsWrongSize: Got unexpected length: " + buf.length + ", expected: " + expectedLength;
          return __handleError(_this, new Error(errmsg));
        }
        _this.s.bytesRead += buf.length;
        if (buf.length === 0) {
          return _this.push(null);
        }
        var sliceStart = null;
        var sliceEnd = null;
        if (_this.s.bytesToSkip != null) {
          sliceStart = _this.s.bytesToSkip;
          _this.s.bytesToSkip = 0;
        }
        const atEndOfStream = expectedN === _this.s.expectedEnd - 1;
        const bytesLeftToRead = _this.s.options.end - _this.s.bytesToSkip;
        if (atEndOfStream && _this.s.bytesToTrim != null) {
          sliceEnd = _this.s.file.chunkSize - _this.s.bytesToTrim;
        } else if (_this.s.options.end && bytesLeftToRead < doc.data.length()) {
          sliceEnd = bytesLeftToRead;
        }
        if (sliceStart != null || sliceEnd != null) {
          buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
        }
        _this.push(buf);
      });
    }
    function init2(self2) {
      var findOneOptions = {};
      if (self2.s.readPreference) {
        findOneOptions.readPreference = self2.s.readPreference;
      }
      if (self2.s.options && self2.s.options.sort) {
        findOneOptions.sort = self2.s.options.sort;
      }
      if (self2.s.options && self2.s.options.skip) {
        findOneOptions.skip = self2.s.options.skip;
      }
      self2.s.files.findOne(self2.s.filter, findOneOptions, function(error2, doc) {
        if (error2) {
          return __handleError(self2, error2);
        }
        if (!doc) {
          var identifier = self2.s.filter._id ? self2.s.filter._id.toString() : self2.s.filter.filename;
          var errmsg = "FileNotFound: file " + identifier + " was not found";
          var err = new Error(errmsg);
          err.code = "ENOENT";
          return __handleError(self2, err);
        }
        if (doc.length <= 0) {
          self2.push(null);
          return;
        }
        if (self2.destroyed) {
          self2.emit("close");
          return;
        }
        try {
          self2.s.bytesToSkip = handleStartOption(self2, doc, self2.s.options);
        } catch (error3) {
          return __handleError(self2, error3);
        }
        var filter = { files_id: doc._id };
        if (self2.s.options && self2.s.options.start != null) {
          var skip = Math.floor(self2.s.options.start / doc.chunkSize);
          if (skip > 0) {
            filter["n"] = { $gte: skip };
          }
        }
        self2.s.cursor = self2.s.chunks.find(filter).sort({ n: 1 });
        if (self2.s.readPreference) {
          self2.s.cursor.setReadPreference(self2.s.readPreference);
        }
        self2.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
        self2.s.file = doc;
        try {
          self2.s.bytesToTrim = handleEndOption(self2, doc, self2.s.cursor, self2.s.options);
        } catch (error3) {
          return __handleError(self2, error3);
        }
        self2.emit("file", doc);
      });
    }
    function waitForFile(_this, callback) {
      if (_this.s.file) {
        return callback();
      }
      if (!_this.s.init) {
        init2(_this);
        _this.s.init = true;
      }
      _this.once("file", function() {
        callback();
      });
    }
    function handleStartOption(stream2, doc, options2) {
      if (options2 && options2.start != null) {
        if (options2.start > doc.length) {
          throw new Error("Stream start (" + options2.start + ") must not be more than the length of the file (" + doc.length + ")");
        }
        if (options2.start < 0) {
          throw new Error("Stream start (" + options2.start + ") must not be negative");
        }
        if (options2.end != null && options2.end < options2.start) {
          throw new Error("Stream start (" + options2.start + ") must not be greater than stream end (" + options2.end + ")");
        }
        stream2.s.bytesRead = Math.floor(options2.start / doc.chunkSize) * doc.chunkSize;
        stream2.s.expected = Math.floor(options2.start / doc.chunkSize);
        return options2.start - stream2.s.bytesRead;
      }
    }
    function handleEndOption(stream2, doc, cursor, options2) {
      if (options2 && options2.end != null) {
        if (options2.end > doc.length) {
          throw new Error("Stream end (" + options2.end + ") must not be more than the length of the file (" + doc.length + ")");
        }
        if (options2.start < 0) {
          throw new Error("Stream end (" + options2.end + ") must not be negative");
        }
        var start = options2.start != null ? Math.floor(options2.start / doc.chunkSize) : 0;
        cursor.limit(Math.ceil(options2.end / doc.chunkSize) - start);
        stream2.s.expectedEnd = Math.ceil(options2.end / doc.chunkSize);
        return Math.ceil(options2.end / doc.chunkSize) * doc.chunkSize - options2.end;
      }
    }
    function __handleError(_this, error2) {
      _this.emit("error", error2);
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/upload.js
var require_upload = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/upload.js"(exports2, module2) {
    init_shims();
    "use strict";
    var core = require_core();
    var crypto = require("crypto");
    var stream = require("stream");
    var util = require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    var ERROR_NAMESPACE_NOT_FOUND = 26;
    module2.exports = GridFSBucketWriteStream;
    function GridFSBucketWriteStream(bucket, filename, options2) {
      options2 = options2 || {};
      stream.Writable.call(this, options2);
      this.bucket = bucket;
      this.chunks = bucket.s._chunksCollection;
      this.filename = filename;
      this.files = bucket.s._filesCollection;
      this.options = options2;
      this.done = false;
      this.id = options2.id ? options2.id : core.BSON.ObjectId();
      this.chunkSizeBytes = this.options.chunkSizeBytes;
      this.bufToStore = Buffer2.alloc(this.chunkSizeBytes);
      this.length = 0;
      this.md5 = !options2.disableMD5 && crypto.createHash("md5");
      this.n = 0;
      this.pos = 0;
      this.state = {
        streamEnd: false,
        outstandingRequests: 0,
        errored: false,
        aborted: false,
        promiseLibrary: this.bucket.s.promiseLibrary
      };
      if (!this.bucket.s.calledOpenUploadStream) {
        this.bucket.s.calledOpenUploadStream = true;
        var _this = this;
        checkIndexes(this, function() {
          _this.bucket.s.checkedIndexes = true;
          _this.bucket.emit("index");
        });
      }
    }
    util.inherits(GridFSBucketWriteStream, stream.Writable);
    GridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {
      var _this = this;
      return waitForIndexes(this, function() {
        return doWrite(_this, chunk, encoding, callback);
      });
    };
    GridFSBucketWriteStream.prototype.abort = function(callback) {
      if (this.state.streamEnd) {
        var error2 = new Error("Cannot abort a stream that has already completed");
        if (typeof callback === "function") {
          return callback(error2);
        }
        return this.state.promiseLibrary.reject(error2);
      }
      if (this.state.aborted) {
        error2 = new Error("Cannot call abort() on a stream twice");
        if (typeof callback === "function") {
          return callback(error2);
        }
        return this.state.promiseLibrary.reject(error2);
      }
      this.state.aborted = true;
      this.chunks.deleteMany({ files_id: this.id }, function(error3) {
        if (typeof callback === "function")
          callback(error3);
      });
    };
    GridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {
      var _this = this;
      if (typeof chunk === "function") {
        callback = chunk, chunk = null, encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding, encoding = null;
      }
      if (checkAborted(this, callback)) {
        return;
      }
      this.state.streamEnd = true;
      if (callback) {
        this.once("finish", function(result) {
          callback(null, result);
        });
      }
      if (!chunk) {
        waitForIndexes(this, function() {
          writeRemnant(_this);
        });
        return;
      }
      this.write(chunk, encoding, function() {
        writeRemnant(_this);
      });
    };
    function __handleError(_this, error2, callback) {
      if (_this.state.errored) {
        return;
      }
      _this.state.errored = true;
      if (callback) {
        return callback(error2);
      }
      _this.emit("error", error2);
    }
    function createChunkDoc(filesId, n, data) {
      return {
        _id: core.BSON.ObjectId(),
        files_id: filesId,
        n,
        data
      };
    }
    function checkChunksIndex(_this, callback) {
      _this.chunks.listIndexes().toArray(function(error2, indexes) {
        if (error2) {
          if (error2.code === ERROR_NAMESPACE_NOT_FOUND) {
            var index2 = { files_id: 1, n: 1 };
            _this.chunks.createIndex(index2, { background: false, unique: true }, function(error3) {
              if (error3) {
                return callback(error3);
              }
              callback();
            });
            return;
          }
          return callback(error2);
        }
        var hasChunksIndex = false;
        indexes.forEach(function(index3) {
          if (index3.key) {
            var keys = Object.keys(index3.key);
            if (keys.length === 2 && index3.key.files_id === 1 && index3.key.n === 1) {
              hasChunksIndex = true;
            }
          }
        });
        if (hasChunksIndex) {
          callback();
        } else {
          index2 = { files_id: 1, n: 1 };
          var indexOptions = getWriteOptions(_this);
          indexOptions.background = false;
          indexOptions.unique = true;
          _this.chunks.createIndex(index2, indexOptions, function(error3) {
            if (error3) {
              return callback(error3);
            }
            callback();
          });
        }
      });
    }
    function checkDone(_this, callback) {
      if (_this.done)
        return true;
      if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {
        _this.done = true;
        var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes, _this.md5 && _this.md5.digest("hex"), _this.filename, _this.options.contentType, _this.options.aliases, _this.options.metadata);
        if (checkAborted(_this, callback)) {
          return false;
        }
        _this.files.insertOne(filesDoc, getWriteOptions(_this), function(error2) {
          if (error2) {
            return __handleError(_this, error2, callback);
          }
          _this.emit("finish", filesDoc);
          _this.emit("close");
        });
        return true;
      }
      return false;
    }
    function checkIndexes(_this, callback) {
      _this.files.findOne({}, { _id: 1 }, function(error2, doc) {
        if (error2) {
          return callback(error2);
        }
        if (doc) {
          return callback();
        }
        _this.files.listIndexes().toArray(function(error3, indexes) {
          if (error3) {
            if (error3.code === ERROR_NAMESPACE_NOT_FOUND) {
              var index2 = { filename: 1, uploadDate: 1 };
              _this.files.createIndex(index2, { background: false }, function(error4) {
                if (error4) {
                  return callback(error4);
                }
                checkChunksIndex(_this, callback);
              });
              return;
            }
            return callback(error3);
          }
          var hasFileIndex = false;
          indexes.forEach(function(index3) {
            var keys = Object.keys(index3.key);
            if (keys.length === 2 && index3.key.filename === 1 && index3.key.uploadDate === 1) {
              hasFileIndex = true;
            }
          });
          if (hasFileIndex) {
            checkChunksIndex(_this, callback);
          } else {
            index2 = { filename: 1, uploadDate: 1 };
            var indexOptions = getWriteOptions(_this);
            indexOptions.background = false;
            _this.files.createIndex(index2, indexOptions, function(error4) {
              if (error4) {
                return callback(error4);
              }
              checkChunksIndex(_this, callback);
            });
          }
        });
      });
    }
    function createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {
      var ret2 = {
        _id,
        length,
        chunkSize,
        uploadDate: new Date(),
        filename
      };
      if (md5) {
        ret2.md5 = md5;
      }
      if (contentType) {
        ret2.contentType = contentType;
      }
      if (aliases) {
        ret2.aliases = aliases;
      }
      if (metadata) {
        ret2.metadata = metadata;
      }
      return ret2;
    }
    function doWrite(_this, chunk, encoding, callback) {
      if (checkAborted(_this, callback)) {
        return false;
      }
      var inputBuf = Buffer2.isBuffer(chunk) ? chunk : Buffer2.from(chunk, encoding);
      _this.length += inputBuf.length;
      if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
        inputBuf.copy(_this.bufToStore, _this.pos);
        _this.pos += inputBuf.length;
        callback && callback();
        return true;
      }
      var inputBufRemaining = inputBuf.length;
      var spaceRemaining = _this.chunkSizeBytes - _this.pos;
      var numToCopy = Math.min(spaceRemaining, inputBuf.length);
      var outstandingRequests = 0;
      while (inputBufRemaining > 0) {
        var inputBufPos = inputBuf.length - inputBufRemaining;
        inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);
        _this.pos += numToCopy;
        spaceRemaining -= numToCopy;
        if (spaceRemaining === 0) {
          if (_this.md5) {
            _this.md5.update(_this.bufToStore);
          }
          var doc = createChunkDoc(_this.id, _this.n, Buffer2.from(_this.bufToStore));
          ++_this.state.outstandingRequests;
          ++outstandingRequests;
          if (checkAborted(_this, callback)) {
            return false;
          }
          _this.chunks.insertOne(doc, getWriteOptions(_this), function(error2) {
            if (error2) {
              return __handleError(_this, error2);
            }
            --_this.state.outstandingRequests;
            --outstandingRequests;
            if (!outstandingRequests) {
              _this.emit("drain", doc);
              callback && callback();
              checkDone(_this);
            }
          });
          spaceRemaining = _this.chunkSizeBytes;
          _this.pos = 0;
          ++_this.n;
        }
        inputBufRemaining -= numToCopy;
        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
      }
      return false;
    }
    function getWriteOptions(_this) {
      var obj = {};
      if (_this.options.writeConcern) {
        obj.w = _this.options.writeConcern.w;
        obj.wtimeout = _this.options.writeConcern.wtimeout;
        obj.j = _this.options.writeConcern.j;
      }
      return obj;
    }
    function waitForIndexes(_this, callback) {
      if (_this.bucket.s.checkedIndexes) {
        return callback(false);
      }
      _this.bucket.once("index", function() {
        callback(true);
      });
      return true;
    }
    function writeRemnant(_this, callback) {
      if (_this.pos === 0) {
        return checkDone(_this, callback);
      }
      ++_this.state.outstandingRequests;
      var remnant = Buffer2.alloc(_this.pos);
      _this.bufToStore.copy(remnant, 0, 0, _this.pos);
      if (_this.md5) {
        _this.md5.update(remnant);
      }
      var doc = createChunkDoc(_this.id, _this.n, remnant);
      if (checkAborted(_this, callback)) {
        return false;
      }
      _this.chunks.insertOne(doc, getWriteOptions(_this), function(error2) {
        if (error2) {
          return __handleError(_this, error2);
        }
        --_this.state.outstandingRequests;
        checkDone(_this);
      });
    }
    function checkAborted(_this, callback) {
      if (_this.state.aborted) {
        if (typeof callback === "function") {
          callback(new Error("this stream has been aborted"));
        }
        return true;
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/index.js
var require_gridfs_stream = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Emitter = require("events").EventEmitter;
    var GridFSBucketReadStream = require_download();
    var GridFSBucketWriteStream = require_upload();
    var shallowClone = require_utils4().shallowClone;
    var toError = require_utils4().toError;
    var util = require("util");
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
      bucketName: "fs",
      chunkSizeBytes: 255 * 1024
    };
    module2.exports = GridFSBucket;
    function GridFSBucket(db, options2) {
      Emitter.apply(this);
      this.setMaxListeners(0);
      if (options2 && typeof options2 === "object") {
        options2 = shallowClone(options2);
        var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
        for (var i = 0; i < keys.length; ++i) {
          if (!options2[keys[i]]) {
            options2[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
          }
        }
      } else {
        options2 = DEFAULT_GRIDFS_BUCKET_OPTIONS;
      }
      this.s = {
        db,
        options: options2,
        _chunksCollection: db.collection(options2.bucketName + ".chunks"),
        _filesCollection: db.collection(options2.bucketName + ".files"),
        checkedIndexes: false,
        calledOpenUploadStream: false,
        promiseLibrary: db.s.promiseLibrary || Promise
      };
    }
    util.inherits(GridFSBucket, Emitter);
    GridFSBucket.prototype.openUploadStream = function(filename, options2) {
      if (options2) {
        options2 = shallowClone(options2);
      } else {
        options2 = {};
      }
      if (!options2.chunkSizeBytes) {
        options2.chunkSizeBytes = this.s.options.chunkSizeBytes;
      }
      return new GridFSBucketWriteStream(this, filename, options2);
    };
    GridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options2) {
      if (options2) {
        options2 = shallowClone(options2);
      } else {
        options2 = {};
      }
      if (!options2.chunkSizeBytes) {
        options2.chunkSizeBytes = this.s.options.chunkSizeBytes;
      }
      options2.id = id;
      return new GridFSBucketWriteStream(this, filename, options2);
    };
    GridFSBucket.prototype.openDownloadStream = function(id, options2) {
      var filter = { _id: id };
      options2 = {
        start: options2 && options2.start,
        end: options2 && options2.end
      };
      return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options2);
    };
    GridFSBucket.prototype.delete = function(id, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {
        skipSessions: true
      });
    };
    function _delete(_this, id, callback) {
      _this.s._filesCollection.deleteOne({ _id: id }, function(error2, res) {
        if (error2) {
          return callback(error2);
        }
        _this.s._chunksCollection.deleteMany({ files_id: id }, function(error3) {
          if (error3) {
            return callback(error3);
          }
          if (!res.result.n) {
            var errmsg = "FileNotFound: no file with id " + id + " found";
            return callback(new Error(errmsg));
          }
          callback();
        });
      });
    }
    GridFSBucket.prototype.find = function(filter, options2) {
      filter = filter || {};
      options2 = options2 || {};
      var cursor = this.s._filesCollection.find(filter);
      if (options2.batchSize != null) {
        cursor.batchSize(options2.batchSize);
      }
      if (options2.limit != null) {
        cursor.limit(options2.limit);
      }
      if (options2.maxTimeMS != null) {
        cursor.maxTimeMS(options2.maxTimeMS);
      }
      if (options2.noCursorTimeout != null) {
        cursor.addCursorFlag("noCursorTimeout", options2.noCursorTimeout);
      }
      if (options2.skip != null) {
        cursor.skip(options2.skip);
      }
      if (options2.sort != null) {
        cursor.sort(options2.sort);
      }
      return cursor;
    };
    GridFSBucket.prototype.openDownloadStreamByName = function(filename, options2) {
      var sort = { uploadDate: -1 };
      var skip = null;
      if (options2 && options2.revision != null) {
        if (options2.revision >= 0) {
          sort = { uploadDate: 1 };
          skip = options2.revision;
        } else {
          skip = -options2.revision - 1;
        }
      }
      var filter = { filename };
      options2 = {
        sort,
        skip,
        start: options2 && options2.start,
        end: options2 && options2.end
      };
      return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options2);
    };
    GridFSBucket.prototype.rename = function(id, filename, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {
        skipSessions: true
      });
    };
    function _rename(_this, id, filename, callback) {
      var filter = { _id: id };
      var update = { $set: { filename } };
      _this.s._filesCollection.updateOne(filter, update, function(error2, res) {
        if (error2) {
          return callback(error2);
        }
        if (!res.result.n) {
          return callback(toError("File with id " + id + " not found"));
        }
        callback();
      });
    }
    GridFSBucket.prototype.drop = function(callback) {
      return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {
        skipSessions: true
      });
    };
    GridFSBucket.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    function _drop(_this, callback) {
      _this.s._filesCollection.drop(function(error2) {
        if (error2) {
          return callback(error2);
        }
        _this.s._chunksCollection.drop(function(error3) {
          if (error3) {
            return callback(error3);
          }
          return callback();
        });
      });
    }
  }
});

// node_modules/mongodb/index.js
var require_mongodb = __commonJS({
  "node_modules/mongodb/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var core = require_core();
    var Instrumentation = require_apm2();
    var connect = require_mongo_client().connect;
    connect.MongoError = core.MongoError;
    connect.MongoNetworkError = core.MongoNetworkError;
    connect.MongoTimeoutError = core.MongoTimeoutError;
    connect.MongoServerSelectionError = core.MongoServerSelectionError;
    connect.MongoParseError = core.MongoParseError;
    connect.MongoWriteConcernError = core.MongoWriteConcernError;
    connect.MongoBulkWriteError = require_common2().BulkWriteError;
    connect.BulkWriteError = connect.MongoBulkWriteError;
    connect.Admin = require_admin();
    connect.MongoClient = require_mongo_client();
    connect.Db = require_db();
    connect.Collection = require_collection();
    connect.Server = require_server3();
    connect.ReplSet = require_replset2();
    connect.Mongos = require_mongos2();
    connect.ReadPreference = core.ReadPreference;
    connect.GridStore = require_grid_store();
    connect.Chunk = require_chunk();
    connect.Logger = core.Logger;
    connect.AggregationCursor = require_aggregation_cursor();
    connect.CommandCursor = require_command_cursor();
    connect.Cursor = require_cursor2();
    connect.GridFSBucket = require_gridfs_stream();
    connect.CoreServer = core.Server;
    connect.CoreConnection = core.Connection;
    connect.Binary = core.BSON.Binary;
    connect.Code = core.BSON.Code;
    connect.Map = core.BSON.Map;
    connect.DBRef = core.BSON.DBRef;
    connect.Double = core.BSON.Double;
    connect.Int32 = core.BSON.Int32;
    connect.Long = core.BSON.Long;
    connect.MinKey = core.BSON.MinKey;
    connect.MaxKey = core.BSON.MaxKey;
    connect.ObjectID = core.BSON.ObjectID;
    connect.ObjectId = core.BSON.ObjectID;
    connect.Symbol = core.BSON.Symbol;
    connect.Timestamp = core.BSON.Timestamp;
    connect.BSONRegExp = core.BSON.BSONRegExp;
    connect.Decimal128 = core.BSON.Decimal128;
    connect.connect = connect;
    connect.instrument = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      const instrumentation = new Instrumentation();
      instrumentation.instrument(connect.MongoClient, callback);
      return instrumentation;
    };
    module2.exports = connect;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/binary.js
var require_binary2 = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/binary.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Binary2 = require_mongodb().Binary;
    module2.exports = exports2 = Binary2;
  }
});

// node_modules/mongoose/lib/connectionstate.js
var require_connectionstate = __commonJS({
  "node_modules/mongoose/lib/connectionstate.js"(exports2, module2) {
    init_shims();
    "use strict";
    var STATES = module2.exports = exports2 = Object.create(null);
    var disconnected = "disconnected";
    var connected = "connected";
    var connecting = "connecting";
    var disconnecting = "disconnecting";
    var uninitialized = "uninitialized";
    STATES[0] = disconnected;
    STATES[1] = connected;
    STATES[2] = connecting;
    STATES[3] = disconnecting;
    STATES[99] = uninitialized;
    STATES[disconnected] = 0;
    STATES[connected] = 1;
    STATES[connecting] = 2;
    STATES[disconnecting] = 3;
    STATES[uninitialized] = 99;
  }
});

// node_modules/mongoose/lib/helpers/immediate.js
var require_immediate = __commonJS({
  "node_modules/mongoose/lib/helpers/immediate.js"(exports2, module2) {
    init_shims();
    "use strict";
    var nextTick = process.nextTick.bind(process);
    module2.exports = function immediate(cb) {
      return nextTick(cb);
    };
  }
});

// node_modules/mongoose/lib/collection.js
var require_collection2 = __commonJS({
  "node_modules/mongoose/lib/collection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var STATES = require_connectionstate();
    var immediate = require_immediate();
    function Collection(name, conn, opts) {
      if (opts === void 0) {
        opts = {};
      }
      if (opts.capped === void 0) {
        opts.capped = {};
      }
      if (typeof opts.capped === "number") {
        opts.capped = { size: opts.capped };
      }
      this.opts = opts;
      this.name = name;
      this.collectionName = name;
      this.conn = conn;
      this.queue = [];
      this.buffer = true;
      this.emitter = new EventEmitter();
      if (STATES.connected === this.conn.readyState) {
        this.onOpen();
      }
    }
    Collection.prototype.name;
    Collection.prototype.collectionName;
    Collection.prototype.conn;
    Collection.prototype.onOpen = function() {
      this.buffer = false;
      immediate(() => this.doQueue());
    };
    Collection.prototype.onClose = function(force) {
      if (this._shouldBufferCommands() && !force) {
        this.buffer = true;
      }
    };
    Collection.prototype.addQueue = function(name, args) {
      this.queue.push([name, args]);
      return this;
    };
    Collection.prototype.removeQueue = function(name, args) {
      const index2 = this.queue.findIndex((v) => v[0] === name && v[1] === args);
      if (index2 === -1) {
        return false;
      }
      this.queue.splice(index2, 1);
      return true;
    };
    Collection.prototype.doQueue = function() {
      for (const method of this.queue) {
        if (typeof method[0] === "function") {
          method[0].apply(this, method[1]);
        } else {
          this[method[0]].apply(this, method[1]);
        }
      }
      this.queue = [];
      const _this = this;
      immediate(function() {
        _this.emitter.emit("queue");
      });
      return this;
    };
    Collection.prototype.ensureIndex = function() {
      throw new Error("Collection#ensureIndex unimplemented by driver");
    };
    Collection.prototype.createIndex = function() {
      throw new Error("Collection#createIndex unimplemented by driver");
    };
    Collection.prototype.findAndModify = function() {
      throw new Error("Collection#findAndModify unimplemented by driver");
    };
    Collection.prototype.findOneAndUpdate = function() {
      throw new Error("Collection#findOneAndUpdate unimplemented by driver");
    };
    Collection.prototype.findOneAndDelete = function() {
      throw new Error("Collection#findOneAndDelete unimplemented by driver");
    };
    Collection.prototype.findOneAndReplace = function() {
      throw new Error("Collection#findOneAndReplace unimplemented by driver");
    };
    Collection.prototype.findOne = function() {
      throw new Error("Collection#findOne unimplemented by driver");
    };
    Collection.prototype.find = function() {
      throw new Error("Collection#find unimplemented by driver");
    };
    Collection.prototype.insert = function() {
      throw new Error("Collection#insert unimplemented by driver");
    };
    Collection.prototype.insertOne = function() {
      throw new Error("Collection#insertOne unimplemented by driver");
    };
    Collection.prototype.insertMany = function() {
      throw new Error("Collection#insertMany unimplemented by driver");
    };
    Collection.prototype.save = function() {
      throw new Error("Collection#save unimplemented by driver");
    };
    Collection.prototype.update = function() {
      throw new Error("Collection#update unimplemented by driver");
    };
    Collection.prototype.getIndexes = function() {
      throw new Error("Collection#getIndexes unimplemented by driver");
    };
    Collection.prototype.mapReduce = function() {
      throw new Error("Collection#mapReduce unimplemented by driver");
    };
    Collection.prototype.watch = function() {
      throw new Error("Collection#watch unimplemented by driver");
    };
    Collection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
      const opts = this.opts;
      if (opts.bufferCommands != null) {
        return opts.bufferCommands;
      }
      if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {
        return opts.schemaUserProvidedOptions.bufferCommands;
      }
      return this.conn._shouldBufferCommands();
    };
    Collection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
      const conn = this.conn;
      const opts = this.opts;
      if (opts.bufferTimeoutMS != null) {
        return opts.bufferTimeoutMS;
      }
      if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {
        return opts.schemaUserProvidedOptions.bufferTimeoutMS;
      }
      if (conn.config.bufferTimeoutMS != null) {
        return conn.config.bufferTimeoutMS;
      }
      if (conn.base != null && conn.base.get("bufferTimeoutMS") != null) {
        return conn.base.get("bufferTimeoutMS");
      }
      return 1e4;
    };
    module2.exports = Collection;
  }
});

// node_modules/mongoose/lib/error/mongooseError.js
var require_mongooseError = __commonJS({
  "node_modules/mongoose/lib/error/mongooseError.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = class extends Error {
    };
    Object.defineProperty(MongooseError.prototype, "name", {
      value: "MongooseError"
    });
    module2.exports = MongooseError;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/objectid.js
var require_objectid2 = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/objectid.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ObjectId2 = require_mongodb().ObjectId;
    module2.exports = exports2 = ObjectId2;
  }
});

// node_modules/mongoose/lib/helpers/get.js
var require_get = __commonJS({
  "node_modules/mongoose/lib/helpers/get.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function get2(obj, path, def) {
      let parts;
      let isPathArray = false;
      if (typeof path === "string") {
        if (path.indexOf(".") === -1) {
          const _v = getProperty(obj, path);
          if (_v == null) {
            return def;
          }
          return _v;
        }
        parts = path.split(".");
      } else {
        isPathArray = true;
        parts = path;
        if (parts.length === 1) {
          const _v = getProperty(obj, parts[0]);
          if (_v == null) {
            return def;
          }
          return _v;
        }
      }
      let rest = path;
      let cur = obj;
      for (const part of parts) {
        if (cur == null) {
          return def;
        }
        if (!isPathArray && cur[rest] != null) {
          return cur[rest];
        }
        cur = getProperty(cur, part);
        if (!isPathArray) {
          rest = rest.substr(part.length + 1);
        }
      }
      return cur == null ? def : cur;
    };
    function getProperty(obj, prop) {
      if (obj == null) {
        return obj;
      }
      if (obj instanceof Map) {
        return obj.get(prop);
      }
      return obj[prop];
    }
  }
});

// node_modules/sliced/index.js
var require_sliced = __commonJS({
  "node_modules/sliced/index.js"(exports2, module2) {
    init_shims();
    module2.exports = function(args, slice, sliceEnd) {
      var ret2 = [];
      var len = args.length;
      if (len === 0)
        return ret2;
      var start = slice < 0 ? Math.max(0, slice + len) : slice || 0;
      if (sliceEnd !== void 0) {
        len = sliceEnd < 0 ? sliceEnd + len : sliceEnd;
      }
      while (len-- > start) {
        ret2[len - start] = args[len];
      }
      return ret2;
    };
  }
});

// node_modules/regexp-clone/index.js
var require_regexp_clone = __commonJS({
  "node_modules/regexp-clone/index.js"(exports2, module2) {
    init_shims();
    var toString = Object.prototype.toString;
    function isRegExp(o) {
      return typeof o == "object" && toString.call(o) == "[object RegExp]";
    }
    module2.exports = exports2 = function(regexp) {
      if (!isRegExp(regexp)) {
        throw new TypeError("Not a RegExp");
      }
      const flags = [];
      if (regexp.global)
        flags.push("g");
      if (regexp.multiline)
        flags.push("m");
      if (regexp.ignoreCase)
        flags.push("i");
      if (regexp.dotAll)
        flags.push("s");
      if (regexp.unicode)
        flags.push("u");
      if (regexp.sticky)
        flags.push("y");
      const result = new RegExp(regexp.source, flags.join(""));
      if (typeof regexp.lastIndex === "number") {
        result.lastIndex = regexp.lastIndex;
      }
      return result;
    };
  }
});

// node_modules/mongoose/lib/types/decimal128.js
var require_decimal1282 = __commonJS({
  "node_modules/mongoose/lib/types/decimal128.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = require_driver().get().Decimal128;
  }
});

// node_modules/mongoose/lib/helpers/symbols.js
var require_symbols = __commonJS({
  "node_modules/mongoose/lib/helpers/symbols.js"(exports2) {
    init_shims();
    "use strict";
    exports2.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics");
    exports2.arrayParentSymbol = Symbol("mongoose#Array#_parent");
    exports2.arrayPathSymbol = Symbol("mongoose#Array#_path");
    exports2.arraySchemaSymbol = Symbol("mongoose#Array#_schema");
    exports2.documentArrayParent = Symbol("mongoose:documentArrayParent");
    exports2.documentIsSelected = Symbol("mongoose#Document#isSelected");
    exports2.documentIsModified = Symbol("mongoose#Document#isModified");
    exports2.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths");
    exports2.documentSchemaSymbol = Symbol("mongoose#Document#schema");
    exports2.getSymbol = Symbol("mongoose#Document#get");
    exports2.modelSymbol = Symbol("mongoose#Model");
    exports2.objectIdSymbol = Symbol("mongoose#ObjectId");
    exports2.populateModelSymbol = Symbol("mongoose.PopulateOptions#Model");
    exports2.schemaTypeSymbol = Symbol("mongoose#schemaType");
    exports2.sessionNewDocuments = Symbol("mongoose:ClientSession#newDocuments");
    exports2.scopeSymbol = Symbol("mongoose#Document#scope");
    exports2.validatorErrorSymbol = Symbol("mongoose:validatorError");
  }
});

// node_modules/mongoose/lib/types/objectid.js
var require_objectid3 = __commonJS({
  "node_modules/mongoose/lib/types/objectid.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ObjectId2 = require_driver().get().ObjectId;
    var objectIdSymbol = require_symbols().objectIdSymbol;
    Object.defineProperty(ObjectId2.prototype, "_id", {
      enumerable: false,
      configurable: true,
      get: function() {
        return this;
      }
    });
    ObjectId2.prototype[objectIdSymbol] = true;
    module2.exports = ObjectId2;
  }
});

// node_modules/mongoose/lib/helpers/specialProperties.js
var require_specialProperties = __commonJS({
  "node_modules/mongoose/lib/helpers/specialProperties.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = new Set(["__proto__", "constructor", "prototype"]);
  }
});

// node_modules/mongoose/lib/helpers/isMongooseObject.js
var require_isMongooseObject = __commonJS({
  "node_modules/mongoose/lib/helpers/isMongooseObject.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(v) {
      if (v == null) {
        return false;
      }
      return v.$__ != null || v.isMongooseArray || v.isMongooseBuffer || v.$isMongooseMap;
    };
  }
});

// node_modules/mongoose/lib/helpers/getFunctionName.js
var require_getFunctionName = __commonJS({
  "node_modules/mongoose/lib/helpers/getFunctionName.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(fn) {
      if (fn.name) {
        return fn.name;
      }
      return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
    };
  }
});

// node_modules/mongoose/lib/helpers/isBsonType.js
var require_isBsonType = __commonJS({
  "node_modules/mongoose/lib/helpers/isBsonType.js"(exports2, module2) {
    init_shims();
    "use strict";
    var get2 = require_get();
    function isBsonType(obj, typename) {
      return get2(obj, "_bsontype", void 0) === typename;
    }
    module2.exports = isBsonType;
  }
});

// node_modules/mongoose/lib/helpers/isObject.js
var require_isObject = __commonJS({
  "node_modules/mongoose/lib/helpers/isObject.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(arg) {
      if (Buffer.isBuffer(arg)) {
        return true;
      }
      return Object.prototype.toString.call(arg) === "[object Object]";
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    init_shims();
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d2 = h * 24;
    var w = d2 * 7;
    var y = d2 * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return plural(ms, msAbs, d2, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/mpath/lib/stringToParts.js
var require_stringToParts = __commonJS({
  "node_modules/mpath/lib/stringToParts.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function stringToParts(str) {
      const result = [];
      let curPropertyName = "";
      let state = "DEFAULT";
      for (let i = 0; i < str.length; ++i) {
        if (state === "IN_SQUARE_BRACKETS" && !/\d/.test(str[i]) && str[i] !== "]") {
          state = "DEFAULT";
          curPropertyName = result[result.length - 1] + "[" + curPropertyName;
          result.splice(result.length - 1, 1);
        }
        if (str[i] === "[") {
          if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
            result.push(curPropertyName);
            curPropertyName = "";
          }
          state = "IN_SQUARE_BRACKETS";
        } else if (str[i] === "]") {
          if (state === "IN_SQUARE_BRACKETS") {
            state = "IMMEDIATELY_AFTER_SQUARE_BRACKETS";
            result.push(curPropertyName);
            curPropertyName = "";
          } else {
            state = "DEFAULT";
            curPropertyName += str[i];
          }
        } else if (str[i] === ".") {
          if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
            result.push(curPropertyName);
            curPropertyName = "";
          }
          state = "DEFAULT";
        } else {
          curPropertyName += str[i];
        }
      }
      if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
        result.push(curPropertyName);
      }
      return result;
    };
  }
});

// node_modules/mpath/lib/index.js
var require_lib = __commonJS({
  "node_modules/mpath/lib/index.js"(exports2) {
    init_shims();
    var stringToParts = require_stringToParts();
    var ignoreProperties = ["__proto__", "constructor", "prototype"];
    exports2.get = function(path, o, special, map) {
      var lookup;
      if (typeof special == "function") {
        if (special.length < 2) {
          map = special;
          special = void 0;
        } else {
          lookup = special;
          special = void 0;
        }
      }
      map || (map = K);
      var parts = typeof path == "string" ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var obj = o, part;
      for (var i = 0; i < parts.length; ++i) {
        part = parts[i];
        if (Array.isArray(obj) && !/^\d+$/.test(part)) {
          var paths = parts.slice(i);
          return [].concat(obj).map(function(item) {
            return item ? exports2.get(paths, item, special || lookup, map) : map(void 0);
          });
        }
        if (lookup) {
          obj = lookup(obj, part);
        } else {
          var _from = special && obj[special] ? obj[special] : obj;
          obj = _from instanceof Map ? _from.get(part) : _from[part];
        }
        if (!obj)
          return map(obj);
      }
      return map(obj);
    };
    exports2.has = function(path, o) {
      var parts = typeof path === "string" ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var len = parts.length;
      var cur = o;
      for (var i = 0; i < len; ++i) {
        if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
          return false;
        }
        cur = cur[parts[i]];
      }
      return true;
    };
    exports2.unset = function(path, o) {
      var parts = typeof path === "string" ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var len = parts.length;
      var cur = o;
      for (var i = 0; i < len; ++i) {
        if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
          return false;
        }
        if (ignoreProperties.indexOf(parts[i]) !== -1) {
          return false;
        }
        if (i === len - 1) {
          delete cur[parts[i]];
          return true;
        }
        cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];
      }
      return true;
    };
    exports2.set = function(path, val, o, special, map, _copying) {
      var lookup;
      if (typeof special == "function") {
        if (special.length < 2) {
          map = special;
          special = void 0;
        } else {
          lookup = special;
          special = void 0;
        }
      }
      map || (map = K);
      var parts = typeof path == "string" ? stringToParts(path) : path;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      if (o == null)
        return;
      for (var i = 0; i < parts.length; ++i) {
        if (ignoreProperties.indexOf(parts[i]) !== -1) {
          return;
        }
      }
      var copy = _copying || /\$/.test(path) && _copying !== false, obj = o, part;
      for (var i = 0, len = parts.length - 1; i < len; ++i) {
        part = parts[i];
        if (part == "$") {
          if (i == len - 1) {
            break;
          } else {
            continue;
          }
        }
        if (Array.isArray(obj) && !/^\d+$/.test(part)) {
          var paths = parts.slice(i);
          if (!copy && Array.isArray(val)) {
            for (var j = 0; j < obj.length && j < val.length; ++j) {
              exports2.set(paths, val[j], obj[j], special || lookup, map, copy);
            }
          } else {
            for (var j = 0; j < obj.length; ++j) {
              exports2.set(paths, val, obj[j], special || lookup, map, copy);
            }
          }
          return;
        }
        if (lookup) {
          obj = lookup(obj, part);
        } else {
          var _to = special && obj[special] ? obj[special] : obj;
          obj = _to instanceof Map ? _to.get(part) : _to[part];
        }
        if (!obj)
          return;
      }
      part = parts[len];
      if (special && obj[special]) {
        obj = obj[special];
      }
      if (Array.isArray(obj) && !/^\d+$/.test(part)) {
        if (!copy && Array.isArray(val)) {
          _setArray(obj, val, part, lookup, special, map);
        } else {
          for (var j = 0; j < obj.length; ++j) {
            var item = obj[j];
            if (item) {
              if (lookup) {
                lookup(item, part, map(val));
              } else {
                if (item[special])
                  item = item[special];
                item[part] = map(val);
              }
            }
          }
        }
      } else {
        if (lookup) {
          lookup(obj, part, map(val));
        } else if (obj instanceof Map) {
          obj.set(part, map(val));
        } else {
          obj[part] = map(val);
        }
      }
    };
    function _setArray(obj, val, part, lookup, special, map) {
      for (var item, j = 0; j < obj.length && j < val.length; ++j) {
        item = obj[j];
        if (Array.isArray(item) && Array.isArray(val[j])) {
          _setArray(item, val[j], part, lookup, special, map);
        } else if (item) {
          if (lookup) {
            lookup(item, part, map(val[j]));
          } else {
            if (item[special])
              item = item[special];
            item[part] = map(val[j]);
          }
        }
      }
    }
    function K(v) {
      return v;
    }
  }
});

// node_modules/mpath/index.js
var require_mpath = __commonJS({
  "node_modules/mpath/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = exports2 = require_lib();
  }
});

// node_modules/mongoose/lib/options/PopulateOptions.js
var require_PopulateOptions = __commonJS({
  "node_modules/mongoose/lib/options/PopulateOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var clone2 = require_clone();
    var PopulateOptions = class {
      constructor(obj) {
        this._docs = {};
        this._childDocs = [];
        if (obj == null) {
          return;
        }
        obj = clone2(obj);
        Object.assign(this, obj);
        if (typeof obj.subPopulate === "object") {
          this.populate = obj.subPopulate;
        }
        if (obj.perDocumentLimit != null && obj.limit != null) {
          throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + obj.path + "`.");
        }
      }
    };
    module2.exports = PopulateOptions;
  }
});

// node_modules/mquery/node_modules/safe-buffer/index.js
var require_safe_buffer3 = __commonJS({
  "node_modules/mquery/node_modules/safe-buffer/index.js"(exports2, module2) {
    init_shims();
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/mquery/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/mquery/lib/utils.js"(exports2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer3().Buffer;
    var RegExpClone = require_regexp_clone();
    var specialProperties = ["__proto__", "constructor", "prototype"];
    var clone2 = exports2.clone = function clone3(obj, options2) {
      if (obj === void 0 || obj === null)
        return obj;
      if (Array.isArray(obj))
        return exports2.cloneArray(obj, options2);
      if (obj.constructor) {
        if (/ObjectI[dD]$/.test(obj.constructor.name)) {
          return typeof obj.clone == "function" ? obj.clone() : new obj.constructor(obj.id);
        }
        if (obj.constructor.name === "ReadPreference") {
          return new obj.constructor(obj.mode, clone3(obj.tags, options2));
        }
        if (obj._bsontype == "Binary" && obj.buffer && obj.value) {
          return typeof obj.clone == "function" ? obj.clone() : new obj.constructor(obj.value(true), obj.sub_type);
        }
        if (obj.constructor.name === "Date" || obj.constructor.name === "Function")
          return new obj.constructor(+obj);
        if (obj.constructor.name === "RegExp")
          return RegExpClone(obj);
        if (obj.constructor.name === "Buffer")
          return exports2.cloneBuffer(obj);
      }
      if (isObject2(obj))
        return exports2.cloneObject(obj, options2);
      if (obj.valueOf)
        return obj.valueOf();
    };
    exports2.cloneObject = function cloneObject(obj, options2) {
      var minimize = options2 && options2.minimize;
      var ret2 = {};
      var hasKeys;
      var val;
      for (const k of Object.keys(obj)) {
        if (specialProperties.indexOf(k) !== -1) {
          continue;
        }
        val = clone2(obj[k], options2);
        if (!minimize || typeof val !== "undefined") {
          hasKeys || (hasKeys = true);
          ret2[k] = val;
        }
      }
      return minimize ? hasKeys && ret2 : ret2;
    };
    exports2.cloneArray = function cloneArray(arr, options2) {
      var ret2 = [];
      for (var i = 0, l = arr.length; i < l; i++)
        ret2.push(clone2(arr[i], options2));
      return ret2;
    };
    exports2.tick = function tick(callback) {
      if (typeof callback !== "function")
        return;
      return function() {
        var args = arguments;
        soon(function() {
          callback.apply(this, args);
        });
      };
    };
    exports2.merge = function merge(to, from) {
      var keys = Object.keys(from), i = keys.length, key;
      while (i--) {
        key = keys[i];
        if (specialProperties.indexOf(key) !== -1) {
          continue;
        }
        if (typeof to[key] === "undefined") {
          to[key] = from[key];
        } else {
          if (exports2.isObject(from[key])) {
            merge(to[key], from[key]);
          } else {
            to[key] = from[key];
          }
        }
      }
    };
    exports2.mergeClone = function mergeClone(to, from) {
      var keys = Object.keys(from), i = keys.length, key;
      while (i--) {
        key = keys[i];
        if (specialProperties.indexOf(key) !== -1) {
          continue;
        }
        if (typeof to[key] === "undefined") {
          to[key] = clone2(from[key]);
        } else {
          if (exports2.isObject(from[key])) {
            mergeClone(to[key], from[key]);
          } else {
            to[key] = clone2(from[key]);
          }
        }
      }
    };
    exports2.readPref = function readPref(pref) {
      switch (pref) {
        case "p":
          pref = "primary";
          break;
        case "pp":
          pref = "primaryPreferred";
          break;
        case "s":
          pref = "secondary";
          break;
        case "sp":
          pref = "secondaryPreferred";
          break;
        case "n":
          pref = "nearest";
          break;
      }
      return pref;
    };
    exports2.readConcern = function readConcern(concern) {
      if (typeof concern === "string") {
        switch (concern) {
          case "l":
            concern = "local";
            break;
          case "a":
            concern = "available";
            break;
          case "m":
            concern = "majority";
            break;
          case "lz":
            concern = "linearizable";
            break;
          case "s":
            concern = "snapshot";
            break;
        }
        concern = { level: concern };
      }
      return concern;
    };
    var _toString = Object.prototype.toString;
    exports2.toString = function(arg) {
      return _toString.call(arg);
    };
    var isObject2 = exports2.isObject = function(arg) {
      return exports2.toString(arg) == "[object Object]";
    };
    exports2.isArray = function(arg) {
      return Array.isArray(arg) || typeof arg == "object" && exports2.toString(arg) == "[object Array]";
    };
    exports2.keys = Object.keys;
    exports2.create = typeof Object.create == "function" ? Object.create : create;
    function create(proto) {
      if (arguments.length > 1) {
        throw new Error("Adding properties is not supported");
      }
      function F() {
      }
      F.prototype = proto;
      return new F();
    }
    exports2.inherits = function(ctor, superCtor) {
      ctor.prototype = exports2.create(superCtor.prototype);
      ctor.prototype.constructor = ctor;
    };
    var soon = exports2.soon = typeof setImmediate == "function" ? setImmediate : process.nextTick;
    exports2.cloneBuffer = function(buff) {
      var dupe = Buffer2.alloc(buff.length);
      buff.copy(dupe, 0, 0, buff.length);
      return dupe;
    };
    exports2.isArgumentsObject = function(v) {
      return Object.prototype.toString.call(v) === "[object Arguments]";
    };
  }
});

// node_modules/mquery/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/mquery/node_modules/ms/index.js"(exports2, module2) {
    init_shims();
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d2 = h * 24;
    var y = d2 * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d2, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s2, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/mquery/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/mquery/node_modules/debug/src/debug.js"(exports2, module2) {
    init_shims();
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms2();
    exports2.instances = [];
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    function selectColor(namespace) {
      var hash2 = 0, i;
      for (i in namespace) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return exports2.colors[Math.abs(hash2) % exports2.colors.length];
    }
    function createDebug(namespace) {
      var prevTime;
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
          if (match === "%%")
            return match;
          index2++;
          var formatter = exports2.formatters[format2];
          if (typeof formatter === "function") {
            var val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      if (typeof exports2.init === "function") {
        exports2.init(debug);
      }
      exports2.instances.push(debug);
      return debug;
    }
    function destroy() {
      var index2 = exports2.instances.indexOf(this);
      if (index2 !== -1) {
        exports2.instances.splice(index2, 1);
        return true;
      } else {
        return false;
      }
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var i;
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0; i < exports2.instances.length; i++) {
        var instance = exports2.instances[i];
        instance.enabled = exports2.enabled(instance.namespace);
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/mquery/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/mquery/node_modules/debug/src/browser.js"(exports2, module2) {
    init_shims();
    exports2 = module2.exports = require_debug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load2() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/mquery/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/mquery/node_modules/debug/src/node.js"(exports2, module2) {
    init_shims();
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug();
    exports2.init = init2;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      supportsColor = require_supports_color();
      if (supportsColor && supportsColor.level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (err) {
    }
    var supportsColor;
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        var prefix = "  " + colorCode + ";1m" + name + " [0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + exports2.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      } else {
        return new Date().toISOString() + " ";
      }
    }
    function log() {
      return process.stderr.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load2());
  }
});

// node_modules/mquery/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/mquery/node_modules/debug/src/index.js"(exports2, module2) {
    init_shims();
    if (typeof process === "undefined" || process.type === "renderer") {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/mquery/lib/permissions.js
var require_permissions = __commonJS({
  "node_modules/mquery/lib/permissions.js"(exports2) {
    init_shims();
    "use strict";
    var denied = exports2;
    denied.distinct = function(self2) {
      if (self2._fields && Object.keys(self2._fields).length > 0) {
        return "field selection and slice";
      }
      var keys = Object.keys(denied.distinct);
      var err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.comment = denied.distinct.maxScan = denied.distinct.snapshot = denied.distinct.hint = denied.distinct.tailable = true;
    denied.findOneAndUpdate = denied.findOneAndRemove = function(self2) {
      var keys = Object.keys(denied.findOneAndUpdate);
      var err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.maxScan = denied.findOneAndUpdate.snapshot = denied.findOneAndUpdate.hint = denied.findOneAndUpdate.tailable = denied.findOneAndUpdate.comment = true;
    denied.count = function(self2) {
      if (self2._fields && Object.keys(self2._fields).length > 0) {
        return "field selection and slice";
      }
      var keys = Object.keys(denied.count);
      var err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.count.slice = denied.count.batchSize = denied.count.comment = denied.count.maxScan = denied.count.snapshot = denied.count.tailable = true;
  }
});

// node_modules/mquery/lib/env.js
var require_env = __commonJS({
  "node_modules/mquery/lib/env.js"(exports2, module2) {
    init_shims();
    "use strict";
    exports2.isNode = typeof process != "undefined" && typeof module2 == "object" && typeof global == "object" && typeof Buffer == "function" && process.argv;
    exports2.isMongo = !exports2.isNode && typeof printjson == "function" && typeof ObjectId == "function" && typeof rs == "function" && typeof sh == "function";
    exports2.isBrowser = !exports2.isNode && !exports2.isMongo && typeof window != "undefined";
    exports2.type = exports2.isNode ? "node" : exports2.isMongo ? "mongo" : exports2.isBrowser ? "browser" : "unknown";
  }
});

// node_modules/mquery/lib/collection/collection.js
var require_collection3 = __commonJS({
  "node_modules/mquery/lib/collection/collection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var methods = [
      "find",
      "findOne",
      "update",
      "updateMany",
      "updateOne",
      "replaceOne",
      "remove",
      "count",
      "distinct",
      "findAndModify",
      "aggregate",
      "findStream",
      "deleteOne",
      "deleteMany"
    ];
    function Collection() {
    }
    for (i = 0, len = methods.length; i < len; ++i) {
      method = methods[i];
      Collection.prototype[method] = notImplemented(method);
    }
    var method;
    var i;
    var len;
    module2.exports = exports2 = Collection;
    Collection.methods = methods;
    function notImplemented(method2) {
      return function() {
        throw new Error("collection." + method2 + " not implemented");
      };
    }
  }
});

// node_modules/mquery/lib/collection/node.js
var require_node3 = __commonJS({
  "node_modules/mquery/lib/collection/node.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Collection = require_collection3();
    var utils2 = require_utils5();
    function NodeCollection(col) {
      this.collection = col;
      this.collectionName = col.collectionName;
    }
    utils2.inherits(NodeCollection, Collection);
    NodeCollection.prototype.find = function(match, options2, cb) {
      this.collection.find(match, options2, function(err, cursor) {
        if (err)
          return cb(err);
        try {
          cursor.toArray(cb);
        } catch (error2) {
          cb(error2);
        }
      });
    };
    NodeCollection.prototype.findOne = function(match, options2, cb) {
      this.collection.findOne(match, options2, cb);
    };
    NodeCollection.prototype.count = function(match, options2, cb) {
      this.collection.count(match, options2, cb);
    };
    NodeCollection.prototype.distinct = function(prop, match, options2, cb) {
      this.collection.distinct(prop, match, options2, cb);
    };
    NodeCollection.prototype.update = function(match, update, options2, cb) {
      this.collection.update(match, update, options2, cb);
    };
    NodeCollection.prototype.updateMany = function(match, update, options2, cb) {
      this.collection.updateMany(match, update, options2, cb);
    };
    NodeCollection.prototype.updateOne = function(match, update, options2, cb) {
      this.collection.updateOne(match, update, options2, cb);
    };
    NodeCollection.prototype.replaceOne = function(match, update, options2, cb) {
      this.collection.replaceOne(match, update, options2, cb);
    };
    NodeCollection.prototype.deleteOne = function(match, options2, cb) {
      this.collection.deleteOne(match, options2, cb);
    };
    NodeCollection.prototype.deleteMany = function(match, options2, cb) {
      this.collection.deleteMany(match, options2, cb);
    };
    NodeCollection.prototype.remove = function(match, options2, cb) {
      this.collection.remove(match, options2, cb);
    };
    NodeCollection.prototype.findAndModify = function(match, update, options2, cb) {
      var sort = Array.isArray(options2.sort) ? options2.sort : [];
      this.collection.findAndModify(match, sort, update, options2, cb);
    };
    NodeCollection.prototype.findStream = function(match, findOptions, streamOptions) {
      return this.collection.find(match, findOptions).stream(streamOptions);
    };
    NodeCollection.prototype.findCursor = function(match, findOptions) {
      return this.collection.find(match, findOptions);
    };
    module2.exports = exports2 = NodeCollection;
  }
});

// node_modules/mquery/lib/collection/index.js
var require_collection4 = __commonJS({
  "node_modules/mquery/lib/collection/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var env2 = require_env();
    if (env2.type == "unknown") {
      throw new Error("Unknown environment");
    }
    module2.exports = env2.isNode ? require_node3() : env2.isMongo ? require_collection3() : require_collection3();
  }
});

// node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS({
  "node_modules/bluebird/js/release/es5.js"(exports2, module2) {
    init_shims();
    var isES5 = function() {
      "use strict";
      return this === void 0;
    }();
    if (isES5) {
      module2.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5,
        propertyIsWritable: function(obj, prop) {
          var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          return !!(!descriptor || descriptor.writable || descriptor.set);
        }
      };
    } else {
      has = {}.hasOwnProperty;
      str = {}.toString;
      proto = {}.constructor.prototype;
      ObjectKeys = function(o) {
        var ret2 = [];
        for (var key in o) {
          if (has.call(o, key)) {
            ret2.push(key);
          }
        }
        return ret2;
      };
      ObjectGetDescriptor = function(o, key) {
        return { value: o[key] };
      };
      ObjectDefineProperty = function(o, key, desc) {
        o[key] = desc.value;
        return o;
      };
      ObjectFreeze = function(obj) {
        return obj;
      };
      ObjectGetPrototypeOf = function(obj) {
        try {
          return Object(obj).constructor.prototype;
        } catch (e) {
          return proto;
        }
      };
      ArrayIsArray = function(obj) {
        try {
          return str.call(obj) === "[object Array]";
        } catch (e) {
          return false;
        }
      };
      module2.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5,
        propertyIsWritable: function() {
          return true;
        }
      };
    }
    var has;
    var str;
    var proto;
    var ObjectKeys;
    var ObjectGetDescriptor;
    var ObjectDefineProperty;
    var ObjectFreeze;
    var ObjectGetPrototypeOf;
    var ArrayIsArray;
  }
});

// node_modules/bluebird/js/release/util.js
var require_util2 = __commonJS({
  "node_modules/bluebird/js/release/util.js"(exports, module) {
    init_shims();
    "use strict";
    var es5 = require_es5();
    var canEvaluate = typeof navigator == "undefined";
    var errorObj = { e: {} };
    var tryCatchTarget;
    var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== void 0 ? exports : null;
    function tryCatcher() {
      try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    var inherits = function(Child, Parent) {
      var hasProp = {}.hasOwnProperty;
      function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
          if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
            this[propertyName + "$"] = Parent.prototype[propertyName];
          }
        }
      }
      T.prototype = Parent.prototype;
      Child.prototype = new T();
      return Child.prototype;
    };
    function isPrimitive(val) {
      return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
    }
    function isObject(value) {
      return typeof value === "function" || typeof value === "object" && value !== null;
    }
    function maybeWrapAsError(maybeError) {
      if (!isPrimitive(maybeError))
        return maybeError;
      return new Error(safeToString(maybeError));
    }
    function withAppended(target, appendee) {
      var len = target.length;
      var ret2 = new Array(len + 1);
      var i;
      for (i = 0; i < len; ++i) {
        ret2[i] = target[i];
      }
      ret2[i] = appendee;
      return ret2;
    }
    function getDataPropertyOrDefault(obj, key, defaultValue) {
      if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc != null) {
          return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
      } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
      }
    }
    function notEnumerableProp(obj, name, value) {
      if (isPrimitive(obj))
        return obj;
      var descriptor = {
        value,
        configurable: true,
        enumerable: false,
        writable: true
      };
      es5.defineProperty(obj, name, descriptor);
      return obj;
    }
    function thrower(r) {
      throw r;
    }
    var inheritedDataKeys = function() {
      var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
      ];
      var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
          if (excludedPrototypes[i] === val) {
            return true;
          }
        }
        return false;
      };
      if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
          var ret2 = [];
          var visitedKeys = Object.create(null);
          while (obj != null && !isExcludedProto(obj)) {
            var keys;
            try {
              keys = getKeys(obj);
            } catch (e) {
              return ret2;
            }
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (visitedKeys[key])
                continue;
              visitedKeys[key] = true;
              var desc = Object.getOwnPropertyDescriptor(obj, key);
              if (desc != null && desc.get == null && desc.set == null) {
                ret2.push(key);
              }
            }
            obj = es5.getPrototypeOf(obj);
          }
          return ret2;
        };
      } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
          if (isExcludedProto(obj))
            return [];
          var ret2 = [];
          enumeration:
            for (var key in obj) {
              if (hasProp.call(obj, key)) {
                ret2.push(key);
              } else {
                for (var i = 0; i < excludedPrototypes.length; ++i) {
                  if (hasProp.call(excludedPrototypes[i], key)) {
                    continue enumeration;
                  }
                }
                ret2.push(key);
              }
            }
          return ret2;
        };
      }
    }();
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
      try {
        if (typeof fn === "function") {
          var keys = es5.names(fn.prototype);
          var hasMethods = es5.isES5 && keys.length > 1;
          var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
          var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
          if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
            return true;
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }
    function toFastProperties(obj) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = obj;
      var l = 8;
      while (l--)
        new FakeConstructor();
      return obj;
      eval(obj);
    }
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
      return rident.test(str);
    }
    function filledRange(count, prefix, suffix) {
      var ret2 = new Array(count);
      for (var i = 0; i < count; ++i) {
        ret2[i] = prefix + i + suffix;
      }
      return ret2;
    }
    function safeToString(obj) {
      try {
        return obj + "";
      } catch (e) {
        return "[no string representation]";
      }
    }
    function isError(obj) {
      return obj instanceof Error || obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
    }
    function markAsOriginatingFromRejection(e) {
      try {
        notEnumerableProp(e, "isOperational", true);
      } catch (ignore) {
      }
    }
    function originatesFromRejection(e) {
      if (e == null)
        return false;
      return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
    }
    function canAttachTrace(obj) {
      return isError(obj) && es5.propertyIsWritable(obj, "stack");
    }
    var ensureErrorObject = function() {
      if (!("stack" in new Error())) {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          try {
            throw new Error(safeToString(value));
          } catch (err) {
            return err;
          }
        };
      } else {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          return new Error(safeToString(value));
        };
      }
    }();
    function classString(obj) {
      return {}.toString.call(obj);
    }
    function copyDescriptors(from, to, filter) {
      var keys = es5.names(from);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
          try {
            es5.defineProperty(to, key, es5.getDescriptor(from, key));
          } catch (ignore) {
          }
        }
      }
    }
    var asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      }
      return null;
    };
    if (typeof Symbol !== "undefined" && Symbol.iterator) {
      ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
      } : function(v) {
        var ret2 = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!(itResult = it.next()).done) {
          ret2.push(itResult.value);
        }
        return ret2;
      };
      asArray = function(v) {
        if (es5.isArray(v)) {
          return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
          return ArrayFrom(v);
        }
        return null;
      };
    }
    var ArrayFrom;
    var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
    var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
    function env(key) {
      return hasEnvVariables ? process.env[key] : void 0;
    }
    function getNativePromise() {
      if (typeof Promise === "function") {
        try {
          var promise = new Promise(function() {
          });
          if ({}.toString.call(promise) === "[object Promise]") {
            return Promise;
          }
        } catch (e) {
        }
      }
    }
    function domainBind(self2, cb) {
      return self2.bind(cb);
    }
    var ret = {
      isClass,
      isIdentifier,
      inheritedDataKeys,
      getDataPropertyOrDefault,
      thrower,
      isArray: es5.isArray,
      asArray,
      notEnumerableProp,
      isPrimitive,
      isObject,
      isError,
      canEvaluate,
      errorObj,
      tryCatch,
      inherits,
      withAppended,
      maybeWrapAsError,
      toFastProperties,
      filledRange,
      toString: safeToString,
      canAttachTrace,
      ensureErrorObject,
      originatesFromRejection,
      markAsOriginatingFromRejection,
      classString,
      copyDescriptors,
      hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
      isNode,
      hasEnvVariables,
      env,
      global: globalObject,
      getNativePromise,
      domainBind
    };
    ret.isRecentNode = ret.isNode && function() {
      var version = process.versions.node.split(".").map(Number);
      return version[0] === 0 && version[1] > 10 || version[0] > 0;
    }();
    if (ret.isNode)
      ret.toFastProperties(process);
    try {
      throw new Error();
    } catch (e) {
      ret.lastLineError = e;
    }
    module.exports = ret;
  }
});

// node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS({
  "node_modules/bluebird/js/release/schedule.js"(exports2, module2) {
    init_shims();
    "use strict";
    var util = require_util2();
    var schedule;
    var noAsyncScheduler = function() {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    };
    var NativePromise = util.getNativePromise();
    if (util.isNode && typeof MutationObserver === "undefined") {
      GlobalSetImmediate = global.setImmediate;
      ProcessNextTick = process.nextTick;
      schedule = util.isRecentNode ? function(fn) {
        GlobalSetImmediate.call(global, fn);
      } : function(fn) {
        ProcessNextTick.call(process, fn);
      };
    } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
      nativePromise = NativePromise.resolve();
      schedule = function(fn) {
        nativePromise.then(fn);
      };
    } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
      schedule = function() {
        var div = document.createElement("div");
        var opts = { attributes: true };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
          div.classList.toggle("foo");
          toggleScheduled = false;
        });
        o2.observe(div2, opts);
        var scheduleToggle = function() {
          if (toggleScheduled)
            return;
          toggleScheduled = true;
          div2.classList.toggle("foo");
        };
        return function schedule2(fn) {
          var o = new MutationObserver(function() {
            o.disconnect();
            fn();
          });
          o.observe(div, opts);
          scheduleToggle();
        };
      }();
    } else if (typeof setImmediate !== "undefined") {
      schedule = function(fn) {
        setImmediate(fn);
      };
    } else if (typeof setTimeout !== "undefined") {
      schedule = function(fn) {
        setTimeout(fn, 0);
      };
    } else {
      schedule = noAsyncScheduler;
    }
    var GlobalSetImmediate;
    var ProcessNextTick;
    var nativePromise;
    module2.exports = schedule;
  }
});

// node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS({
  "node_modules/bluebird/js/release/queue.js"(exports2, module2) {
    init_shims();
    "use strict";
    function arrayMove(src2, srcIndex, dst, dstIndex, len) {
      for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src2[j + srcIndex];
        src2[j + srcIndex] = void 0;
      }
    }
    function Queue(capacity) {
      this._capacity = capacity;
      this._length = 0;
      this._front = 0;
    }
    Queue.prototype._willBeOverCapacity = function(size) {
      return this._capacity < size;
    };
    Queue.prototype._pushOne = function(arg) {
      var length = this.length();
      this._checkCapacity(length + 1);
      var i = this._front + length & this._capacity - 1;
      this[i] = arg;
      this._length = length + 1;
    };
    Queue.prototype.push = function(fn, receiver, arg) {
      var length = this.length() + 3;
      if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
      }
      var j = this._front + length - 3;
      this._checkCapacity(length);
      var wrapMask = this._capacity - 1;
      this[j + 0 & wrapMask] = fn;
      this[j + 1 & wrapMask] = receiver;
      this[j + 2 & wrapMask] = arg;
      this._length = length;
    };
    Queue.prototype.shift = function() {
      var front = this._front, ret2 = this[front];
      this[front] = void 0;
      this._front = front + 1 & this._capacity - 1;
      this._length--;
      return ret2;
    };
    Queue.prototype.length = function() {
      return this._length;
    };
    Queue.prototype._checkCapacity = function(size) {
      if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
      }
    };
    Queue.prototype._resizeTo = function(capacity) {
      var oldCapacity = this._capacity;
      this._capacity = capacity;
      var front = this._front;
      var length = this._length;
      var moveItemsCount = front + length & oldCapacity - 1;
      arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    module2.exports = Queue;
  }
});

// node_modules/bluebird/js/release/async.js
var require_async = __commonJS({
  "node_modules/bluebird/js/release/async.js"(exports2, module2) {
    init_shims();
    "use strict";
    var firstLineError;
    try {
      throw new Error();
    } catch (e) {
      firstLineError = e;
    }
    var schedule = require_schedule();
    var Queue = require_queue();
    var util = require_util2();
    function Async() {
      this._customScheduler = false;
      this._isTickUsed = false;
      this._lateQueue = new Queue(16);
      this._normalQueue = new Queue(16);
      this._haveDrainedQueues = false;
      this._trampolineEnabled = true;
      var self2 = this;
      this.drainQueues = function() {
        self2._drainQueues();
      };
      this._schedule = schedule;
    }
    Async.prototype.setScheduler = function(fn) {
      var prev = this._schedule;
      this._schedule = fn;
      this._customScheduler = true;
      return prev;
    };
    Async.prototype.hasCustomScheduler = function() {
      return this._customScheduler;
    };
    Async.prototype.enableTrampoline = function() {
      this._trampolineEnabled = true;
    };
    Async.prototype.disableTrampolineIfNecessary = function() {
      if (util.hasDevTools) {
        this._trampolineEnabled = false;
      }
    };
    Async.prototype.haveItemsQueued = function() {
      return this._isTickUsed || this._haveDrainedQueues;
    };
    Async.prototype.fatalError = function(e, isNode2) {
      if (isNode2) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
      } else {
        this.throwLater(e);
      }
    };
    Async.prototype.throwLater = function(fn, arg) {
      if (arguments.length === 1) {
        arg = fn;
        fn = function() {
          throw arg;
        };
      }
      if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
          fn(arg);
        }, 0);
      } else
        try {
          this._schedule(function() {
            fn(arg);
          });
        } catch (e) {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        }
    };
    function AsyncInvokeLater(fn, receiver, arg) {
      this._lateQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncInvoke(fn, receiver, arg) {
      this._normalQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncSettlePromises(promise) {
      this._normalQueue._pushOne(promise);
      this._queueTick();
    }
    if (!util.hasDevTools) {
      Async.prototype.invokeLater = AsyncInvokeLater;
      Async.prototype.invoke = AsyncInvoke;
      Async.prototype.settlePromises = AsyncSettlePromises;
    } else {
      Async.prototype.invokeLater = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
          this._schedule(function() {
            setTimeout(function() {
              fn.call(receiver, arg);
            }, 100);
          });
        }
      };
      Async.prototype.invoke = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvoke.call(this, fn, receiver, arg);
        } else {
          this._schedule(function() {
            fn.call(receiver, arg);
          });
        }
      };
      Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
          AsyncSettlePromises.call(this, promise);
        } else {
          this._schedule(function() {
            promise._settlePromises();
          });
        }
      };
    }
    Async.prototype._drainQueue = function(queue) {
      while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
          fn._settlePromises();
          continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
      }
    };
    Async.prototype._drainQueues = function() {
      this._drainQueue(this._normalQueue);
      this._reset();
      this._haveDrainedQueues = true;
      this._drainQueue(this._lateQueue);
    };
    Async.prototype._queueTick = function() {
      if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
      }
    };
    Async.prototype._reset = function() {
      this._isTickUsed = false;
    };
    module2.exports = Async;
    module2.exports.firstLineError = firstLineError;
  }
});

// node_modules/bluebird/js/release/errors.js
var require_errors2 = __commonJS({
  "node_modules/bluebird/js/release/errors.js"(exports2, module2) {
    init_shims();
    "use strict";
    var es52 = require_es5();
    var Objectfreeze = es52.freeze;
    var util = require_util2();
    var inherits2 = util.inherits;
    var notEnumerableProp2 = util.notEnumerableProp;
    function subError(nameProperty, defaultMessage) {
      function SubError(message) {
        if (!(this instanceof SubError))
          return new SubError(message);
        notEnumerableProp2(this, "message", typeof message === "string" ? message : defaultMessage);
        notEnumerableProp2(this, "name", nameProperty);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          Error.call(this);
        }
      }
      inherits2(SubError, Error);
      return SubError;
    }
    var _TypeError;
    var _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
      _TypeError = TypeError;
      _RangeError = RangeError;
    } catch (e) {
      _TypeError = subError("TypeError", "type error");
      _RangeError = subError("RangeError", "range error");
    }
    var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
    for (i = 0; i < methods.length; ++i) {
      if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
      }
    }
    var i;
    es52.defineProperty(AggregateError.prototype, "length", {
      value: 0,
      configurable: false,
      writable: true,
      enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
      var indent = Array(level * 4 + 1).join(" ");
      var ret2 = "\n" + indent + "AggregateError of:\n";
      level++;
      indent = Array(level * 4 + 1).join(" ");
      for (var i2 = 0; i2 < this.length; ++i2) {
        var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
          lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret2 += str + "\n";
      }
      level--;
      return ret2;
    };
    function OperationalError(message) {
      if (!(this instanceof OperationalError))
        return new OperationalError(message);
      notEnumerableProp2(this, "name", "OperationalError");
      notEnumerableProp2(this, "message", message);
      this.cause = message;
      this["isOperational"] = true;
      if (message instanceof Error) {
        notEnumerableProp2(this, "message", message.message);
        notEnumerableProp2(this, "stack", message.stack);
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    inherits2(OperationalError, Error);
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
      errorTypes = Objectfreeze({
        CancellationError,
        TimeoutError,
        OperationalError,
        RejectionError: OperationalError,
        AggregateError
      });
      es52.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      Error,
      TypeError: _TypeError,
      RangeError: _RangeError,
      CancellationError: errorTypes.CancellationError,
      OperationalError: errorTypes.OperationalError,
      TimeoutError: errorTypes.TimeoutError,
      AggregateError: errorTypes.AggregateError,
      Warning
    };
  }
});

// node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS({
  "node_modules/bluebird/js/release/thenables.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var util = require_util2();
      var errorObj2 = util.errorObj;
      var isObject2 = util.isObject;
      function tryConvertToPromise(obj, context) {
        if (isObject2(obj)) {
          if (obj instanceof Promise2)
            return obj;
          var then = getThen(obj);
          if (then === errorObj2) {
            if (context)
              context._pushContext();
            var ret2 = Promise2.reject(then.e);
            if (context)
              context._popContext();
            return ret2;
          } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj)) {
              var ret2 = new Promise2(INTERNAL);
              obj._then(ret2._fulfill, ret2._reject, void 0, ret2, null);
              return ret2;
            }
            return doThenable(obj, then, context);
          }
        }
        return obj;
      }
      function doGetThen(obj) {
        return obj.then;
      }
      function getThen(obj) {
        try {
          return doGetThen(obj);
        } catch (e) {
          errorObj2.e = e;
          return errorObj2;
        }
      }
      var hasProp = {}.hasOwnProperty;
      function isAnyBluebirdPromise(obj) {
        try {
          return hasProp.call(obj, "_promise0");
        } catch (e) {
          return false;
        }
      }
      function doThenable(x, then, context) {
        var promise = new Promise2(INTERNAL);
        var ret2 = promise;
        if (context)
          context._pushContext();
        promise._captureStackTrace();
        if (context)
          context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x, resolve2, reject);
        synchronous = false;
        if (promise && result === errorObj2) {
          promise._rejectCallback(result.e, true, true);
          promise = null;
        }
        function resolve2(value) {
          if (!promise)
            return;
          promise._resolveCallback(value);
          promise = null;
        }
        function reject(reason) {
          if (!promise)
            return;
          promise._rejectCallback(reason, synchronous, true);
          promise = null;
        }
        return ret2;
      }
      return tryConvertToPromise;
    };
  }
});

// node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS({
  "node_modules/bluebird/js/release/promise_array.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
      var util = require_util2();
      var isArray = util.isArray;
      function toResolutionValue(val) {
        switch (val) {
          case -2:
            return [];
          case -3:
            return {};
          case -6:
            return new Map();
        }
      }
      function PromiseArray(values) {
        var promise = this._promise = new Promise2(INTERNAL);
        if (values instanceof Promise2) {
          promise._propagateFrom(values, 3);
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(void 0, -2);
      }
      util.inherits(PromiseArray, Proxyable);
      PromiseArray.prototype.length = function() {
        return this._length;
      };
      PromiseArray.prototype.promise = function() {
        return this._promise;
      };
      PromiseArray.prototype._init = function init2(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise2) {
          values = values._target();
          var bitField = values._bitField;
          ;
          this._values = values;
          if ((bitField & 50397184) === 0) {
            this._promise._setAsyncGuaranteed();
            return values._then(init2, this._reject, void 0, this, resolveValueIfEmpty);
          } else if ((bitField & 33554432) !== 0) {
            values = values._value();
          } else if ((bitField & 16777216) !== 0) {
            return this._reject(values._reason());
          } else {
            return this._cancel();
          }
        }
        values = util.asArray(values);
        if (values === null) {
          var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
          this._promise._rejectCallback(err, false);
          return;
        }
        if (values.length === 0) {
          if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
          } else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
          }
          return;
        }
        this._iterate(values);
      };
      PromiseArray.prototype._iterate = function(values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i = 0; i < len; ++i) {
          var maybePromise = tryConvertToPromise(values[i], result);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
          } else {
            bitField = null;
          }
          if (isResolved) {
            if (bitField !== null) {
              maybePromise.suppressUnhandledRejections();
            }
          } else if (bitField !== null) {
            if ((bitField & 50397184) === 0) {
              maybePromise._proxy(this, i);
              this._values[i] = maybePromise;
            } else if ((bitField & 33554432) !== 0) {
              isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if ((bitField & 16777216) !== 0) {
              isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
              isResolved = this._promiseCancelled(i);
            }
          } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
          }
        }
        if (!isResolved)
          result._setAsyncGuaranteed();
      };
      PromiseArray.prototype._isResolved = function() {
        return this._values === null;
      };
      PromiseArray.prototype._resolve = function(value) {
        this._values = null;
        this._promise._fulfill(value);
      };
      PromiseArray.prototype._cancel = function() {
        if (this._isResolved() || !this._promise._isCancellable())
          return;
        this._values = null;
        this._promise._cancel();
      };
      PromiseArray.prototype._reject = function(reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
      };
      PromiseArray.prototype._promiseFulfilled = function(value, index2) {
        this._values[index2] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      PromiseArray.prototype._promiseCancelled = function() {
        this._cancel();
        return true;
      };
      PromiseArray.prototype._promiseRejected = function(reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
      };
      PromiseArray.prototype._resultCancelled = function() {
        if (this._isResolved())
          return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise2) {
          values.cancel();
        } else {
          for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise2) {
              values[i].cancel();
            }
          }
        }
      };
      PromiseArray.prototype.shouldCopyValues = function() {
        return true;
      };
      PromiseArray.prototype.getActualLength = function(len) {
        return len;
      };
      return PromiseArray;
    };
  }
});

// node_modules/bluebird/js/release/context.js
var require_context = __commonJS({
  "node_modules/bluebird/js/release/context.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2) {
      var longStackTraces = false;
      var contextStack = [];
      Promise2.prototype._promiseCreated = function() {
      };
      Promise2.prototype._pushContext = function() {
      };
      Promise2.prototype._popContext = function() {
        return null;
      };
      Promise2._peekContext = Promise2.prototype._peekContext = function() {
      };
      function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
      }
      Context.prototype._pushContext = function() {
        if (this._trace !== void 0) {
          this._trace._promiseCreated = null;
          contextStack.push(this._trace);
        }
      };
      Context.prototype._popContext = function() {
        if (this._trace !== void 0) {
          var trace = contextStack.pop();
          var ret2 = trace._promiseCreated;
          trace._promiseCreated = null;
          return ret2;
        }
        return null;
      };
      function createContext() {
        if (longStackTraces)
          return new Context();
      }
      function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
          return contextStack[lastIndex];
        }
        return void 0;
      }
      Context.CapturedTrace = null;
      Context.create = createContext;
      Context.deactivateLongStackTraces = function() {
      };
      Context.activateLongStackTraces = function() {
        var Promise_pushContext = Promise2.prototype._pushContext;
        var Promise_popContext = Promise2.prototype._popContext;
        var Promise_PeekContext = Promise2._peekContext;
        var Promise_peekContext = Promise2.prototype._peekContext;
        var Promise_promiseCreated = Promise2.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function() {
          Promise2.prototype._pushContext = Promise_pushContext;
          Promise2.prototype._popContext = Promise_popContext;
          Promise2._peekContext = Promise_PeekContext;
          Promise2.prototype._peekContext = Promise_peekContext;
          Promise2.prototype._promiseCreated = Promise_promiseCreated;
          longStackTraces = false;
        };
        longStackTraces = true;
        Promise2.prototype._pushContext = Context.prototype._pushContext;
        Promise2.prototype._popContext = Context.prototype._popContext;
        Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
        Promise2.prototype._promiseCreated = function() {
          var ctx = this._peekContext();
          if (ctx && ctx._promiseCreated == null)
            ctx._promiseCreated = this;
        };
      };
      return Context;
    };
  }
});

// node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS({
  "node_modules/bluebird/js/release/debuggability.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, Context) {
      var getDomain = Promise2._getDomain;
      var async = Promise2._async;
      var Warning = require_errors2().Warning;
      var util = require_util2();
      var canAttachTrace2 = util.canAttachTrace;
      var unhandledRejectionHandled;
      var possiblyUnhandledRejection;
      var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
      var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
      var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
      var stackFramePattern = null;
      var formatStack = null;
      var indentStackFrames = false;
      var printWarning;
      var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
      var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
      var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
      var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
      Promise2.prototype.suppressUnhandledRejections = function() {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
      };
      Promise2.prototype._ensurePossibleRejectionHandled = function() {
        if ((this._bitField & 524288) !== 0)
          return;
        this._setRejectionIsUnhandled();
        var self2 = this;
        setTimeout(function() {
          self2._notifyUnhandledRejection();
        }, 1);
      };
      Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
        fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, void 0, this);
      };
      Promise2.prototype._setReturnedNonUndefined = function() {
        this._bitField = this._bitField | 268435456;
      };
      Promise2.prototype._returnedNonUndefined = function() {
        return (this._bitField & 268435456) !== 0;
      };
      Promise2.prototype._notifyUnhandledRejection = function() {
        if (this._isRejectionUnhandled()) {
          var reason = this._settledValue();
          this._setUnhandledRejectionIsNotified();
          fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
        }
      };
      Promise2.prototype._setUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField | 262144;
      };
      Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField & ~262144;
      };
      Promise2.prototype._isUnhandledRejectionNotified = function() {
        return (this._bitField & 262144) > 0;
      };
      Promise2.prototype._setRejectionIsUnhandled = function() {
        this._bitField = this._bitField | 1048576;
      };
      Promise2.prototype._unsetRejectionIsUnhandled = function() {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
          this._unsetUnhandledRejectionIsNotified();
          this._notifyUnhandledRejectionIsHandled();
        }
      };
      Promise2.prototype._isRejectionUnhandled = function() {
        return (this._bitField & 1048576) > 0;
      };
      Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
        return warn(message, shouldUseOwnTrace, promise || this);
      };
      Promise2.onPossiblyUnhandledRejection = function(fn) {
        var domain = getDomain();
        possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : void 0;
      };
      Promise2.onUnhandledRejectionHandled = function(fn) {
        var domain = getDomain();
        unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : void 0;
      };
      var disableLongStackTraces = function() {
      };
      Promise2.longStackTraces = function() {
        if (async.haveItemsQueued() && !config.longStackTraces) {
          throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (!config.longStackTraces && longStackTracesIsSupported()) {
          var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
          var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
          config.longStackTraces = true;
          disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
          };
          Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
          Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
          Context.activateLongStackTraces();
          async.disableTrampolineIfNecessary();
        }
      };
      Promise2.hasLongStackTraces = function() {
        return config.longStackTraces && longStackTracesIsSupported();
      };
      var fireDomEvent = function() {
        try {
          if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new CustomEvent(name.toLowerCase(), {
                detail: event2,
                cancelable: true
              });
              return !util.global.dispatchEvent(domEvent);
            };
          } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new Event(name.toLowerCase(), {
                cancelable: true
              });
              domEvent.detail = event2;
              return !util.global.dispatchEvent(domEvent);
            };
          } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = document.createEvent("CustomEvent");
              domEvent.initCustomEvent(name.toLowerCase(), false, true, event2);
              return !util.global.dispatchEvent(domEvent);
            };
          }
        } catch (e) {
        }
        return function() {
          return false;
        };
      }();
      var fireGlobalEvent = function() {
        if (util.isNode) {
          return function() {
            return process.emit.apply(process, arguments);
          };
        } else {
          if (!util.global) {
            return function() {
              return false;
            };
          }
          return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method)
              return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
          };
        }
      }();
      function generatePromiseLifecycleEventObject(name, promise) {
        return { promise };
      }
      var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function(name, promise, child) {
          return { promise, child };
        },
        warning: function(name, warning) {
          return { warning };
        },
        unhandledRejection: function(name, reason, promise) {
          return { reason, promise };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
      };
      var activeFireEvent = function(name) {
        var globalEventFired = false;
        try {
          globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
          async.throwLater(e);
          globalEventFired = true;
        }
        var domEventFired = false;
        try {
          domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
        } catch (e) {
          async.throwLater(e);
          domEventFired = true;
        }
        return domEventFired || globalEventFired;
      };
      Promise2.config = function(opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
          if (opts.longStackTraces) {
            Promise2.longStackTraces();
          } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
            disableLongStackTraces();
          }
        }
        if ("warnings" in opts) {
          var warningsOption = opts.warnings;
          config.warnings = !!warningsOption;
          wForgottenReturn = config.warnings;
          if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
              wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
          }
        }
        if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
          if (async.haveItemsQueued()) {
            throw new Error("cannot enable cancellation after promises are in use");
          }
          Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
          Promise2.prototype._propagateFrom = cancellationPropagateFrom;
          Promise2.prototype._onCancel = cancellationOnCancel;
          Promise2.prototype._setOnCancel = cancellationSetOnCancel;
          Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
          Promise2.prototype._execute = cancellationExecute;
          propagateFromFunction = cancellationPropagateFrom;
          config.cancellation = true;
        }
        if ("monitoring" in opts) {
          if (opts.monitoring && !config.monitoring) {
            config.monitoring = true;
            Promise2.prototype._fireEvent = activeFireEvent;
          } else if (!opts.monitoring && config.monitoring) {
            config.monitoring = false;
            Promise2.prototype._fireEvent = defaultFireEvent;
          }
        }
        return Promise2;
      };
      function defaultFireEvent() {
        return false;
      }
      Promise2.prototype._fireEvent = defaultFireEvent;
      Promise2.prototype._execute = function(executor, resolve2, reject) {
        try {
          executor(resolve2, reject);
        } catch (e) {
          return e;
        }
      };
      Promise2.prototype._onCancel = function() {
      };
      Promise2.prototype._setOnCancel = function(handler) {
        ;
      };
      Promise2.prototype._attachCancellationCallback = function(onCancel) {
        ;
      };
      Promise2.prototype._captureStackTrace = function() {
      };
      Promise2.prototype._attachExtraTrace = function() {
      };
      Promise2.prototype._clearCancellationData = function() {
      };
      Promise2.prototype._propagateFrom = function(parent, flags) {
        ;
        ;
      };
      function cancellationExecute(executor, resolve2, reject) {
        var promise = this;
        try {
          executor(resolve2, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
              throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
          });
        } catch (e) {
          return e;
        }
      }
      function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable())
          return this;
        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== void 0) {
          if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
          } else {
            this._setOnCancel([previousOnCancel, onCancel]);
          }
        } else {
          this._setOnCancel(onCancel);
        }
      }
      function cancellationOnCancel() {
        return this._onCancelField;
      }
      function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
      }
      function cancellationClearCancellationData() {
        this._cancellationParent = void 0;
        this._onCancelField = void 0;
      }
      function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
          this._cancellationParent = parent;
          var branchesRemainingToCancel = parent._branchesRemainingToCancel;
          if (branchesRemainingToCancel === void 0) {
            branchesRemainingToCancel = 0;
          }
          parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      var propagateFromFunction = bindingPropagateFrom;
      function boundValueFunction() {
        var ret2 = this._boundTo;
        if (ret2 !== void 0) {
          if (ret2 instanceof Promise2) {
            if (ret2.isFulfilled()) {
              return ret2.value();
            } else {
              return void 0;
            }
          }
        }
        return ret2;
      }
      function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
      }
      function longStackTracesAttachExtraTrace(error2, ignoreSelf) {
        if (canAttachTrace2(error2)) {
          var trace = this._trace;
          if (trace !== void 0) {
            if (ignoreSelf)
              trace = trace._parent;
          }
          if (trace !== void 0) {
            trace.attachExtraTrace(error2);
          } else if (!error2.__stackCleaned__) {
            var parsed = parseStackAndMessage(error2);
            util.notEnumerableProp(error2, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error2, "__stackCleaned__", true);
          }
        }
      }
      function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
          if (parent !== void 0 && parent._returnedNonUndefined())
            return;
          if ((promise._bitField & 65535) === 0)
            return;
          if (name)
            name = name + " ";
          var handlerLine = "";
          var creatorLine = "";
          if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
              var line = stack[i];
              if (!nodeFramePattern.test(line)) {
                var lineMatches = line.match(parseLinePattern);
                if (lineMatches) {
                  handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                }
                break;
              }
            }
            if (stack.length > 0) {
              var firstUserLine = stack[0];
              for (var i = 0; i < traceLines.length; ++i) {
                if (traceLines[i] === firstUserLine) {
                  if (i > 0) {
                    creatorLine = "\n" + traceLines[i - 1];
                  }
                  break;
                }
              }
            }
          }
          var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
          promise._warn(msg, true, promiseCreated);
        }
      }
      function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement)
          message += " Use " + replacement + " instead.";
        return warn(message);
      }
      function warn(message, shouldUseOwnTrace, promise) {
        if (!config.warnings)
          return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
          promise._attachExtraTrace(warning);
        } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
          ctx.attachExtraTrace(warning);
        } else {
          var parsed = parseStackAndMessage(warning);
          warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        if (!activeFireEvent("warning", warning)) {
          formatAndLogError(warning, "", true);
        }
      }
      function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
          stacks[i].push("From previous event:");
          stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
          stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
      }
      function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
          if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
            stacks.splice(i, 1);
            i--;
          }
        }
      }
      function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
          var prev = stacks[i];
          var currentLastIndex = current.length - 1;
          var currentLastLine = current[currentLastIndex];
          var commonRootMeetPoint = -1;
          for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
              commonRootMeetPoint = j;
              break;
            }
          }
          for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
              current.pop();
              currentLastIndex--;
            } else {
              break;
            }
          }
          current = prev;
        }
      }
      function cleanStack(stack) {
        var ret2 = [];
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          var isTraceLine = line === "    (No stack trace)" || stackFramePattern.test(line);
          var isInternalFrame = isTraceLine && shouldIgnore(line);
          if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
              line = "    " + line;
            }
            ret2.push(line);
          }
        }
        return ret2;
      }
      function stackFramesAsArray(error2) {
        var stack = error2.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          if (line === "    (No stack trace)" || stackFramePattern.test(line)) {
            break;
          }
        }
        if (i > 0 && error2.name != "SyntaxError") {
          stack = stack.slice(i);
        }
        return stack;
      }
      function parseStackAndMessage(error2) {
        var stack = error2.stack;
        var message = error2.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error2) : ["    (No stack trace)"];
        return {
          message,
          stack: error2.name == "SyntaxError" ? stack : cleanStack(stack)
        };
      }
      function formatAndLogError(error2, title, isSoft) {
        if (typeof console !== "undefined") {
          var message;
          if (util.isObject(error2)) {
            var stack = error2.stack;
            message = title + formatStack(stack, error2);
          } else {
            message = title + String(error2);
          }
          if (typeof printWarning === "function") {
            printWarning(message, isSoft);
          } else if (typeof console.log === "function" || typeof console.log === "object") {
            console.log(message);
          }
        }
      }
      function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
          if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
              localHandler(promise);
            } else {
              localHandler(reason, promise);
            }
          }
        } catch (e) {
          async.throwLater(e);
        }
        if (name === "unhandledRejection") {
          if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
          }
        } else {
          activeFireEvent(name, promise);
        }
      }
      function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
          str = "[function " + (obj.name || "anonymous") + "]";
        } else {
          str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
          var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
          if (ruselessToString.test(str)) {
            try {
              var newStr = JSON.stringify(obj);
              str = newStr;
            } catch (e) {
            }
          }
          if (str.length === 0) {
            str = "(empty array)";
          }
        }
        return "(<" + snip(str) + ">, no stack trace)";
      }
      function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
          return str;
        }
        return str.substr(0, maxChars - 3) + "...";
      }
      function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
      }
      var shouldIgnore = function() {
        return false;
      };
      var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
      function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
          return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
          };
        }
      }
      function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported())
          return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
          var result = parseLineInfo(firstStackLines[i]);
          if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
          }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
          var result = parseLineInfo(lastStackLines[i]);
          if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
          }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
          return;
        }
        shouldIgnore = function(line) {
          if (bluebirdFramePattern.test(line))
            return true;
          var info = parseLineInfo(line);
          if (info) {
            if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
              return true;
            }
          }
          return false;
        };
      }
      function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32)
          this.uncycle();
      }
      util.inherits(CapturedTrace, Error);
      Context.CapturedTrace = CapturedTrace;
      CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2)
          return;
        var nodes = [];
        var stackToIndex = {};
        for (var i = 0, node = this; node !== void 0; ++i) {
          nodes.push(node);
          node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
          var stack = nodes[i].stack;
          if (stackToIndex[stack] === void 0) {
            stackToIndex[stack] = i;
          }
        }
        for (var i = 0; i < length; ++i) {
          var currentStack = nodes[i].stack;
          var index2 = stackToIndex[currentStack];
          if (index2 !== void 0 && index2 !== i) {
            if (index2 > 0) {
              nodes[index2 - 1]._parent = void 0;
              nodes[index2 - 1]._length = 1;
            }
            nodes[i]._parent = void 0;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
            if (index2 < length - 1) {
              cycleEdgeNode._parent = nodes[index2 + 1];
              cycleEdgeNode._parent.uncycle();
              cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
            } else {
              cycleEdgeNode._parent = void 0;
              cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
              nodes[j]._length = currentChildLength;
              currentChildLength++;
            }
            return;
          }
        }
      };
      CapturedTrace.prototype.attachExtraTrace = function(error2) {
        if (error2.__stackCleaned__)
          return;
        this.uncycle();
        var parsed = parseStackAndMessage(error2);
        var message = parsed.message;
        var stacks = [parsed.stack];
        var trace = this;
        while (trace !== void 0) {
          stacks.push(cleanStack(trace.stack.split("\n")));
          trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error2, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error2, "__stackCleaned__", true);
      };
      var captureStackTrace = function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error2) {
          if (typeof stack === "string")
            return stack;
          if (error2.name !== void 0 && error2.message !== void 0) {
            return error2.toString();
          }
          return formatNonError(error2);
        };
        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
          Error.stackTraceLimit += 6;
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          var captureStackTrace2 = Error.captureStackTrace;
          shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
          };
          return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace2(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
          };
        }
        var err = new Error();
        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
          stackFramePattern = /@/;
          formatStack = v8stackFormatter;
          indentStackFrames = true;
          return function captureStackTrace3(o) {
            o.stack = new Error().stack;
          };
        }
        var hasStackAfterThrow;
        try {
          throw new Error();
        } catch (e) {
          hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          return function captureStackTrace3(o) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (e) {
              o.stack = e.stack;
            }
            Error.stackTraceLimit -= 6;
          };
        }
        formatStack = function(stack, error2) {
          if (typeof stack === "string")
            return stack;
          if ((typeof error2 === "object" || typeof error2 === "function") && error2.name !== void 0 && error2.message !== void 0) {
            return error2.toString();
          }
          return formatNonError(error2);
        };
        return null;
      }([]);
      if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function(message) {
          console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
          printWarning = function(message, isSoft) {
            var color = isSoft ? "[33m" : "[31m";
            console.warn(color + message + "[0m\n");
          };
        } else if (!util.isNode && typeof new Error().stack === "string") {
          printWarning = function(message, isSoft) {
            console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
          };
        }
      }
      var config = {
        warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false
      };
      if (longStackTraces)
        Promise2.longStackTraces();
      return {
        longStackTraces: function() {
          return config.longStackTraces;
        },
        warnings: function() {
          return config.warnings;
        },
        cancellation: function() {
          return config.cancellation;
        },
        monitoring: function() {
          return config.monitoring;
        },
        propagateFromFunction: function() {
          return propagateFromFunction;
        },
        boundValueFunction: function() {
          return boundValueFunction;
        },
        checkForgottenReturns,
        setBounds,
        warn,
        deprecated,
        CapturedTrace,
        fireDomEvent,
        fireGlobalEvent
      };
    };
  }
});

// node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS({
  "node_modules/bluebird/js/release/catch_filter.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(NEXT_FILTER) {
      var util = require_util2();
      var getKeys = require_es5().keys;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function catchFilter(instances, cb, promise) {
        return function(e) {
          var boundTo = promise._boundValue();
          predicateLoop:
            for (var i = 0; i < instances.length; ++i) {
              var item = instances[i];
              if (item === Error || item != null && item.prototype instanceof Error) {
                if (e instanceof item) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (typeof item === "function") {
                var matchesPredicate = tryCatch2(item).call(boundTo, e);
                if (matchesPredicate === errorObj2) {
                  return matchesPredicate;
                } else if (matchesPredicate) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                  var key = keys[j];
                  if (item[key] != e[key]) {
                    continue predicateLoop;
                  }
                }
                return tryCatch2(cb).call(boundTo, e);
              }
            }
          return NEXT_FILTER;
        };
      }
      return catchFilter;
    };
  }
});

// node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS({
  "node_modules/bluebird/js/release/finally.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
      var util = require_util2();
      var CancellationError = Promise2.CancellationError;
      var errorObj2 = util.errorObj;
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      function PassThroughHandlerContext(promise, type, handler) {
        this.promise = promise;
        this.type = type;
        this.handler = handler;
        this.called = false;
        this.cancelPromise = null;
      }
      PassThroughHandlerContext.prototype.isFinallyHandler = function() {
        return this.type === 0;
      };
      function FinallyHandlerCancelReaction(finallyHandler2) {
        this.finallyHandler = finallyHandler2;
      }
      FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
        checkCancel(this.finallyHandler);
      };
      function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
          if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
          } else {
            ctx.cancelPromise._cancel();
          }
          ctx.cancelPromise = null;
          return true;
        }
        return false;
      }
      function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
      }
      function fail(reason) {
        if (checkCancel(this, reason))
          return;
        errorObj2.e = reason;
        return errorObj2;
      }
      function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
        if (!this.called) {
          this.called = true;
          var ret2 = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
          if (ret2 === NEXT_FILTER) {
            return ret2;
          } else if (ret2 !== void 0) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret2, promise);
            if (maybePromise instanceof Promise2) {
              if (this.cancelPromise != null) {
                if (maybePromise._isCancelled()) {
                  var reason = new CancellationError("late cancellation observer");
                  promise._attachExtraTrace(reason);
                  errorObj2.e = reason;
                  return errorObj2;
                } else if (maybePromise.isPending()) {
                  maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                }
              }
              return maybePromise._then(succeed, fail, void 0, this, void 0);
            }
          }
        }
        if (promise.isRejected()) {
          checkCancel(this);
          errorObj2.e = reasonOrValue;
          return errorObj2;
        } else {
          checkCancel(this);
          return reasonOrValue;
        }
      }
      Promise2.prototype._passThrough = function(handler, type, success, fail2) {
        if (typeof handler !== "function")
          return this.then();
        return this._then(success, fail2, void 0, new PassThroughHandlerContext(this, type, handler), void 0);
      };
      Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
        return this._passThrough(handler, 0, finallyHandler, finallyHandler);
      };
      Promise2.prototype.tap = function(handler) {
        return this._passThrough(handler, 1, finallyHandler);
      };
      Promise2.prototype.tapCatch = function(handlerOrPredicate) {
        var len = arguments.length;
        if (len === 1) {
          return this._passThrough(handlerOrPredicate, 1, void 0, finallyHandler);
        } else {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return Promise2.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + util.classString(item)));
            }
          }
          catchInstances.length = j;
          var handler = arguments[i];
          return this._passThrough(catchFilter(catchInstances, handler, this), 1, void 0, finallyHandler);
        }
      };
      return PassThroughHandlerContext;
    };
  }
});

// node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS({
  "node_modules/bluebird/js/release/nodeback.js"(exports2, module2) {
    init_shims();
    "use strict";
    var util = require_util2();
    var maybeWrapAsError2 = util.maybeWrapAsError;
    var errors = require_errors2();
    var OperationalError = errors.OperationalError;
    var es52 = require_es5();
    function isUntypedError(obj) {
      return obj instanceof Error && es52.getPrototypeOf(obj) === Error.prototype;
    }
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj) {
      var ret2;
      if (isUntypedError(obj)) {
        ret2 = new OperationalError(obj);
        ret2.name = obj.name;
        ret2.message = obj.message;
        ret2.stack = obj.stack;
        var keys = es52.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!rErrorKey.test(key)) {
            ret2[key] = obj[key];
          }
        }
        return ret2;
      }
      util.markAsOriginatingFromRejection(obj);
      return obj;
    }
    function nodebackForPromise(promise, multiArgs) {
      return function(err, value) {
        if (promise === null)
          return;
        if (err) {
          var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
          promise._attachExtraTrace(wrapped);
          promise._reject(wrapped);
        } else if (!multiArgs) {
          promise._fulfill(value);
        } else {
          var $_len = arguments.length;
          var args = new Array(Math.max($_len - 1, 0));
          for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
          }
          ;
          promise._fulfill(args);
        }
        promise = null;
      };
    }
    module2.exports = nodebackForPromise;
  }
});

// node_modules/bluebird/js/release/method.js
var require_method = __commonJS({
  "node_modules/bluebird/js/release/method.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
      var util = require_util2();
      var tryCatch2 = util.tryCatch;
      Promise2.method = function(fn) {
        if (typeof fn !== "function") {
          throw new Promise2.TypeError("expecting a function but got " + util.classString(fn));
        }
        return function() {
          var ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._pushContext();
          var value = tryCatch2(fn).apply(this, arguments);
          var promiseCreated = ret2._popContext();
          debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret2);
          ret2._resolveFromSyncValue(value);
          return ret2;
        };
      };
      Promise2.attempt = Promise2["try"] = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._pushContext();
        var value;
        if (arguments.length > 1) {
          debug.deprecated("calling Promise.try with more than 1 argument");
          var arg = arguments[1];
          var ctx = arguments[2];
          value = util.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
        } else {
          value = tryCatch2(fn)();
        }
        var promiseCreated = ret2._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret2);
        ret2._resolveFromSyncValue(value);
        return ret2;
      };
      Promise2.prototype._resolveFromSyncValue = function(value) {
        if (value === util.errorObj) {
          this._rejectCallback(value.e, false);
        } else {
          this._resolveCallback(value, true);
        }
      };
    };
  }
});

// node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS({
  "node_modules/bluebird/js/release/bind.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
      var calledBind = false;
      var rejectThis = function(_, e) {
        this._reject(e);
      };
      var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
      };
      var bindingResolved = function(thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
          this._resolveCallback(context.target);
        }
      };
      var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued)
          this._reject(e);
      };
      Promise2.prototype.bind = function(thisArg) {
        if (!calledBind) {
          calledBind = true;
          Promise2.prototype._propagateFrom = debug.propagateFromFunction();
          Promise2.prototype._boundValue = debug.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret2 = new Promise2(INTERNAL);
        ret2._propagateFrom(this, 1);
        var target = this._target();
        ret2._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise2) {
          var context = {
            promiseRejectionQueued: false,
            promise: ret2,
            target,
            bindingPromise: maybePromise
          };
          target._then(INTERNAL, targetRejected, void 0, ret2, context);
          maybePromise._then(bindingResolved, bindingRejected, void 0, ret2, context);
          ret2._setOnCancel(maybePromise);
        } else {
          ret2._resolveCallback(target);
        }
        return ret2;
      };
      Promise2.prototype._setBoundTo = function(obj) {
        if (obj !== void 0) {
          this._bitField = this._bitField | 2097152;
          this._boundTo = obj;
        } else {
          this._bitField = this._bitField & ~2097152;
        }
      };
      Promise2.prototype._isBound = function() {
        return (this._bitField & 2097152) === 2097152;
      };
      Promise2.bind = function(thisArg, value) {
        return Promise2.resolve(value).bind(thisArg);
      };
    };
  }
});

// node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS({
  "node_modules/bluebird/js/release/cancel.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
      var util = require_util2();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
        if (!debug.cancellation())
          return this._warn("cancellation is disabled");
        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
          if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
              child._followee().cancel();
            } else {
              child._cancelBranched();
            }
            break;
          }
          var parent = promise._cancellationParent;
          if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
              promise._followee().cancel();
            } else {
              promise._cancelBranched();
            }
            break;
          } else {
            if (promise._isFollowing())
              promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
          }
        }
      };
      Promise2.prototype._branchHasCancelled = function() {
        this._branchesRemainingToCancel--;
      };
      Promise2.prototype._enoughBranchesHaveCancelled = function() {
        return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
      };
      Promise2.prototype._cancelBy = function(canceller) {
        if (canceller === this) {
          this._branchesRemainingToCancel = 0;
          this._invokeOnCancel();
          return true;
        } else {
          this._branchHasCancelled();
          if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
          }
        }
        return false;
      };
      Promise2.prototype._cancelBranched = function() {
        if (this._enoughBranchesHaveCancelled()) {
          this._cancel();
        }
      };
      Promise2.prototype._cancel = function() {
        if (!this._isCancellable())
          return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, void 0);
      };
      Promise2.prototype._cancelPromises = function() {
        if (this._length() > 0)
          this._settlePromises();
      };
      Promise2.prototype._unsetOnCancel = function() {
        this._onCancelField = void 0;
      };
      Promise2.prototype._isCancellable = function() {
        return this.isPending() && !this._isCancelled();
      };
      Promise2.prototype.isCancellable = function() {
        return this.isPending() && !this.isCancelled();
      };
      Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
          for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
          }
        } else if (onCancelCallback !== void 0) {
          if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
              var e = tryCatch2(onCancelCallback).call(this._boundValue());
              if (e === errorObj2) {
                this._attachExtraTrace(e.e);
                async.throwLater(e.e);
              }
            }
          } else {
            onCancelCallback._resultCancelled(this);
          }
        }
      };
      Promise2.prototype._invokeOnCancel = function() {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
      };
      Promise2.prototype._invokeInternalOnCancel = function() {
        if (this._isCancellable()) {
          this._doInvokeOnCancel(this._onCancel(), true);
          this._unsetOnCancel();
        }
      };
      Promise2.prototype._resultCancelled = function() {
        this.cancel();
      };
    };
  }
});

// node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS({
  "node_modules/bluebird/js/release/direct_resolve.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2) {
      function returner() {
        return this.value;
      }
      function thrower2() {
        throw this.reason;
      }
      Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(returner, void 0, void 0, { value }, void 0);
      };
      Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
        return this._then(thrower2, void 0, void 0, { reason }, void 0);
      };
      Promise2.prototype.catchThrow = function(reason) {
        if (arguments.length <= 1) {
          return this._then(void 0, thrower2, void 0, { reason }, void 0);
        } else {
          var _reason = arguments[1];
          var handler = function() {
            throw _reason;
          };
          return this.caught(reason, handler);
        }
      };
      Promise2.prototype.catchReturn = function(value) {
        if (arguments.length <= 1) {
          if (value instanceof Promise2)
            value.suppressUnhandledRejections();
          return this._then(void 0, returner, void 0, { value }, void 0);
        } else {
          var _value = arguments[1];
          if (_value instanceof Promise2)
            _value.suppressUnhandledRejections();
          var handler = function() {
            return _value;
          };
          return this.caught(value, handler);
        }
      };
    };
  }
});

// node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS({
  "node_modules/bluebird/js/release/synchronous_inspection.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2) {
      function PromiseInspection(promise) {
        if (promise !== void 0) {
          promise = promise._target();
          this._bitField = promise._bitField;
          this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
        } else {
          this._bitField = 0;
          this._settledValueField = void 0;
        }
      }
      PromiseInspection.prototype._settledValue = function() {
        return this._settledValueField;
      };
      var value = PromiseInspection.prototype.value = function() {
        if (!this.isFulfilled()) {
          throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
        if (!this.isRejected()) {
          throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
        return (this._bitField & 33554432) !== 0;
      };
      var isRejected = PromiseInspection.prototype.isRejected = function() {
        return (this._bitField & 16777216) !== 0;
      };
      var isPending = PromiseInspection.prototype.isPending = function() {
        return (this._bitField & 50397184) === 0;
      };
      var isResolved = PromiseInspection.prototype.isResolved = function() {
        return (this._bitField & 50331648) !== 0;
      };
      PromiseInspection.prototype.isCancelled = function() {
        return (this._bitField & 8454144) !== 0;
      };
      Promise2.prototype.__isCancelled = function() {
        return (this._bitField & 65536) === 65536;
      };
      Promise2.prototype._isCancelled = function() {
        return this._target().__isCancelled();
      };
      Promise2.prototype.isCancelled = function() {
        return (this._target()._bitField & 8454144) !== 0;
      };
      Promise2.prototype.isPending = function() {
        return isPending.call(this._target());
      };
      Promise2.prototype.isRejected = function() {
        return isRejected.call(this._target());
      };
      Promise2.prototype.isFulfilled = function() {
        return isFulfilled.call(this._target());
      };
      Promise2.prototype.isResolved = function() {
        return isResolved.call(this._target());
      };
      Promise2.prototype.value = function() {
        return value.call(this._target());
      };
      Promise2.prototype.reason = function() {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
      };
      Promise2.prototype._value = function() {
        return this._settledValue();
      };
      Promise2.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
      };
      Promise2.PromiseInspection = PromiseInspection;
    };
  }
});

// node_modules/bluebird/js/release/join.js
var require_join = __commonJS({
  "node_modules/bluebird/js/release/join.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
      var util = require_util2();
      var canEvaluate2 = util.canEvaluate;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var reject;
      if (true) {
        if (canEvaluate2) {
          var thenCallback = function(i2) {
            return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
          };
          var promiseSetter = function(i2) {
            return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
          };
          var generateHolderClass = function(total) {
            var props = new Array(total);
            for (var i2 = 0; i2 < props.length; ++i2) {
              props[i2] = "this.p" + (i2 + 1);
            }
            var assignment = props.join(" = ") + " = null;";
            var cancellationCode = "var promise;\n" + props.map(function(prop) {
              return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
            }).join("\n");
            var passedArguments = props.join(", ");
            var name = "Holder$" + total;
            var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
            code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
            return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
          };
          var holderClasses = [];
          var thenCallbacks = [];
          var promiseSetters = [];
          for (var i = 0; i < 8; ++i) {
            holderClasses.push(generateHolderClass(i + 1));
            thenCallbacks.push(thenCallback(i + 1));
            promiseSetters.push(promiseSetter(i + 1));
          }
          reject = function(reason) {
            this._reject(reason);
          };
        }
      }
      Promise2.join = function() {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
          fn = arguments[last];
          if (true) {
            if (last <= 8 && canEvaluate2) {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              var HolderClass = holderClasses[last - 1];
              var holder = new HolderClass(fn);
              var callbacks = thenCallbacks;
              for (var i2 = 0; i2 < last; ++i2) {
                var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                if (maybePromise instanceof Promise2) {
                  maybePromise = maybePromise._target();
                  var bitField = maybePromise._bitField;
                  ;
                  if ((bitField & 50397184) === 0) {
                    maybePromise._then(callbacks[i2], reject, void 0, ret2, holder);
                    promiseSetters[i2](maybePromise, holder);
                    holder.asyncNeeded = false;
                  } else if ((bitField & 33554432) !== 0) {
                    callbacks[i2].call(ret2, maybePromise._value(), holder);
                  } else if ((bitField & 16777216) !== 0) {
                    ret2._reject(maybePromise._reason());
                  } else {
                    ret2._cancel();
                  }
                } else {
                  callbacks[i2].call(ret2, maybePromise, holder);
                }
              }
              if (!ret2._isFateSealed()) {
                if (holder.asyncNeeded) {
                  var domain = getDomain();
                  if (domain !== null) {
                    holder.fn = util.domainBind(domain, holder.fn);
                  }
                }
                ret2._setAsyncGuaranteed();
                ret2._setOnCancel(holder);
              }
              return ret2;
            }
          }
        }
        var $_len = arguments.length;
        var args = new Array($_len);
        for (var $_i = 0; $_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i];
        }
        ;
        if (fn)
          args.pop();
        var ret2 = new PromiseArray(args).promise();
        return fn !== void 0 ? ret2.spread(fn) : ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/map.js
var require_map2 = __commonJS({
  "node_modules/bluebird/js/release/map.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
      var getDomain = Promise2._getDomain;
      var util = require_util2();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain = getDomain();
        this._callback = domain === null ? fn : util.domainBind(domain, fn);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, void 0);
      }
      util.inherits(MappingPromiseArray, PromiseArray);
      MappingPromiseArray.prototype._asyncInit = function() {
        this._init$(void 0, -2);
      };
      MappingPromiseArray.prototype._init = function() {
      };
      MappingPromiseArray.prototype._promiseFulfilled = function(value, index2) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (index2 < 0) {
          index2 = index2 * -1 - 1;
          values[index2] = value;
          if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved())
              return true;
          }
        } else {
          if (limit >= 1 && this._inFlight >= limit) {
            values[index2] = value;
            this._queue.push(index2);
            return false;
          }
          if (preservedValues !== null)
            preservedValues[index2] = value;
          var promise = this._promise;
          var callback = this._callback;
          var receiver = promise._boundValue();
          promise._pushContext();
          var ret2 = tryCatch2(callback).call(receiver, value, index2, length);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(ret2, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
          if (ret2 === errorObj2) {
            this._reject(ret2.e);
            return true;
          }
          var maybePromise = tryConvertToPromise(ret2, this._promise);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
              if (limit >= 1)
                this._inFlight++;
              values[index2] = maybePromise;
              maybePromise._proxy(this, (index2 + 1) * -1);
              return false;
            } else if ((bitField & 33554432) !== 0) {
              ret2 = maybePromise._value();
            } else if ((bitField & 16777216) !== 0) {
              this._reject(maybePromise._reason());
              return true;
            } else {
              this._cancel();
              return true;
            }
          }
          values[index2] = ret2;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
          if (preservedValues !== null) {
            this._filter(values, preservedValues);
          } else {
            this._resolve(values);
          }
          return true;
        }
        return false;
      };
      MappingPromiseArray.prototype._drainQueue = function() {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
          if (this._isResolved())
            return;
          var index2 = queue.pop();
          this._promiseFulfilled(values[index2], index2);
        }
      };
      MappingPromiseArray.prototype._filter = function(booleans, values) {
        var len = values.length;
        var ret2 = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
          if (booleans[i])
            ret2[j++] = values[i];
        }
        ret2.length = j;
        this._resolve(ret2);
      };
      MappingPromiseArray.prototype.preservedValues = function() {
        return this._preservedValues;
      };
      function map(promises, fn, options2, _filter) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var limit = 0;
        if (options2 !== void 0) {
          if (typeof options2 === "object" && options2 !== null) {
            if (typeof options2.concurrency !== "number") {
              return Promise2.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options2.concurrency)));
            }
            limit = options2.concurrency;
          } else {
            return Promise2.reject(new TypeError("options argument must be an object but it is " + util.classString(options2)));
          }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
      }
      Promise2.prototype.map = function(fn, options2) {
        return map(this, fn, options2, null);
      };
      Promise2.map = function(promises, fn, options2, _filter) {
        return map(promises, fn, options2, _filter);
      };
    };
  }
});

// node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS({
  "node_modules/bluebird/js/release/call_get.js"(exports2, module2) {
    init_shims();
    "use strict";
    var cr = Object.create;
    if (cr) {
      callerCache = cr(null);
      getterCache = cr(null);
      callerCache[" size"] = getterCache[" size"] = 0;
    }
    var callerCache;
    var getterCache;
    module2.exports = function(Promise2) {
      var util = require_util2();
      var canEvaluate2 = util.canEvaluate;
      var isIdentifier2 = util.isIdentifier;
      var getMethodCaller;
      var getGetter;
      if (true) {
        var makeMethodCaller = function(methodName) {
          return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
        };
        var makeGetter = function(propertyName) {
          return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
        };
        var getCompiled = function(name, compiler, cache) {
          var ret2 = cache[name];
          if (typeof ret2 !== "function") {
            if (!isIdentifier2(name)) {
              return null;
            }
            ret2 = compiler(name);
            cache[name] = ret2;
            cache[" size"]++;
            if (cache[" size"] > 512) {
              var keys = Object.keys(cache);
              for (var i = 0; i < 256; ++i)
                delete cache[keys[i]];
              cache[" size"] = keys.length - 256;
            }
          }
          return ret2;
        };
        getMethodCaller = function(name) {
          return getCompiled(name, makeMethodCaller, callerCache);
        };
        getGetter = function(name) {
          return getCompiled(name, makeGetter, getterCache);
        };
      }
      function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null)
          fn = obj[methodName];
        if (typeof fn !== "function") {
          var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
          throw new Promise2.TypeError(message);
        }
        return fn;
      }
      function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
      }
      Promise2.prototype.call = function(methodName) {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        ;
        if (true) {
          if (canEvaluate2) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
              return this._then(maybeCaller, void 0, void 0, args, void 0);
            }
          }
        }
        args.push(methodName);
        return this._then(caller, void 0, void 0, args, void 0);
      };
      function namedGetter(obj) {
        return obj[this];
      }
      function indexedGetter(obj) {
        var index2 = +this;
        if (index2 < 0)
          index2 = Math.max(0, index2 + obj.length);
        return obj[index2];
      }
      Promise2.prototype.get = function(propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
          if (canEvaluate2) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
          } else {
            getter = namedGetter;
          }
        } else {
          getter = indexedGetter;
        }
        return this._then(getter, void 0, void 0, propertyName, void 0);
      };
    };
  }
});

// node_modules/bluebird/js/release/using.js
var require_using = __commonJS({
  "node_modules/bluebird/js/release/using.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
      var util = require_util2();
      var TypeError2 = require_errors2().TypeError;
      var inherits2 = require_util2().inherits;
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var NULL = {};
      function thrower2(e) {
        setTimeout(function() {
          throw e;
        }, 0);
      }
      function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
          maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
      }
      function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret2 = new Promise2(INTERNAL);
        function iterator() {
          if (i >= len)
            return ret2._fulfill();
          var maybePromise = castPreservingDisposable(resources[i++]);
          if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
            try {
              maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
            } catch (e) {
              return thrower2(e);
            }
            if (maybePromise instanceof Promise2) {
              return maybePromise._then(iterator, thrower2, null, null, null);
            }
          }
          iterator();
        }
        iterator();
        return ret2;
      }
      function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
      }
      Disposer.prototype.data = function() {
        return this._data;
      };
      Disposer.prototype.promise = function() {
        return this._promise;
      };
      Disposer.prototype.resource = function() {
        if (this.promise().isFulfilled()) {
          return this.promise().value();
        }
        return NULL;
      };
      Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== void 0)
          context._pushContext();
        var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== void 0)
          context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret2;
      };
      Disposer.isDisposer = function(d2) {
        return d2 != null && typeof d2.resource === "function" && typeof d2.tryDispose === "function";
      };
      function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
      }
      inherits2(FunctionDisposer, Disposer);
      FunctionDisposer.prototype.doDispose = function(resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
      };
      function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
          this.resources[this.index]._setDisposable(value);
          return value.promise();
        }
        return value;
      }
      function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
      }
      ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
          var item = this[i];
          if (item instanceof Promise2) {
            item.cancel();
          }
        }
      };
      Promise2.using = function() {
        var len = arguments.length;
        if (len < 2)
          return apiRejection("you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
          input = arguments[0];
          len = input.length;
          spreadArgs = false;
        } else {
          input = arguments;
          len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
          var resource = input[i];
          if (Disposer.isDisposer(resource)) {
            var disposer = resource;
            resource = resource.promise();
            resource._setDisposable(disposer);
          } else {
            var maybePromise = tryConvertToPromise(resource);
            if (maybePromise instanceof Promise2) {
              resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                resources,
                index: i
              }, void 0);
            }
          }
          resources[i] = resource;
        }
        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
          reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
        }
        var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
          for (var i2 = 0; i2 < inspections.length; ++i2) {
            var inspection = inspections[i2];
            if (inspection.isRejected()) {
              errorObj2.e = inspection.error();
              return errorObj2;
            } else if (!inspection.isFulfilled()) {
              resultPromise.cancel();
              return;
            }
            inspections[i2] = inspection.value();
          }
          promise._pushContext();
          fn = tryCatch2(fn);
          var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(ret2, promiseCreated, "Promise.using", promise);
          return ret2;
        });
        var promise = resultPromise.lastly(function() {
          var inspection = new Promise2.PromiseInspection(resultPromise);
          return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
      };
      Promise2.prototype._setDisposable = function(disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
      };
      Promise2.prototype._isDisposable = function() {
        return (this._bitField & 131072) > 0;
      };
      Promise2.prototype._getDisposer = function() {
        return this._disposer;
      };
      Promise2.prototype._unsetDisposable = function() {
        this._bitField = this._bitField & ~131072;
        this._disposer = void 0;
      };
      Promise2.prototype.disposer = function(fn) {
        if (typeof fn === "function") {
          return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError2();
      };
    };
  }
});

// node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS({
  "node_modules/bluebird/js/release/timers.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, INTERNAL, debug) {
      var util = require_util2();
      var TimeoutError = Promise2.TimeoutError;
      function HandleWrapper(handle) {
        this.handle = handle;
      }
      HandleWrapper.prototype._resultCancelled = function() {
        clearTimeout(this.handle);
      };
      var afterValue = function(value) {
        return delay(+this).thenReturn(value);
      };
      var delay = Promise2.delay = function(ms, value) {
        var ret2;
        var handle;
        if (value !== void 0) {
          ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          if (debug.cancellation() && value instanceof Promise2) {
            ret2._setOnCancel(value);
          }
        } else {
          ret2 = new Promise2(INTERNAL);
          handle = setTimeout(function() {
            ret2._fulfill();
          }, +ms);
          if (debug.cancellation()) {
            ret2._setOnCancel(new HandleWrapper(handle));
          }
          ret2._captureStackTrace();
        }
        ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.prototype.delay = function(ms) {
        return delay(ms, this);
      };
      var afterTimeout = function(promise, message, parent) {
        var err;
        if (typeof message !== "string") {
          if (message instanceof Error) {
            err = message;
          } else {
            err = new TimeoutError("operation timed out");
          }
        } else {
          err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);
        if (parent != null) {
          parent.cancel();
        }
      };
      function successClear(value) {
        clearTimeout(this.handle);
        return value;
      }
      function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
      }
      Promise2.prototype.timeout = function(ms, message) {
        ms = +ms;
        var ret2, parent;
        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
          if (ret2.isPending()) {
            afterTimeout(ret2, message, parent);
          }
        }, ms));
        if (debug.cancellation()) {
          parent = this.then();
          ret2 = parent._then(successClear, failureClear, void 0, handleWrapper, void 0);
          ret2._setOnCancel(handleWrapper);
        } else {
          ret2 = this._then(successClear, failureClear, void 0, handleWrapper, void 0);
        }
        return ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS({
  "node_modules/bluebird/js/release/generators.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
      var errors = require_errors2();
      var TypeError2 = errors.TypeError;
      var util = require_util2();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var yieldHandlers = [];
      function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
        for (var i = 0; i < yieldHandlers2.length; ++i) {
          traceParent._pushContext();
          var result = tryCatch2(yieldHandlers2[i])(value);
          traceParent._popContext();
          if (result === errorObj2) {
            traceParent._pushContext();
            var ret2 = Promise2.reject(errorObj2.e);
            traceParent._popContext();
            return ret2;
          }
          var maybePromise = tryConvertToPromise(result, traceParent);
          if (maybePromise instanceof Promise2)
            return maybePromise;
        }
        return null;
      }
      function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug.cancellation()) {
          var internal = new Promise2(INTERNAL);
          var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
          this._promise = internal.lastly(function() {
            return _finallyPromise;
          });
          internal._captureStackTrace();
          internal._setOnCancel(this);
        } else {
          var promise = this._promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = void 0;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
      }
      util.inherits(PromiseSpawn, Proxyable);
      PromiseSpawn.prototype._isResolved = function() {
        return this._promise === null;
      };
      PromiseSpawn.prototype._cleanup = function() {
        this._promise = this._generator = null;
        if (debug.cancellation() && this._finallyPromise !== null) {
          this._finallyPromise._fulfill();
          this._finallyPromise = null;
        }
      };
      PromiseSpawn.prototype._promiseCancelled = function() {
        if (this._isResolved())
          return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";
        var result;
        if (!implementsReturn) {
          var reason = new Promise2.CancellationError("generator .return() sentinel");
          Promise2.coroutine.returnSentinel = reason;
          this._promise._attachExtraTrace(reason);
          this._promise._pushContext();
          result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
          this._promise._popContext();
        } else {
          this._promise._pushContext();
          result = tryCatch2(this._generator["return"]).call(this._generator, void 0);
          this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseFulfilled = function(value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch2(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseRejected = function(reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._resultCancelled = function() {
        if (this._yieldedPromise instanceof Promise2) {
          var promise = this._yieldedPromise;
          this._yieldedPromise = null;
          promise.cancel();
        }
      };
      PromiseSpawn.prototype.promise = function() {
        return this._promise;
      };
      PromiseSpawn.prototype._run = function() {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = void 0;
        this._promiseFulfilled(void 0);
      };
      PromiseSpawn.prototype._continue = function(result) {
        var promise = this._promise;
        if (result === errorObj2) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._rejectCallback(result.e, false);
          }
        }
        var value = result.value;
        if (result.done === true) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._resolveCallback(value);
          }
        } else {
          var maybePromise = tryConvertToPromise(value, this._promise);
          if (!(maybePromise instanceof Promise2)) {
            maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
            if (maybePromise === null) {
              this._promiseRejected(new TypeError2("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
              return;
            }
          }
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          ;
          if ((bitField & 50397184) === 0) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
          } else if ((bitField & 33554432) !== 0) {
            Promise2._async.invoke(this._promiseFulfilled, this, maybePromise._value());
          } else if ((bitField & 16777216) !== 0) {
            Promise2._async.invoke(this._promiseRejected, this, maybePromise._reason());
          } else {
            this._promiseCancelled();
          }
        }
      };
      Promise2.coroutine = function(generatorFunction, options2) {
        if (typeof generatorFunction !== "function") {
          throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var yieldHandler = Object(options2).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function() {
          var generator = generatorFunction.apply(this, arguments);
          var spawn = new PromiseSpawn$(void 0, void 0, yieldHandler, stack);
          var ret2 = spawn.promise();
          spawn._generator = generator;
          spawn._promiseFulfilled(void 0);
          return ret2;
        };
      };
      Promise2.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        yieldHandlers.push(fn);
      };
      Promise2.spawn = function(generatorFunction) {
        debug.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
          return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret2 = spawn.promise();
        spawn._run(Promise2.spawn);
        return ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS({
  "node_modules/bluebird/js/release/nodeify.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2) {
      var util = require_util2();
      var async = Promise2._async;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val))
          return successAdapter.call(promise, val, nodeback);
        var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
          var newReason = new Error(reason + "");
          newReason.cause = reason;
          reason = newReason;
        }
        var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options2) {
        if (typeof nodeback == "function") {
          var adapter = successAdapter;
          if (options2 !== void 0 && Object(options2).spread) {
            adapter = spreadAdapter;
          }
          this._then(adapter, errorAdapter, void 0, this, nodeback);
        }
        return this;
      };
    };
  }
});

// node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS({
  "node_modules/bluebird/js/release/promisify.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var THIS = {};
      var util = require_util2();
      var nodebackForPromise = require_nodeback();
      var withAppended2 = util.withAppended;
      var maybeWrapAsError2 = util.maybeWrapAsError;
      var canEvaluate2 = util.canEvaluate;
      var TypeError2 = require_errors2().TypeError;
      var defaultSuffix = "Async";
      var defaultPromisified = { __isPromisified__: true };
      var noCopyProps = [
        "arity",
        "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
      ];
      var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
      var defaultFilter = function(name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
      };
      function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
      }
      function isPromisified(fn) {
        try {
          return fn.__isPromisified__ === true;
        } catch (e) {
          return false;
        }
      }
      function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
        return val ? isPromisified(val) : false;
      }
      function checkValid(ret2, suffix, suffixRegexp) {
        for (var i = 0; i < ret2.length; i += 2) {
          var key = ret2[i];
          if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret2.length; j += 2) {
              if (ret2[j] === keyWithoutAsyncSuffix) {
                throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
              }
            }
          }
        }
      }
      function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret2 = [];
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var value = obj[key];
          var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
          if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
            ret2.push(key, value);
          }
        }
        checkValid(ret2, suffix, suffixRegexp);
        return ret2;
      }
      var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
      };
      var makeNodePromisifiedEval;
      if (true) {
        var switchCaseArgumentOrder = function(likelyArgumentCount) {
          var ret2 = [likelyArgumentCount];
          var min = Math.max(0, likelyArgumentCount - 1 - 3);
          for (var i = likelyArgumentCount - 1; i >= min; --i) {
            ret2.push(i);
          }
          for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret2.push(i);
          }
          return ret2;
        };
        var argumentSequence = function(argumentCount) {
          return util.filledRange(argumentCount, "_arg", "");
        };
        var parameterDeclaration = function(parameterCount2) {
          return util.filledRange(Math.max(parameterCount2, 3), "_arg", "");
        };
        var parameterCount = function(fn) {
          if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
          }
          return 0;
        };
        makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
          var newParameterCount = Math.max(0, parameterCount(fn) - 1);
          var argumentOrder = switchCaseArgumentOrder(newParameterCount);
          var shouldProxyThis = typeof callback === "string" || receiver === THIS;
          function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret2;
            if (shouldProxyThis) {
              ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
              ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret2.replace("{{args}}", args).replace(", ", comma);
          }
          function generateArgumentSwitchCase() {
            var ret2 = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
              ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
            }
            ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
            return ret2;
          }
          var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
          var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
          body = body.replace("Parameters", parameterDeclaration(newParameterCount));
          return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise2, fn, receiver, withAppended2, maybeWrapAsError2, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
        };
      }
      function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
        var defaultThis = function() {
          return this;
        }();
        var method = callback;
        if (typeof method === "string") {
          callback = fn;
        }
        function promisified() {
          var _receiver = receiver;
          if (receiver === THIS)
            _receiver = this;
          var promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
          var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
          var fn2 = nodebackForPromise(promise, multiArgs);
          try {
            cb.apply(_receiver, withAppended2(arguments, fn2));
          } catch (e) {
            promise._rejectCallback(maybeWrapAsError2(e), true, true);
          }
          if (!promise._isFateSealed())
            promise._setAsyncGuaranteed();
          return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
      }
      var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
      function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);
        for (var i = 0, len = methods.length; i < len; i += 2) {
          var key = methods[i];
          var fn = methods[i + 1];
          var promisifiedKey = key + suffix;
          if (promisifier === makeNodePromisified) {
            obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
          } else {
            var promisified = promisifier(fn, function() {
              return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj[promisifiedKey] = promisified;
          }
        }
        util.toFastProperties(obj);
        return obj;
      }
      function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(callback, receiver, void 0, callback, null, multiArgs);
      }
      Promise2.promisify = function(fn, options2) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        if (isPromisified(fn)) {
          return fn;
        }
        options2 = Object(options2);
        var receiver = options2.context === void 0 ? THIS : options2.context;
        var multiArgs = !!options2.multiArgs;
        var ret2 = promisify(fn, receiver, multiArgs);
        util.copyDescriptors(fn, ret2, propsFilter);
        return ret2;
      };
      Promise2.promisifyAll = function(target, options2) {
        if (typeof target !== "function" && typeof target !== "object") {
          throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        options2 = Object(options2);
        var multiArgs = !!options2.multiArgs;
        var suffix = options2.suffix;
        if (typeof suffix !== "string")
          suffix = defaultSuffix;
        var filter = options2.filter;
        if (typeof filter !== "function")
          filter = defaultFilter;
        var promisifier = options2.promisifier;
        if (typeof promisifier !== "function")
          promisifier = makeNodePromisified;
        if (!util.isIdentifier(suffix)) {
          throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
        }
        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
          var value = target[keys[i]];
          if (keys[i] !== "constructor" && util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
          }
        }
        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
      };
    };
  }
});

// node_modules/bluebird/js/release/props.js
var require_props = __commonJS({
  "node_modules/bluebird/js/release/props.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
      var util = require_util2();
      var isObject2 = util.isObject;
      var es52 = require_es5();
      var Es6Map;
      if (typeof Map === "function")
        Es6Map = Map;
      var mapToEntries = function() {
        var index2 = 0;
        var size = 0;
        function extractEntry(value, key) {
          this[index2] = value;
          this[index2 + size] = key;
          index2++;
        }
        return function mapToEntries2(map) {
          size = map.size;
          index2 = 0;
          var ret2 = new Array(map.size * 2);
          map.forEach(extractEntry, ret2);
          return ret2;
        };
      }();
      var entriesToMap = function(entries) {
        var ret2 = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i = 0; i < length; ++i) {
          var key = entries[length + i];
          var value = entries[i];
          ret2.set(key, value);
        }
        return ret2;
      };
      function PropertiesPromiseArray(obj) {
        var isMap = false;
        var entries;
        if (Es6Map !== void 0 && obj instanceof Es6Map) {
          entries = mapToEntries(obj);
          isMap = true;
        } else {
          var keys = es52.keys(obj);
          var len = keys.length;
          entries = new Array(len * 2);
          for (var i = 0; i < len; ++i) {
            var key = keys[i];
            entries[i] = obj[key];
            entries[i + len] = key;
          }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(void 0, isMap ? -6 : -3);
      }
      util.inherits(PropertiesPromiseArray, PromiseArray);
      PropertiesPromiseArray.prototype._init = function() {
      };
      PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index2) {
        this._values[index2] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          var val;
          if (this._isMap) {
            val = entriesToMap(this._values);
          } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
              val[this._values[i + keyOffset]] = this._values[i];
            }
          }
          this._resolve(val);
          return true;
        }
        return false;
      };
      PropertiesPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      PropertiesPromiseArray.prototype.getActualLength = function(len) {
        return len >> 1;
      };
      function props(promises) {
        var ret2;
        var castValue = tryConvertToPromise(promises);
        if (!isObject2(castValue)) {
          return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
        } else if (castValue instanceof Promise2) {
          ret2 = castValue._then(Promise2.props, void 0, void 0, void 0, void 0);
        } else {
          ret2 = new PropertiesPromiseArray(castValue).promise();
        }
        if (castValue instanceof Promise2) {
          ret2._propagateFrom(castValue, 2);
        }
        return ret2;
      }
      Promise2.prototype.props = function() {
        return props(this);
      };
      Promise2.props = function(promises) {
        return props(promises);
      };
    };
  }
});

// node_modules/bluebird/js/release/race.js
var require_race = __commonJS({
  "node_modules/bluebird/js/release/race.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
      var util = require_util2();
      var raceLater = function(promise) {
        return promise.then(function(array) {
          return race(array, promise);
        });
      };
      function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
        if (maybePromise instanceof Promise2) {
          return raceLater(maybePromise);
        } else {
          promises = util.asArray(promises);
          if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }
        var ret2 = new Promise2(INTERNAL);
        if (parent !== void 0) {
          ret2._propagateFrom(parent, 3);
        }
        var fulfill = ret2._fulfill;
        var reject = ret2._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
          var val = promises[i];
          if (val === void 0 && !(i in promises)) {
            continue;
          }
          Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
        }
        return ret2;
      }
      Promise2.race = function(promises) {
        return race(promises, void 0);
      };
      Promise2.prototype.race = function() {
        return race(this, void 0);
      };
    };
  }
});

// node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS({
  "node_modules/bluebird/js/release/reduce.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
      var getDomain = Promise2._getDomain;
      var util = require_util2();
      var tryCatch2 = util.tryCatch;
      function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var domain = getDomain();
        this._fn = domain === null ? fn : util.domainBind(domain, fn);
        if (initialValue !== void 0) {
          initialValue = Promise2.resolve(initialValue);
          initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
          this._eachValues = Array(this._length);
        } else if (_each === 0) {
          this._eachValues = null;
        } else {
          this._eachValues = void 0;
        }
        this._promise._captureStackTrace();
        this._init$(void 0, -5);
      }
      util.inherits(ReductionPromiseArray, PromiseArray);
      ReductionPromiseArray.prototype._gotAccum = function(accum) {
        if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
          this._eachValues.push(accum);
        }
      };
      ReductionPromiseArray.prototype._eachComplete = function(value) {
        if (this._eachValues !== null) {
          this._eachValues.push(value);
        }
        return this._eachValues;
      };
      ReductionPromiseArray.prototype._init = function() {
      };
      ReductionPromiseArray.prototype._resolveEmptyArray = function() {
        this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
      };
      ReductionPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      ReductionPromiseArray.prototype._resolve = function(value) {
        this._promise._resolveCallback(value);
        this._values = null;
      };
      ReductionPromiseArray.prototype._resultCancelled = function(sender) {
        if (sender === this._initialValue)
          return this._cancel();
        if (this._isResolved())
          return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise2) {
          this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise2) {
          this._initialValue.cancel();
        }
      };
      ReductionPromiseArray.prototype._iterate = function(values) {
        this._values = values;
        var value;
        var i;
        var length = values.length;
        if (this._initialValue !== void 0) {
          value = this._initialValue;
          i = 0;
        } else {
          value = Promise2.resolve(values[0]);
          i = 1;
        }
        this._currentCancellable = value;
        if (!value.isRejected()) {
          for (; i < length; ++i) {
            var ctx = {
              accum: null,
              value: values[i],
              index: i,
              length,
              array: this
            };
            value = value._then(gotAccum, void 0, void 0, ctx, void 0);
          }
        }
        if (this._eachValues !== void 0) {
          value = value._then(this._eachComplete, void 0, void 0, this, void 0);
        }
        value._then(completed, completed, void 0, value, this);
      };
      Promise2.prototype.reduce = function(fn, initialValue) {
        return reduce(this, fn, initialValue, null);
      };
      Promise2.reduce = function(promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
      };
      function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
          array._resolve(valueOrReason);
        } else {
          array._reject(valueOrReason);
        }
      }
      function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
      }
      function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise2) {
          this.array._currentCancellable = value;
          return value._then(gotValue, void 0, void 0, this, void 0);
        } else {
          return gotValue.call(this, value);
        }
      }
      function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch2(array._fn);
        promise._pushContext();
        var ret2;
        if (array._eachValues !== void 0) {
          ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
          ret2 = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
        }
        if (ret2 instanceof Promise2) {
          array._currentCancellable = ret2;
        }
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret2, promiseCreated, array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce", promise);
        return ret2;
      }
    };
  }
});

// node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS({
  "node_modules/bluebird/js/release/settle.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, PromiseArray, debug) {
      var PromiseInspection = Promise2.PromiseInspection;
      var util = require_util2();
      function SettledPromiseArray(values) {
        this.constructor$(values);
      }
      util.inherits(SettledPromiseArray, PromiseArray);
      SettledPromiseArray.prototype._promiseResolved = function(index2, inspection) {
        this._values[index2] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      SettledPromiseArray.prototype._promiseFulfilled = function(value, index2) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 33554432;
        ret2._settledValueField = value;
        return this._promiseResolved(index2, ret2);
      };
      SettledPromiseArray.prototype._promiseRejected = function(reason, index2) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 16777216;
        ret2._settledValueField = reason;
        return this._promiseResolved(index2, ret2);
      };
      Promise2.settle = function(promises) {
        debug.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
      };
      Promise2.prototype.settle = function() {
        return Promise2.settle(this);
      };
    };
  }
});

// node_modules/bluebird/js/release/some.js
var require_some = __commonJS({
  "node_modules/bluebird/js/release/some.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection) {
      var util = require_util2();
      var RangeError2 = require_errors2().RangeError;
      var AggregateError = require_errors2().AggregateError;
      var isArray = util.isArray;
      var CANCELLATION = {};
      function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
      }
      util.inherits(SomePromiseArray, PromiseArray);
      SomePromiseArray.prototype._init = function() {
        if (!this._initialized) {
          return;
        }
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
          this._reject(this._getRangeError(this.length()));
        }
      };
      SomePromiseArray.prototype.init = function() {
        this._initialized = true;
        this._init();
      };
      SomePromiseArray.prototype.setUnwrap = function() {
        this._unwrap = true;
      };
      SomePromiseArray.prototype.howMany = function() {
        return this._howMany;
      };
      SomePromiseArray.prototype.setHowMany = function(count) {
        this._howMany = count;
      };
      SomePromiseArray.prototype._promiseFulfilled = function(value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
          this._values.length = this.howMany();
          if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
          } else {
            this._resolve(this._values);
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._promiseRejected = function(reason) {
        this._addRejected(reason);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._promiseCancelled = function() {
        if (this._values instanceof Promise2 || this._values == null) {
          return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._checkOutcome = function() {
        if (this.howMany() > this._canPossiblyFulfill()) {
          var e = new AggregateError();
          for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
              e.push(this._values[i]);
            }
          }
          if (e.length > 0) {
            this._reject(e);
          } else {
            this._cancel();
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._fulfilled = function() {
        return this._totalResolved;
      };
      SomePromiseArray.prototype._rejected = function() {
        return this._values.length - this.length();
      };
      SomePromiseArray.prototype._addRejected = function(reason) {
        this._values.push(reason);
      };
      SomePromiseArray.prototype._addFulfilled = function(value) {
        this._values[this._totalResolved++] = value;
      };
      SomePromiseArray.prototype._canPossiblyFulfill = function() {
        return this.length() - this._rejected();
      };
      SomePromiseArray.prototype._getRangeError = function(count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError2(message);
      };
      SomePromiseArray.prototype._resolveEmptyArray = function() {
        this._reject(this._getRangeError(0));
      };
      function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
          return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
        }
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(howMany);
        ret2.init();
        return promise;
      }
      Promise2.some = function(promises, howMany) {
        return some(promises, howMany);
      };
      Promise2.prototype.some = function(howMany) {
        return some(this, howMany);
      };
      Promise2._SomePromiseArray = SomePromiseArray;
    };
  }
});

// node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS({
  "node_modules/bluebird/js/release/filter.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseMap = Promise2.map;
      Promise2.prototype.filter = function(fn, options2) {
        return PromiseMap(this, fn, options2, INTERNAL);
      };
      Promise2.filter = function(promises, fn, options2) {
        return PromiseMap(promises, fn, options2, INTERNAL);
      };
    };
  }
});

// node_modules/bluebird/js/release/each.js
var require_each = __commonJS({
  "node_modules/bluebird/js/release/each.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseReduce = Promise2.reduce;
      var PromiseAll = Promise2.all;
      function promiseAllThis() {
        return PromiseAll(this);
      }
      function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
      }
      Promise2.prototype.each = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
      };
      Promise2.prototype.mapSeries = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, INTERNAL);
      };
      Promise2.each = function(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
      };
      Promise2.mapSeries = PromiseMapSeries;
    };
  }
});

// node_modules/bluebird/js/release/any.js
var require_any = __commonJS({
  "node_modules/bluebird/js/release/any.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(Promise2) {
      var SomePromiseArray = Promise2._SomePromiseArray;
      function any(promises) {
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(1);
        ret2.setUnwrap();
        ret2.init();
        return promise;
      }
      Promise2.any = function(promises) {
        return any(promises);
      };
      Promise2.prototype.any = function() {
        return any(this);
      };
    };
  }
});

// node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS({
  "node_modules/bluebird/js/release/promise.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function() {
      var makeSelfResolutionError = function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      };
      var reflectHandler = function() {
        return new Promise2.PromiseInspection(this._target());
      };
      var apiRejection = function(msg) {
        return Promise2.reject(new TypeError2(msg));
      };
      function Proxyable() {
      }
      var UNDEFINED_BINDING = {};
      var util = require_util2();
      var getDomain;
      if (util.isNode) {
        getDomain = function() {
          var ret2 = process.domain;
          if (ret2 === void 0)
            ret2 = null;
          return ret2;
        };
      } else {
        getDomain = function() {
          return null;
        };
      }
      util.notEnumerableProp(Promise2, "_getDomain", getDomain);
      var es52 = require_es5();
      var Async = require_async();
      var async = new Async();
      es52.defineProperty(Promise2, "_async", { value: async });
      var errors = require_errors2();
      var TypeError2 = Promise2.TypeError = errors.TypeError;
      Promise2.RangeError = errors.RangeError;
      var CancellationError = Promise2.CancellationError = errors.CancellationError;
      Promise2.TimeoutError = errors.TimeoutError;
      Promise2.OperationalError = errors.OperationalError;
      Promise2.RejectionError = errors.OperationalError;
      Promise2.AggregateError = errors.AggregateError;
      var INTERNAL = function() {
      };
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
      var PromiseArray = require_promise_array()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
      var Context = require_context()(Promise2);
      var createContext = Context.create;
      var debug = require_debuggability()(Promise2, Context);
      var CapturedTrace = debug.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise, NEXT_FILTER);
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      var nodebackForPromise = require_nodeback();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      function check(self2, executor) {
        if (self2 == null || self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(executor));
        }
      }
      function Promise2(executor) {
        if (executor !== INTERNAL) {
          check(this, executor);
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._resolveFromExecutor(executor);
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
            }
          }
          catchInstances.length = j;
          fn = arguments[i];
          return this.then(void 0, catchFilter(catchInstances, fn, this));
        }
        return this.then(void 0, fn);
      };
      Promise2.prototype.reflect = function() {
        return this._then(reflectHandler, reflectHandler, void 0, this, void 0);
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise._setIsFinal();
      };
      Promise2.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        return this.all()._then(fn, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret2 = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret2.fulfillmentValue = this.value();
          ret2.isFulfilled = true;
        } else if (this.isRejected()) {
          ret2.rejectionReason = this.reason();
          ret2.isRejected = true;
        }
        return ret2;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn) {
        return this.caught(util.originatesFromRejection, fn);
      };
      Promise2.getNewLibraryCopy = module2.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
        if (result === errorObj2) {
          ret2._rejectCallback(result.e, true);
        }
        if (!ret2._isFateSealed())
          ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.all = function(promises) {
        return new PromiseArray(promises).promise();
      };
      Promise2.cast = function(obj) {
        var ret2 = tryConvertToPromise(obj);
        if (!(ret2 instanceof Promise2)) {
          ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._setFulfilled();
          ret2._rejectionHandler0 = obj;
        }
        return ret2;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._rejectCallback(reason, true);
        return ret2;
      };
      Promise2.setScheduler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        return async.setScheduler(fn);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
          promise._propagateFrom(this, 3);
          promise._captureStackTrace();
          if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver = this._boundValue();
            } else {
              receiver = target === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise);
        }
        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
          var handler, value, settler = target._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target._rejectionHandler0;
            handler = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
          } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
          }
          async.invoke(settler, target, {
            handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
            promise,
            receiver,
            value
          });
        } else {
          target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
        }
        return promise;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & ~65536;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async.hasCustomScheduler())
          return;
        this._bitField = this._bitField | 134217728;
      };
      Promise2.prototype._receiverAt = function(index2) {
        var ret2 = index2 === 0 ? this._receiver0 : this[index2 * 4 - 4 + 3];
        if (ret2 === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret2 === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret2;
      };
      Promise2.prototype._promiseAt = function(index2) {
        return this[index2 * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index2) {
        return this[index2 * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index2) {
        return this[index2 * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index2) {
        var fulfill = follower._fulfillmentHandlerAt(index2);
        var reject = follower._rejectionHandlerAt(index2);
        var promise = follower._promiseAt(index2);
        var receiver = follower._receiverAt(index2);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain) {
        var index2 = this._length();
        if (index2 >= 65535 - 4) {
          index2 = 0;
          this._setLength(0);
        }
        if (index2 === 0) {
          this._promise0 = promise;
          this._receiver0 = receiver;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
          }
          if (typeof reject === "function") {
            this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
          }
        } else {
          var base = index2 * 4 - 4;
          this[base + 2] = promise;
          this[base + 3] = receiver;
          if (typeof fulfill === "function") {
            this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
          }
          if (typeof reject === "function") {
            this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
          }
        }
        this._setLength(index2 + 1);
        return index2;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0)
          return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2))
          return this._fulfill(value);
        if (shouldBind)
          this._propagateFrom(maybePromise, 2);
        var promise = maybePromise._target();
        if (promise === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0)
            promise._migrateCallback0(this);
          for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(promise);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
          var message = "a promise was rejected with a non-error: " + util.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        if (executor === INTERNAL)
          return;
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
          promise._resolveCallback(value);
        }, function(reason) {
          promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== void 0) {
          promise._rejectCallback(r, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        promise._pushContext();
        var x;
        if (receiver === APPLY) {
          if (!value || typeof value.length !== "number") {
            x = errorObj2;
            x.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
          } else {
            x = tryCatch2(handler).apply(this._boundValue(), value);
          }
        } else {
          x = tryCatch2(handler).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        if (x === NEXT_FILTER) {
          promise._reject(value);
        } else if (x === errorObj2) {
          promise._rejectCallback(x.e, false);
        } else {
          debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
          promise._resolveCallback(x);
        }
      };
      Promise2.prototype._target = function() {
        var ret2 = this;
        while (ret2._isFollowing())
          ret2 = ret2._followee();
        return ret2;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
      };
      Promise2.prototype._settlePromise = function(promise, handler, receiver, value) {
        var isPromise = promise instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise)
            promise._invokeInternalOnCancel();
          if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch2(handler).call(receiver, value) === errorObj2) {
              promise._reject(errorObj2.e);
            }
          } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
          } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
          } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
          } else {
            receiver.cancel();
          }
        } else if (typeof handler === "function") {
          if (!isPromise) {
            handler.call(receiver, value, promise);
          } else {
            if (asyncGuaranteed)
              promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
          }
        } else if (receiver instanceof Proxyable) {
          if (!receiver._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver._promiseFulfilled(value, promise);
            } else {
              receiver._promiseRejected(value, promise);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise._fulfill(value);
          } else {
            promise._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
          if (!(promise instanceof Promise2)) {
            handler.call(receiver, value, promise);
          } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
          }
        } else if (promise instanceof Promise2) {
          promise._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise, handler, receiver, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index2) {
        var base = index2 * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async.settlePromises(this);
          }
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async.fatalError(reason, util.isNode);
        }
        if ((bitField & 65535) > 0) {
          async.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i = 1; i < len; i++) {
          var handler = this._fulfillmentHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler, receiver, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i = 1; i < len; i++) {
          var handler = this._rejectionHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler, receiver, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      function deferResolve(v) {
        this.promise._resolveCallback(v);
      }
      function deferReject(v) {
        this.promise._rejectCallback(v, false);
      }
      Promise2.defer = Promise2.pending = function() {
        debug.deprecated("Promise.defer", "new Promise");
        var promise = new Promise2(INTERNAL);
        return {
          promise,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util.notEnumerableProp(Promise2, "_makeSelfResolutionError", makeSelfResolutionError);
      require_method()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug);
      require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug);
      require_cancel()(Promise2, PromiseArray, apiRejection, debug);
      require_direct_resolve()(Promise2);
      require_synchronous_inspection()(Promise2);
      require_join()(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
      Promise2.Promise = Promise2;
      Promise2.version = "3.5.1";
      require_map2()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      require_call_get()(Promise2);
      require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
      require_timers()(Promise2, INTERNAL, debug);
      require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
      require_nodeify()(Promise2);
      require_promisify()(Promise2, INTERNAL);
      require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
      require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      require_settle()(Promise2, PromiseArray, debug);
      require_some()(Promise2, PromiseArray, apiRejection);
      require_filter()(Promise2, INTERNAL);
      require_each()(Promise2, INTERNAL);
      require_any()(Promise2);
      util.toFastProperties(Promise2);
      util.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p = new Promise2(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
      }
      fillTypes({ a: 1 });
      fillTypes({ b: 2 });
      fillTypes({ c: 3 });
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL));
      debug.setBounds(Async.firstLineError, util.lastLineError);
      return Promise2;
    };
  }
});

// node_modules/bluebird/js/release/bluebird.js
var require_bluebird = __commonJS({
  "node_modules/bluebird/js/release/bluebird.js"(exports2, module2) {
    init_shims();
    "use strict";
    var old;
    if (typeof Promise !== "undefined")
      old = Promise;
    function noConflict() {
      try {
        if (Promise === bluebird)
          Promise = old;
      } catch (e) {
      }
      return bluebird;
    }
    var bluebird = require_promise()();
    bluebird.noConflict = noConflict;
    module2.exports = bluebird;
  }
});

// node_modules/mquery/lib/mquery.js
var require_mquery = __commonJS({
  "node_modules/mquery/lib/mquery.js"(exports2, module2) {
    init_shims();
    "use strict";
    var slice = require_sliced();
    var assert = require("assert");
    var util = require("util");
    var utils2 = require_utils5();
    var debug = require_src()("mquery");
    function Query(criteria, options2) {
      if (!(this instanceof Query))
        return new Query(criteria, options2);
      var proto = this.constructor.prototype;
      this.op = proto.op || void 0;
      this.options = Object.assign({}, proto.options);
      this._conditions = proto._conditions ? utils2.clone(proto._conditions) : {};
      this._fields = proto._fields ? utils2.clone(proto._fields) : void 0;
      this._update = proto._update ? utils2.clone(proto._update) : void 0;
      this._path = proto._path || void 0;
      this._distinct = proto._distinct || void 0;
      this._collection = proto._collection || void 0;
      this._traceFunction = proto._traceFunction || void 0;
      if (options2) {
        this.setOptions(options2);
      }
      if (criteria) {
        if (criteria.find && criteria.remove && criteria.update) {
          this.collection(criteria);
        } else {
          this.find(criteria);
        }
      }
    }
    var $withinCmd = "$geoWithin";
    Object.defineProperty(Query, "use$geoWithin", {
      get: function() {
        return $withinCmd == "$geoWithin";
      },
      set: function(v) {
        if (v === true) {
          $withinCmd = "$geoWithin";
        } else {
          $withinCmd = "$within";
        }
      }
    });
    Query.prototype.toConstructor = function toConstructor() {
      function CustomQuery(criteria, options2) {
        if (!(this instanceof CustomQuery))
          return new CustomQuery(criteria, options2);
        Query.call(this, criteria, options2);
      }
      utils2.inherits(CustomQuery, Query);
      var p = CustomQuery.prototype;
      p.options = {};
      p.setOptions(this.options);
      p.op = this.op;
      p._conditions = utils2.clone(this._conditions);
      p._fields = utils2.clone(this._fields);
      p._update = utils2.clone(this._update);
      p._path = this._path;
      p._distinct = this._distinct;
      p._collection = this._collection;
      p._traceFunction = this._traceFunction;
      return CustomQuery;
    };
    Query.prototype.setOptions = function(options2) {
      if (!(options2 && utils2.isObject(options2)))
        return this;
      var methods = utils2.keys(options2), method;
      for (var i = 0; i < methods.length; ++i) {
        method = methods[i];
        if (typeof this[method] == "function") {
          var args = utils2.isArray(options2[method]) ? options2[method] : [options2[method]];
          this[method].apply(this, args);
        } else {
          this.options[method] = options2[method];
        }
      }
      return this;
    };
    Query.prototype.collection = function collection(coll) {
      this._collection = new Query.Collection(coll);
      return this;
    };
    Query.prototype.collation = function(value) {
      this.options.collation = value;
      return this;
    };
    Query.prototype.$where = function(js) {
      this._conditions.$where = js;
      return this;
    };
    Query.prototype.where = function() {
      if (!arguments.length)
        return this;
      if (!this.op)
        this.op = "find";
      var type = typeof arguments[0];
      if (type == "string") {
        this._path = arguments[0];
        if (arguments.length === 2) {
          this._conditions[this._path] = arguments[1];
        }
        return this;
      }
      if (type == "object" && !Array.isArray(arguments[0])) {
        return this.merge(arguments[0]);
      }
      throw new TypeError("path must be a string or object");
    };
    Query.prototype.equals = function equals(val) {
      this._ensurePath("equals");
      var path = this._path;
      this._conditions[path] = val;
      return this;
    };
    Query.prototype.eq = function eq(val) {
      this._ensurePath("eq");
      var path = this._path;
      this._conditions[path] = val;
      return this;
    };
    Query.prototype.or = function or(array) {
      var or2 = this._conditions.$or || (this._conditions.$or = []);
      if (!utils2.isArray(array))
        array = [array];
      or2.push.apply(or2, array);
      return this;
    };
    Query.prototype.nor = function nor(array) {
      var nor2 = this._conditions.$nor || (this._conditions.$nor = []);
      if (!utils2.isArray(array))
        array = [array];
      nor2.push.apply(nor2, array);
      return this;
    };
    Query.prototype.and = function and(array) {
      var and2 = this._conditions.$and || (this._conditions.$and = []);
      if (!Array.isArray(array))
        array = [array];
      and2.push.apply(and2, array);
      return this;
    };
    "gt gte lt lte ne in nin all regex size maxDistance minDistance".split(" ").forEach(function($conditional) {
      Query.prototype[$conditional] = function() {
        var path, val;
        if (arguments.length === 1) {
          this._ensurePath($conditional);
          val = arguments[0];
          path = this._path;
        } else {
          val = arguments[1];
          path = arguments[0];
        }
        var conds = this._conditions[path] === null || typeof this._conditions[path] === "object" ? this._conditions[path] : this._conditions[path] = {};
        conds["$" + $conditional] = val;
        return this;
      };
    });
    Query.prototype.mod = function() {
      var val, path;
      if (arguments.length === 1) {
        this._ensurePath("mod");
        val = arguments[0];
        path = this._path;
      } else if (arguments.length === 2 && !utils2.isArray(arguments[1])) {
        this._ensurePath("mod");
        val = slice(arguments);
        path = this._path;
      } else if (arguments.length === 3) {
        val = slice(arguments, 1);
        path = arguments[0];
      } else {
        val = arguments[1];
        path = arguments[0];
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$mod = val;
      return this;
    };
    Query.prototype.exists = function() {
      var path, val;
      if (arguments.length === 0) {
        this._ensurePath("exists");
        path = this._path;
        val = true;
      } else if (arguments.length === 1) {
        if (typeof arguments[0] === "boolean") {
          this._ensurePath("exists");
          path = this._path;
          val = arguments[0];
        } else {
          path = arguments[0];
          val = true;
        }
      } else if (arguments.length === 2) {
        path = arguments[0];
        val = arguments[1];
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$exists = val;
      return this;
    };
    Query.prototype.elemMatch = function() {
      if (arguments[0] == null)
        throw new TypeError("Invalid argument");
      var fn, path, criteria;
      if (typeof arguments[0] === "function") {
        this._ensurePath("elemMatch");
        path = this._path;
        fn = arguments[0];
      } else if (utils2.isObject(arguments[0])) {
        this._ensurePath("elemMatch");
        path = this._path;
        criteria = arguments[0];
      } else if (typeof arguments[1] === "function") {
        path = arguments[0];
        fn = arguments[1];
      } else if (arguments[1] && utils2.isObject(arguments[1])) {
        path = arguments[0];
        criteria = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (fn) {
        criteria = new Query();
        fn(criteria);
        criteria = criteria._conditions;
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$elemMatch = criteria;
      return this;
    };
    Query.prototype.within = function within() {
      this._ensurePath("within");
      this._geoComparison = $withinCmd;
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 2) {
        return this.box.apply(this, arguments);
      } else if (2 < arguments.length) {
        return this.polygon.apply(this, arguments);
      }
      var area = arguments[0];
      if (!area)
        throw new TypeError("Invalid argument");
      if (area.center)
        return this.circle(area);
      if (area.box)
        return this.box.apply(this, area.box);
      if (area.polygon)
        return this.polygon.apply(this, area.polygon);
      if (area.type && area.coordinates)
        return this.geometry(area);
      throw new TypeError("Invalid argument");
    };
    Query.prototype.box = function() {
      var path, box;
      if (arguments.length === 3) {
        path = arguments[0];
        box = [arguments[1], arguments[2]];
      } else if (arguments.length === 2) {
        this._ensurePath("box");
        path = this._path;
        box = [arguments[0], arguments[1]];
      } else {
        throw new TypeError("Invalid argument");
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds[this._geoComparison || $withinCmd] = { "$box": box };
      return this;
    };
    Query.prototype.polygon = function() {
      var val, path;
      if (typeof arguments[0] == "string") {
        path = arguments[0];
        val = slice(arguments, 1);
      } else {
        this._ensurePath("polygon");
        path = this._path;
        val = slice(arguments);
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds[this._geoComparison || $withinCmd] = { "$polygon": val };
      return this;
    };
    Query.prototype.circle = function() {
      var path, val;
      if (arguments.length === 1) {
        this._ensurePath("circle");
        path = this._path;
        val = arguments[0];
      } else if (arguments.length === 2) {
        path = arguments[0];
        val = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!("radius" in val && val.center))
        throw new Error("center and radius are required");
      var conds = this._conditions[path] || (this._conditions[path] = {});
      var type = val.spherical ? "$centerSphere" : "$center";
      var wKey = this._geoComparison || $withinCmd;
      conds[wKey] = {};
      conds[wKey][type] = [val.center, val.radius];
      if ("unique" in val)
        conds[wKey].$uniqueDocs = !!val.unique;
      return this;
    };
    Query.prototype.near = function near() {
      var path, val;
      this._geoComparison = "$near";
      if (arguments.length === 0) {
        return this;
      } else if (arguments.length === 1) {
        this._ensurePath("near");
        path = this._path;
        val = arguments[0];
      } else if (arguments.length === 2) {
        path = arguments[0];
        val = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!val.center) {
        throw new Error("center is required");
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      var type = val.spherical ? "$nearSphere" : "$near";
      if (Array.isArray(val.center)) {
        conds[type] = val.center;
        var radius = "maxDistance" in val ? val.maxDistance : null;
        if (radius != null) {
          conds.$maxDistance = radius;
        }
        if (val.minDistance != null) {
          conds.$minDistance = val.minDistance;
        }
      } else {
        if (val.center.type != "Point" || !Array.isArray(val.center.coordinates)) {
          throw new Error(util.format("Invalid GeoJSON specified for %s", type));
        }
        conds[type] = { $geometry: val.center };
        if ("maxDistance" in val) {
          conds[type]["$maxDistance"] = val.maxDistance;
        }
        if ("minDistance" in val) {
          conds[type]["$minDistance"] = val.minDistance;
        }
      }
      return this;
    };
    Query.prototype.intersects = function intersects() {
      this._ensurePath("intersects");
      this._geoComparison = "$geoIntersects";
      if (arguments.length === 0) {
        return this;
      }
      var area = arguments[0];
      if (area != null && area.type && area.coordinates)
        return this.geometry(area);
      throw new TypeError("Invalid argument");
    };
    Query.prototype.geometry = function geometry() {
      if (!(this._geoComparison == "$within" || this._geoComparison == "$geoWithin" || this._geoComparison == "$near" || this._geoComparison == "$geoIntersects")) {
        throw new Error("geometry() must come after `within()`, `intersects()`, or `near()");
      }
      var val, path;
      if (arguments.length === 1) {
        this._ensurePath("geometry");
        path = this._path;
        val = arguments[0];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!(val.type && Array.isArray(val.coordinates))) {
        throw new TypeError("Invalid argument");
      }
      var conds = this._conditions[path] || (this._conditions[path] = {});
      conds[this._geoComparison] = { $geometry: val };
      return this;
    };
    Query.prototype.select = function select() {
      var arg = arguments[0];
      if (!arg)
        return this;
      if (arguments.length !== 1) {
        throw new Error("Invalid select: select only takes 1 argument");
      }
      this._validate("select");
      var fields = this._fields || (this._fields = {});
      var type = typeof arg;
      var i, len;
      if ((type == "string" || utils2.isArgumentsObject(arg)) && typeof arg.length == "number" || Array.isArray(arg)) {
        if (type == "string")
          arg = arg.split(/\s+/);
        for (i = 0, len = arg.length; i < len; ++i) {
          var field = arg[i];
          if (!field)
            continue;
          var include = field[0] == "-" ? 0 : 1;
          if (include === 0)
            field = field.substring(1);
          fields[field] = include;
        }
        return this;
      }
      if (utils2.isObject(arg)) {
        var keys = utils2.keys(arg);
        for (i = 0; i < keys.length; ++i) {
          fields[keys[i]] = arg[keys[i]];
        }
        return this;
      }
      throw new TypeError("Invalid select() argument. Must be string or object.");
    };
    Query.prototype.slice = function() {
      if (arguments.length === 0)
        return this;
      this._validate("slice");
      var path, val;
      if (arguments.length === 1) {
        var arg = arguments[0];
        if (typeof arg === "object" && !Array.isArray(arg)) {
          var keys = Object.keys(arg);
          var numKeys = keys.length;
          for (var i = 0; i < numKeys; ++i) {
            this.slice(keys[i], arg[keys[i]]);
          }
          return this;
        }
        this._ensurePath("slice");
        path = this._path;
        val = arguments[0];
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === "number") {
          this._ensurePath("slice");
          path = this._path;
          val = slice(arguments);
        } else {
          path = arguments[0];
          val = arguments[1];
        }
      } else if (arguments.length === 3) {
        path = arguments[0];
        val = slice(arguments, 1);
      }
      var myFields = this._fields || (this._fields = {});
      myFields[path] = { "$slice": val };
      return this;
    };
    Query.prototype.sort = function(arg) {
      if (!arg)
        return this;
      var i, len, field;
      this._validate("sort");
      var type = typeof arg;
      if (Array.isArray(arg)) {
        len = arg.length;
        for (i = 0; i < arg.length; ++i) {
          if (!Array.isArray(arg[i])) {
            throw new Error("Invalid sort() argument, must be array of arrays");
          }
          _pushArr(this.options, arg[i][0], arg[i][1]);
        }
        return this;
      }
      if (arguments.length === 1 && type == "string") {
        arg = arg.split(/\s+/);
        len = arg.length;
        for (i = 0; i < len; ++i) {
          field = arg[i];
          if (!field)
            continue;
          var ascend = field[0] == "-" ? -1 : 1;
          if (ascend === -1)
            field = field.substring(1);
          push(this.options, field, ascend);
        }
        return this;
      }
      if (utils2.isObject(arg)) {
        var keys = utils2.keys(arg);
        for (i = 0; i < keys.length; ++i) {
          field = keys[i];
          push(this.options, field, arg[field]);
        }
        return this;
      }
      if (typeof Map !== "undefined" && arg instanceof Map) {
        _pushMap(this.options, arg);
        return this;
      }
      throw new TypeError("Invalid sort() argument. Must be a string, object, or array.");
    };
    var _validSortValue = {
      "1": 1,
      "-1": -1,
      "asc": 1,
      "ascending": 1,
      "desc": -1,
      "descending": -1
    };
    function push(opts, field, value) {
      if (Array.isArray(opts.sort)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object:\n- `.sort([['field', 1], ['test', -1]])`\n- `.sort({ field: 1, test: -1 })`");
      }
      var s2;
      if (value && value.$meta) {
        s2 = opts.sort || (opts.sort = {});
        s2[field] = { $meta: value.$meta };
        return;
      }
      s2 = opts.sort || (opts.sort = {});
      var val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val)
        throw new TypeError("Invalid sort value: { " + field + ": " + value + " }");
      s2[field] = val;
    }
    function _pushArr(opts, field, value) {
      opts.sort = opts.sort || [];
      if (!Array.isArray(opts.sort)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object:\n- `.sort([['field', 1], ['test', -1]])`\n- `.sort({ field: 1, test: -1 })`");
      }
      var val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val)
        throw new TypeError("Invalid sort value: [ " + field + ", " + value + " ]");
      opts.sort.push([field, val]);
    }
    function _pushMap(opts, map) {
      opts.sort = opts.sort || new Map();
      if (!(opts.sort instanceof Map)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object or map consistently");
      }
      map.forEach(function(value, key) {
        var val = String(value || 1).toLowerCase();
        val = _validSortValue[val];
        if (!val)
          throw new TypeError("Invalid sort value: < " + key + ": " + value + " >");
        opts.sort.set(key, val);
      });
    }
    ["limit", "skip", "maxScan", "batchSize", "comment"].forEach(function(method) {
      Query.prototype[method] = function(v) {
        this._validate(method);
        this.options[method] = v;
        return this;
      };
    });
    Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {
      this._validate("maxTime");
      this.options.maxTimeMS = ms;
      return this;
    };
    Query.prototype.snapshot = function() {
      this._validate("snapshot");
      this.options.snapshot = arguments.length ? !!arguments[0] : true;
      return this;
    };
    Query.prototype.hint = function() {
      if (arguments.length === 0)
        return this;
      this._validate("hint");
      var arg = arguments[0];
      if (utils2.isObject(arg)) {
        var hint = this.options.hint || (this.options.hint = {});
        for (var k in arg) {
          hint[k] = arg[k];
        }
        return this;
      }
      if (typeof arg === "string") {
        this.options.hint = arg;
        return this;
      }
      throw new TypeError("Invalid hint. " + arg);
    };
    Query.prototype.j = function j(val) {
      this.options.j = val;
      return this;
    };
    Query.prototype.slaveOk = function(v) {
      this.options.slaveOk = arguments.length ? !!v : true;
      return this;
    };
    Query.prototype.read = Query.prototype.setReadPreference = function(pref) {
      if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
        console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
        Query.prototype.read.deprecationWarningIssued = true;
      }
      this.options.readPreference = utils2.readPref(pref);
      return this;
    };
    Query.prototype.readConcern = Query.prototype.r = function(level) {
      this.options.readConcern = utils2.readConcern(level);
      return this;
    };
    Query.prototype.tailable = function() {
      this._validate("tailable");
      this.options.tailable = arguments.length ? !!arguments[0] : true;
      return this;
    };
    Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {
      if (typeof concern === "object") {
        if (typeof concern.j !== "undefined")
          this.options.j = concern.j;
        if (typeof concern.w !== "undefined")
          this.options.w = concern.w;
        if (typeof concern.wtimeout !== "undefined")
          this.options.wtimeout = concern.wtimeout;
      } else {
        this.options.w = concern === "m" ? "majority" : concern;
      }
      return this;
    };
    Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {
      this.options.wtimeout = ms;
      return this;
    };
    Query.prototype.merge = function(source) {
      if (!source)
        return this;
      if (!Query.canMerge(source))
        throw new TypeError("Invalid argument. Expected instanceof mquery or plain object");
      if (source instanceof Query) {
        if (source._conditions) {
          utils2.merge(this._conditions, source._conditions);
        }
        if (source._fields) {
          this._fields || (this._fields = {});
          utils2.merge(this._fields, source._fields);
        }
        if (source.options) {
          this.options || (this.options = {});
          utils2.merge(this.options, source.options);
        }
        if (source._update) {
          this._update || (this._update = {});
          utils2.mergeClone(this._update, source._update);
        }
        if (source._distinct) {
          this._distinct = source._distinct;
        }
        return this;
      }
      utils2.merge(this._conditions, source);
      return this;
    };
    Query.prototype.find = function(criteria, callback) {
      this.op = "find";
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback)
        return this;
      var conds = this._conditions;
      var options2 = this._optionsForExec();
      if (this.$useProjection) {
        options2.projection = this._fieldsForExec();
      } else {
        options2.fields = this._fieldsForExec();
      }
      debug("find", this._collection.collectionName, conds, options2);
      callback = this._wrapCallback("find", callback, {
        conditions: conds,
        options: options2
      });
      this._collection.find(conds, options2, utils2.tick(callback));
      return this;
    };
    Query.prototype.cursor = function cursor(criteria) {
      if (this.op) {
        if (this.op !== "find") {
          throw new TypeError(".cursor only support .find method");
        }
      } else {
        this.find(criteria);
      }
      var conds = this._conditions;
      var options2 = this._optionsForExec();
      if (this.$useProjection) {
        options2.projection = this._fieldsForExec();
      } else {
        options2.fields = this._fieldsForExec();
      }
      debug("findCursor", this._collection.collectionName, conds, options2);
      return this._collection.findCursor(conds, options2);
    };
    Query.prototype.findOne = function(criteria, callback) {
      this.op = "findOne";
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback)
        return this;
      var conds = this._conditions;
      var options2 = this._optionsForExec();
      if (this.$useProjection) {
        options2.projection = this._fieldsForExec();
      } else {
        options2.fields = this._fieldsForExec();
      }
      debug("findOne", this._collection.collectionName, conds, options2);
      callback = this._wrapCallback("findOne", callback, {
        conditions: conds,
        options: options2
      });
      this._collection.findOne(conds, options2, utils2.tick(callback));
      return this;
    };
    Query.prototype.count = function(criteria, callback) {
      this.op = "count";
      this._validate();
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback)
        return this;
      var conds = this._conditions, options2 = this._optionsForExec();
      debug("count", this._collection.collectionName, conds, options2);
      callback = this._wrapCallback("count", callback, {
        conditions: conds,
        options: options2
      });
      this._collection.count(conds, options2, utils2.tick(callback));
      return this;
    };
    Query.prototype.distinct = function(criteria, field, callback) {
      this.op = "distinct";
      this._validate();
      if (!callback) {
        switch (typeof field) {
          case "function":
            callback = field;
            if (typeof criteria == "string") {
              field = criteria;
              criteria = void 0;
            }
            break;
          case "undefined":
          case "string":
            break;
          default:
            throw new TypeError("Invalid `field` argument. Must be string or function");
        }
        switch (typeof criteria) {
          case "function":
            callback = criteria;
            criteria = field = void 0;
            break;
          case "string":
            field = criteria;
            criteria = void 0;
            break;
        }
      }
      if (typeof field == "string") {
        this._distinct = field;
      }
      if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback) {
        return this;
      }
      if (!this._distinct) {
        throw new Error("No value for `distinct` has been declared");
      }
      var conds = this._conditions, options2 = this._optionsForExec();
      debug("distinct", this._collection.collectionName, conds, options2);
      callback = this._wrapCallback("distinct", callback, {
        conditions: conds,
        options: options2
      });
      this._collection.distinct(this._distinct, conds, options2, utils2.tick(callback));
      return this;
    };
    Query.prototype.update = function update(criteria, doc, options2, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if (typeof options2 == "function") {
            callback = options2;
            options2 = void 0;
          }
          break;
        case 2:
          if (typeof doc == "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options2 = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options2 = void 0;
              break;
          }
      }
      return _update(this, "update", criteria, doc, options2, force, callback);
    };
    Query.prototype.updateMany = function updateMany(criteria, doc, options2, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if (typeof options2 == "function") {
            callback = options2;
            options2 = void 0;
          }
          break;
        case 2:
          if (typeof doc == "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options2 = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options2 = void 0;
              break;
          }
      }
      return _update(this, "updateMany", criteria, doc, options2, force, callback);
    };
    Query.prototype.updateOne = function updateOne(criteria, doc, options2, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if (typeof options2 == "function") {
            callback = options2;
            options2 = void 0;
          }
          break;
        case 2:
          if (typeof doc == "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options2 = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options2 = void 0;
              break;
          }
      }
      return _update(this, "updateOne", criteria, doc, options2, force, callback);
    };
    Query.prototype.replaceOne = function replaceOne(criteria, doc, options2, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if (typeof options2 == "function") {
            callback = options2;
            options2 = void 0;
          }
          break;
        case 2:
          if (typeof doc == "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options2 = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options2 = void 0;
              break;
          }
      }
      this.setOptions({ overwrite: true });
      return _update(this, "replaceOne", criteria, doc, options2, force, callback);
    };
    function _update(query, op, criteria, doc, options2, force, callback) {
      query.op = op;
      if (Query.canMerge(criteria)) {
        query.merge(criteria);
      }
      if (doc) {
        query._mergeUpdate(doc);
      }
      if (utils2.isObject(options2)) {
        query.setOptions(options2);
      }
      if (!(force || callback)) {
        return query;
      }
      if (!query._update || !query.options.overwrite && utils2.keys(query._update).length === 0) {
        callback && utils2.soon(callback.bind(null, null, 0));
        return query;
      }
      options2 = query._optionsForExec();
      if (!callback)
        options2.safe = false;
      criteria = query._conditions;
      doc = query._updateForExec();
      debug("update", query._collection.collectionName, criteria, doc, options2);
      callback = query._wrapCallback(op, callback, {
        conditions: criteria,
        doc,
        options: options2
      });
      query._collection[op](criteria, doc, options2, utils2.tick(callback));
      return query;
    }
    Query.prototype.remove = function(criteria, callback) {
      this.op = "remove";
      var force;
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (criteria === true) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      var options2 = this._optionsForExec();
      if (!callback)
        options2.safe = false;
      var conds = this._conditions;
      debug("remove", this._collection.collectionName, conds, options2);
      callback = this._wrapCallback("remove", callback, {
        conditions: conds,
        options: options2
      });
      this._collection.remove(conds, options2, utils2.tick(callback));
      return this;
    };
    Query.prototype.deleteOne = function(criteria, callback) {
      this.op = "deleteOne";
      var force;
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (criteria === true) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      var options2 = this._optionsForExec();
      if (!callback)
        options2.safe = false;
      delete options2.justOne;
      var conds = this._conditions;
      debug("deleteOne", this._collection.collectionName, conds, options2);
      callback = this._wrapCallback("deleteOne", callback, {
        conditions: conds,
        options: options2
      });
      this._collection.deleteOne(conds, options2, utils2.tick(callback));
      return this;
    };
    Query.prototype.deleteMany = function(criteria, callback) {
      this.op = "deleteMany";
      var force;
      if (typeof criteria === "function") {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (criteria === true) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      var options2 = this._optionsForExec();
      if (!callback)
        options2.safe = false;
      delete options2.justOne;
      var conds = this._conditions;
      debug("deleteOne", this._collection.collectionName, conds, options2);
      callback = this._wrapCallback("deleteOne", callback, {
        conditions: conds,
        options: options2
      });
      this._collection.deleteMany(conds, options2, utils2.tick(callback));
      return this;
    };
    Query.prototype.findOneAndUpdate = function(criteria, doc, options2, callback) {
      this.op = "findOneAndUpdate";
      this._validate();
      switch (arguments.length) {
        case 3:
          if (typeof options2 == "function") {
            callback = options2;
            options2 = {};
          }
          break;
        case 2:
          if (typeof doc == "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          options2 = void 0;
          break;
        case 1:
          if (typeof criteria == "function") {
            callback = criteria;
            criteria = options2 = doc = void 0;
          } else {
            doc = criteria;
            criteria = options2 = void 0;
          }
      }
      if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (doc) {
        this._mergeUpdate(doc);
      }
      options2 && this.setOptions(options2);
      if (!callback)
        return this;
      return this._findAndModify("update", callback);
    };
    Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options2, callback) {
      this.op = "findOneAndRemove";
      this._validate();
      if (typeof options2 == "function") {
        callback = options2;
        options2 = void 0;
      } else if (typeof conditions == "function") {
        callback = conditions;
        conditions = void 0;
      }
      if (Query.canMerge(conditions)) {
        this.merge(conditions);
      }
      options2 && this.setOptions(options2);
      if (!callback)
        return this;
      return this._findAndModify("remove", callback);
    };
    Query.prototype._findAndModify = function(type, callback) {
      assert.equal("function", typeof callback);
      var options2 = this._optionsForExec();
      var fields;
      var doc;
      if (type == "remove") {
        options2.remove = true;
      } else {
        if (!("new" in options2))
          options2.new = true;
        if (!("upsert" in options2))
          options2.upsert = false;
        doc = this._updateForExec();
        if (!doc) {
          if (options2.upsert) {
            doc = { $set: {} };
          } else {
            return this.findOne(callback);
          }
        }
      }
      fields = this._fieldsForExec();
      if (fields != null) {
        if (this.$useProjection) {
          options2.projection = this._fieldsForExec();
        } else {
          options2.fields = this._fieldsForExec();
        }
      }
      var conds = this._conditions;
      debug("findAndModify", this._collection.collectionName, conds, doc, options2);
      callback = this._wrapCallback("findAndModify", callback, {
        conditions: conds,
        doc,
        options: options2
      });
      this._collection.findAndModify(conds, doc, options2, utils2.tick(callback));
      return this;
    };
    Query.prototype._wrapCallback = function(method, callback, queryInfo) {
      var traceFunction = this._traceFunction || Query.traceFunction;
      if (traceFunction) {
        queryInfo.collectionName = this._collection.collectionName;
        var traceCallback = traceFunction && traceFunction.call(null, method, queryInfo, this);
        var startTime = new Date().getTime();
        return function wrapperCallback(err, result) {
          if (traceCallback) {
            var millis = new Date().getTime() - startTime;
            traceCallback.call(null, err, result, millis);
          }
          if (callback) {
            callback.apply(null, arguments);
          }
        };
      }
      return callback;
    };
    Query.prototype.setTraceFunction = function(traceFunction) {
      this._traceFunction = traceFunction;
      return this;
    };
    Query.prototype.exec = function exec(op, callback) {
      switch (typeof op) {
        case "function":
          callback = op;
          op = null;
          break;
        case "string":
          this.op = op;
          break;
      }
      assert.ok(this.op, "Missing query type: (find, update, etc)");
      if (this.op == "update" || this.op == "remove") {
        callback || (callback = true);
      }
      var _this = this;
      if (typeof callback == "function") {
        this[this.op](callback);
      } else {
        return new Query.Promise(function(success, error2) {
          _this[_this.op](function(err, val) {
            if (err)
              error2(err);
            else
              success(val);
            success = error2 = null;
          });
        });
      }
    };
    Query.prototype.thunk = function() {
      var _this = this;
      return function(cb) {
        _this.exec(cb);
      };
    };
    Query.prototype.then = function(resolve2, reject) {
      var _this = this;
      var promise = new Query.Promise(function(success, error2) {
        _this.exec(function(err, val) {
          if (err)
            error2(err);
          else
            success(val);
          success = error2 = null;
        });
      });
      return promise.then(resolve2, reject);
    };
    Query.prototype.stream = function(streamOptions) {
      if (this.op != "find")
        throw new Error("stream() is only available for find");
      var conds = this._conditions;
      var options2 = this._optionsForExec();
      if (this.$useProjection) {
        options2.projection = this._fieldsForExec();
      } else {
        options2.fields = this._fieldsForExec();
      }
      debug("stream", this._collection.collectionName, conds, options2, streamOptions);
      return this._collection.findStream(conds, options2, streamOptions);
    };
    Query.prototype.selected = function selected() {
      return !!(this._fields && Object.keys(this._fields).length > 0);
    };
    Query.prototype.selectedInclusively = function selectedInclusively() {
      if (!this._fields)
        return false;
      var keys = Object.keys(this._fields);
      if (keys.length === 0)
        return false;
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (this._fields[key] === 0)
          return false;
        if (this._fields[key] && typeof this._fields[key] === "object" && this._fields[key].$meta) {
          return false;
        }
      }
      return true;
    };
    Query.prototype.selectedExclusively = function selectedExclusively() {
      if (!this._fields)
        return false;
      var keys = Object.keys(this._fields);
      if (keys.length === 0)
        return false;
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (this._fields[key] === 0)
          return true;
      }
      return false;
    };
    Query.prototype._mergeUpdate = function(doc) {
      if (!this._update)
        this._update = {};
      if (doc instanceof Query) {
        if (doc._update) {
          utils2.mergeClone(this._update, doc._update);
        }
      } else {
        utils2.mergeClone(this._update, doc);
      }
    };
    Query.prototype._optionsForExec = function() {
      var options2 = utils2.clone(this.options);
      return options2;
    };
    Query.prototype._fieldsForExec = function() {
      return utils2.clone(this._fields);
    };
    Query.prototype._updateForExec = function() {
      var update = utils2.clone(this._update), ops = utils2.keys(update), i = ops.length, ret2 = {};
      while (i--) {
        var op = ops[i];
        if (this.options.overwrite) {
          ret2[op] = update[op];
          continue;
        }
        if (op[0] !== "$") {
          if (!ret2.$set) {
            if (update.$set) {
              ret2.$set = update.$set;
            } else {
              ret2.$set = {};
            }
          }
          ret2.$set[op] = update[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set"))
            ops.push("$set");
        } else if (op === "$set") {
          if (!ret2.$set) {
            ret2[op] = update[op];
          }
        } else {
          ret2[op] = update[op];
        }
      }
      this._compiledUpdate = ret2;
      return ret2;
    };
    Query.prototype._ensurePath = function(method) {
      if (!this._path) {
        var msg = method + "() must be used after where() when called with these arguments";
        throw new Error(msg);
      }
    };
    Query.permissions = require_permissions();
    Query._isPermitted = function(a, b) {
      var denied = Query.permissions[b];
      if (!denied)
        return true;
      return denied[a] !== true;
    };
    Query.prototype._validate = function(action) {
      var fail;
      var validator;
      if (action === void 0) {
        validator = Query.permissions[this.op];
        if (typeof validator != "function")
          return true;
        fail = validator(this);
      } else if (!Query._isPermitted(action, this.op)) {
        fail = action;
      }
      if (fail) {
        throw new Error(fail + " cannot be used with " + this.op);
      }
    };
    Query.canMerge = function(conds) {
      return conds instanceof Query || utils2.isObject(conds);
    };
    Query.setGlobalTraceFunction = function(traceFunction) {
      Query.traceFunction = traceFunction;
    };
    Query.utils = utils2;
    Query.env = require_env();
    Query.Collection = require_collection4();
    Query.BaseCollection = require_collection3();
    Query.Promise = require_bluebird();
    module2.exports = exports2 = Query;
  }
});

// node_modules/mongoose/lib/promise_provider.js
var require_promise_provider = __commonJS({
  "node_modules/mongoose/lib/promise_provider.js"(exports2, module2) {
    init_shims();
    "use strict";
    var assert = require("assert");
    var mquery = require_mquery();
    var store = {
      _promise: null
    };
    store.get = function() {
      return store._promise;
    };
    store.set = function(lib) {
      assert.ok(typeof lib === "function", `mongoose.Promise must be a function, got ${lib}`);
      store._promise = lib;
      mquery.Promise = lib;
    };
    store.set(global.Promise);
    module2.exports = store;
  }
});

// node_modules/mongoose/lib/helpers/promiseOrCallback.js
var require_promiseOrCallback = __commonJS({
  "node_modules/mongoose/lib/helpers/promiseOrCallback.js"(exports2, module2) {
    init_shims();
    "use strict";
    var PromiseProvider = require_promise_provider();
    var immediate = require_immediate();
    var emittedSymbol = Symbol("mongoose:emitted");
    module2.exports = function promiseOrCallback(callback, fn, ee, Promise2) {
      if (typeof callback === "function") {
        return fn(function(error2) {
          if (error2 != null) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error2[emittedSymbol]) {
              error2[emittedSymbol] = true;
              ee.emit("error", error2);
            }
            try {
              callback(error2);
            } catch (error3) {
              return immediate(() => {
                throw error3;
              });
            }
            return;
          }
          callback.apply(this, arguments);
        });
      }
      Promise2 = Promise2 || PromiseProvider.get();
      return new Promise2((resolve2, reject) => {
        fn(function(error2, res) {
          if (error2 != null) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error2[emittedSymbol]) {
              error2[emittedSymbol] = true;
              ee.emit("error", error2);
            }
            return reject(error2);
          }
          if (arguments.length > 2) {
            return resolve2(Array.prototype.slice.call(arguments, 1));
          }
          resolve2(res);
        });
      });
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/merge.js
var require_merge = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/merge.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function merge(s1, s2, skipConflictingPaths) {
      const paths = Object.keys(s2.tree);
      const pathsToAdd = {};
      for (const key of paths) {
        if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {
          continue;
        }
        pathsToAdd[key] = s2.tree[key];
      }
      s1.add(pathsToAdd);
      s1.callQueue = s1.callQueue.concat(s2.callQueue);
      s1.method(s2.methods);
      s1.static(s2.statics);
      for (const query in s2.query) {
        s1.query[query] = s2.query[query];
      }
      for (const virtual in s2.virtuals) {
        s1.virtuals[virtual] = s2.virtuals[virtual].clone();
      }
      s1.s.hooks.merge(s2.s.hooks, false);
    };
  }
});

// node_modules/mongoose/lib/statemachine.js
var require_statemachine = __commonJS({
  "node_modules/mongoose/lib/statemachine.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils6();
    var StateMachine = module2.exports = exports2 = function StateMachine2() {
    };
    StateMachine.ctor = function() {
      const states = utils2.args(arguments);
      const ctor = function() {
        StateMachine.apply(this, arguments);
        this.paths = {};
        this.states = {};
        this.stateNames = states;
        let i = states.length, state;
        while (i--) {
          state = states[i];
          this.states[state] = {};
        }
      };
      ctor.prototype = new StateMachine();
      states.forEach(function(state) {
        ctor.prototype[state] = function(path) {
          this._changeState(path, state);
        };
      });
      return ctor;
    };
    StateMachine.prototype._changeState = function _changeState(path, nextState) {
      const prevBucket = this.states[this.paths[path]];
      if (prevBucket)
        delete prevBucket[path];
      this.paths[path] = nextState;
      this.states[nextState][path] = true;
    };
    StateMachine.prototype.clear = function clear(state) {
      const keys = Object.keys(this.states[state]);
      let i = keys.length;
      let path;
      while (i--) {
        path = keys[i];
        delete this.states[state][path];
        delete this.paths[path];
      }
    };
    StateMachine.prototype.some = function some() {
      const _this = this;
      const what = arguments.length ? arguments : this.stateNames;
      return Array.prototype.some.call(what, function(state) {
        return Object.keys(_this.states[state]).length;
      });
    };
    StateMachine.prototype._iter = function _iter(iterMethod) {
      return function() {
        const numArgs = arguments.length;
        let states = utils2.args(arguments, 0, numArgs - 1);
        const callback = arguments[numArgs - 1];
        if (!states.length)
          states = this.stateNames;
        const _this = this;
        const paths = states.reduce(function(paths2, state) {
          return paths2.concat(Object.keys(_this.states[state]));
        }, []);
        return paths[iterMethod](function(path, i, paths2) {
          return callback(path, i, paths2);
        });
      };
    };
    StateMachine.prototype.forEach = function forEach() {
      this.forEach = this._iter("forEach");
      return this.forEach.apply(this, arguments);
    };
    StateMachine.prototype.map = function map() {
      this.map = this._iter("map");
      return this.map.apply(this, arguments);
    };
  }
});

// node_modules/mongoose/lib/internal.js
var require_internal = __commonJS({
  "node_modules/mongoose/lib/internal.js"(exports2, module2) {
    init_shims();
    "use strict";
    var StateMachine = require_statemachine();
    var ActiveRoster = StateMachine.ctor("require", "modify", "init", "default", "ignore");
    module2.exports = exports2 = InternalCache;
    function InternalCache() {
      this.strictMode = void 0;
      this.selected = void 0;
      this.shardval = void 0;
      this.saveError = void 0;
      this.validationError = void 0;
      this.adhocPaths = void 0;
      this.removing = void 0;
      this.inserting = void 0;
      this.saving = void 0;
      this.version = void 0;
      this.getters = {};
      this._id = void 0;
      this.populate = void 0;
      this.populated = void 0;
      this.wasPopulated = false;
      this.scope = void 0;
      this.activePaths = new ActiveRoster();
      this.pathsToScopes = {};
      this.cachedRequired = {};
      this.session = null;
      this.$setCalled = new Set();
      this.ownerDocument = void 0;
      this.fullPath = void 0;
    }
  }
});

// node_modules/mongoose/lib/error/messages.js
var require_messages = __commonJS({
  "node_modules/mongoose/lib/error/messages.js"(exports2, module2) {
    init_shims();
    "use strict";
    var msg = module2.exports = exports2 = {};
    msg.DocumentNotFoundError = null;
    msg.general = {};
    msg.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`";
    msg.general.required = "Path `{PATH}` is required.";
    msg.Number = {};
    msg.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).";
    msg.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).";
    msg.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
    msg.Date = {};
    msg.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).";
    msg.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).";
    msg.String = {};
    msg.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
    msg.String.match = "Path `{PATH}` is invalid ({VALUE}).";
    msg.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).";
    msg.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";
  }
});

// node_modules/mongoose/lib/error/notFound.js
var require_notFound = __commonJS({
  "node_modules/mongoose/lib/error/notFound.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var util = require("util");
    var DocumentNotFoundError = class extends MongooseError {
      constructor(filter, model, numAffected, result) {
        let msg;
        const messages = MongooseError.messages;
        if (messages.DocumentNotFoundError != null) {
          msg = typeof messages.DocumentNotFoundError === "function" ? messages.DocumentNotFoundError(filter, model) : messages.DocumentNotFoundError;
        } else {
          msg = 'No document found for query "' + util.inspect(filter) + '" on model "' + model + '"';
        }
        super(msg);
        this.result = result;
        this.numAffected = numAffected;
        this.filter = filter;
        this.query = filter;
      }
    };
    Object.defineProperty(DocumentNotFoundError.prototype, "name", {
      value: "DocumentNotFoundError"
    });
    module2.exports = DocumentNotFoundError;
  }
});

// node_modules/mongoose/lib/error/cast.js
var require_cast = __commonJS({
  "node_modules/mongoose/lib/error/cast.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_mongooseError();
    var get2 = require_get();
    var util = require("util");
    var CastError = class extends MongooseError {
      constructor(type, value, path, reason, schemaType) {
        if (arguments.length > 0) {
          const stringValue = getStringValue(value);
          const valueType = getValueType(value);
          const messageFormat = getMessageFormat(schemaType);
          const msg = formatMessage(null, type, stringValue, path, messageFormat, valueType);
          super(msg);
          this.init(type, value, path, reason, schemaType);
        } else {
          super(formatMessage());
        }
      }
      toJSON() {
        return {
          stringValue: this.stringValue,
          valueType: this.valueType,
          kind: this.kind,
          value: this.value,
          path: this.path,
          reason: this.reason,
          name: this.name,
          message: this.message
        };
      }
      init(type, value, path, reason, schemaType) {
        this.stringValue = getStringValue(value);
        this.messageFormat = getMessageFormat(schemaType);
        this.kind = type;
        this.value = value;
        this.path = path;
        this.reason = reason;
        this.valueType = getValueType(value);
      }
      copy(other) {
        this.messageFormat = other.messageFormat;
        this.stringValue = other.stringValue;
        this.kind = other.kind;
        this.value = other.value;
        this.path = other.path;
        this.reason = other.reason;
        this.message = other.message;
        this.valueType = other.valueType;
      }
      setModel(model) {
        this.model = model;
        this.message = formatMessage(model, this.kind, this.stringValue, this.path, this.messageFormat, this.valueType);
      }
    };
    Object.defineProperty(CastError.prototype, "name", {
      value: "CastError"
    });
    function getStringValue(value) {
      let stringValue = util.inspect(value);
      stringValue = stringValue.replace(/^'|'$/g, '"');
      if (!stringValue.startsWith('"')) {
        stringValue = '"' + stringValue + '"';
      }
      return stringValue;
    }
    function getValueType(value) {
      if (value == null) {
        return "" + value;
      }
      const t = typeof value;
      if (t !== "object") {
        return t;
      }
      if (typeof value.constructor !== "function") {
        return t;
      }
      return value.constructor.name;
    }
    function getMessageFormat(schemaType) {
      const messageFormat = get2(schemaType, "options.cast", null);
      if (typeof messageFormat === "string") {
        return messageFormat;
      }
    }
    function formatMessage(model, kind, stringValue, path, messageFormat, valueType) {
      if (messageFormat != null) {
        let ret2 = messageFormat.replace("{KIND}", kind).replace("{VALUE}", stringValue).replace("{PATH}", path);
        if (model != null) {
          ret2 = ret2.replace("{MODEL}", model.modelName);
        }
        return ret2;
      } else {
        const valueTypeMsg = valueType ? " (type " + valueType + ")" : "";
        let ret2 = "Cast to " + kind + " failed for value " + stringValue + valueTypeMsg + ' at path "' + path + '"';
        if (model != null) {
          ret2 += ' for model "' + model.modelName + '"';
        }
        return ret2;
      }
    }
    module2.exports = CastError;
  }
});

// node_modules/mongoose/lib/error/validation.js
var require_validation = __commonJS({
  "node_modules/mongoose/lib/error/validation.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_mongooseError();
    var util = require("util");
    var ValidationError = class extends MongooseError {
      constructor(instance) {
        let _message;
        if (instance && instance.constructor.name === "model") {
          _message = instance.constructor.modelName + " validation failed";
        } else {
          _message = "Validation failed";
        }
        super(_message);
        this.errors = {};
        this._message = _message;
        if (instance) {
          instance.errors = this.errors;
        }
      }
      toString() {
        return this.name + ": " + _generateMessage(this);
      }
      inspect() {
        return Object.assign(new Error(this.message), this);
      }
      addError(path, error2) {
        this.errors[path] = error2;
        this.message = this._message + ": " + _generateMessage(this);
      }
    };
    if (util.inspect.custom) {
      ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;
    }
    Object.defineProperty(ValidationError.prototype, "toJSON", {
      enumerable: false,
      writable: false,
      configurable: true,
      value: function() {
        return Object.assign({}, this, { name: this.name, message: this.message });
      }
    });
    Object.defineProperty(ValidationError.prototype, "name", {
      value: "ValidationError"
    });
    function _generateMessage(err) {
      const keys = Object.keys(err.errors || {});
      const len = keys.length;
      const msgs = [];
      let key;
      for (let i = 0; i < len; ++i) {
        key = keys[i];
        if (err === err.errors[key]) {
          continue;
        }
        msgs.push(key + ": " + err.errors[key].message);
      }
      return msgs.join(", ");
    }
    module2.exports = ValidationError;
  }
});

// node_modules/mongoose/lib/error/validator.js
var require_validator = __commonJS({
  "node_modules/mongoose/lib/error/validator.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var ValidatorError = class extends MongooseError {
      constructor(properties) {
        let msg = properties.message;
        if (!msg) {
          msg = MongooseError.messages.general.default;
        }
        const message = formatMessage(msg, properties);
        super(message);
        properties = Object.assign({}, properties, { message });
        this.properties = properties;
        this.kind = properties.type;
        this.path = properties.path;
        this.value = properties.value;
        this.reason = properties.reason;
      }
      toString() {
        return this.message;
      }
      toJSON() {
        return Object.assign({ name: this.name, message: this.message }, this);
      }
    };
    Object.defineProperty(ValidatorError.prototype, "name", {
      value: "ValidatorError"
    });
    Object.defineProperty(ValidatorError.prototype, "properties", {
      enumerable: false,
      writable: true,
      value: null
    });
    ValidatorError.prototype.formatMessage = formatMessage;
    function formatMessage(msg, properties) {
      if (typeof msg === "function") {
        return msg(properties);
      }
      const propertyNames = Object.keys(properties);
      for (const propertyName of propertyNames) {
        if (propertyName === "message") {
          continue;
        }
        msg = msg.replace("{" + propertyName.toUpperCase() + "}", properties[propertyName]);
      }
      return msg;
    }
    module2.exports = ValidatorError;
  }
});

// node_modules/mongoose/lib/error/version.js
var require_version = __commonJS({
  "node_modules/mongoose/lib/error/version.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var VersionError = class extends MongooseError {
      constructor(doc, currentVersion, modifiedPaths) {
        const modifiedPathsStr = modifiedPaths.join(", ");
        super('No matching document found for id "' + doc._id + '" version ' + currentVersion + ' modifiedPaths "' + modifiedPathsStr + '"');
        this.version = currentVersion;
        this.modifiedPaths = modifiedPaths;
      }
    };
    Object.defineProperty(VersionError.prototype, "name", {
      value: "VersionError"
    });
    module2.exports = VersionError;
  }
});

// node_modules/mongoose/lib/error/parallelSave.js
var require_parallelSave = __commonJS({
  "node_modules/mongoose/lib/error/parallelSave.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var ParallelSaveError = class extends MongooseError {
      constructor(doc) {
        const msg = "Can't save() the same doc multiple times in parallel. Document: ";
        super(msg + doc._id);
      }
    };
    Object.defineProperty(ParallelSaveError.prototype, "name", {
      value: "ParallelSaveError"
    });
    module2.exports = ParallelSaveError;
  }
});

// node_modules/mongoose/lib/error/overwriteModel.js
var require_overwriteModel = __commonJS({
  "node_modules/mongoose/lib/error/overwriteModel.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var OverwriteModelError = class extends MongooseError {
      constructor(name) {
        super("Cannot overwrite `" + name + "` model once compiled.");
      }
    };
    Object.defineProperty(OverwriteModelError.prototype, "name", {
      value: "OverwriteModelError"
    });
    module2.exports = OverwriteModelError;
  }
});

// node_modules/mongoose/lib/error/missingSchema.js
var require_missingSchema = __commonJS({
  "node_modules/mongoose/lib/error/missingSchema.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var MissingSchemaError = class extends MongooseError {
      constructor(name) {
        const msg = `Schema hasn't been registered for model "` + name + '".\nUse mongoose.model(name, schema)';
        super(msg);
      }
    };
    Object.defineProperty(MissingSchemaError.prototype, "name", {
      value: "MissingSchemaError"
    });
    module2.exports = MissingSchemaError;
  }
});

// node_modules/mongoose/lib/error/divergentArray.js
var require_divergentArray = __commonJS({
  "node_modules/mongoose/lib/error/divergentArray.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var DivergentArrayError = class extends MongooseError {
      constructor(paths) {
        const msg = "For your own good, using `document.save()` to update an array which was selected using an $elemMatch projection OR populated using skip, limit, query conditions, or exclusion of the _id field when the operation results in a $pop or $set of the entire array is not supported. The following path(s) would have been modified unsafely:\n  " + paths.join("\n  ") + "\nUse Model.update() to update these arrays instead.";
        super(msg);
      }
    };
    Object.defineProperty(DivergentArrayError.prototype, "name", {
      value: "DivergentArrayError"
    });
    module2.exports = DivergentArrayError;
  }
});

// node_modules/mongoose/lib/error/strict.js
var require_strict = __commonJS({
  "node_modules/mongoose/lib/error/strict.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var StrictModeError = class extends MongooseError {
      constructor(path, msg, immutable) {
        msg = msg || "Field `" + path + "` is not in schema and strict mode is set to throw.";
        super(msg);
        this.isImmutableError = !!immutable;
        this.path = path;
      }
    };
    Object.defineProperty(StrictModeError.prototype, "name", {
      value: "StrictModeError"
    });
    module2.exports = StrictModeError;
  }
});

// node_modules/mongoose/lib/error/index.js
var require_error3 = __commonJS({
  "node_modules/mongoose/lib/error/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_mongooseError();
    module2.exports = exports2 = MongooseError;
    MongooseError.messages = require_messages();
    MongooseError.Messages = MongooseError.messages;
    MongooseError.DocumentNotFoundError = require_notFound();
    MongooseError.CastError = require_cast();
    MongooseError.ValidationError = require_validation();
    MongooseError.ValidatorError = require_validator();
    MongooseError.VersionError = require_version();
    MongooseError.ParallelSaveError = require_parallelSave();
    MongooseError.OverwriteModelError = require_overwriteModel();
    MongooseError.MissingSchemaError = require_missingSchema();
    MongooseError.DivergentArrayError = require_divergentArray();
    MongooseError.StrictModeError = require_strict();
  }
});

// node_modules/mongoose/lib/options/propertyOptions.js
var require_propertyOptions = __commonJS({
  "node_modules/mongoose/lib/options/propertyOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Object.freeze({
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
});

// node_modules/mongoose/lib/options/SchemaTypeOptions.js
var require_SchemaTypeOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaTypeOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var clone2 = require_clone();
    var SchemaTypeOptions = class {
      constructor(obj) {
        if (obj == null) {
          return this;
        }
        Object.assign(this, clone2(obj));
      }
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaTypeOptions.prototype, "type", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "validate", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "cast", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "required", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "default", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "ref", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "select", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "index", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "unique", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "immutable", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "sparse", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "text", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "transform", opts);
    module2.exports = SchemaTypeOptions;
  }
});

// node_modules/mongoose/lib/cast/boolean.js
var require_boolean = __commonJS({
  "node_modules/mongoose/lib/cast/boolean.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CastError = require_cast();
    module2.exports = function castBoolean(value, path) {
      if (module2.exports.convertToTrue.has(value)) {
        return true;
      }
      if (module2.exports.convertToFalse.has(value)) {
        return false;
      }
      if (value == null) {
        return value;
      }
      throw new CastError("boolean", value, path);
    };
    module2.exports.convertToTrue = new Set([true, "true", 1, "1", "yes"]);
    module2.exports.convertToFalse = new Set([false, "false", 0, "0", "no"]);
  }
});

// node_modules/mongoose/lib/schema/operators/exists.js
var require_exists = __commonJS({
  "node_modules/mongoose/lib/schema/operators/exists.js"(exports2, module2) {
    init_shims();
    "use strict";
    var castBoolean = require_boolean();
    module2.exports = function(val) {
      const path = this != null ? this.path : null;
      return castBoolean(val, path);
    };
  }
});

// node_modules/mongoose/lib/schema/operators/type.js
var require_type = __commonJS({
  "node_modules/mongoose/lib/schema/operators/type.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(val) {
      if (Array.isArray(val)) {
        if (!val.every((v) => typeof v === "number" || typeof v === "string")) {
          throw new Error("$type array values must be strings or numbers");
        }
        return val;
      }
      if (typeof val !== "number" && typeof val !== "string") {
        throw new Error("$type parameter must be number, string, or array of numbers and strings");
      }
      return val;
    };
  }
});

// node_modules/mongoose/lib/helpers/schematype/handleImmutable.js
var require_handleImmutable = __commonJS({
  "node_modules/mongoose/lib/helpers/schematype/handleImmutable.js"(exports2, module2) {
    init_shims();
    "use strict";
    var StrictModeError = require_strict();
    module2.exports = function(schematype) {
      if (schematype.$immutable) {
        schematype.$immutableSetter = createImmutableSetter(schematype.path, schematype.options.immutable);
        schematype.set(schematype.$immutableSetter);
      } else if (schematype.$immutableSetter) {
        schematype.setters = schematype.setters.filter((fn) => fn !== schematype.$immutableSetter);
        delete schematype.$immutableSetter;
      }
    };
    function createImmutableSetter(path, immutable) {
      return function immutableSetter(v) {
        if (this == null || this.$__ == null) {
          return v;
        }
        if (this.isNew) {
          return v;
        }
        const _immutable = typeof immutable === "function" ? immutable.call(this, this) : immutable;
        if (!_immutable) {
          return v;
        }
        const _value = this.$__getValue(path);
        if (this.$__.strictMode === "throw" && v !== _value) {
          throw new StrictModeError(path, "Path `" + path + "` is immutable and strict mode is set to throw.", true);
        }
        return _value;
      };
    }
  }
});

// node_modules/mongoose/lib/schematype.js
var require_schematype = __commonJS({
  "node_modules/mongoose/lib/schematype.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var $exists = require_exists();
    var $type = require_type();
    var get2 = require_get();
    var handleImmutable = require_handleImmutable();
    var immediate = require_immediate();
    var schemaTypeSymbol = require_symbols().schemaTypeSymbol;
    var util = require("util");
    var utils2 = require_utils6();
    var validatorErrorSymbol = require_symbols().validatorErrorSymbol;
    var documentIsModified = require_symbols().documentIsModified;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var CastError = MongooseError.CastError;
    var ValidatorError = MongooseError.ValidatorError;
    function SchemaType(path, options2, instance) {
      this[schemaTypeSymbol] = true;
      this.path = path;
      this.instance = instance;
      this.validators = [];
      this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [];
      this.setters = [];
      this.splitPath();
      options2 = options2 || {};
      const defaultOptions = this.constructor.defaultOptions || {};
      const defaultOptionsKeys = Object.keys(defaultOptions);
      for (const option of defaultOptionsKeys) {
        if (defaultOptions.hasOwnProperty(option) && !options2.hasOwnProperty(option)) {
          options2[option] = defaultOptions[option];
        }
      }
      if (options2.select == null) {
        delete options2.select;
      }
      const Options = this.OptionsConstructor || SchemaTypeOptions;
      this.options = new Options(options2);
      this._index = null;
      if (utils2.hasUserDefinedProperty(this.options, "immutable")) {
        this.$immutable = this.options.immutable;
        handleImmutable(this);
      }
      const keys = Object.keys(this.options);
      for (const prop of keys) {
        if (prop === "cast") {
          this.castFunction(this.options[prop]);
          continue;
        }
        if (utils2.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === "function") {
          if (prop === "index" && this._index) {
            if (options2.index === false) {
              const index2 = this._index;
              if (typeof index2 === "object" && index2 != null) {
                if (index2.unique) {
                  throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
                }
                if (index2.sparse) {
                  throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
                }
              }
              this._index = false;
            }
            continue;
          }
          const val = options2[prop];
          if (prop === "default") {
            this.default(val);
            continue;
          }
          const opts = Array.isArray(val) ? val : [val];
          this[prop].apply(this, opts);
        }
      }
      Object.defineProperty(this, "$$context", {
        enumerable: false,
        configurable: false,
        writable: true,
        value: null
      });
    }
    SchemaType.prototype.OptionsConstructor = SchemaTypeOptions;
    SchemaType.prototype.splitPath = function() {
      if (this._presplitPath != null) {
        return this._presplitPath;
      }
      if (this.path == null) {
        return void 0;
      }
      this._presplitPath = this.path.indexOf(".") === -1 ? [this.path] : this.path.split(".");
      return this._presplitPath;
    };
    SchemaType.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = (v) => v;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaType.prototype.castFunction = function castFunction(caster) {
      if (arguments.length === 0) {
        return this._castFunction;
      }
      if (caster === false) {
        caster = this.constructor._defaultCaster || ((v) => v);
      }
      this._castFunction = caster;
      return this._castFunction;
    };
    SchemaType.prototype.cast = function cast() {
      throw new Error("Base SchemaType class does not implement a `cast()` function");
    };
    SchemaType.set = function set(option, value) {
      if (!this.hasOwnProperty("defaultOptions")) {
        this.defaultOptions = Object.assign({}, this.defaultOptions);
      }
      this.defaultOptions[option] = value;
    };
    SchemaType.get = function(getter) {
      this.getters = this.hasOwnProperty("getters") ? this.getters : [];
      this.getters.push(getter);
    };
    SchemaType.prototype.default = function(val) {
      if (arguments.length === 1) {
        if (val === void 0) {
          this.defaultValue = void 0;
          return void 0;
        }
        if (val != null && val.instanceOfSchema) {
          throw new MongooseError("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
        }
        this.defaultValue = val;
        return this.defaultValue;
      } else if (arguments.length > 1) {
        this.defaultValue = utils2.args(arguments);
      }
      return this.defaultValue;
    };
    SchemaType.prototype.index = function(options2) {
      this._index = options2;
      utils2.expires(this._index);
      return this;
    };
    SchemaType.prototype.unique = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
      }
      if (this._index == null || this._index === true) {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.unique = bool;
      return this;
    };
    SchemaType.prototype.text = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `text` set to true');
      }
      if (this._index === null || this._index === void 0 || typeof this._index === "boolean") {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.text = bool;
      return this;
    };
    SchemaType.prototype.sparse = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
      }
      if (this._index == null || typeof this._index === "boolean") {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.sparse = bool;
      return this;
    };
    SchemaType.prototype.immutable = function(bool) {
      this.$immutable = bool;
      handleImmutable(this);
      return this;
    };
    SchemaType.prototype.transform = function(fn) {
      this.options.transform = fn;
      return this;
    };
    SchemaType.prototype.set = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError("A setter must be a function.");
      }
      this.setters.push(fn);
      return this;
    };
    SchemaType.prototype.get = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError("A getter must be a function.");
      }
      this.getters.push(fn);
      return this;
    };
    SchemaType.prototype.validate = function(obj, message, type) {
      if (typeof obj === "function" || obj && utils2.getFunctionName(obj.constructor) === "RegExp") {
        let properties;
        if (typeof message === "function") {
          properties = { validator: obj, message };
          properties.type = type || "user defined";
        } else if (message instanceof Object && !type) {
          properties = utils2.clone(message);
          if (!properties.message) {
            properties.message = properties.msg;
          }
          properties.validator = obj;
          properties.type = properties.type || "user defined";
        } else {
          if (message == null) {
            message = MongooseError.messages.general.default;
          }
          if (!type) {
            type = "user defined";
          }
          properties = { message, type, validator: obj };
        }
        if (properties.isAsync) {
          handleIsAsync();
        }
        this.validators.push(properties);
        return this;
      }
      let i;
      let length;
      let arg;
      for (i = 0, length = arguments.length; i < length; i++) {
        arg = arguments[i];
        if (!utils2.isPOJO(arg)) {
          const msg = "Invalid validator. Received (" + typeof arg + ") " + arg + ". See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate";
          throw new Error(msg);
        }
        this.validate(arg.validator, arg);
      }
      return this;
    };
    var handleIsAsync = util.deprecate(function handleIsAsync2() {
    }, "Mongoose: the `isAsync` option for custom validators is deprecated. Make your async validators return a promise instead: https://mongoosejs.com/docs/validation.html#async-custom-validators");
    SchemaType.prototype.required = function(required, message) {
      let customOptions = {};
      if (arguments.length > 0 && required == null) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.requiredValidator;
        }, this);
        this.isRequired = false;
        delete this.originalRequiredValue;
        return this;
      }
      if (typeof required === "object") {
        customOptions = required;
        message = customOptions.message || message;
        required = required.isRequired;
      }
      if (required === false) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.requiredValidator;
        }, this);
        this.isRequired = false;
        delete this.originalRequiredValue;
        return this;
      }
      const _this = this;
      this.isRequired = true;
      this.requiredValidator = function(v) {
        const cachedRequired = get2(this, "$__.cachedRequired");
        if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {
          return true;
        }
        if (cachedRequired != null && _this.path in cachedRequired) {
          const res = cachedRequired[_this.path] ? _this.checkRequired(v, this) : true;
          delete cachedRequired[_this.path];
          return res;
        } else if (typeof required === "function") {
          return required.apply(this) ? _this.checkRequired(v, this) : true;
        }
        return _this.checkRequired(v, this);
      };
      this.originalRequiredValue = required;
      if (typeof required === "string") {
        message = required;
        required = void 0;
      }
      const msg = message || MongooseError.messages.general.required;
      this.validators.unshift(Object.assign({}, customOptions, {
        validator: this.requiredValidator,
        message: msg,
        type: "required"
      }));
      return this;
    };
    SchemaType.prototype.ref = function(ref) {
      this.options.ref = ref;
      return this;
    };
    SchemaType.prototype.getDefault = function(scope, init2) {
      let ret2 = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
      if (ret2 !== null && ret2 !== void 0) {
        if (typeof ret2 === "object" && (!this.options || !this.options.shared)) {
          ret2 = utils2.clone(ret2);
        }
        const casted = this.applySetters(ret2, scope, init2);
        if (casted && casted.$isSingleNested) {
          casted.$__parent = scope;
        }
        return casted;
      }
      return ret2;
    };
    SchemaType.prototype._applySetters = function(value, scope, init2) {
      let v = value;
      if (init2) {
        return v;
      }
      const setters = this.setters;
      for (let i = setters.length - 1; i >= 0; i--) {
        v = setters[i].call(scope, v, this);
      }
      return v;
    };
    SchemaType.prototype._castNullish = function _castNullish(v) {
      return v;
    };
    SchemaType.prototype.applySetters = function(value, scope, init2, priorVal, options2) {
      let v = this._applySetters(value, scope, init2, priorVal, options2);
      if (v == null) {
        return this._castNullish(v);
      }
      v = this.cast(v, scope, init2, priorVal, options2);
      return v;
    };
    SchemaType.prototype.applyGetters = function(value, scope) {
      let v = value;
      const getters = this.getters;
      const len = getters.length;
      if (len === 0) {
        return v;
      }
      for (let i = 0; i < len; ++i) {
        v = getters[i].call(scope, v, this);
      }
      return v;
    };
    SchemaType.prototype.select = function select(val) {
      this.selected = !!val;
      return this;
    };
    SchemaType.prototype.doValidate = function(value, fn, scope, options2) {
      let err = false;
      const path = this.path;
      const validators = this.validators.filter((v) => v != null && typeof v === "object");
      let count = validators.length;
      if (!count) {
        return fn(null);
      }
      const _this = this;
      validators.forEach(function(v) {
        if (err) {
          return;
        }
        const validator = v.validator;
        let ok;
        const validatorProperties = utils2.clone(v);
        validatorProperties.path = options2 && options2.path ? options2.path : path;
        validatorProperties.value = value;
        if (validator instanceof RegExp) {
          validate(validator.test(value), validatorProperties);
          return;
        }
        if (typeof validator !== "function") {
          return;
        }
        if (value === void 0 && validator !== _this.requiredValidator) {
          validate(true, validatorProperties);
          return;
        }
        if (validatorProperties.isAsync) {
          asyncValidate(validator, scope, value, validatorProperties, validate);
          return;
        }
        try {
          if (validatorProperties.propsParameter) {
            ok = validator.call(scope, value, validatorProperties);
          } else {
            ok = validator.call(scope, value);
          }
        } catch (error2) {
          ok = false;
          validatorProperties.reason = error2;
          if (error2.message) {
            validatorProperties.message = error2.message;
          }
        }
        if (ok != null && typeof ok.then === "function") {
          ok.then(function(ok2) {
            validate(ok2, validatorProperties);
          }, function(error2) {
            validatorProperties.reason = error2;
            validatorProperties.message = error2.message;
            ok = false;
            validate(ok, validatorProperties);
          });
        } else {
          validate(ok, validatorProperties);
        }
      });
      function validate(ok, validatorProperties) {
        if (err) {
          return;
        }
        if (ok === void 0 || ok) {
          if (--count <= 0) {
            immediate(function() {
              fn(null);
            });
          }
        } else {
          const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
          err = new ErrorConstructor(validatorProperties);
          err[validatorErrorSymbol] = true;
          immediate(function() {
            fn(err);
          });
        }
      }
    };
    function asyncValidate(validator, scope, value, props, cb) {
      let called = false;
      const returnVal = validator.call(scope, value, function(ok, customMsg) {
        if (called) {
          return;
        }
        called = true;
        if (customMsg) {
          props.message = customMsg;
        }
        cb(ok, props);
      });
      if (typeof returnVal === "boolean") {
        called = true;
        cb(returnVal, props);
      } else if (returnVal && typeof returnVal.then === "function") {
        returnVal.then(function(ok) {
          if (called) {
            return;
          }
          called = true;
          cb(ok, props);
        }, function(error2) {
          if (called) {
            return;
          }
          called = true;
          props.reason = error2;
          props.message = error2.message;
          cb(false, props);
        });
      }
    }
    SchemaType.prototype.doValidateSync = function(value, scope, options2) {
      const path = this.path;
      const count = this.validators.length;
      if (!count) {
        return null;
      }
      let validators = this.validators;
      if (value === void 0) {
        if (this.validators.length > 0 && this.validators[0].type === "required") {
          validators = [this.validators[0]];
        } else {
          return null;
        }
      }
      let err = null;
      validators.forEach(function(v) {
        if (err) {
          return;
        }
        if (v == null || typeof v !== "object") {
          return;
        }
        const validator = v.validator;
        const validatorProperties = utils2.clone(v);
        validatorProperties.path = options2 && options2.path ? options2.path : path;
        validatorProperties.value = value;
        let ok;
        if (validator.isAsync) {
          return;
        }
        if (validator instanceof RegExp) {
          validate(validator.test(value), validatorProperties);
          return;
        }
        if (typeof validator !== "function") {
          return;
        }
        try {
          if (validatorProperties.propsParameter) {
            ok = validator.call(scope, value, validatorProperties);
          } else {
            ok = validator.call(scope, value);
          }
        } catch (error2) {
          ok = false;
          validatorProperties.reason = error2;
        }
        if (ok != null && typeof ok.then === "function") {
          return;
        }
        validate(ok, validatorProperties);
      });
      return err;
      function validate(ok, validatorProperties) {
        if (err) {
          return;
        }
        if (ok !== void 0 && !ok) {
          const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
          err = new ErrorConstructor(validatorProperties);
          err[validatorErrorSymbol] = true;
        }
      }
    };
    SchemaType._isRef = function(self2, value, doc, init2) {
      let ref = init2 && self2.options && (self2.options.ref || self2.options.refPath);
      if (!ref && doc && doc.$__ != null) {
        const path = doc.$__fullPath(self2.path);
        const owner = doc.ownerDocument ? doc.ownerDocument() : doc;
        ref = owner.populated(path) || doc.populated(self2.path);
      }
      if (ref) {
        if (value == null) {
          return true;
        }
        if (!Buffer.isBuffer(value) && value._bsontype !== "Binary" && utils2.isObject(value)) {
          return true;
        }
        return init2;
      }
      return false;
    };
    SchemaType.prototype._castRef = function _castRef(value, doc, init2) {
      if (value == null) {
        return value;
      }
      if (value.$__ != null) {
        value.$__.wasPopulated = true;
        return value;
      }
      if (Buffer.isBuffer(value) || !utils2.isObject(value)) {
        if (init2) {
          return value;
        }
        throw new CastError(this.instance, value, this.path, null, this);
      }
      const path = doc.$__fullPath(this.path);
      const owner = doc.ownerDocument ? doc.ownerDocument() : doc;
      const pop = owner.populated(path, true);
      let ret2 = value;
      if (!doc.$__.populated || !doc.$__.populated[path] || !doc.$__.populated[path].options || !doc.$__.populated[path].options.options || !doc.$__.populated[path].options.options.lean) {
        ret2 = new pop.options[populateModelSymbol](value);
        ret2.$__.wasPopulated = true;
      }
      return ret2;
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        return _this.castForQuery(m);
      });
    }
    function handle$in(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        if (Array.isArray(m) && m.length === 0) {
          return m;
        }
        return _this.castForQuery(m);
      });
    }
    SchemaType.prototype.$conditionalHandlers = {
      $all: handleArray,
      $eq: handleSingle,
      $in: handle$in,
      $ne: handleSingle,
      $nin: handle$in,
      $exists,
      $type
    };
    SchemaType.prototype.castForQueryWrapper = function(params) {
      this.$$context = params.context;
      if ("$conditional" in params) {
        const ret3 = this.castForQuery(params.$conditional, params.val);
        this.$$context = null;
        return ret3;
      }
      if (params.$skipQueryCastForUpdate || params.$applySetters) {
        const ret3 = this._castForQuery(params.val);
        this.$$context = null;
        return ret3;
      }
      const ret2 = this.castForQuery(params.val);
      this.$$context = null;
      return ret2;
    };
    SchemaType.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional);
        }
        return handler.call(this, val);
      }
      val = $conditional;
      return this._castForQuery(val);
    };
    SchemaType.prototype._castForQuery = function(val) {
      return this.applySetters(val, this.$$context);
    };
    SchemaType.checkRequired = function(fn) {
      if (arguments.length > 0) {
        this._checkRequired = fn;
      }
      return this._checkRequired;
    };
    SchemaType.prototype.checkRequired = function(val) {
      return val != null;
    };
    SchemaType.prototype.clone = function() {
      const options2 = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, options2, this.instance);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0)
        schematype.requiredValidator = this.requiredValidator;
      if (this.defaultValue !== void 0)
        schematype.defaultValue = this.defaultValue;
      if (this.$immutable !== void 0 && this.options.immutable === void 0) {
        schematype.$immutable = this.$immutable;
        handleImmutable(schematype);
      }
      if (this._index !== void 0)
        schematype._index = this._index;
      if (this.selected !== void 0)
        schematype.selected = this.selected;
      if (this.isRequired !== void 0)
        schematype.isRequired = this.isRequired;
      if (this.originalRequiredValue !== void 0)
        schematype.originalRequiredValue = this.originalRequiredValue;
      schematype.getters = this.getters.slice();
      schematype.setters = this.setters.slice();
      return schematype;
    };
    module2.exports = exports2 = SchemaType;
    exports2.CastError = CastError;
    exports2.ValidatorError = ValidatorError;
  }
});

// node_modules/mongoose/lib/schema/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/mongoose/lib/schema/symbols.js"(exports2) {
    init_shims();
    "use strict";
    exports2.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed");
    exports2.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
  }
});

// node_modules/mongoose/lib/schema/mixed.js
var require_mixed = __commonJS({
  "node_modules/mongoose/lib/schema/mixed.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaType = require_schematype();
    var symbols = require_symbols2();
    var isObject2 = require_isObject();
    var utils2 = require_utils6();
    function Mixed(path, options2) {
      if (options2 && options2.default) {
        const def = options2.default;
        if (Array.isArray(def) && def.length === 0) {
          options2.default = Array;
        } else if (!options2.shared && isObject2(def) && Object.keys(def).length === 0) {
          options2.default = function() {
            return {};
          };
        }
      }
      SchemaType.call(this, path, options2, "Mixed");
      this[symbols.schemaMixedSymbol] = true;
    }
    Mixed.schemaName = "Mixed";
    Mixed.defaultOptions = {};
    Mixed.prototype = Object.create(SchemaType.prototype);
    Mixed.prototype.constructor = Mixed;
    Mixed.get = SchemaType.get;
    Mixed.set = SchemaType.set;
    Mixed.prototype.cast = function(val) {
      if (val instanceof Error) {
        return utils2.errorToPOJO(val);
      }
      return val;
    };
    Mixed.prototype.castForQuery = function($cond, val) {
      if (arguments.length === 2) {
        return val;
      }
      return $cond;
    };
    module2.exports = Mixed;
  }
});

// node_modules/mongoose/lib/error/objectExpected.js
var require_objectExpected = __commonJS({
  "node_modules/mongoose/lib/error/objectExpected.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var ObjectExpectedError = class extends MongooseError {
      constructor(path, val) {
        const typeDescription = Array.isArray(val) ? "array" : "primitive value";
        super("Tried to set nested object field `" + path + `\` to ${typeDescription} \`` + val + "` and strict mode is set to throw.");
        this.path = path;
      }
    };
    Object.defineProperty(ObjectExpectedError.prototype, "name", {
      value: "ObjectExpectedError"
    });
    module2.exports = ObjectExpectedError;
  }
});

// node_modules/mongoose/lib/error/objectParameter.js
var require_objectParameter = __commonJS({
  "node_modules/mongoose/lib/error/objectParameter.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var ObjectParameterError = class extends MongooseError {
      constructor(value, paramName, fnName) {
        super('Parameter "' + paramName + '" to ' + fnName + "() must be an object, got " + value.toString());
      }
    };
    Object.defineProperty(ObjectParameterError.prototype, "name", {
      value: "ObjectParameterError"
    });
    module2.exports = ObjectParameterError;
  }
});

// node_modules/mongoose/lib/error/parallelValidate.js
var require_parallelValidate = __commonJS({
  "node_modules/mongoose/lib/error/parallelValidate.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_mongooseError();
    var ParallelValidateError = class extends MongooseError {
      constructor(doc) {
        const msg = "Can't validate() the same doc multiple times in parallel. Document: ";
        super(msg + doc._id);
      }
    };
    Object.defineProperty(ParallelValidateError.prototype, "name", {
      value: "ParallelValidateError"
    });
    module2.exports = ParallelValidateError;
  }
});

// node_modules/kareem/index.js
var require_kareem = __commonJS({
  "node_modules/kareem/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    function Kareem() {
      this._pres = new Map();
      this._posts = new Map();
    }
    Kareem.prototype.execPre = function(name, context, args, callback) {
      if (arguments.length === 3) {
        callback = args;
        args = [];
      }
      var pres = get2(this._pres, name, []);
      var numPres = pres.length;
      var numAsyncPres = pres.numAsync || 0;
      var currentPre = 0;
      var asyncPresLeft = numAsyncPres;
      var done = false;
      var $args = args;
      if (!numPres) {
        return process.nextTick(function() {
          callback(null);
        });
      }
      var next = function() {
        if (currentPre >= numPres) {
          return;
        }
        var pre = pres[currentPre];
        if (pre.isAsync) {
          var args2 = [
            decorateNextFn(_next),
            decorateNextFn(function(error2) {
              if (error2) {
                if (done) {
                  return;
                }
                done = true;
                return callback(error2);
              }
              if (--asyncPresLeft === 0 && currentPre >= numPres) {
                return callback(null);
              }
            })
          ];
          callMiddlewareFunction(pre.fn, context, args2, args2[0]);
        } else if (pre.fn.length > 0) {
          var args2 = [decorateNextFn(_next)];
          var _args = arguments.length >= 2 ? arguments : [null].concat($args);
          for (var i = 1; i < _args.length; ++i) {
            args2.push(_args[i]);
          }
          callMiddlewareFunction(pre.fn, context, args2, args2[0]);
        } else {
          let maybePromise = null;
          try {
            maybePromise = pre.fn.call(context);
          } catch (err) {
            if (err != null) {
              return callback(err);
            }
          }
          if (isPromise(maybePromise)) {
            maybePromise.then(() => _next(), (err) => _next(err));
          } else {
            if (++currentPre >= numPres) {
              if (asyncPresLeft > 0) {
                return;
              } else {
                return process.nextTick(function() {
                  callback(null);
                });
              }
            }
            next();
          }
        }
      };
      next.apply(null, [null].concat(args));
      function _next(error2) {
        if (error2) {
          if (done) {
            return;
          }
          done = true;
          return callback(error2);
        }
        if (++currentPre >= numPres) {
          if (asyncPresLeft > 0) {
            return;
          } else {
            return callback(null);
          }
        }
        next.apply(context, arguments);
      }
    };
    Kareem.prototype.execPreSync = function(name, context, args) {
      var pres = get2(this._pres, name, []);
      var numPres = pres.length;
      for (var i = 0; i < numPres; ++i) {
        pres[i].fn.apply(context, args || []);
      }
    };
    Kareem.prototype.execPost = function(name, context, args, options2, callback) {
      if (arguments.length < 5) {
        callback = options2;
        options2 = null;
      }
      var posts2 = get2(this._posts, name, []);
      var numPosts = posts2.length;
      var currentPost = 0;
      var firstError = null;
      if (options2 && options2.error) {
        firstError = options2.error;
      }
      if (!numPosts) {
        return process.nextTick(function() {
          callback.apply(null, [firstError].concat(args));
        });
      }
      var next = function() {
        var post = posts2[currentPost].fn;
        var numArgs = 0;
        var argLength = args.length;
        var newArgs = [];
        for (var i = 0; i < argLength; ++i) {
          numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;
          if (!args[i] || !args[i]._kareemIgnore) {
            newArgs.push(args[i]);
          }
        }
        if (firstError) {
          if (post.length === numArgs + 2) {
            var _cb = decorateNextFn(function(error2) {
              if (error2) {
                firstError = error2;
              }
              if (++currentPost >= numPosts) {
                return callback.call(null, firstError);
              }
              next();
            });
            callMiddlewareFunction(post, context, [firstError].concat(newArgs).concat([_cb]), _cb);
          } else {
            if (++currentPost >= numPosts) {
              return callback.call(null, firstError);
            }
            next();
          }
        } else {
          const _cb2 = decorateNextFn(function(error2) {
            if (error2) {
              firstError = error2;
              return next();
            }
            if (++currentPost >= numPosts) {
              return callback.apply(null, [null].concat(args));
            }
            next();
          });
          if (post.length === numArgs + 2) {
            if (++currentPost >= numPosts) {
              return callback.apply(null, [null].concat(args));
            }
            return next();
          }
          if (post.length === numArgs + 1) {
            callMiddlewareFunction(post, context, newArgs.concat([_cb2]), _cb2);
          } else {
            let error2;
            let maybePromise;
            try {
              maybePromise = post.apply(context, newArgs);
            } catch (err) {
              error2 = err;
              firstError = err;
            }
            if (isPromise(maybePromise)) {
              return maybePromise.then(() => _cb2(), (err) => _cb2(err));
            }
            if (++currentPost >= numPosts) {
              return callback.apply(null, [error2].concat(args));
            }
            next(error2);
          }
        }
      };
      next();
    };
    Kareem.prototype.execPostSync = function(name, context, args) {
      const posts2 = get2(this._posts, name, []);
      const numPosts = posts2.length;
      for (let i = 0; i < numPosts; ++i) {
        posts2[i].fn.apply(context, args || []);
      }
    };
    Kareem.prototype.createWrapperSync = function(name, fn) {
      var kareem = this;
      return function syncWrapper() {
        kareem.execPreSync(name, this, arguments);
        var toReturn = fn.apply(this, arguments);
        kareem.execPostSync(name, this, [toReturn]);
        return toReturn;
      };
    };
    function _handleWrapError(instance, error2, name, context, args, options2, callback) {
      if (options2.useErrorHandlers) {
        var _options = { error: error2 };
        return instance.execPost(name, context, args, _options, function(error3) {
          return typeof callback === "function" && callback(error3);
        });
      } else {
        return typeof callback === "function" ? callback(error2) : void 0;
      }
    }
    Kareem.prototype.wrap = function(name, fn, context, args, options2) {
      const lastArg = args.length > 0 ? args[args.length - 1] : null;
      const argsWithoutCb = typeof lastArg === "function" ? args.slice(0, args.length - 1) : args;
      const _this = this;
      options2 = options2 || {};
      const checkForPromise = options2.checkForPromise;
      this.execPre(name, context, args, function(error2) {
        if (error2) {
          const numCallbackParams = options2.numCallbackParams || 0;
          const errorArgs = options2.contextParameter ? [context] : [];
          for (var i = errorArgs.length; i < numCallbackParams; ++i) {
            errorArgs.push(null);
          }
          return _handleWrapError(_this, error2, name, context, errorArgs, options2, lastArg);
        }
        const end = typeof lastArg === "function" ? args.length - 1 : args.length;
        const numParameters = fn.length;
        const ret2 = fn.apply(context, args.slice(0, end).concat(_cb));
        if (checkForPromise) {
          if (ret2 != null && typeof ret2.then === "function") {
            return ret2.then((res) => _cb(null, res), (err) => _cb(err));
          }
          if (numParameters < end + 1) {
            return _cb(null, ret2);
          }
        }
        function _cb() {
          const args2 = arguments;
          const argsWithoutError = Array.prototype.slice.call(arguments, 1);
          if (options2.nullResultByDefault && argsWithoutError.length === 0) {
            argsWithoutError.push(null);
          }
          if (arguments[0]) {
            return _handleWrapError(_this, arguments[0], name, context, argsWithoutError, options2, lastArg);
          } else {
            _this.execPost(name, context, argsWithoutError, function() {
              if (arguments[0]) {
                return typeof lastArg === "function" ? lastArg(arguments[0]) : void 0;
              }
              return typeof lastArg === "function" ? lastArg.apply(context, arguments) : void 0;
            });
          }
        }
      });
    };
    Kareem.prototype.filter = function(fn) {
      const clone2 = this.clone();
      const pres = Array.from(clone2._pres.keys());
      for (const name of pres) {
        const hooks = this._pres.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
        if (hooks.length === 0) {
          clone2._pres.delete(name);
          continue;
        }
        hooks.numAsync = hooks.filter((h) => h.isAsync).length;
        clone2._pres.set(name, hooks);
      }
      const posts2 = Array.from(clone2._posts.keys());
      for (const name of posts2) {
        const hooks = this._posts.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
        if (hooks.length === 0) {
          clone2._posts.delete(name);
          continue;
        }
        clone2._posts.set(name, hooks);
      }
      return clone2;
    };
    Kareem.prototype.hasHooks = function(name) {
      return this._pres.has(name) || this._posts.has(name);
    };
    Kareem.prototype.createWrapper = function(name, fn, context, options2) {
      var _this = this;
      if (!this.hasHooks(name)) {
        return function() {
          process.nextTick(() => fn.apply(this, arguments));
        };
      }
      return function() {
        var _context = context || this;
        var args = Array.prototype.slice.call(arguments);
        _this.wrap(name, fn, _context, args, options2);
      };
    };
    Kareem.prototype.pre = function(name, isAsync, fn, error2, unshift) {
      let options2 = {};
      if (typeof isAsync === "object" && isAsync != null) {
        options2 = isAsync;
        isAsync = options2.isAsync;
      } else if (typeof arguments[1] !== "boolean") {
        error2 = fn;
        fn = isAsync;
        isAsync = false;
      }
      const pres = get2(this._pres, name, []);
      this._pres.set(name, pres);
      if (isAsync) {
        pres.numAsync = pres.numAsync || 0;
        ++pres.numAsync;
      }
      if (typeof fn !== "function") {
        throw new Error('pre() requires a function, got "' + typeof fn + '"');
      }
      if (unshift) {
        pres.unshift(Object.assign({}, options2, { fn, isAsync }));
      } else {
        pres.push(Object.assign({}, options2, { fn, isAsync }));
      }
      return this;
    };
    Kareem.prototype.post = function(name, options2, fn, unshift) {
      const hooks = get2(this._posts, name, []);
      if (typeof options2 === "function") {
        unshift = !!fn;
        fn = options2;
        options2 = {};
      }
      if (typeof fn !== "function") {
        throw new Error('post() requires a function, got "' + typeof fn + '"');
      }
      if (unshift) {
        hooks.unshift(Object.assign({}, options2, { fn }));
      } else {
        hooks.push(Object.assign({}, options2, { fn }));
      }
      this._posts.set(name, hooks);
      return this;
    };
    Kareem.prototype.clone = function() {
      const n = new Kareem();
      for (let key of this._pres.keys()) {
        const clone2 = this._pres.get(key).slice();
        clone2.numAsync = this._pres.get(key).numAsync;
        n._pres.set(key, clone2);
      }
      for (let key of this._posts.keys()) {
        n._posts.set(key, this._posts.get(key).slice());
      }
      return n;
    };
    Kareem.prototype.merge = function(other, clone2) {
      clone2 = arguments.length === 1 ? true : clone2;
      var ret2 = clone2 ? this.clone() : this;
      for (let key of other._pres.keys()) {
        const sourcePres = get2(ret2._pres, key, []);
        const deduplicated = other._pres.get(key).filter((p) => sourcePres.map((_p) => _p.fn).indexOf(p.fn) === -1);
        const combined = sourcePres.concat(deduplicated);
        combined.numAsync = sourcePres.numAsync || 0;
        combined.numAsync += deduplicated.filter((p) => p.isAsync).length;
        ret2._pres.set(key, combined);
      }
      for (let key of other._posts.keys()) {
        const sourcePosts = get2(ret2._posts, key, []);
        const deduplicated = other._posts.get(key).filter((p) => sourcePosts.indexOf(p) === -1);
        ret2._posts.set(key, sourcePosts.concat(deduplicated));
      }
      return ret2;
    };
    function get2(map, key, def) {
      if (map.has(key)) {
        return map.get(key);
      }
      return def;
    }
    function callMiddlewareFunction(fn, context, args, next) {
      let maybePromise;
      try {
        maybePromise = fn.apply(context, args);
      } catch (error2) {
        return next(error2);
      }
      if (isPromise(maybePromise)) {
        maybePromise.then(() => next(), (err) => next(err));
      }
    }
    function isPromise(v) {
      return v != null && typeof v.then === "function";
    }
    function decorateNextFn(fn) {
      var called = false;
      var _this = this;
      return function() {
        if (called) {
          return;
        }
        called = true;
        return process.nextTick(() => fn.apply(_this, arguments));
      };
    }
    module2.exports = Kareem;
  }
});

// node_modules/mongoose/lib/options/VirtualOptions.js
var require_VirtualOptions = __commonJS({
  "node_modules/mongoose/lib/options/VirtualOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var opts = require_propertyOptions();
    var VirtualOptions = class {
      constructor(obj) {
        Object.assign(this, obj);
        if (obj != null && obj.options != null) {
          this.options = Object.assign({}, obj.options);
        }
      }
    };
    Object.defineProperty(VirtualOptions.prototype, "ref", opts);
    Object.defineProperty(VirtualOptions.prototype, "refPath", opts);
    Object.defineProperty(VirtualOptions.prototype, "localField", opts);
    Object.defineProperty(VirtualOptions.prototype, "foreignField", opts);
    Object.defineProperty(VirtualOptions.prototype, "justOne", opts);
    Object.defineProperty(VirtualOptions.prototype, "count", opts);
    Object.defineProperty(VirtualOptions.prototype, "match", opts);
    Object.defineProperty(VirtualOptions.prototype, "options", opts);
    Object.defineProperty(VirtualOptions.prototype, "skip", opts);
    Object.defineProperty(VirtualOptions.prototype, "limit", opts);
    Object.defineProperty(VirtualOptions.prototype, "perDocumentLimit", opts);
    module2.exports = VirtualOptions;
  }
});

// node_modules/mongoose/lib/virtualtype.js
var require_virtualtype = __commonJS({
  "node_modules/mongoose/lib/virtualtype.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils6();
    function VirtualType(options2, name) {
      this.path = name;
      this.getters = [];
      this.setters = [];
      this.options = Object.assign({}, options2);
    }
    VirtualType.prototype._applyDefaultGetters = function() {
      if (this.getters.length > 0 || this.setters.length > 0) {
        return;
      }
      const path = this.path;
      const internalProperty = "$" + path;
      this.getters.push(function() {
        return this[internalProperty];
      });
      this.setters.push(function(v) {
        this[internalProperty] = v;
      });
    };
    VirtualType.prototype.clone = function() {
      const clone2 = new VirtualType(this.options, this.path);
      clone2.getters = [].concat(this.getters);
      clone2.setters = [].concat(this.setters);
      return clone2;
    };
    VirtualType.prototype.get = function(fn) {
      this.getters.push(fn);
      return this;
    };
    VirtualType.prototype.set = function(fn) {
      this.setters.push(fn);
      return this;
    };
    VirtualType.prototype.applyGetters = function(value, doc) {
      if (utils2.hasUserDefinedProperty(this.options, ["ref", "refPath"]) && doc.$$populatedVirtuals && doc.$$populatedVirtuals.hasOwnProperty(this.path)) {
        value = doc.$$populatedVirtuals[this.path];
      }
      let v = value;
      for (let l = this.getters.length - 1; l >= 0; l--) {
        v = this.getters[l].call(doc, v, this, doc);
      }
      return v;
    };
    VirtualType.prototype.applySetters = function(value, doc) {
      let v = value;
      for (let l = this.setters.length - 1; l >= 0; l--) {
        v = this.setters[l].call(doc, v, this, doc);
      }
      return v;
    };
    module2.exports = VirtualType;
  }
});

// node_modules/mongoose/lib/helpers/schema/addAutoId.js
var require_addAutoId = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/addAutoId.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function addAutoId(schema) {
      const _obj = { _id: { auto: true } };
      _obj._id[schema.options.typeKey] = "ObjectId";
      schema.add(_obj);
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/getIndexes.js
var require_getIndexes = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/getIndexes.js"(exports2, module2) {
    init_shims();
    "use strict";
    var get2 = require_get();
    var helperIsObject = require_isObject();
    module2.exports = function getIndexes(schema) {
      let indexes = [];
      const schemaStack = new WeakMap();
      const indexTypes = schema.constructor.indexTypes;
      const indexByName = new Map();
      collectIndexes(schema);
      return indexes;
      function collectIndexes(schema2, prefix, baseSchema) {
        if (schemaStack.has(schema2)) {
          return;
        }
        schemaStack.set(schema2, true);
        prefix = prefix || "";
        const keys = Object.keys(schema2.paths);
        for (const key of keys) {
          const path = schema2.paths[key];
          if (baseSchema != null && baseSchema.paths[key]) {
            continue;
          }
          if (path.$isMongooseDocumentArray || path.$isSingleNested) {
            if (get2(path, "options.excludeIndexes") !== true && get2(path, "schemaOptions.excludeIndexes") !== true && get2(path, "schema.options.excludeIndexes") !== true) {
              collectIndexes(path.schema, prefix + key + ".");
            }
            if (path.schema.discriminators != null) {
              const discriminators = path.schema.discriminators;
              const discriminatorKeys = Object.keys(discriminators);
              for (const discriminatorKey of discriminatorKeys) {
                collectIndexes(discriminators[discriminatorKey], prefix + key + ".", path.schema);
              }
            }
            if (path.$isMongooseDocumentArray) {
              continue;
            }
          }
          const index2 = path._index || path.caster && path.caster._index;
          if (index2 !== false && index2 !== null && index2 !== void 0) {
            const field = {};
            const isObject2 = helperIsObject(index2);
            const options2 = isObject2 ? index2 : {};
            const type = typeof index2 === "string" ? index2 : isObject2 ? index2.type : false;
            if (type && indexTypes.indexOf(type) !== -1) {
              field[prefix + key] = type;
            } else if (options2.text) {
              field[prefix + key] = "text";
              delete options2.text;
            } else {
              const isDescendingIndex = Number(index2) === -1;
              field[prefix + key] = isDescendingIndex ? -1 : 1;
            }
            delete options2.type;
            if (!("background" in options2)) {
              options2.background = true;
            }
            if (schema2.options.autoIndex != null) {
              options2._autoIndex = schema2.options.autoIndex;
            }
            const indexName = options2 && options2.name;
            if (typeof indexName === "string") {
              if (indexByName.has(indexName)) {
                Object.assign(indexByName.get(indexName), field);
              } else {
                indexes.push([field, options2]);
                indexByName.set(indexName, field);
              }
            } else {
              indexes.push([field, options2]);
              indexByName.set(indexName, field);
            }
          }
        }
        schemaStack.delete(schema2);
        if (prefix) {
          fixSubIndexPaths(schema2, prefix);
        } else {
          schema2._indexes.forEach(function(index2) {
            if (!("background" in index2[1])) {
              index2[1].background = true;
            }
          });
          indexes = indexes.concat(schema2._indexes);
        }
      }
      function fixSubIndexPaths(schema2, prefix) {
        const subindexes = schema2._indexes;
        const len = subindexes.length;
        for (let i = 0; i < len; ++i) {
          const indexObj = subindexes[i][0];
          const indexOptions = subindexes[i][1];
          const keys = Object.keys(indexObj);
          const klen = keys.length;
          const newindex = {};
          for (let j = 0; j < klen; ++j) {
            const key = keys[j];
            newindex[prefix + key] = indexObj[key];
          }
          const newIndexOptions = Object.assign({}, indexOptions);
          if (indexOptions != null && indexOptions.partialFilterExpression != null) {
            newIndexOptions.partialFilterExpression = {};
            const partialFilterExpression = indexOptions.partialFilterExpression;
            for (const key of Object.keys(partialFilterExpression)) {
              newIndexOptions.partialFilterExpression[prefix + key] = partialFilterExpression[key];
            }
          }
          indexes.push([newindex, newIndexOptions]);
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js
var require_cleanPositionalOperators = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function cleanPositionalOperators(path) {
      return path.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js
var require_handleTimestampOption = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = handleTimestampOption;
    function handleTimestampOption(arg, prop) {
      if (arg == null) {
        return null;
      }
      if (typeof arg === "boolean") {
        return prop;
      }
      if (typeof arg[prop] === "boolean") {
        return arg[prop] ? prop : null;
      }
      if (!(prop in arg)) {
        return prop;
      }
      return arg[prop];
    }
  }
});

// node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js
var require_applyTimestampsToChildren = __commonJS({
  "node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js"(exports2, module2) {
    init_shims();
    "use strict";
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var handleTimestampOption = require_handleTimestampOption();
    module2.exports = applyTimestampsToChildren;
    function applyTimestampsToChildren(now, update, schema) {
      if (update == null) {
        return;
      }
      const keys = Object.keys(update);
      const hasDollarKey = keys.some((key) => key.startsWith("$"));
      if (hasDollarKey) {
        if (update.$push) {
          _applyTimestampToUpdateOperator(update.$push);
        }
        if (update.$addToSet) {
          _applyTimestampToUpdateOperator(update.$addToSet);
        }
        if (update.$set != null) {
          const keys2 = Object.keys(update.$set);
          for (const key of keys2) {
            applyTimestampsToUpdateKey(schema, key, update.$set, now);
          }
        }
        if (update.$setOnInsert != null) {
          const keys2 = Object.keys(update.$setOnInsert);
          for (const key of keys2) {
            applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);
          }
        }
      }
      const updateKeys = Object.keys(update).filter((key) => !key.startsWith("$"));
      for (const key of updateKeys) {
        applyTimestampsToUpdateKey(schema, key, update, now);
      }
      function _applyTimestampToUpdateOperator(op) {
        for (const key of Object.keys(op)) {
          const $path = schema.path(key.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
          if (op[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
            const timestamps = $path.schema.options.timestamps;
            const createdAt = handleTimestampOption(timestamps, "createdAt");
            const updatedAt = handleTimestampOption(timestamps, "updatedAt");
            if (op[key].$each) {
              op[key].$each.forEach(function(subdoc) {
                if (updatedAt != null) {
                  subdoc[updatedAt] = now;
                }
                if (createdAt != null) {
                  subdoc[createdAt] = now;
                }
              });
            } else {
              if (updatedAt != null) {
                op[key][updatedAt] = now;
              }
              if (createdAt != null) {
                op[key][createdAt] = now;
              }
            }
          }
        }
      }
    }
    function applyTimestampsToDocumentArray(arr, schematype, now) {
      const timestamps = schematype.schema.options.timestamps;
      if (!timestamps) {
        return;
      }
      const len = arr.length;
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      for (let i = 0; i < len; ++i) {
        if (updatedAt != null) {
          arr[i][updatedAt] = now;
        }
        if (createdAt != null) {
          arr[i][createdAt] = now;
        }
        applyTimestampsToChildren(now, arr[i], schematype.schema);
      }
    }
    function applyTimestampsToSingleNested(subdoc, schematype, now) {
      const timestamps = schematype.schema.options.timestamps;
      if (!timestamps) {
        return;
      }
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      if (updatedAt != null) {
        subdoc[updatedAt] = now;
      }
      if (createdAt != null) {
        subdoc[createdAt] = now;
      }
      applyTimestampsToChildren(now, subdoc, schematype.schema);
    }
    function applyTimestampsToUpdateKey(schema, key, update, now) {
      const keyToSearch = cleanPositionalOperators(key);
      const path = schema.path(keyToSearch);
      if (!path) {
        return;
      }
      const parentSchemaTypes = [];
      const pieces = keyToSearch.split(".");
      for (let i = pieces.length - 1; i > 0; --i) {
        const s2 = schema.path(pieces.slice(0, i).join("."));
        if (s2 != null && (s2.$isMongooseDocumentArray || s2.$isSingleNested)) {
          parentSchemaTypes.push({ parentPath: key.split(".").slice(0, i).join("."), parentSchemaType: s2 });
        }
      }
      if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {
        applyTimestampsToDocumentArray(update[key], path, now);
      } else if (update[key] && path.$isSingleNested) {
        applyTimestampsToSingleNested(update[key], path, now);
      } else if (parentSchemaTypes.length > 0) {
        for (const item of parentSchemaTypes) {
          const parentPath = item.parentPath;
          const parentSchemaType = item.parentSchemaType;
          const timestamps = parentSchemaType.schema.options.timestamps;
          const updatedAt = handleTimestampOption(timestamps, "updatedAt");
          if (!timestamps || updatedAt == null) {
            continue;
          }
          if (parentSchemaType.$isSingleNested) {
            update[parentPath + "." + updatedAt] = now;
          } else if (parentSchemaType.$isMongooseDocumentArray) {
            let childPath = key.substr(parentPath.length + 1);
            if (/^\d+$/.test(childPath)) {
              update[parentPath + "." + childPath][updatedAt] = now;
              continue;
            }
            const firstDot = childPath.indexOf(".");
            childPath = firstDot !== -1 ? childPath.substr(0, firstDot) : childPath;
            update[parentPath + "." + childPath + "." + updatedAt] = now;
          }
        }
      } else if (path.schema != null && path.schema != schema && update[key]) {
        const timestamps = path.schema.options.timestamps;
        const createdAt = handleTimestampOption(timestamps, "createdAt");
        const updatedAt = handleTimestampOption(timestamps, "updatedAt");
        if (!timestamps) {
          return;
        }
        if (updatedAt != null) {
          update[key][updatedAt] = now;
        }
        if (createdAt != null) {
          update[key][createdAt] = now;
        }
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js
var require_applyTimestampsToUpdate = __commonJS({
  "node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js"(exports2, module2) {
    init_shims();
    "use strict";
    var get2 = require_get();
    module2.exports = applyTimestampsToUpdate;
    function applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options2) {
      const updates = currentUpdate;
      let _updates = updates;
      const overwrite = get2(options2, "overwrite", false);
      const timestamps = get2(options2, "timestamps", true);
      if (!timestamps || updates == null) {
        return currentUpdate;
      }
      const skipCreatedAt = timestamps != null && timestamps.createdAt === false;
      const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;
      if (overwrite) {
        if (currentUpdate && currentUpdate.$set) {
          currentUpdate = currentUpdate.$set;
          updates.$set = {};
          _updates = updates.$set;
        }
        if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {
          _updates[updatedAt] = now;
        }
        if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {
          _updates[createdAt] = now;
        }
        return updates;
      }
      currentUpdate = currentUpdate || {};
      if (Array.isArray(updates)) {
        updates.push({ $set: { updatedAt: now } });
        return updates;
      }
      updates.$set = updates.$set || {};
      if (!skipUpdatedAt && updatedAt && (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {
        let timestampSet = false;
        if (updatedAt.indexOf(".") !== -1) {
          const pieces = updatedAt.split(".");
          for (let i = 1; i < pieces.length; ++i) {
            const remnant = pieces.slice(-i).join(".");
            const start = pieces.slice(0, -i).join(".");
            if (currentUpdate[start] != null) {
              currentUpdate[start][remnant] = now;
              timestampSet = true;
              break;
            } else if (currentUpdate.$set && currentUpdate.$set[start]) {
              currentUpdate.$set[start][remnant] = now;
              timestampSet = true;
              break;
            }
          }
        }
        if (!timestampSet) {
          updates.$set[updatedAt] = now;
        }
        if (updates.hasOwnProperty(updatedAt)) {
          delete updates[updatedAt];
        }
      }
      if (!skipCreatedAt && createdAt) {
        if (currentUpdate[createdAt]) {
          delete currentUpdate[createdAt];
        }
        if (currentUpdate.$set && currentUpdate.$set[createdAt]) {
          delete currentUpdate.$set[createdAt];
        }
        let timestampSet = false;
        if (createdAt.indexOf(".") !== -1) {
          const pieces = createdAt.split(".");
          for (let i = 1; i < pieces.length; ++i) {
            const remnant = pieces.slice(-i).join(".");
            const start = pieces.slice(0, -i).join(".");
            if (currentUpdate[start] != null) {
              currentUpdate[start][remnant] = now;
              timestampSet = true;
              break;
            } else if (currentUpdate.$set && currentUpdate.$set[start]) {
              currentUpdate.$set[start][remnant] = now;
              timestampSet = true;
              break;
            }
          }
        }
        if (!timestampSet) {
          updates.$setOnInsert = updates.$setOnInsert || {};
          updates.$setOnInsert[createdAt] = now;
        }
      }
      if (Object.keys(updates.$set).length === 0) {
        delete updates.$set;
      }
      return updates;
    }
  }
});

// node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js
var require_setupTimestamps = __commonJS({
  "node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyTimestampsToChildren = require_applyTimestampsToChildren();
    var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
    var get2 = require_get();
    var handleTimestampOption = require_handleTimestampOption();
    var symbols = require_symbols2();
    module2.exports = function setupTimestamps(schema, timestamps) {
      const childHasTimestamp = schema.childSchemas.find(withTimestamp);
      function withTimestamp(s2) {
        const ts = s2.schema.options.timestamps;
        return !!ts;
      }
      if (!timestamps && !childHasTimestamp) {
        return;
      }
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      const currentTime = timestamps != null && timestamps.hasOwnProperty("currentTime") ? timestamps.currentTime : null;
      const schemaAdditions = {};
      schema.$timestamps = { createdAt, updatedAt };
      if (updatedAt && !schema.paths[updatedAt]) {
        schemaAdditions[updatedAt] = Date;
      }
      if (createdAt && !schema.paths[createdAt]) {
        schemaAdditions[createdAt] = Date;
      }
      schema.add(schemaAdditions);
      schema.pre("save", function(next) {
        const timestampOption = get2(this, "$__.saveOptions.timestamps");
        if (timestampOption === false) {
          return next();
        }
        const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;
        const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;
        const defaultTimestamp = currentTime != null ? currentTime() : (this.ownerDocument ? this.ownerDocument() : this).constructor.base.now();
        const auto_id = this._id && this._id.auto;
        if (!skipCreatedAt && createdAt && !this.get(createdAt) && this.$__isSelected(createdAt)) {
          this.$set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);
        }
        if (!skipUpdatedAt && updatedAt && (this.isNew || this.isModified())) {
          let ts = defaultTimestamp;
          if (this.isNew) {
            if (createdAt != null) {
              ts = this.$__getValue(createdAt);
            } else if (auto_id) {
              ts = this._id.getTimestamp();
            }
          }
          this.$set(updatedAt, ts);
        }
        next();
      });
      schema.methods.initializeTimestamps = function() {
        const ts = currentTime != null ? currentTime() : this.constructor.base.now();
        if (createdAt && !this.get(createdAt)) {
          this.$set(createdAt, ts);
        }
        if (updatedAt && !this.get(updatedAt)) {
          this.$set(updatedAt, ts);
        }
        return this;
      };
      _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;
      const opts = { query: true, model: false };
      schema.pre("findOneAndReplace", opts, _setTimestampsOnUpdate);
      schema.pre("findOneAndUpdate", opts, _setTimestampsOnUpdate);
      schema.pre("replaceOne", opts, _setTimestampsOnUpdate);
      schema.pre("update", opts, _setTimestampsOnUpdate);
      schema.pre("updateOne", opts, _setTimestampsOnUpdate);
      schema.pre("updateMany", opts, _setTimestampsOnUpdate);
      function _setTimestampsOnUpdate(next) {
        const now = currentTime != null ? currentTime() : this.model.base.now();
        if (this.op === "findOneAndReplace" && this.getUpdate() == null) {
          this.setUpdate({});
        }
        applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(), this.options, this.schema);
        applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
        next();
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/validateRef.js
var require_validateRef = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/validateRef.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_mongooseError();
    var util = require("util");
    module2.exports = validateRef;
    function validateRef(ref, path) {
      if (typeof ref === "string") {
        return;
      }
      if (typeof ref === "function") {
        return;
      }
      throw new MongooseError('Invalid ref at path "' + path + '". Got ' + util.inspect(ref, { depth: 0 }));
    }
  }
});

// node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js
var require_applyQueryMiddleware = __commonJS({
  "node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = applyQueryMiddleware;
    applyQueryMiddleware.middlewareFunctions = [
      "count",
      "countDocuments",
      "deleteMany",
      "deleteOne",
      "distinct",
      "estimatedDocumentCount",
      "find",
      "findOne",
      "findOneAndDelete",
      "findOneAndRemove",
      "findOneAndReplace",
      "findOneAndUpdate",
      "remove",
      "replaceOne",
      "update",
      "updateMany",
      "updateOne",
      "validate"
    ];
    function applyQueryMiddleware(Query, model) {
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1,
        nullResultByDefault: true
      };
      const middleware = model.hooks.filter((hook) => {
        const contexts = _getContexts(hook);
        if (hook.name === "updateOne") {
          return contexts.query == null || !!contexts.query;
        }
        if (hook.name === "deleteOne") {
          return !!contexts.query || Object.keys(contexts).length === 0;
        }
        if (hook.name === "validate" || hook.name === "remove") {
          return !!contexts.query;
        }
        if (hook.query != null || hook.document != null) {
          return !!hook.query;
        }
        return true;
      });
      Query.prototype._execUpdate = middleware.createWrapper("update", Query.prototype._execUpdate, null, kareemOptions);
      Query.prototype.__distinct = middleware.createWrapper("distinct", Query.prototype.__distinct, null, kareemOptions);
      Query.prototype.validate = middleware.createWrapper("validate", Query.prototype.validate, null, kareemOptions);
      applyQueryMiddleware.middlewareFunctions.filter((v) => v !== "update" && v !== "distinct" && v !== "validate").forEach((fn) => {
        Query.prototype[`_${fn}`] = middleware.createWrapper(fn, Query.prototype[`_${fn}`], null, kareemOptions);
      });
    }
    function _getContexts(hook) {
      const ret2 = {};
      if (hook.hasOwnProperty("query")) {
        ret2.query = hook.query;
      }
      if (hook.hasOwnProperty("document")) {
        ret2.document = hook.document;
      }
      return ret2;
    }
  }
});

// node_modules/mongoose/lib/helpers/model/applyHooks.js
var require_applyHooks = __commonJS({
  "node_modules/mongoose/lib/helpers/model/applyHooks.js"(exports2, module2) {
    init_shims();
    "use strict";
    var symbols = require_symbols2();
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = applyHooks;
    applyHooks.middlewareFunctions = [
      "deleteOne",
      "save",
      "validate",
      "remove",
      "updateOne",
      "init"
    ];
    function applyHooks(model, schema, options2) {
      options2 = options2 || {};
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1,
        nullResultByDefault: true,
        contextParameter: true
      };
      const objToDecorate = options2.decorateDoc ? model : model.prototype;
      model.$appliedHooks = true;
      for (const key of Object.keys(schema.paths)) {
        const type = schema.paths[key];
        let childModel = null;
        if (type.$isSingleNested) {
          childModel = type.caster;
        } else if (type.$isMongooseDocumentArray) {
          childModel = type.Constructor;
        } else {
          continue;
        }
        if (childModel.$appliedHooks) {
          continue;
        }
        applyHooks(childModel, type.schema, options2);
        if (childModel.discriminators != null) {
          const keys = Object.keys(childModel.discriminators);
          for (const key2 of keys) {
            applyHooks(childModel.discriminators[key2], childModel.discriminators[key2].schema, options2);
          }
        }
      }
      const middleware = schema.s.hooks.filter((hook) => {
        if (hook.name === "updateOne" || hook.name === "deleteOne") {
          return !!hook["document"];
        }
        if (hook.name === "remove" || hook.name === "init") {
          return hook["document"] == null || !!hook["document"];
        }
        if (hook.query != null || hook.document != null) {
          return hook.document !== false;
        }
        return true;
      }).filter((hook) => {
        if (schema.methods[hook.name]) {
          return !hook.fn[symbols.builtInMiddleware];
        }
        return true;
      });
      model._middleware = middleware;
      objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;
      for (const method of ["save", "validate", "remove", "deleteOne"]) {
        const toWrap = method === "validate" ? "$__originalValidate" : `$__${method}`;
        const wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);
        objToDecorate[`$__${method}`] = wrapped;
      }
      objToDecorate.$__init = middleware.createWrapperSync("init", objToDecorate.$__init, null, kareemOptions);
      const customMethods = Object.keys(schema.methods);
      const customMethodOptions = Object.assign({}, kareemOptions, {
        checkForPromise: true
      });
      for (const method of customMethods) {
        if (!middleware.hasHooks(method)) {
          continue;
        }
        const originalMethod = objToDecorate[method];
        objToDecorate[method] = function() {
          const args = Array.prototype.slice.call(arguments);
          const cb = args.slice(-1).pop();
          const argsWithoutCallback = typeof cb === "function" ? args.slice(0, args.length - 1) : args;
          return promiseOrCallback(cb, (callback) => {
            return this[`$__${method}`].apply(this, argsWithoutCallback.concat([callback]));
          }, model.events);
        };
        objToDecorate[`$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);
      }
    }
  }
});

// node_modules/mongoose/lib/options/SchemaStringOptions.js
var require_SchemaStringOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaStringOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaStringOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaStringOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "match", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "lowercase", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "trim", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "uppercase", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "minLength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "minlength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "maxLength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "maxlength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "populate", opts);
    module2.exports = SchemaStringOptions;
  }
});

// node_modules/mongoose/lib/cast/string.js
var require_string = __commonJS({
  "node_modules/mongoose/lib/cast/string.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CastError = require_cast();
    module2.exports = function castString(value, path) {
      if (value == null) {
        return value;
      }
      if (value._id && typeof value._id === "string") {
        return value._id;
      }
      if (value.toString && value.toString !== Object.prototype.toString && !Array.isArray(value)) {
        return value.toString();
      }
      throw new CastError("string", value, path);
    };
  }
});

// node_modules/mongoose/lib/schema/string.js
var require_string2 = __commonJS({
  "node_modules/mongoose/lib/schema/string.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaType = require_schematype();
    var MongooseError = require_error3();
    var SchemaStringOptions = require_SchemaStringOptions();
    var castString = require_string();
    var utils2 = require_utils6();
    var CastError = SchemaType.CastError;
    function SchemaString(key, options2) {
      this.enumValues = [];
      this.regExp = null;
      SchemaType.call(this, key, options2, "String");
    }
    SchemaString.schemaName = "String";
    SchemaString.defaultOptions = {};
    SchemaString.prototype = Object.create(SchemaType.prototype);
    SchemaString.prototype.constructor = SchemaString;
    Object.defineProperty(SchemaString.prototype, "OptionsConstructor", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: SchemaStringOptions
    });
    SchemaString._cast = castString;
    SchemaString.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaString._defaultCaster = (v) => {
      if (v != null && typeof v !== "string") {
        throw new Error();
      }
      return v;
    };
    SchemaString.get = SchemaType.get;
    SchemaString.set = SchemaType.set;
    SchemaString._checkRequired = (v) => (v instanceof String || typeof v === "string") && v.length;
    SchemaString.checkRequired = SchemaType.checkRequired;
    SchemaString.prototype.enum = function() {
      if (this.enumValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.enumValidator;
        }, this);
        this.enumValidator = false;
      }
      if (arguments[0] === void 0 || arguments[0] === false) {
        return this;
      }
      let values;
      let errorMessage;
      if (utils2.isObject(arguments[0])) {
        if (Array.isArray(arguments[0].values)) {
          values = arguments[0].values;
          errorMessage = arguments[0].message;
        } else {
          values = utils2.object.vals(arguments[0]);
          errorMessage = MongooseError.messages.String.enum;
        }
      } else {
        values = arguments;
        errorMessage = MongooseError.messages.String.enum;
      }
      for (const value of values) {
        if (value !== void 0) {
          this.enumValues.push(this.cast(value));
        }
      }
      const vals = this.enumValues;
      this.enumValidator = function(v) {
        return v === void 0 || ~vals.indexOf(v);
      };
      this.validators.push({
        validator: this.enumValidator,
        message: errorMessage,
        type: "enum",
        enumValues: vals
      });
      return this;
    };
    SchemaString.prototype.lowercase = function(shouldApply) {
      if (arguments.length > 0 && !shouldApply) {
        return this;
      }
      return this.set(function(v, self2) {
        if (typeof v !== "string") {
          v = self2.cast(v);
        }
        if (v) {
          return v.toLowerCase();
        }
        return v;
      });
    };
    SchemaString.prototype.uppercase = function(shouldApply) {
      if (arguments.length > 0 && !shouldApply) {
        return this;
      }
      return this.set(function(v, self2) {
        if (typeof v !== "string") {
          v = self2.cast(v);
        }
        if (v) {
          return v.toUpperCase();
        }
        return v;
      });
    };
    SchemaString.prototype.trim = function(shouldTrim) {
      if (arguments.length > 0 && !shouldTrim) {
        return this;
      }
      return this.set(function(v, self2) {
        if (typeof v !== "string") {
          v = self2.cast(v);
        }
        if (v) {
          return v.trim();
        }
        return v;
      });
    };
    SchemaString.prototype.minlength = function(value, message) {
      if (this.minlengthValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minlengthValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.String.minlength;
        msg = msg.replace(/{MINLENGTH}/, value);
        this.validators.push({
          validator: this.minlengthValidator = function(v) {
            return v === null || v.length >= value;
          },
          message: msg,
          type: "minlength",
          minlength: value
        });
      }
      return this;
    };
    SchemaString.prototype.minLength = SchemaString.prototype.minlength;
    SchemaString.prototype.maxlength = function(value, message) {
      if (this.maxlengthValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxlengthValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.String.maxlength;
        msg = msg.replace(/{MAXLENGTH}/, value);
        this.validators.push({
          validator: this.maxlengthValidator = function(v) {
            return v === null || v.length <= value;
          },
          message: msg,
          type: "maxlength",
          maxlength: value
        });
      }
      return this;
    };
    SchemaString.prototype.maxLength = SchemaString.prototype.maxlength;
    SchemaString.prototype.match = function match(regExp, message) {
      const msg = message || MongooseError.messages.String.match;
      const matchValidator = function(v) {
        if (!regExp) {
          return false;
        }
        regExp.lastIndex = 0;
        const ret2 = v != null && v !== "" ? regExp.test(v) : true;
        return ret2;
      };
      this.validators.push({
        validator: matchValidator,
        message: msg,
        type: "regexp",
        regexp: regExp
      });
      return this;
    };
    SchemaString.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaString.checkRequired();
      return _checkRequired(value);
    };
    SchemaString.prototype.cast = function(value, doc, init2) {
      if (SchemaType._isRef(this, value, doc, init2)) {
        if (typeof value === "string") {
          return value;
        }
        return this._castRef(value, doc, init2);
      }
      let castString2;
      if (typeof this._castFunction === "function") {
        castString2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castString2 = this.constructor.cast();
      } else {
        castString2 = SchemaString.cast();
      }
      try {
        return castString2(value);
      } catch (error2) {
        throw new CastError("string", value, this.path, null, this);
      }
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        return _this.castForQuery(m);
      });
    }
    var $conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $all: handleArray,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle,
      $options: String,
      $regex: handleSingle,
      $not: handleSingle
    });
    Object.defineProperty(SchemaString.prototype, "$conditionalHandlers", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: Object.freeze($conditionalHandlers)
    });
    SchemaString.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional + " with String.");
        }
        return handler.call(this, val);
      }
      val = $conditional;
      if (Object.prototype.toString.call(val) === "[object RegExp]") {
        return val;
      }
      return this._castForQuery(val);
    };
    module2.exports = SchemaString;
  }
});

// node_modules/mongoose/lib/options/SchemaNumberOptions.js
var require_SchemaNumberOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaNumberOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaNumberOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaNumberOptions.prototype, "min", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "max", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "populate", opts);
    module2.exports = SchemaNumberOptions;
  }
});

// node_modules/mongoose/lib/cast/number.js
var require_number = __commonJS({
  "node_modules/mongoose/lib/cast/number.js"(exports2, module2) {
    init_shims();
    "use strict";
    var assert = require("assert");
    module2.exports = function castNumber(val) {
      if (val == null) {
        return val;
      }
      if (val === "") {
        return null;
      }
      if (typeof val === "string" || typeof val === "boolean") {
        val = Number(val);
      }
      assert.ok(!isNaN(val));
      if (val instanceof Number) {
        return val.valueOf();
      }
      if (typeof val === "number") {
        return val;
      }
      if (!Array.isArray(val) && typeof val.valueOf === "function") {
        return Number(val.valueOf());
      }
      if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {
        return Number(val);
      }
      assert.ok(false);
    };
  }
});

// node_modules/mongoose/lib/schema/operators/bitwise.js
var require_bitwise = __commonJS({
  "node_modules/mongoose/lib/schema/operators/bitwise.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CastError = require_cast();
    function handleBitwiseOperator(val) {
      const _this = this;
      if (Array.isArray(val)) {
        return val.map(function(v) {
          return _castNumber(_this.path, v);
        });
      } else if (Buffer.isBuffer(val)) {
        return val;
      }
      return _castNumber(_this.path, val);
    }
    function _castNumber(path, num) {
      const v = Number(num);
      if (isNaN(v)) {
        throw new CastError("number", num, path);
      }
      return v;
    }
    module2.exports = handleBitwiseOperator;
  }
});

// node_modules/mongoose/lib/schema/number.js
var require_number2 = __commonJS({
  "node_modules/mongoose/lib/schema/number.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var SchemaNumberOptions = require_SchemaNumberOptions();
    var SchemaType = require_schematype();
    var castNumber = require_number();
    var handleBitwiseOperator = require_bitwise();
    var utils2 = require_utils6();
    var CastError = SchemaType.CastError;
    function SchemaNumber(key, options2) {
      SchemaType.call(this, key, options2, "Number");
    }
    SchemaNumber.get = SchemaType.get;
    SchemaNumber.set = SchemaType.set;
    SchemaNumber._cast = castNumber;
    SchemaNumber.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaNumber._defaultCaster = (v) => {
      if (typeof v !== "number") {
        throw new Error();
      }
      return v;
    };
    SchemaNumber.schemaName = "Number";
    SchemaNumber.defaultOptions = {};
    SchemaNumber.prototype = Object.create(SchemaType.prototype);
    SchemaNumber.prototype.constructor = SchemaNumber;
    SchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;
    SchemaNumber._checkRequired = (v) => typeof v === "number" || v instanceof Number;
    SchemaNumber.checkRequired = SchemaType.checkRequired;
    SchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaNumber.checkRequired();
      return _checkRequired(value);
    };
    SchemaNumber.prototype.min = function(value, message) {
      if (this.minValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.Number.min;
        msg = msg.replace(/{MIN}/, value);
        this.validators.push({
          validator: this.minValidator = function(v) {
            return v == null || v >= value;
          },
          message: msg,
          type: "min",
          min: value
        });
      }
      return this;
    };
    SchemaNumber.prototype.max = function(value, message) {
      if (this.maxValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.Number.max;
        msg = msg.replace(/{MAX}/, value);
        this.validators.push({
          validator: this.maxValidator = function(v) {
            return v == null || v <= value;
          },
          message: msg,
          type: "max",
          max: value
        });
      }
      return this;
    };
    SchemaNumber.prototype.enum = function(values, message) {
      if (this.enumValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.enumValidator;
        }, this);
      }
      if (!Array.isArray(values)) {
        if (utils2.isObject(values)) {
          values = utils2.object.vals(values);
        } else {
          values = Array.prototype.slice.call(arguments);
        }
        message = MongooseError.messages.Number.enum;
      }
      message = message == null ? MongooseError.messages.Number.enum : message;
      this.enumValidator = (v) => v == null || values.indexOf(v) !== -1;
      this.validators.push({
        validator: this.enumValidator,
        message,
        type: "enum",
        enumValues: values
      });
      return this;
    };
    SchemaNumber.prototype.cast = function(value, doc, init2) {
      if (SchemaType._isRef(this, value, doc, init2)) {
        if (typeof value === "number") {
          return value;
        }
        return this._castRef(value, doc, init2);
      }
      const val = value && typeof value._id !== "undefined" ? value._id : value;
      let castNumber2;
      if (typeof this._castFunction === "function") {
        castNumber2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castNumber2 = this.constructor.cast();
      } else {
        castNumber2 = SchemaNumber.cast();
      }
      try {
        return castNumber2(val);
      } catch (err) {
        throw new CastError("Number", val, this.path, err, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.cast(val)];
      }
      return val.map(function(m) {
        return _this.cast(m);
      });
    }
    SchemaNumber.prototype.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $bitsAllClear: handleBitwiseOperator,
      $bitsAnyClear: handleBitwiseOperator,
      $bitsAllSet: handleBitwiseOperator,
      $bitsAnySet: handleBitwiseOperator,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle,
      $mod: handleArray
    });
    SchemaNumber.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new CastError("number", val, this.path, null, this);
        }
        return handler.call(this, val);
      }
      val = this._castForQuery($conditional);
      return val;
    };
    module2.exports = SchemaNumber;
  }
});

// node_modules/mongoose/lib/schema/boolean.js
var require_boolean2 = __commonJS({
  "node_modules/mongoose/lib/schema/boolean.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CastError = require_cast();
    var SchemaType = require_schematype();
    var castBoolean = require_boolean();
    var utils2 = require_utils6();
    function SchemaBoolean(path, options2) {
      SchemaType.call(this, path, options2, "Boolean");
    }
    SchemaBoolean.schemaName = "Boolean";
    SchemaBoolean.defaultOptions = {};
    SchemaBoolean.prototype = Object.create(SchemaType.prototype);
    SchemaBoolean.prototype.constructor = SchemaBoolean;
    SchemaBoolean._cast = castBoolean;
    SchemaBoolean.set = SchemaType.set;
    SchemaBoolean.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaBoolean._defaultCaster = (v) => {
      if (v != null && typeof v !== "boolean") {
        throw new Error();
      }
      return v;
    };
    SchemaBoolean._checkRequired = (v) => v === true || v === false;
    SchemaBoolean.checkRequired = SchemaType.checkRequired;
    SchemaBoolean.prototype.checkRequired = function(value) {
      return this.constructor._checkRequired(value);
    };
    Object.defineProperty(SchemaBoolean, "convertToTrue", {
      get: () => castBoolean.convertToTrue,
      set: (v) => {
        castBoolean.convertToTrue = v;
      }
    });
    Object.defineProperty(SchemaBoolean, "convertToFalse", {
      get: () => castBoolean.convertToFalse,
      set: (v) => {
        castBoolean.convertToFalse = v;
      }
    });
    SchemaBoolean.prototype.cast = function(value) {
      let castBoolean2;
      if (typeof this._castFunction === "function") {
        castBoolean2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castBoolean2 = this.constructor.cast();
      } else {
        castBoolean2 = SchemaBoolean.cast();
      }
      try {
        return castBoolean2(value);
      } catch (error2) {
        throw new CastError("Boolean", value, this.path, error2, this);
      }
    };
    SchemaBoolean.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {});
    SchemaBoolean.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = SchemaBoolean.$conditionalHandlers[$conditional];
        if (handler) {
          return handler.call(this, val);
        }
        return this._castForQuery(val);
      }
      return this._castForQuery($conditional);
    };
    SchemaBoolean.prototype._castNullish = function _castNullish(v) {
      if (typeof v === "undefined" && this.$$context != null && this.$$context._mongooseOptions != null && this.$$context._mongooseOptions.omitUndefined) {
        return v;
      }
      const castBoolean2 = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBoolean.cast();
      if (castBoolean2 == null) {
        return v;
      }
      if (castBoolean2.convertToFalse instanceof Set && castBoolean2.convertToFalse.has(v)) {
        return false;
      }
      if (castBoolean2.convertToTrue instanceof Set && castBoolean2.convertToTrue.has(v)) {
        return true;
      }
      return v;
    };
    module2.exports = SchemaBoolean;
  }
});

// node_modules/mongoose/lib/options/SchemaArrayOptions.js
var require_SchemaArrayOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaArrayOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaArrayOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaArrayOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaArrayOptions.prototype, "of", opts);
    module2.exports = SchemaArrayOptions;
  }
});

// node_modules/mongoose/lib/helpers/arrayDepth.js
var require_arrayDepth = __commonJS({
  "node_modules/mongoose/lib/helpers/arrayDepth.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = arrayDepth;
    function arrayDepth(arr) {
      if (!Array.isArray(arr)) {
        return { min: 0, max: 0, containsNonArrayItem: true };
      }
      if (arr.length === 0) {
        return { min: 1, max: 1, containsNonArrayItem: false };
      }
      if (arr.length === 1 && !Array.isArray(arr[0])) {
        return { min: 1, max: 1, containsNonArrayItem: false };
      }
      const res = arrayDepth(arr[0]);
      for (let i = 1; i < arr.length; ++i) {
        const _res = arrayDepth(arr[i]);
        if (_res.min < res.min) {
          res.min = _res.min;
        }
        if (_res.max > res.max) {
          res.max = _res.max;
        }
        res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;
      }
      res.min = res.min + 1;
      res.max = res.max + 1;
      return res;
    }
  }
});

// node_modules/mongoose/lib/schema/operators/text.js
var require_text = __commonJS({
  "node_modules/mongoose/lib/schema/operators/text.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CastError = require_cast();
    var castBoolean = require_boolean();
    var castString = require_string();
    module2.exports = function(val, path) {
      if (val == null || typeof val !== "object") {
        throw new CastError("$text", val, path);
      }
      if (val.$search != null) {
        val.$search = castString(val.$search, path + ".$search");
      }
      if (val.$language != null) {
        val.$language = castString(val.$language, path + ".$language");
      }
      if (val.$caseSensitive != null) {
        val.$caseSensitive = castBoolean(val.$caseSensitive, path + ".$castSensitive");
      }
      if (val.$diacriticSensitive != null) {
        val.$diacriticSensitive = castBoolean(val.$diacriticSensitive, path + ".$diacriticSensitive");
      }
      return val;
    };
  }
});

// node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js
var require_areDiscriminatorValuesEqual = __commonJS({
  "node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ObjectId2 = require_objectid3();
    module2.exports = function areDiscriminatorValuesEqual(a, b) {
      if (typeof a === "string" && typeof b === "string") {
        return a === b;
      }
      if (typeof a === "number" && typeof b === "number") {
        return a === b;
      }
      if (a instanceof ObjectId2 && b instanceof ObjectId2) {
        return a.toString() === b.toString();
      }
      return false;
    };
  }
});

// node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js
var require_getSchemaDiscriminatorByValue = __commonJS({
  "node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js"(exports2, module2) {
    init_shims();
    "use strict";
    var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
    module2.exports = function getSchemaDiscriminatorByValue(schema, value) {
      if (schema == null || schema.discriminators == null) {
        return null;
      }
      for (const key of Object.keys(schema.discriminators)) {
        const discriminatorSchema = schema.discriminators[key];
        if (discriminatorSchema.discriminatorMapping == null) {
          continue;
        }
        if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {
          return discriminatorSchema;
        }
      }
      return null;
    };
  }
});

// node_modules/mongoose/lib/helpers/query/isOperator.js
var require_isOperator = __commonJS({
  "node_modules/mongoose/lib/helpers/query/isOperator.js"(exports2, module2) {
    init_shims();
    "use strict";
    var specialKeys = new Set([
      "$ref",
      "$id",
      "$db"
    ]);
    module2.exports = function isOperator(path) {
      return path.startsWith("$") && !specialKeys.has(path);
    };
  }
});

// node_modules/mongoose/lib/cast.js
var require_cast2 = __commonJS({
  "node_modules/mongoose/lib/cast.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CastError = require_cast();
    var StrictModeError = require_strict();
    var Types = require_schema();
    var castTextSearch = require_text();
    var get2 = require_get();
    var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
    var isOperator = require_isOperator();
    var util = require("util");
    var isObject2 = require_isObject();
    var isMongooseObject = require_isMongooseObject();
    var ALLOWED_GEOWITHIN_GEOJSON_TYPES = ["Polygon", "MultiPolygon"];
    module2.exports = function cast(schema, obj, options2, context) {
      if (Array.isArray(obj)) {
        throw new Error("Query filter must be an object, got an array ", util.inspect(obj));
      }
      if (obj == null) {
        return obj;
      }
      if (obj.hasOwnProperty("_bsontype") && obj._bsontype !== "ObjectID") {
        delete obj._bsontype;
      }
      if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {
        schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;
      }
      const paths = Object.keys(obj);
      let i = paths.length;
      let _keys;
      let any$conditionals;
      let schematype;
      let nested;
      let path;
      let type;
      let val;
      options2 = options2 || {};
      while (i--) {
        path = paths[i];
        val = obj[path];
        if (path === "$or" || path === "$nor" || path === "$and") {
          if (!Array.isArray(val)) {
            throw new CastError("Array", val, path);
          }
          for (let k = 0; k < val.length; ++k) {
            if (val[k] == null || typeof val[k] !== "object") {
              throw new CastError("Object", val[k], path + "." + k);
            }
            val[k] = cast(schema, val[k], options2, context);
          }
        } else if (path === "$where") {
          type = typeof val;
          if (type !== "string" && type !== "function") {
            throw new Error("Must have a string or function for $where");
          }
          if (type === "function") {
            obj[path] = val.toString();
          }
          continue;
        } else if (path === "$elemMatch") {
          val = cast(schema, val, options2, context);
        } else if (path === "$text") {
          val = castTextSearch(val, path);
        } else {
          if (!schema) {
            continue;
          }
          schematype = schema.path(path);
          if (!schematype) {
            const split = path.split(".");
            let j = split.length;
            while (j--) {
              const pathFirstHalf = split.slice(0, j).join(".");
              const pathLastHalf = split.slice(j).join(".");
              const _schematype = schema.path(pathFirstHalf);
              const discriminatorKey = get2(_schematype, "schema.options.discriminatorKey");
              if (_schematype != null && get2(_schematype, "schema.discriminators") != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {
                const discriminatorVal = get2(obj, pathFirstHalf + "." + discriminatorKey);
                if (discriminatorVal != null) {
                  schematype = _schematype.schema.discriminators[discriminatorVal].path(pathLastHalf);
                }
              }
            }
          }
          if (!schematype) {
            const split = path.split(".");
            let j = split.length;
            let pathFirstHalf;
            let pathLastHalf;
            let remainingConds;
            while (j--) {
              pathFirstHalf = split.slice(0, j).join(".");
              schematype = schema.path(pathFirstHalf);
              if (schematype) {
                break;
              }
            }
            if (schematype) {
              if (schematype.caster && schematype.caster.schema) {
                remainingConds = {};
                pathLastHalf = split.slice(j).join(".");
                remainingConds[pathLastHalf] = val;
                obj[path] = cast(schematype.caster.schema, remainingConds, options2, context)[pathLastHalf];
              } else {
                obj[path] = val;
              }
              continue;
            }
            if (isObject2(val)) {
              let geo = "";
              if (val.$near) {
                geo = "$near";
              } else if (val.$nearSphere) {
                geo = "$nearSphere";
              } else if (val.$within) {
                geo = "$within";
              } else if (val.$geoIntersects) {
                geo = "$geoIntersects";
              } else if (val.$geoWithin) {
                geo = "$geoWithin";
              }
              if (geo) {
                const numbertype = new Types.Number("__QueryCasting__");
                let value = val[geo];
                if (val.$maxDistance != null) {
                  val.$maxDistance = numbertype.castForQueryWrapper({
                    val: val.$maxDistance,
                    context
                  });
                }
                if (val.$minDistance != null) {
                  val.$minDistance = numbertype.castForQueryWrapper({
                    val: val.$minDistance,
                    context
                  });
                }
                if (geo === "$within") {
                  const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;
                  if (!withinType) {
                    throw new Error("Bad $within parameter: " + JSON.stringify(val));
                  }
                  value = withinType;
                } else if (geo === "$near" && typeof value.type === "string" && Array.isArray(value.coordinates)) {
                  value = value.coordinates;
                } else if ((geo === "$near" || geo === "$nearSphere" || geo === "$geoIntersects") && value.$geometry && typeof value.$geometry.type === "string" && Array.isArray(value.$geometry.coordinates)) {
                  if (value.$maxDistance != null) {
                    value.$maxDistance = numbertype.castForQueryWrapper({
                      val: value.$maxDistance,
                      context
                    });
                  }
                  if (value.$minDistance != null) {
                    value.$minDistance = numbertype.castForQueryWrapper({
                      val: value.$minDistance,
                      context
                    });
                  }
                  if (isMongooseObject(value.$geometry)) {
                    value.$geometry = value.$geometry.toObject({
                      transform: false,
                      virtuals: false
                    });
                  }
                  value = value.$geometry.coordinates;
                } else if (geo === "$geoWithin") {
                  if (value.$geometry) {
                    if (isMongooseObject(value.$geometry)) {
                      value.$geometry = value.$geometry.toObject({ virtuals: false });
                    }
                    const geoWithinType = value.$geometry.type;
                    if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
                      throw new Error('Invalid geoJSON type for $geoWithin "' + geoWithinType + '", must be "Polygon" or "MultiPolygon"');
                    }
                    value = value.$geometry.coordinates;
                  } else {
                    value = value.$box || value.$polygon || value.$center || value.$centerSphere;
                    if (isMongooseObject(value)) {
                      value = value.toObject({ virtuals: false });
                    }
                  }
                }
                _cast(value, numbertype, context);
                continue;
              }
            }
            if (schema.nested[path]) {
              continue;
            }
            if (options2.upsert && options2.strict) {
              if (options2.strict === "throw") {
                throw new StrictModeError(path);
              }
              throw new StrictModeError(path, 'Path "' + path + '" is not in schema, strict mode is `true`, and upsert is `true`.');
            } else if (options2.strictQuery === "throw") {
              throw new StrictModeError(path, 'Path "' + path + `" is not in schema and strictQuery is 'throw'.`);
            } else if (options2.strictQuery) {
              delete obj[path];
            }
          } else if (val == null) {
            continue;
          } else if (val.constructor.name === "Object") {
            any$conditionals = Object.keys(val).some(isOperator);
            if (!any$conditionals) {
              obj[path] = schematype.castForQueryWrapper({
                val,
                context
              });
            } else {
              const ks = Object.keys(val);
              let $cond;
              let k = ks.length;
              while (k--) {
                $cond = ks[k];
                nested = val[$cond];
                if ($cond === "$not") {
                  if (nested && schematype && !schematype.caster) {
                    _keys = Object.keys(nested);
                    if (_keys.length && isOperator(_keys[0])) {
                      for (const key in nested) {
                        nested[key] = schematype.castForQueryWrapper({
                          $conditional: key,
                          val: nested[key],
                          context
                        });
                      }
                    } else {
                      val[$cond] = schematype.castForQueryWrapper({
                        $conditional: $cond,
                        val: nested,
                        context
                      });
                    }
                    continue;
                  }
                  cast(schematype.caster ? schematype.caster.schema : schema, nested, options2, context);
                } else {
                  val[$cond] = schematype.castForQueryWrapper({
                    $conditional: $cond,
                    val: nested,
                    context
                  });
                }
              }
            }
          } else if (Array.isArray(val) && ["Buffer", "Array"].indexOf(schematype.instance) === -1) {
            const casted = [];
            const valuesArray = val;
            for (const _val of valuesArray) {
              casted.push(schematype.castForQueryWrapper({
                val: _val,
                context
              }));
            }
            obj[path] = { $in: casted };
          } else {
            obj[path] = schematype.castForQueryWrapper({
              val,
              context
            });
          }
        }
      }
      return obj;
    };
    function _cast(val, numbertype, context) {
      if (Array.isArray(val)) {
        val.forEach(function(item, i) {
          if (Array.isArray(item) || isObject2(item)) {
            return _cast(item, numbertype, context);
          }
          val[i] = numbertype.castForQueryWrapper({ val: item, context });
        });
      } else {
        const nearKeys = Object.keys(val);
        let nearLen = nearKeys.length;
        while (nearLen--) {
          const nkey = nearKeys[nearLen];
          const item = val[nkey];
          if (Array.isArray(item) || isObject2(item)) {
            _cast(item, numbertype, context);
            val[nkey] = item;
          } else {
            val[nkey] = numbertype.castForQuery({ val: item, context });
          }
        }
      }
    }
  }
});

// node_modules/mongoose/lib/schema/operators/helpers.js
var require_helpers = __commonJS({
  "node_modules/mongoose/lib/schema/operators/helpers.js"(exports2) {
    init_shims();
    "use strict";
    var SchemaNumber = require_number2();
    exports2.castToNumber = castToNumber;
    exports2.castArraysOfNumbers = castArraysOfNumbers;
    function castToNumber(val) {
      return SchemaNumber.cast()(val);
    }
    function castArraysOfNumbers(arr, self2) {
      arr.forEach(function(v, i) {
        if (Array.isArray(v)) {
          castArraysOfNumbers(v, self2);
        } else {
          arr[i] = castToNumber.call(self2, v);
        }
      });
    }
  }
});

// node_modules/mongoose/lib/schema/operators/geospatial.js
var require_geospatial = __commonJS({
  "node_modules/mongoose/lib/schema/operators/geospatial.js"(exports2) {
    init_shims();
    "use strict";
    var castArraysOfNumbers = require_helpers().castArraysOfNumbers;
    var castToNumber = require_helpers().castToNumber;
    exports2.cast$geoIntersects = cast$geoIntersects;
    exports2.cast$near = cast$near;
    exports2.cast$within = cast$within;
    function cast$near(val) {
      const SchemaArray = require_array2();
      if (Array.isArray(val)) {
        castArraysOfNumbers(val, this);
        return val;
      }
      _castMinMaxDistance(this, val);
      if (val && val.$geometry) {
        return cast$geometry(val, this);
      }
      if (!Array.isArray(val)) {
        throw new TypeError("$near must be either an array or an object with a $geometry property");
      }
      return SchemaArray.prototype.castForQuery.call(this, val);
    }
    function cast$geometry(val, self2) {
      switch (val.$geometry.type) {
        case "Polygon":
        case "LineString":
        case "Point":
          castArraysOfNumbers(val.$geometry.coordinates, self2);
          break;
        default:
          break;
      }
      _castMinMaxDistance(self2, val);
      return val;
    }
    function cast$within(val) {
      _castMinMaxDistance(this, val);
      if (val.$box || val.$polygon) {
        const type = val.$box ? "$box" : "$polygon";
        val[type].forEach((arr) => {
          if (!Array.isArray(arr)) {
            const msg = "Invalid $within $box argument. Expected an array, received " + arr;
            throw new TypeError(msg);
          }
          arr.forEach((v, i) => {
            arr[i] = castToNumber.call(this, v);
          });
        });
      } else if (val.$center || val.$centerSphere) {
        const type = val.$center ? "$center" : "$centerSphere";
        val[type].forEach((item, i) => {
          if (Array.isArray(item)) {
            item.forEach((v, j) => {
              item[j] = castToNumber.call(this, v);
            });
          } else {
            val[type][i] = castToNumber.call(this, item);
          }
        });
      } else if (val.$geometry) {
        cast$geometry(val, this);
      }
      return val;
    }
    function cast$geoIntersects(val) {
      const geo = val.$geometry;
      if (!geo) {
        return;
      }
      cast$geometry(val, this);
      return val;
    }
    function _castMinMaxDistance(self2, val) {
      if (val.$maxDistance) {
        val.$maxDistance = castToNumber.call(self2, val.$maxDistance);
      }
      if (val.$minDistance) {
        val.$minDistance = castToNumber.call(self2, val.$minDistance);
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js
var require_getDiscriminatorByValue = __commonJS({
  "node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js"(exports2, module2) {
    init_shims();
    "use strict";
    var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
    module2.exports = function getDiscriminatorByValue(discriminators, value) {
      if (discriminators == null) {
        return null;
      }
      for (const name of Object.keys(discriminators)) {
        const it = discriminators[name];
        if (it.schema && it.schema.discriminatorMapping && areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)) {
          return it;
        }
      }
      return null;
    };
  }
});

// node_modules/mongoose/lib/browserDocument.js
var require_browserDocument = __commonJS({
  "node_modules/mongoose/lib/browserDocument.js"(exports2, module2) {
    init_shims();
    "use strict";
    var NodeJSDocument = require_document();
    var EventEmitter = require("events").EventEmitter;
    var MongooseError = require_error3();
    var Schema = require_schema2();
    var ObjectId2 = require_objectid3();
    var ValidationError = MongooseError.ValidationError;
    var applyHooks = require_applyHooks();
    var isObject2 = require_isObject();
    function Document(obj, schema, fields, skipId, skipInit) {
      if (!(this instanceof Document)) {
        return new Document(obj, schema, fields, skipId, skipInit);
      }
      if (isObject2(schema) && !schema.instanceOfSchema) {
        schema = new Schema(schema);
      }
      schema = this.schema || schema;
      if (!this.schema && schema.options._id) {
        obj = obj || {};
        if (obj._id === void 0) {
          obj._id = new ObjectId2();
        }
      }
      if (!schema) {
        throw new MongooseError.MissingSchemaError();
      }
      this.$__setSchema(schema);
      NodeJSDocument.call(this, obj, fields, skipId, skipInit);
      applyHooks(this, schema, { decorateDoc: true });
      for (const m in schema.methods) {
        this[m] = schema.methods[m];
      }
      for (const s2 in schema.statics) {
        this[s2] = schema.statics[s2];
      }
    }
    Document.prototype = Object.create(NodeJSDocument.prototype);
    Document.prototype.constructor = Document;
    Document.events = new EventEmitter();
    Document.$emitter = new EventEmitter();
    [
      "on",
      "once",
      "emit",
      "listeners",
      "removeListener",
      "setMaxListeners",
      "removeAllListeners",
      "addListener"
    ].forEach(function(emitterFn) {
      Document[emitterFn] = function() {
        return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
      };
    });
    Document.ValidationError = ValidationError;
    module2.exports = exports2 = Document;
  }
});

// node_modules/mongoose/lib/document_provider.js
var require_document_provider = __commonJS({
  "node_modules/mongoose/lib/document_provider.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Document = require_document();
    var BrowserDocument = require_browserDocument();
    var isBrowser = false;
    module2.exports = function() {
      if (isBrowser) {
        return BrowserDocument;
      }
      return Document;
    };
    module2.exports.setBrowser = function(flag) {
      isBrowser = flag;
    };
  }
});

// node_modules/mongoose/lib/options.js
var require_options = __commonJS({
  "node_modules/mongoose/lib/options.js"(exports2) {
    init_shims();
    "use strict";
    exports2.internalToObjectOptions = {
      transform: false,
      virtuals: false,
      getters: false,
      _skipDepopulateTopLevel: true,
      depopulate: true,
      flattenDecimals: false,
      useProjection: false
    };
  }
});

// node_modules/mongoose/lib/types/embedded.js
var require_embedded = __commonJS({
  "node_modules/mongoose/lib/types/embedded.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Document = require_document_provider()();
    var EventEmitter = require("events").EventEmitter;
    var ValidationError = require_validation();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var get2 = require_get();
    var promiseOrCallback = require_promiseOrCallback();
    var util = require("util");
    var documentArrayParent = require_symbols().documentArrayParent;
    var validatorErrorSymbol = require_symbols().validatorErrorSymbol;
    function EmbeddedDocument(obj, parentArr, skipId, fields, index2) {
      const options2 = {};
      if (parentArr != null && parentArr.isMongooseDocumentArray) {
        this.__parentArray = parentArr;
        this[documentArrayParent] = parentArr.$parent();
      } else {
        this.__parentArray = void 0;
        this[documentArrayParent] = void 0;
      }
      this.$setIndex(index2);
      this.$isDocumentArrayElement = true;
      if (this[documentArrayParent] != null) {
        options2.defaults = this[documentArrayParent].$__.$options.defaults;
      }
      Document.call(this, obj, fields, skipId, options2);
      const _this = this;
      this.on("isNew", function(val) {
        _this.isNew = val;
      });
      _this.on("save", function() {
        _this.constructor.emit("save", _this);
      });
    }
    EmbeddedDocument.prototype = Object.create(Document.prototype);
    EmbeddedDocument.prototype.constructor = EmbeddedDocument;
    for (const i in EventEmitter.prototype) {
      EmbeddedDocument[i] = EventEmitter.prototype[i];
    }
    EmbeddedDocument.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    EmbeddedDocument.prototype.$setIndex = function(index2) {
      this.__index = index2;
      if (get2(this, "$__.validationError", null) != null) {
        const keys = Object.keys(this.$__.validationError.errors);
        for (const key of keys) {
          this.invalidate(key, this.$__.validationError.errors[key]);
        }
      }
    };
    EmbeddedDocument.prototype.markModified = function(path) {
      this.$__.activePaths.modify(path);
      if (!this.__parentArray) {
        return;
      }
      const pathToCheck = this.__parentArray.$path() + ".0." + path;
      if (this.isNew && this.ownerDocument().$__isSelected(pathToCheck)) {
        this.__parentArray._markModified();
      } else {
        this.__parentArray._markModified(this, path);
      }
    };
    EmbeddedDocument.prototype.populate = function() {
      throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.arr[0].populate("path")`, use `doc.populate("arr.0.path")`');
    };
    EmbeddedDocument.prototype.save = function(options2, fn) {
      if (typeof options2 === "function") {
        fn = options2;
        options2 = {};
      }
      options2 = options2 || {};
      if (!options2.suppressWarning) {
        console.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app.");
      }
      return promiseOrCallback(fn, (cb) => {
        this.$__save(cb);
      });
    };
    EmbeddedDocument.prototype.$__save = function(fn) {
      return immediate(() => fn(null, this));
    };
    function registerRemoveListener(sub) {
      let owner = sub.ownerDocument();
      function emitRemove() {
        owner.removeListener("save", emitRemove);
        owner.removeListener("remove", emitRemove);
        sub.emit("remove", sub);
        sub.constructor.emit("remove", sub);
        owner = sub = null;
      }
      owner.on("save", emitRemove);
      owner.on("remove", emitRemove);
    }
    EmbeddedDocument.prototype.$__remove = function(cb) {
      if (cb == null) {
        return;
      }
      return cb(null, this);
    };
    EmbeddedDocument.prototype.remove = function(options2, fn) {
      if (typeof options2 === "function" && !fn) {
        fn = options2;
        options2 = void 0;
      }
      if (!this.__parentArray || options2 && options2.noop) {
        this.$__remove(fn);
        return this;
      }
      let _id;
      if (!this.willRemove) {
        _id = this._doc._id;
        if (!_id) {
          throw new Error("For your own good, Mongoose does not know how to remove an EmbeddedDocument that has no _id");
        }
        this.__parentArray.pull({ _id });
        this.willRemove = true;
        registerRemoveListener(this);
      }
      this.$__remove(fn);
      return this;
    };
    EmbeddedDocument.prototype.update = function() {
      throw new Error("The #update method is not available on EmbeddedDocuments");
    };
    EmbeddedDocument.prototype.inspect = function() {
      return this.toObject({
        transform: false,
        virtuals: false,
        flattenDecimals: false
      });
    };
    if (util.inspect.custom) {
      EmbeddedDocument.prototype[util.inspect.custom] = EmbeddedDocument.prototype.inspect;
    }
    EmbeddedDocument.prototype.invalidate = function(path, err, val) {
      Document.prototype.invalidate.call(this, path, err, val);
      if (!this[documentArrayParent] || this.__index == null) {
        if (err[validatorErrorSymbol] || err instanceof ValidationError) {
          return this.ownerDocument().$__.validationError;
        }
        throw err;
      }
      const index2 = this.__index;
      const parentPath = this.__parentArray.$path();
      const fullPath = [parentPath, index2, path].join(".");
      this[documentArrayParent].invalidate(fullPath, err, val);
      return this.ownerDocument().$__.validationError;
    };
    EmbeddedDocument.prototype.$markValid = function(path) {
      if (!this[documentArrayParent]) {
        return;
      }
      const index2 = this.__index;
      if (typeof index2 !== "undefined") {
        const parentPath = this.__parentArray.$path();
        const fullPath = [parentPath, index2, path].join(".");
        this[documentArrayParent].$markValid(fullPath);
      }
    };
    EmbeddedDocument.prototype.$ignore = function(path) {
      Document.prototype.$ignore.call(this, path);
      if (!this[documentArrayParent]) {
        return;
      }
      const index2 = this.__index;
      if (typeof index2 !== "undefined") {
        const parentPath = this.__parentArray.$path();
        const fullPath = [parentPath, index2, path].join(".");
        this[documentArrayParent].$ignore(fullPath);
      }
    };
    EmbeddedDocument.prototype.$isValid = function(path) {
      const index2 = this.__index;
      if (typeof index2 !== "undefined" && this[documentArrayParent]) {
        return !this[documentArrayParent].$__.validationError || !this[documentArrayParent].$__.validationError.errors[this.$__fullPath(path)];
      }
      return true;
    };
    EmbeddedDocument.prototype.ownerDocument = function() {
      if (this.$__.ownerDocument) {
        return this.$__.ownerDocument;
      }
      let parent = this[documentArrayParent];
      if (!parent) {
        return this;
      }
      while (parent[documentArrayParent] || parent.$__parent) {
        parent = parent[documentArrayParent] || parent.$__parent;
      }
      this.$__.ownerDocument = parent;
      return this.$__.ownerDocument;
    };
    EmbeddedDocument.prototype.$__fullPath = function(path) {
      if (!this.$__.fullPath) {
        let parent = this;
        if (!parent[documentArrayParent]) {
          return path;
        }
        const paths = [];
        while (parent[documentArrayParent] || parent.$__parent) {
          if (parent[documentArrayParent]) {
            paths.unshift(parent.__parentArray.$path());
          } else {
            paths.unshift(parent.$basePath);
          }
          parent = parent[documentArrayParent] || parent.$__parent;
        }
        this.$__.fullPath = paths.join(".");
        if (!this.$__.ownerDocument) {
          this.$__.ownerDocument = parent;
        }
      }
      return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
    };
    EmbeddedDocument.prototype.parent = function() {
      return this[documentArrayParent];
    };
    EmbeddedDocument.prototype.$parent = EmbeddedDocument.prototype.parent;
    EmbeddedDocument.prototype.parentArray = function() {
      return this.__parentArray;
    };
    module2.exports = EmbeddedDocument;
  }
});

// node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js
var require_cleanModifiedSubpaths = __commonJS({
  "node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function cleanModifiedSubpaths(doc, path, options2) {
      options2 = options2 || {};
      const skipDocArrays = options2.skipDocArrays;
      let deleted = 0;
      if (!doc) {
        return deleted;
      }
      for (const modifiedPath of Object.keys(doc.$__.activePaths.states.modify)) {
        if (skipDocArrays) {
          const schemaType = doc.$__schema.path(modifiedPath);
          if (schemaType && schemaType.$isMongooseDocumentArray) {
            continue;
          }
        }
        if (modifiedPath.startsWith(path + ".")) {
          delete doc.$__.activePaths.states.modify[modifiedPath];
          ++deleted;
        }
      }
      return deleted;
    };
  }
});

// node_modules/mongoose/lib/types/core_array.js
var require_core_array = __commonJS({
  "node_modules/mongoose/lib/types/core_array.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Document = require_document();
    var EmbeddedDocument = require_embedded();
    var MongooseError = require_mongooseError();
    var ObjectId2 = require_objectid3();
    var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
    var get2 = require_get();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var utils2 = require_utils6();
    var util = require("util");
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var slicedSymbol = Symbol("mongoose#Array#sliced");
    var _basePush = Array.prototype.push;
    var validatorsSymbol = Symbol("mongoose#MongooseCoreArray#validators");
    var CoreMongooseArray = class extends Array {
      get isMongooseArray() {
        return true;
      }
      get validators() {
        return this[validatorsSymbol];
      }
      set validators(v) {
        this[validatorsSymbol] = v;
      }
      $__getAtomics() {
        const ret2 = [];
        const keys = Object.keys(this[arrayAtomicsSymbol] || {});
        let i = keys.length;
        const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });
        if (i === 0) {
          ret2[0] = ["$set", this.toObject(opts)];
          return ret2;
        }
        while (i--) {
          const op = keys[i];
          let val = this[arrayAtomicsSymbol][op];
          if (utils2.isMongooseObject(val)) {
            val = val.toObject(opts);
          } else if (Array.isArray(val)) {
            val = this.toObject.call(val, opts);
          } else if (val != null && Array.isArray(val.$each)) {
            val.$each = this.toObject.call(val.$each, opts);
          } else if (val != null && typeof val.valueOf === "function") {
            val = val.valueOf();
          }
          if (op === "$addToSet") {
            val = { $each: val };
          }
          ret2.push([op, val]);
        }
        return ret2;
      }
      $atomics() {
        return this[arrayAtomicsSymbol] || {};
      }
      $parent() {
        return this[arrayParentSymbol];
      }
      $path() {
        return this[arrayPathSymbol];
      }
      $shift() {
        this._registerAtomic("$pop", -1);
        this._markModified();
        if (this._shifted) {
          return;
        }
        this._shifted = true;
        return [].shift.call(this);
      }
      $pop() {
        this._registerAtomic("$pop", 1);
        this._markModified();
        if (this._popped) {
          return;
        }
        this._popped = true;
        return [].pop.call(this);
      }
      $schema() {
        return this[arraySchemaSymbol];
      }
      _cast(value) {
        let populated = false;
        let Model;
        if (this[arrayParentSymbol]) {
          populated = this[arrayParentSymbol].populated(this[arrayPathSymbol], true);
        }
        if (populated && value !== null && value !== void 0) {
          Model = populated.options[populateModelSymbol];
          if (Buffer.isBuffer(value) || value instanceof ObjectId2 || !utils2.isObject(value)) {
            value = { _id: value };
          }
          const isDisc = value.$__schema && value.$__schema.discriminatorMapping && value.$__schema.discriminatorMapping.key !== void 0;
          if (!isDisc) {
            value = new Model(value);
          }
          return this[arraySchemaSymbol].caster.applySetters(value, this[arrayParentSymbol], true);
        }
        return this[arraySchemaSymbol].caster.applySetters(value, this[arrayParentSymbol], false);
      }
      _mapCast(val, index2) {
        return this._cast(val, this.length + index2);
      }
      _markModified(elem) {
        const parent = this[arrayParentSymbol];
        let dirtyPath;
        if (parent) {
          dirtyPath = this[arrayPathSymbol];
          if (arguments.length) {
            dirtyPath = dirtyPath + "." + elem;
          }
          if (dirtyPath != null && dirtyPath.endsWith(".$")) {
            return this;
          }
          parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);
        }
        return this;
      }
      _registerAtomic(op, val) {
        if (this[slicedSymbol]) {
          return;
        }
        if (op === "$set") {
          this[arrayAtomicsSymbol] = { $set: val };
          cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);
          this._markModified();
          return this;
        }
        this[arrayAtomicsSymbol] || (this[arrayAtomicsSymbol] = {});
        const atomics = this[arrayAtomicsSymbol];
        if (op === "$pop" && !("$pop" in atomics)) {
          const _this = this;
          this[arrayParentSymbol].once("save", function() {
            _this._popped = _this._shifted = null;
          });
        }
        if (this[arrayAtomicsSymbol].$set || Object.keys(atomics).length && !(op in atomics)) {
          this[arrayAtomicsSymbol] = { $set: this };
          return this;
        }
        let selector;
        if (op === "$pullAll" || op === "$addToSet") {
          atomics[op] || (atomics[op] = []);
          atomics[op] = atomics[op].concat(val);
        } else if (op === "$pullDocs") {
          const pullOp = atomics["$pull"] || (atomics["$pull"] = {});
          if (val[0] instanceof EmbeddedDocument) {
            selector = pullOp["$or"] || (pullOp["$or"] = []);
            Array.prototype.push.apply(selector, val.map(function(v) {
              return v.toObject({ transform: false, virtuals: false });
            }));
          } else {
            selector = pullOp["_id"] || (pullOp["_id"] = { $in: [] });
            selector["$in"] = selector["$in"].concat(val);
          }
        } else if (op === "$push") {
          atomics.$push = atomics.$push || { $each: [] };
          if (val != null && utils2.hasUserDefinedProperty(val, "$each")) {
            atomics.$push = val;
          } else {
            atomics.$push.$each = atomics.$push.$each.concat(val);
          }
        } else {
          atomics[op] = val;
        }
        return this;
      }
      addToSet() {
        _checkManualPopulation(this, arguments);
        let values = [].map.call(arguments, this._mapCast, this);
        values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
        const added = [];
        let type = "";
        if (values[0] instanceof EmbeddedDocument) {
          type = "doc";
        } else if (values[0] instanceof Date) {
          type = "date";
        }
        values.forEach(function(v) {
          let found;
          const val = +v;
          switch (type) {
            case "doc":
              found = this.some(function(doc) {
                return doc.equals(v);
              });
              break;
            case "date":
              found = this.some(function(d2) {
                return +d2 === val;
              });
              break;
            default:
              found = ~this.indexOf(v);
          }
          if (!found) {
            [].push.call(this, v);
            this._registerAtomic("$addToSet", v);
            this._markModified();
            [].push.call(added, v);
          }
        }, this);
        return added;
      }
      hasAtomics() {
        if (!utils2.isPOJO(this[arrayAtomicsSymbol])) {
          return 0;
        }
        return Object.keys(this[arrayAtomicsSymbol]).length;
      }
      includes(obj, fromIndex) {
        const ret2 = this.indexOf(obj, fromIndex);
        return ret2 !== -1;
      }
      indexOf(obj, fromIndex) {
        if (obj instanceof ObjectId2) {
          obj = obj.toString();
        }
        fromIndex = fromIndex == null ? 0 : fromIndex;
        const len = this.length;
        for (let i = fromIndex; i < len; ++i) {
          if (obj == this[i]) {
            return i;
          }
        }
        return -1;
      }
      inspect() {
        return JSON.stringify(this);
      }
      nonAtomicPush() {
        const values = [].map.call(arguments, this._mapCast, this);
        const ret2 = [].push.apply(this, values);
        this._registerAtomic("$set", this);
        this._markModified();
        return ret2;
      }
      pop() {
        const ret2 = [].pop.call(this);
        this._registerAtomic("$set", this);
        this._markModified();
        return ret2;
      }
      pull() {
        const values = [].map.call(arguments, this._cast, this);
        const cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);
        let i = cur.length;
        let mem;
        while (i--) {
          mem = cur[i];
          if (mem instanceof Document) {
            const some = values.some(function(v) {
              return mem.equals(v);
            });
            if (some) {
              [].splice.call(cur, i, 1);
            }
          } else if (~cur.indexOf.call(values, mem)) {
            [].splice.call(cur, i, 1);
          }
        }
        if (values[0] instanceof EmbeddedDocument) {
          this._registerAtomic("$pullDocs", values.map(function(v) {
            return v.$__getValue("_id") || v;
          }));
        } else {
          this._registerAtomic("$pullAll", values);
        }
        this._markModified();
        if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {
          this._registerAtomic("$set", this);
        }
        return this;
      }
      push() {
        let values = arguments;
        let atomic = values;
        const isOverwrite = values[0] != null && utils2.hasUserDefinedProperty(values[0], "$each");
        if (isOverwrite) {
          atomic = values[0];
          values = values[0].$each;
        }
        if (this[arraySchemaSymbol] == null) {
          return _basePush.apply(this, values);
        }
        _checkManualPopulation(this, values);
        const parent = this[arrayParentSymbol];
        values = [].map.call(values, this._mapCast, this);
        values = this[arraySchemaSymbol].applySetters(values, parent, void 0, void 0, { skipDocumentArrayCast: true });
        let ret2;
        const atomics = this[arrayAtomicsSymbol];
        if (isOverwrite) {
          atomic.$each = values;
          if (get2(atomics, "$push.$each.length", 0) > 0 && atomics.$push.$position != atomics.$position) {
            throw new MongooseError("Cannot call `Array#push()` multiple times with different `$position`");
          }
          if (atomic.$position != null) {
            [].splice.apply(this, [atomic.$position, 0].concat(values));
            ret2 = this.length;
          } else {
            ret2 = [].push.apply(this, values);
          }
        } else {
          if (get2(atomics, "$push.$each.length", 0) > 0 && atomics.$push.$position != null) {
            throw new MongooseError("Cannot call `Array#push()` multiple times with different `$position`");
          }
          atomic = values;
          ret2 = [].push.apply(this, values);
        }
        this._registerAtomic("$push", atomic);
        this._markModified();
        return ret2;
      }
      remove() {
        return this.pull.apply(this, arguments);
      }
      set(i, val) {
        const value = this._cast(val, i);
        this[i] = value;
        this._markModified(i);
        return this;
      }
      shift() {
        const ret2 = [].shift.call(this);
        this._registerAtomic("$set", this);
        this._markModified();
        return ret2;
      }
      sort() {
        const ret2 = [].sort.apply(this, arguments);
        this._registerAtomic("$set", this);
        return ret2;
      }
      splice() {
        let ret2;
        _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));
        if (arguments.length) {
          let vals;
          if (this[arraySchemaSymbol] == null) {
            vals = arguments;
          } else {
            vals = [];
            for (let i = 0; i < arguments.length; ++i) {
              vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));
            }
          }
          ret2 = [].splice.apply(this, vals);
          this._registerAtomic("$set", this);
        }
        return ret2;
      }
      slice() {
        const ret2 = super.slice.apply(this, arguments);
        ret2[arrayParentSymbol] = this[arrayParentSymbol];
        ret2[arraySchemaSymbol] = this[arraySchemaSymbol];
        ret2[arrayAtomicsSymbol] = this[arrayAtomicsSymbol];
        ret2[arrayPathSymbol] = this[arrayPathSymbol];
        ret2[slicedSymbol] = true;
        return ret2;
      }
      filter() {
        const ret2 = super.filter.apply(this, arguments);
        ret2[arrayParentSymbol] = this[arrayParentSymbol];
        ret2[arraySchemaSymbol] = this[arraySchemaSymbol];
        ret2[arrayAtomicsSymbol] = this[arrayAtomicsSymbol];
        ret2[arrayPathSymbol] = this[arrayPathSymbol];
        return ret2;
      }
      toBSON() {
        return this.toObject(internalToObjectOptions);
      }
      toObject(options2) {
        if (options2 && options2.depopulate) {
          options2 = utils2.clone(options2);
          options2._isNested = true;
          return [].concat(this).map(function(doc) {
            return doc instanceof Document ? doc.toObject(options2) : doc;
          });
        }
        return [].concat(this);
      }
      unshift() {
        _checkManualPopulation(this, arguments);
        let values;
        if (this[arraySchemaSymbol] == null) {
          values = arguments;
        } else {
          values = [].map.call(arguments, this._cast, this);
          values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
        }
        [].unshift.apply(this, values);
        this._registerAtomic("$set", this);
        this._markModified();
        return this.length;
      }
    };
    if (util.inspect.custom) {
      CoreMongooseArray.prototype[util.inspect.custom] = CoreMongooseArray.prototype.inspect;
    }
    function _isAllSubdocs(docs, ref) {
      if (!ref) {
        return false;
      }
      for (const arg of docs) {
        if (arg == null) {
          return false;
        }
        const model = arg.constructor;
        if (!(arg instanceof Document) || model.modelName !== ref && model.baseModelName !== ref) {
          return false;
        }
      }
      return true;
    }
    function _checkManualPopulation(arr, docs) {
      const ref = arr == null ? null : get2(arr[arraySchemaSymbol], "caster.options.ref", null);
      if (arr.length === 0 && docs.length > 0) {
        if (_isAllSubdocs(docs, ref)) {
          arr[arrayParentSymbol].populated(arr[arrayPathSymbol], [], {
            [populateModelSymbol]: docs[0].constructor
          });
        }
      }
    }
    module2.exports = CoreMongooseArray;
  }
});

// node_modules/mongoose/lib/types/array.js
var require_array = __commonJS({
  "node_modules/mongoose/lib/types/array.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CoreMongooseArray = require_core_array();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var _basePush = Array.prototype.push;
    function MongooseArray(values, path, doc, schematype) {
      let arr;
      if (Array.isArray(values)) {
        const len = values.length;
        if (len === 0) {
          arr = new CoreMongooseArray();
        } else if (len === 1) {
          arr = new CoreMongooseArray(1);
          arr[0] = values[0];
        } else if (len < 1e4) {
          arr = new CoreMongooseArray();
          _basePush.apply(arr, values);
        } else {
          arr = new CoreMongooseArray();
          for (let i = 0; i < len; ++i) {
            _basePush.call(arr, values[i]);
          }
        }
        if (values[arrayAtomicsSymbol] != null) {
          arr[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];
        }
      } else {
        arr = new CoreMongooseArray();
      }
      arr[arrayPathSymbol] = path;
      if (doc != null && doc.$__ != null) {
        arr[arrayParentSymbol] = doc;
        arr[arraySchemaSymbol] = schematype || doc.schema.path(path);
      }
      return arr;
    }
    module2.exports = exports2 = MongooseArray;
  }
});

// node_modules/mongoose/lib/types/buffer.js
var require_buffer = __commonJS({
  "node_modules/mongoose/lib/types/buffer.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Binary2 = require_driver().get().Binary;
    var utils2 = require_utils6();
    var Buffer2 = require_safe_buffer().Buffer;
    function MongooseBuffer(value, encode, offset) {
      const length = arguments.length;
      let val;
      if (length === 0 || arguments[0] === null || arguments[0] === void 0) {
        val = 0;
      } else {
        val = value;
      }
      let encoding;
      let path;
      let doc;
      if (Array.isArray(encode)) {
        path = encode[0];
        doc = encode[1];
      } else {
        encoding = encode;
      }
      let buf;
      if (typeof val === "number" || val instanceof Number) {
        buf = Buffer2.alloc(val);
      } else {
        buf = Buffer2.from(val, encoding, offset);
      }
      utils2.decorate(buf, MongooseBuffer.mixin);
      buf.isMongooseBuffer = true;
      buf[MongooseBuffer.pathSymbol] = path;
      buf[parentSymbol] = doc;
      buf._subtype = 0;
      return buf;
    }
    var pathSymbol = Symbol.for("mongoose#Buffer#_path");
    var parentSymbol = Symbol.for("mongoose#Buffer#_parent");
    MongooseBuffer.pathSymbol = pathSymbol;
    MongooseBuffer.mixin = {
      _subtype: void 0,
      _markModified: function() {
        const parent = this[parentSymbol];
        if (parent) {
          parent.markModified(this[MongooseBuffer.pathSymbol]);
        }
        return this;
      },
      write: function() {
        const written = Buffer2.prototype.write.apply(this, arguments);
        if (written > 0) {
          this._markModified();
        }
        return written;
      },
      copy: function(target) {
        const ret2 = Buffer2.prototype.copy.apply(this, arguments);
        if (target && target.isMongooseBuffer) {
          target._markModified();
        }
        return ret2;
      }
    };
    "writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 writeFloat writeDouble fill utf8Write binaryWrite asciiWrite set writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE writeInt16LE writeInt16BE writeInt32LE writeInt32BE writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE".split(" ").forEach(function(method) {
      if (!Buffer2.prototype[method]) {
        return;
      }
      MongooseBuffer.mixin[method] = function() {
        const ret2 = Buffer2.prototype[method].apply(this, arguments);
        this._markModified();
        return ret2;
      };
    });
    MongooseBuffer.mixin.toObject = function(options2) {
      const subtype = typeof options2 === "number" ? options2 : this._subtype || 0;
      return new Binary2(Buffer2.from(this), subtype);
    };
    MongooseBuffer.mixin.toBSON = function() {
      return new Binary2(this, this._subtype || 0);
    };
    MongooseBuffer.mixin.equals = function(other) {
      if (!Buffer2.isBuffer(other)) {
        return false;
      }
      if (this.length !== other.length) {
        return false;
      }
      for (let i = 0; i < this.length; ++i) {
        if (this[i] !== other[i]) {
          return false;
        }
      }
      return true;
    };
    MongooseBuffer.mixin.subtype = function(subtype) {
      if (typeof subtype !== "number") {
        throw new TypeError("Invalid subtype. Expected a number");
      }
      if (this._subtype !== subtype) {
        this._markModified();
      }
      this._subtype = subtype;
    };
    MongooseBuffer.Binary = Binary2;
    module2.exports = MongooseBuffer;
  }
});

// node_modules/mongoose/lib/cast/objectid.js
var require_objectid4 = __commonJS({
  "node_modules/mongoose/lib/cast/objectid.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ObjectId2 = require_driver().get().ObjectId;
    var assert = require("assert");
    module2.exports = function castObjectId(value) {
      if (value == null) {
        return value;
      }
      if (value instanceof ObjectId2) {
        return value;
      }
      if (value._id) {
        if (value._id instanceof ObjectId2) {
          return value._id;
        }
        if (value._id.toString instanceof Function) {
          return new ObjectId2(value._id.toString());
        }
      }
      if (value.toString instanceof Function) {
        return new ObjectId2(value.toString());
      }
      assert.ok(false);
    };
  }
});

// node_modules/mongoose/lib/types/documentarray.js
var require_documentarray = __commonJS({
  "node_modules/mongoose/lib/types/documentarray.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CoreMongooseArray = require_core_array();
    var Document = require_document();
    var ObjectId2 = require_objectid3();
    var castObjectId = require_objectid4();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var util = require("util");
    var utils2 = require_utils6();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var _basePush = Array.prototype.push;
    var CoreDocumentArray = class extends CoreMongooseArray {
      get isMongooseDocumentArray() {
        return true;
      }
      toBSON() {
        return this.toObject(internalToObjectOptions);
      }
      map() {
        const ret2 = super.map.apply(this, arguments);
        ret2[arraySchemaSymbol] = null;
        ret2[arrayPathSymbol] = null;
        ret2[arrayParentSymbol] = null;
        return ret2;
      }
      _cast(value, index2) {
        if (this[arraySchemaSymbol] == null) {
          return value;
        }
        let Constructor = this[arraySchemaSymbol].casterConstructor;
        const isInstance = Constructor.$isMongooseDocumentArray ? value && value.isMongooseDocumentArray : value instanceof Constructor;
        if (isInstance || value && value.constructor && value.constructor.baseCasterConstructor === Constructor) {
          if (!(value[documentArrayParent] && value.__parentArray)) {
            value[documentArrayParent] = this[arrayParentSymbol];
            value.__parentArray = this;
          }
          value.$setIndex(index2);
          return value;
        }
        if (value === void 0 || value === null) {
          return null;
        }
        if (Buffer.isBuffer(value) || value instanceof ObjectId2 || !utils2.isObject(value)) {
          value = { _id: value };
        }
        if (value && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof value[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        if (Constructor.$isMongooseDocumentArray) {
          return Constructor.cast(value, this, void 0, void 0, index2);
        }
        return new Constructor(value, this, void 0, void 0, index2);
      }
      id(id) {
        let casted;
        let sid;
        let _id;
        try {
          casted = castObjectId(id).toString();
        } catch (e) {
          casted = null;
        }
        for (const val of this) {
          if (!val) {
            continue;
          }
          _id = val.get("_id");
          if (_id === null || typeof _id === "undefined") {
            continue;
          } else if (_id instanceof Document) {
            sid || (sid = String(id));
            if (sid == _id._id) {
              return val;
            }
          } else if (!(id instanceof ObjectId2) && !(_id instanceof ObjectId2)) {
            if (id == _id || utils2.deepEqual(id, _id)) {
              return val;
            }
          } else if (casted == _id) {
            return val;
          }
        }
        return null;
      }
      toObject(options2) {
        return [].concat(this.map(function(doc) {
          if (doc == null) {
            return null;
          }
          if (typeof doc.toObject !== "function") {
            return doc;
          }
          return doc.toObject(options2);
        }));
      }
      slice() {
        const arr = super.slice.apply(this, arguments);
        arr[arrayParentSymbol] = this[arrayParentSymbol];
        arr[arrayPathSymbol] = this[arrayPathSymbol];
        return arr;
      }
      push() {
        const ret2 = super.push.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      pull() {
        const ret2 = super.pull.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      shift() {
        const ret2 = super.shift.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      splice() {
        const ret2 = super.splice.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      inspect() {
        return this.toObject();
      }
      create(obj) {
        let Constructor = this[arraySchemaSymbol].casterConstructor;
        if (obj && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof obj[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        return new Constructor(obj, this);
      }
      notify(event) {
        const _this = this;
        return function notify(val, _arr) {
          _arr = _arr || _this;
          let i = _arr.length;
          while (i--) {
            if (_arr[i] == null) {
              continue;
            }
            switch (event) {
              case "save":
                val = _this[i];
                break;
              default:
                break;
            }
            if (_arr[i].isMongooseArray) {
              notify(val, _arr[i]);
            } else if (_arr[i]) {
              _arr[i].emit(event, val);
            }
          }
        };
      }
      _markModified(elem, embeddedPath) {
        const parent = this[arrayParentSymbol];
        let dirtyPath;
        if (parent) {
          dirtyPath = this[arrayPathSymbol];
          if (arguments.length) {
            if (embeddedPath != null) {
              const index2 = elem.__index;
              dirtyPath = dirtyPath + "." + index2 + "." + embeddedPath;
            } else {
              dirtyPath = dirtyPath + "." + elem;
            }
          }
          if (dirtyPath != null && dirtyPath.endsWith(".$")) {
            return this;
          }
          parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);
        }
        return this;
      }
    };
    if (util.inspect.custom) {
      CoreDocumentArray.prototype[util.inspect.custom] = CoreDocumentArray.prototype.inspect;
    }
    function _updateParentPopulated(arr) {
      const parent = arr[arrayParentSymbol];
      if (!parent || parent.$__.populated == null)
        return;
      const populatedPaths = Object.keys(parent.$__.populated).filter((p) => p.startsWith(arr[arrayPathSymbol] + "."));
      for (const path of populatedPaths) {
        const remnant = path.slice((arr[arrayPathSymbol] + ".").length);
        if (!Array.isArray(parent.$__.populated[path].value)) {
          continue;
        }
        parent.$__.populated[path].value = arr.map((val) => val.populated(remnant));
      }
    }
    function MongooseDocumentArray(values, path, doc) {
      const arr = new CoreDocumentArray();
      arr[arrayAtomicsSymbol] = {};
      arr[arraySchemaSymbol] = void 0;
      if (Array.isArray(values)) {
        if (values[arrayPathSymbol] === path && values[arrayParentSymbol] === doc) {
          arr[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);
        }
        values.forEach((v) => {
          _basePush.call(arr, v);
        });
      }
      arr[arrayPathSymbol] = path;
      if (doc && doc instanceof Document) {
        arr[arrayParentSymbol] = doc;
        arr[arraySchemaSymbol] = doc.schema.path(path);
        while (arr != null && arr[arraySchemaSymbol] != null && arr[arraySchemaSymbol].$isMongooseArray && !arr[arraySchemaSymbol].$isMongooseDocumentArray) {
          arr[arraySchemaSymbol] = arr[arraySchemaSymbol].casterConstructor;
        }
      }
      return arr;
    }
    module2.exports = MongooseDocumentArray;
  }
});

// node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js
var require_handleSpreadDoc = __commonJS({
  "node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils6();
    module2.exports = function handleSpreadDoc(v) {
      if (utils2.isPOJO(v) && v.$__ != null && v._doc != null) {
        return v._doc;
      }
      return v;
    };
  }
});

// node_modules/mongoose/lib/types/map.js
var require_map3 = __commonJS({
  "node_modules/mongoose/lib/types/map.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Mixed = require_mixed();
    var ObjectId2 = require_objectid3();
    var clone2 = require_clone();
    var deepEqual = require_utils6().deepEqual;
    var get2 = require_get();
    var handleSpreadDoc = require_handleSpreadDoc();
    var util = require("util");
    var specialProperties = require_specialProperties();
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var MongooseMap = class extends Map {
      constructor(v, path, doc, schemaType) {
        if (v != null && v.constructor.name === "Object") {
          v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);
        }
        super(v);
        this.$__parent = doc != null && doc.$__ != null ? doc : null;
        this.$__path = path;
        this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;
        this.$__runDeferred();
      }
      $init(key, value) {
        checkValidKey(key);
        super.set(key, value);
        if (value != null && value.$isSingleNested) {
          value.$basePath = this.$__path + "." + key;
        }
      }
      $__set(key, value) {
        super.set(key, value);
      }
      get(key, options2) {
        if (key instanceof ObjectId2) {
          key = key.toString();
        }
        options2 = options2 || {};
        if (options2.getters === false) {
          return super.get(key);
        }
        return this.$__schemaType.applyGetters(super.get(key), this.$__parent);
      }
      set(key, value) {
        if (key instanceof ObjectId2) {
          key = key.toString();
        }
        checkValidKey(key);
        value = handleSpreadDoc(value);
        if (this.$__schemaType == null) {
          this.$__deferred = this.$__deferred || [];
          this.$__deferred.push({ key, value });
          return;
        }
        const fullPath = this.$__path + "." + key;
        const populated = this.$__parent != null && this.$__parent.$__ ? this.$__parent.populated(fullPath) || this.$__parent.populated(this.$__path) : null;
        const priorVal = this.get(key);
        if (populated != null) {
          if (value.$__ == null) {
            value = new populated.options[populateModelSymbol](value);
          }
          value.$__.wasPopulated = true;
        } else {
          try {
            value = this.$__schemaType.applySetters(value, this.$__parent, false, this.get(key), { path: fullPath });
          } catch (error2) {
            if (this.$__parent != null && this.$__parent.$__ != null) {
              this.$__parent.invalidate(fullPath, error2);
              return;
            }
            throw error2;
          }
        }
        super.set(key, value);
        if (value != null && value.$isSingleNested) {
          value.$basePath = this.$__path + "." + key;
        }
        const parent = this.$__parent;
        if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {
          parent.markModified(this.$__path + "." + key);
        }
      }
      clear() {
        super.clear();
        const parent = this.$__parent;
        if (parent != null) {
          parent.markModified(this.$__path);
        }
      }
      delete(key) {
        if (key instanceof ObjectId2) {
          key = key.toString();
        }
        this.set(key, void 0);
        super.delete(key);
      }
      toBSON() {
        return new Map(this);
      }
      toObject(options2) {
        if (get2(options2, "flattenMaps")) {
          const ret2 = {};
          const keys = this.keys();
          for (const key of keys) {
            ret2[key] = clone2(this.get(key));
          }
          return ret2;
        }
        return new Map(this);
      }
      toJSON() {
        const ret2 = {};
        const keys = this.keys();
        for (const key of keys) {
          ret2[key] = this.get(key);
        }
        return ret2;
      }
      inspect() {
        return new Map(this);
      }
      $__runDeferred() {
        if (!this.$__deferred) {
          return;
        }
        for (const keyValueObject of this.$__deferred) {
          this.set(keyValueObject.key, keyValueObject.value);
        }
        this.$__deferred = null;
      }
    };
    if (util.inspect.custom) {
      Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {
        enumerable: false,
        writable: false,
        configurable: false,
        value: MongooseMap.prototype.inspect
      });
    }
    Object.defineProperty(MongooseMap.prototype, "$__set", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__parent", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__path", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__schemaType", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$isMongooseMap", {
      enumerable: false,
      writable: false,
      configurable: false,
      value: true
    });
    Object.defineProperty(MongooseMap.prototype, "$__deferredCalls", {
      enumerable: false,
      writable: false,
      configurable: false,
      value: true
    });
    function checkValidKey(key) {
      const keyType = typeof key;
      if (keyType !== "string") {
        throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);
      }
      if (key.startsWith("$")) {
        throw new Error(`Mongoose maps do not support keys that start with "$", got "${key}"`);
      }
      if (key.includes(".")) {
        throw new Error(`Mongoose maps do not support keys that contain ".", got "${key}"`);
      }
      if (specialProperties.has(key)) {
        throw new Error(`Mongoose maps do not support reserved key name "${key}"`);
      }
    }
    module2.exports = MongooseMap;
  }
});

// node_modules/mongoose/lib/types/subdocument.js
var require_subdocument = __commonJS({
  "node_modules/mongoose/lib/types/subdocument.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Document = require_document();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var promiseOrCallback = require_promiseOrCallback();
    var documentArrayParent = require_symbols().documentArrayParent;
    module2.exports = Subdocument;
    function Subdocument(value, fields, parent, skipId, options2) {
      this.$isSingleNested = true;
      if (options2 != null && options2.path != null) {
        this.$basePath = options2.path;
      }
      const hasPriorDoc = options2 != null && options2.priorDoc;
      let initedPaths = null;
      if (hasPriorDoc) {
        this._doc = Object.assign({}, options2.priorDoc._doc);
        delete this._doc[this.$__schema.options.discriminatorKey];
        initedPaths = Object.keys(options2.priorDoc._doc || {}).filter((key) => key !== this.$__schema.options.discriminatorKey);
      }
      if (parent != null) {
        options2 = Object.assign({}, options2, {
          isNew: parent.isNew,
          defaults: parent.$__.$options.defaults
        });
      }
      Document.call(this, value, fields, skipId, options2);
      if (hasPriorDoc) {
        for (const key of initedPaths) {
          if (!this.$__.activePaths.states.modify[key] && !this.$__.activePaths.states.default[key] && !this.$__.$setCalled.has(key)) {
            const schematype = this.$__schema.path(key);
            const def = schematype == null ? void 0 : schematype.getDefault(this);
            if (def === void 0) {
              delete this._doc[key];
            } else {
              this._doc[key] = def;
              this.$__.activePaths.default(key);
            }
          }
        }
        delete options2.priorDoc;
        delete this.$__.$options.priorDoc;
      }
    }
    Subdocument.prototype = Object.create(Document.prototype);
    Subdocument.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    Subdocument.prototype.save = function(options2, fn) {
      if (typeof options2 === "function") {
        fn = options2;
        options2 = {};
      }
      options2 = options2 || {};
      if (!options2.suppressWarning) {
        console.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app.");
      }
      return promiseOrCallback(fn, (cb) => {
        this.$__save(cb);
      });
    };
    Subdocument.prototype.$__save = function(fn) {
      return immediate(() => fn(null, this));
    };
    Subdocument.prototype.$isValid = function(path) {
      if (this.$__parent && this.$basePath) {
        return this.$__parent.$isValid([this.$basePath, path].join("."));
      }
      return Document.prototype.$isValid.call(this, path);
    };
    Subdocument.prototype.markModified = function(path) {
      Document.prototype.markModified.call(this, path);
      if (this.$__parent && this.$basePath) {
        if (this.$__parent.isDirectModified(this.$basePath)) {
          return;
        }
        this.$__parent.markModified([this.$basePath, path].join("."), this);
      }
    };
    Subdocument.prototype.isModified = function(paths, modifiedPaths) {
      if (this.$__parent && this.$basePath) {
        if (Array.isArray(paths) || typeof paths === "string") {
          paths = Array.isArray(paths) ? paths : paths.split(" ");
          paths = paths.map((p) => [this.$basePath, p].join("."));
          return this.$__parent.isModified(paths, modifiedPaths);
        }
        return this.$__parent.isModified(this.$basePath);
      }
      return Document.prototype.isModified.call(this, paths, modifiedPaths);
    };
    Subdocument.prototype.$markValid = function(path) {
      Document.prototype.$markValid.call(this, path);
      if (this.$__parent && this.$basePath) {
        this.$__parent.$markValid([this.$basePath, path].join("."));
      }
    };
    Subdocument.prototype.invalidate = function(path, err, val) {
      if (err !== this.ownerDocument().$__.validationError) {
        Document.prototype.invalidate.call(this, path, err, val);
      }
      if (this.$__parent && this.$basePath) {
        this.$__parent.invalidate([this.$basePath, path].join("."), err, val);
      } else if (err.kind === "cast" || err.name === "CastError") {
        throw err;
      }
      return this.ownerDocument().$__.validationError;
    };
    Subdocument.prototype.$ignore = function(path) {
      Document.prototype.$ignore.call(this, path);
      if (this.$__parent && this.$basePath) {
        this.$__parent.$ignore([this.$basePath, path].join("."));
      }
    };
    Subdocument.prototype.ownerDocument = function() {
      if (this.$__.ownerDocument) {
        return this.$__.ownerDocument;
      }
      let parent = this.$__parent;
      if (!parent) {
        return this;
      }
      while (parent.$__parent || parent[documentArrayParent]) {
        parent = parent.$__parent || parent[documentArrayParent];
      }
      this.$__.ownerDocument = parent;
      return this.$__.ownerDocument;
    };
    Subdocument.prototype.parent = function() {
      return this.$__parent;
    };
    Subdocument.prototype.$parent = Subdocument.prototype.parent;
    Subdocument.prototype.$__remove = function(cb) {
      return cb(null, this);
    };
    Subdocument.prototype.remove = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      registerRemoveListener(this);
      if (!options2 || !options2.noop) {
        this.$__parent.set(this.$basePath, null);
      }
      if (typeof callback === "function") {
        callback(null);
      }
    };
    Subdocument.prototype.populate = function() {
      throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.nested.populate("path")`, use `doc.populate("nested.path")`');
    };
    function registerRemoveListener(sub) {
      let owner = sub.ownerDocument();
      function emitRemove() {
        owner.removeListener("save", emitRemove);
        owner.removeListener("remove", emitRemove);
        sub.emit("remove", sub);
        sub.constructor.emit("remove", sub);
        owner = sub = null;
      }
      owner.on("save", emitRemove);
      owner.on("remove", emitRemove);
    }
  }
});

// node_modules/mongoose/lib/types/index.js
var require_types = __commonJS({
  "node_modules/mongoose/lib/types/index.js"(exports2) {
    init_shims();
    "use strict";
    exports2.Array = require_array();
    exports2.Buffer = require_buffer();
    exports2.Document = exports2.Embedded = require_embedded();
    exports2.DocumentArray = require_documentarray();
    exports2.Decimal128 = require_decimal1282();
    exports2.ObjectId = require_objectid3();
    exports2.Map = require_map3();
    exports2.Subdocument = require_subdocument();
  }
});

// node_modules/mongoose/lib/schema/array.js
var require_array2 = __commonJS({
  "node_modules/mongoose/lib/schema/array.js"(exports2, module2) {
    init_shims();
    "use strict";
    var $exists = require_exists();
    var $type = require_type();
    var MongooseError = require_mongooseError();
    var SchemaArrayOptions = require_SchemaArrayOptions();
    var SchemaType = require_schematype();
    var CastError = SchemaType.CastError;
    var Mixed = require_mixed();
    var arrayDepth = require_arrayDepth();
    var cast = require_cast2();
    var get2 = require_get();
    var isOperator = require_isOperator();
    var util = require("util");
    var utils2 = require_utils6();
    var castToNumber = require_helpers().castToNumber;
    var geospatial = require_geospatial();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var MongooseArray;
    var EmbeddedDoc;
    var isNestedArraySymbol = Symbol("mongoose#isNestedArray");
    var emptyOpts = Object.freeze({});
    function SchemaArray(key, cast2, options2, schemaOptions) {
      EmbeddedDoc || (EmbeddedDoc = require_types().Embedded);
      let typeKey = "type";
      if (schemaOptions && schemaOptions.typeKey) {
        typeKey = schemaOptions.typeKey;
      }
      this.schemaOptions = schemaOptions;
      if (cast2) {
        let castOptions = {};
        if (utils2.isPOJO(cast2)) {
          if (cast2[typeKey]) {
            castOptions = utils2.clone(cast2);
            delete castOptions[typeKey];
            cast2 = cast2[typeKey];
          } else {
            cast2 = Mixed;
          }
        }
        if (options2 != null && options2.ref != null && castOptions.ref == null) {
          castOptions.ref = options2.ref;
        }
        if (cast2 === Object) {
          cast2 = Mixed;
        }
        const name = typeof cast2 === "string" ? cast2 : utils2.getFunctionName(cast2);
        const Types = require_schema();
        const caster = Types.hasOwnProperty(name) ? Types[name] : cast2;
        this.casterConstructor = caster;
        if (this.casterConstructor instanceof SchemaArray) {
          this.casterConstructor[isNestedArraySymbol] = true;
        }
        if (typeof caster === "function" && !caster.$isArraySubdocument && !caster.$isSchemaMap) {
          const path = this.caster instanceof EmbeddedDoc ? null : key;
          this.caster = new caster(path, castOptions);
        } else {
          this.caster = caster;
          if (!(this.caster instanceof EmbeddedDoc)) {
            this.caster.path = key;
          }
        }
        this.$embeddedSchemaType = this.caster;
      }
      this.$isMongooseArray = true;
      SchemaType.call(this, key, options2, "Array");
      let defaultArr;
      let fn;
      if (this.defaultValue != null) {
        defaultArr = this.defaultValue;
        fn = typeof defaultArr === "function";
      }
      if (!("defaultValue" in this) || this.defaultValue !== void 0) {
        const defaultFn = function() {
          let arr = [];
          if (fn) {
            arr = defaultArr.call(this);
          } else if (defaultArr != null) {
            arr = arr.concat(defaultArr);
          }
          return arr;
        };
        defaultFn.$runBeforeSetters = !fn;
        this.default(defaultFn);
      }
    }
    SchemaArray.schemaName = "Array";
    SchemaArray.options = { castNonArrays: true };
    SchemaArray.defaultOptions = {};
    SchemaArray.set = SchemaType.set;
    SchemaArray.prototype = Object.create(SchemaType.prototype);
    SchemaArray.prototype.constructor = SchemaArray;
    SchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;
    SchemaArray._checkRequired = SchemaType.prototype.checkRequired;
    SchemaArray.checkRequired = SchemaType.checkRequired;
    SchemaArray.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaArray.checkRequired();
      return _checkRequired(value);
    };
    SchemaArray.prototype.enum = function() {
      let arr = this;
      while (true) {
        const instance = get2(arr, "caster.instance");
        if (instance === "Array") {
          arr = arr.caster;
          continue;
        }
        if (instance !== "String" && instance !== "Number") {
          throw new Error("`enum` can only be set on an array of strings or numbers , not " + instance);
        }
        break;
      }
      let enumArray = arguments;
      if (!Array.isArray(arguments) && utils2.isObject(arguments)) {
        enumArray = utils2.object.vals(enumArray);
      }
      arr.caster.enum.apply(arr.caster, enumArray);
      return this;
    };
    SchemaArray.prototype.applyGetters = function(value, scope) {
      if (scope != null && scope.$__ != null && scope.populated(this.path)) {
        return value;
      }
      const ret2 = SchemaType.prototype.applyGetters.call(this, value, scope);
      if (Array.isArray(ret2)) {
        const len = ret2.length;
        for (let i = 0; i < len; ++i) {
          ret2[i] = this.caster.applyGetters(ret2[i], scope);
        }
      }
      return ret2;
    };
    SchemaArray.prototype._applySetters = function(value, scope, init2, priorVal) {
      if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {
        let depth = 0;
        let arr = this;
        while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
          ++depth;
          arr = arr.casterConstructor;
        }
        if (value != null && value.length > 0) {
          const valueDepth = arrayDepth(value);
          if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {
            for (let i = valueDepth.max; i < depth; ++i) {
              value = [value];
            }
          }
        }
      }
      return SchemaType.prototype._applySetters.call(this, value, scope, init2, priorVal);
    };
    SchemaArray.prototype.cast = function(value, doc, init2, prev, options2) {
      MongooseArray || (MongooseArray = require_types().Array);
      let i;
      let l;
      if (Array.isArray(value)) {
        const len = value.length;
        if (!len && doc) {
          const indexes = doc.schema.indexedPaths();
          const arrayPath = this.path;
          for (i = 0, l = indexes.length; i < l; ++i) {
            const pathIndex = indexes[i][0][arrayPath];
            if (pathIndex === "2dsphere" || pathIndex === "2d") {
              return;
            }
          }
          const arrayGeojsonPath = this.path.endsWith(".coordinates") ? this.path.substr(0, this.path.lastIndexOf(".")) : null;
          if (arrayGeojsonPath != null) {
            for (i = 0, l = indexes.length; i < l; ++i) {
              const pathIndex = indexes[i][0][arrayGeojsonPath];
              if (pathIndex === "2dsphere") {
                return;
              }
            }
          }
        }
        options2 = options2 || emptyOpts;
        value = MongooseArray(value, options2.path || this._arrayPath || this.path, doc, this);
        if (init2 && doc != null && doc.$__ != null && doc.populated(this.path)) {
          return value;
        }
        const caster = this.caster;
        const isMongooseArray = caster.$isMongooseArray;
        const isArrayOfNumbers = caster.instance === "Number";
        if (caster && this.casterConstructor !== Mixed) {
          try {
            for (i = 0; i < len; i++) {
              if (isArrayOfNumbers && value[i] === void 0) {
                throw new MongooseError("Mongoose number arrays disallow storing undefined");
              }
              const opts = {};
              if (isMongooseArray) {
                if (options2.arrayPath != null) {
                  opts.arrayPathIndex = i;
                } else if (caster._arrayParentPath != null) {
                  opts.arrayPathIndex = i;
                }
              }
              value[i] = caster.applySetters(value[i], doc, init2, void 0, opts);
            }
          } catch (e) {
            throw new CastError("[" + e.kind + "]", util.inspect(value), this.path + "." + i, e, this);
          }
        }
        return value;
      }
      if (init2 || SchemaArray.options.castNonArrays) {
        if (!!doc && !!init2) {
          doc.markModified(this.path);
        }
        return this.cast([value], doc, init2);
      }
      throw new CastError("Array", util.inspect(value), this.path, null, this);
    };
    SchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {
      MongooseArray || (MongooseArray = require_types().Array);
      if (Array.isArray(value)) {
        let i;
        const len = value.length;
        const caster = this.caster;
        if (caster && this.casterConstructor !== Mixed) {
          try {
            for (i = 0; i < len; i++) {
              const opts = {};
              if (caster.$isMongooseArray && caster._arrayParentPath != null) {
                opts.arrayPathIndex = i;
              }
              value[i] = caster.cast(value[i], doc, false, void 0, opts);
            }
          } catch (e) {
            throw new CastError("[" + e.kind + "]", util.inspect(value), this.path + "." + i, e, this);
          }
        }
        return value;
      }
      throw new CastError("Array", util.inspect(value), this.path, null, this);
    };
    SchemaArray.prototype.discriminator = function(name, schema) {
      let arr = this;
      while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
        arr = arr.casterConstructor;
        if (arr == null || typeof arr === "function") {
          throw new MongooseError("You can only add an embedded discriminator on a document array, " + this.path + " is a plain array");
        }
      }
      return arr.discriminator(name, schema);
    };
    SchemaArray.prototype.clone = function() {
      const options2 = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, this.caster, options2, this.schemaOptions);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      return schematype;
    };
    SchemaArray.prototype.castForQuery = function($conditional, value) {
      let handler;
      let val;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional + " with Array.");
        }
        val = handler.call(this, value);
      } else {
        val = $conditional;
        let Constructor = this.casterConstructor;
        if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof val[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        const proto = this.casterConstructor.prototype;
        let method = proto && (proto.castForQuery || proto.cast);
        if (!method && Constructor.castForQuery) {
          method = Constructor.castForQuery;
        }
        const caster = this.caster;
        if (Array.isArray(val)) {
          this.setters.reverse().forEach((setter) => {
            val = setter.call(this, val, this);
          });
          val = val.map(function(v) {
            if (utils2.isObject(v) && v.$elemMatch) {
              return v;
            }
            if (method) {
              v = method.call(caster, v);
              return v;
            }
            if (v != null) {
              v = new Constructor(v);
              return v;
            }
            return v;
          });
        } else if (method) {
          val = method.call(caster, val);
        } else if (val != null) {
          val = new Constructor(val);
        }
      }
      return val;
    };
    function cast$all(val) {
      if (!Array.isArray(val)) {
        val = [val];
      }
      val = val.map(function(v) {
        if (utils2.isObject(v)) {
          const o = {};
          o[this.path] = v;
          return cast(this.casterConstructor.schema, o)[this.path];
        }
        return v;
      }, this);
      return this.castForQuery(val);
    }
    function cast$elemMatch(val) {
      const keys = Object.keys(val);
      const numKeys = keys.length;
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        const value = val[key];
        if (isOperator(key) && value != null) {
          val[key] = this.castForQuery(key, value);
        }
      }
      const discriminatorKey = get2(this, "casterConstructor.schema.options.discriminatorKey");
      const discriminators = get2(this, "casterConstructor.schema.discriminators", {});
      if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {
        return cast(discriminators[val[discriminatorKey]], val);
      }
      return cast(this.casterConstructor.schema, val);
    }
    var handle = SchemaArray.prototype.$conditionalHandlers = {};
    handle.$all = cast$all;
    handle.$options = String;
    handle.$elemMatch = cast$elemMatch;
    handle.$geoIntersects = geospatial.cast$geoIntersects;
    handle.$or = createLogicalQueryOperatorHandler("$or");
    handle.$and = createLogicalQueryOperatorHandler("$and");
    handle.$nor = createLogicalQueryOperatorHandler("$nor");
    function createLogicalQueryOperatorHandler(op) {
      return function logicalQueryOperatorHandler(val) {
        if (!Array.isArray(val)) {
          throw new TypeError("conditional " + op + " requires an array");
        }
        const ret2 = [];
        for (const obj of val) {
          ret2.push(cast(this.casterConstructor.schema, obj));
        }
        return ret2;
      };
    }
    handle.$near = handle.$nearSphere = geospatial.cast$near;
    handle.$within = handle.$geoWithin = geospatial.cast$within;
    handle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;
    handle.$exists = $exists;
    handle.$type = $type;
    handle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$regex = SchemaArray.prototype.castForQuery;
    handle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;
    handle.$in = SchemaType.prototype.$conditionalHandlers.$in;
    module2.exports = SchemaArray;
  }
});

// node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js
var require_SchemaDocumentArrayOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaDocumentArrayOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaDocumentArrayOptions.prototype, "excludeIndexes", opts);
    Object.defineProperty(SchemaDocumentArrayOptions.prototype, "_id", opts);
    module2.exports = SchemaDocumentArrayOptions;
  }
});

// node_modules/mongoose/lib/helpers/document/compile.js
var require_compile = __commonJS({
  "node_modules/mongoose/lib/helpers/document/compile.js"(exports2) {
    init_shims();
    "use strict";
    var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
    var get2 = require_get();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var utils2 = require_utils6();
    var Document;
    var getSymbol = require_symbols().getSymbol;
    var scopeSymbol = require_symbols().scopeSymbol;
    exports2.compile = compile;
    exports2.defineKey = defineKey;
    function compile(tree, proto, prefix, options2) {
      Document = Document || require_document();
      const keys = Object.keys(tree);
      const len = keys.length;
      let limb;
      let key;
      for (let i = 0; i < len; ++i) {
        key = keys[i];
        limb = tree[key];
        const hasSubprops = utils2.isPOJO(limb) && Object.keys(limb).length && (!limb[options2.typeKey] || options2.typeKey === "type" && limb.type.type);
        const subprops = hasSubprops ? limb : null;
        defineKey(key, subprops, proto, prefix, keys, options2);
      }
    }
    function defineKey(prop, subprops, prototype, prefix, keys, options2) {
      Document = Document || require_document();
      const path = (prefix ? prefix + "." : "") + prop;
      prefix = prefix || "";
      if (subprops) {
        Object.defineProperty(prototype, prop, {
          enumerable: true,
          configurable: true,
          get: function() {
            const _this = this;
            if (!this.$__.getters) {
              this.$__.getters = {};
            }
            if (!this.$__.getters[path]) {
              const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));
              if (!prefix) {
                nested.$__[scopeSymbol] = this;
              }
              nested.$__.nestedPath = path;
              Object.defineProperty(nested, "schema", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, "$__schema", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, documentSchemaSymbol, {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, "toObject", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return utils2.clone(_this.get(path, null, {
                    virtuals: get2(this, "schema.options.toObject.virtuals", null)
                  }));
                }
              });
              Object.defineProperty(nested, "$__get", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return _this.get(path, null, {
                    virtuals: get2(this, "schema.options.toObject.virtuals", null)
                  });
                }
              });
              Object.defineProperty(nested, "toJSON", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return _this.get(path, null, {
                    virtuals: get2(_this, "schema.options.toJSON.virtuals", null)
                  });
                }
              });
              Object.defineProperty(nested, "$__isNested", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: true
              });
              const _isEmptyOptions = Object.freeze({
                minimize: true,
                virtuals: false,
                getters: false,
                transform: false
              });
              Object.defineProperty(nested, "$isEmpty", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;
                }
              });
              Object.defineProperty(nested, "$__parent", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: this
              });
              compile(subprops, nested, path, options2);
              this.$__.getters[path] = nested;
            }
            return this.$__.getters[path];
          },
          set: function(v) {
            if (v != null && v.$__isNested) {
              v = v.$__get();
            } else if (v instanceof Document && !v.$__isNested) {
              v = v.toObject(internalToObjectOptions);
            }
            const doc = this.$__[scopeSymbol] || this;
            doc.$set(path, v);
          }
        });
      } else {
        Object.defineProperty(prototype, prop, {
          enumerable: true,
          configurable: true,
          get: function() {
            return this[getSymbol].call(this.$__[scopeSymbol] || this, path);
          },
          set: function(v) {
            this.$set.call(this.$__[scopeSymbol] || this, path, v);
          }
        });
      }
    }
    function getOwnPropertyDescriptors(object) {
      const result = {};
      Object.getOwnPropertyNames(object).forEach(function(key) {
        const skip = [
          "isNew",
          "$__",
          "errors",
          "_doc",
          "$locals",
          "$op",
          "__parentArray",
          "__index",
          "$isDocumentArrayElement"
        ].indexOf(key) === -1;
        if (skip) {
          return;
        }
        result[key] = Object.getOwnPropertyDescriptor(object, key);
        result[key].enumerable = false;
      });
      return result;
    }
  }
});

// node_modules/mongoose/lib/helpers/model/discriminator.js
var require_discriminator = __commonJS({
  "node_modules/mongoose/lib/helpers/model/discriminator.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Mixed = require_mixed();
    var defineKey = require_compile().defineKey;
    var get2 = require_get();
    var utils2 = require_utils6();
    var CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {
      toJSON: true,
      toObject: true,
      _id: true,
      id: true
    };
    module2.exports = function discriminator(model, name, schema, tiedValue, applyPlugins) {
      if (!(schema && schema.instanceOfSchema)) {
        throw new Error("You must pass a valid discriminator Schema");
      }
      if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {
        throw new Error('Discriminator "' + name + '" can only be a discriminator of the root model');
      }
      if (applyPlugins) {
        const applyPluginsToDiscriminators = get2(model.base, "options.applyPluginsToDiscriminators", false);
        model.base._applyPlugins(schema, {
          skipTopLevel: !applyPluginsToDiscriminators
        });
      }
      const key = model.schema.options.discriminatorKey;
      const existingPath = model.schema.path(key);
      if (existingPath != null) {
        if (!utils2.hasUserDefinedProperty(existingPath.options, "select")) {
          existingPath.options.select = true;
        }
        existingPath.options.$skipDiscriminatorCheck = true;
      } else {
        const baseSchemaAddition = {};
        baseSchemaAddition[key] = {
          default: void 0,
          select: true,
          $skipDiscriminatorCheck: true
        };
        baseSchemaAddition[key][model.schema.options.typeKey] = String;
        model.schema.add(baseSchemaAddition);
        defineKey(key, null, model.prototype, null, [key], model.schema.options);
      }
      if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {
        throw new Error('Discriminator "' + name + '" cannot have field with name "' + key + '"');
      }
      let value = name;
      if (typeof tiedValue === "string" && tiedValue.length || tiedValue != null) {
        value = tiedValue;
      }
      function merge(schema2, baseSchema) {
        schema2._baseSchema = baseSchema;
        if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {
          schema2.remove("_id");
        }
        const baseSchemaPaths = Object.keys(baseSchema.paths);
        const conflictingPaths = [];
        for (const path of baseSchemaPaths) {
          if (schema2.nested[path]) {
            conflictingPaths.push(path);
            continue;
          }
          if (path.indexOf(".") === -1) {
            continue;
          }
          const sp = path.split(".").slice(0, -1);
          let cur = "";
          for (const piece of sp) {
            cur += (cur.length ? "." : "") + piece;
            if (schema2.paths[cur] instanceof Mixed || schema2.singleNestedPaths[cur] instanceof Mixed) {
              conflictingPaths.push(path);
            }
          }
        }
        utils2.merge(schema2, baseSchema, {
          isDiscriminatorSchemaMerge: true,
          omit: { discriminators: true, base: true },
          omitNested: conflictingPaths.reduce((cur, path) => {
            cur["tree." + path] = true;
            return cur;
          }, {})
        });
        for (const conflictingPath of conflictingPaths) {
          delete schema2.paths[conflictingPath];
        }
        schema2.childSchemas.forEach((obj2) => {
          obj2.model.prototype.$__setSchema(obj2.schema);
        });
        const obj = {};
        obj[key] = {
          default: value,
          select: true,
          set: function(newName) {
            if (newName === value || Array.isArray(value) && utils2.deepEqual(newName, value)) {
              return value;
            }
            throw new Error(`Can't set discriminator key "` + key + '"');
          },
          $skipDiscriminatorCheck: true
        };
        obj[key][schema2.options.typeKey] = existingPath ? existingPath.options[schema2.options.typeKey] : String;
        schema2.add(obj);
        schema2.discriminatorMapping = { key, value, isRoot: false };
        if (baseSchema.options.collection) {
          schema2.options.collection = baseSchema.options.collection;
        }
        const toJSON = schema2.options.toJSON;
        const toObject = schema2.options.toObject;
        const _id = schema2.options._id;
        const id = schema2.options.id;
        const keys = Object.keys(schema2.options);
        schema2.options.discriminatorKey = baseSchema.options.discriminatorKey;
        for (const _key of keys) {
          if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {
            if (_key === "pluralization" && schema2.options[_key] == true && baseSchema.options[_key] == null) {
              continue;
            }
            if (!utils2.deepEqual(schema2.options[_key], baseSchema.options[_key])) {
              throw new Error("Can't customize discriminator option " + _key + " (can only modify " + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(", ") + ")");
            }
          }
        }
        schema2.options = utils2.clone(baseSchema.options);
        if (toJSON)
          schema2.options.toJSON = toJSON;
        if (toObject)
          schema2.options.toObject = toObject;
        if (typeof _id !== "undefined") {
          schema2.options._id = _id;
        }
        schema2.options.id = id;
        schema2.s.hooks = model.schema.s.hooks.merge(schema2.s.hooks);
        schema2.plugins = Array.prototype.slice.call(baseSchema.plugins);
        schema2.callQueue = baseSchema.callQueue.concat(schema2.callQueue);
        delete schema2._requiredpaths;
      }
      merge(schema, model.schema);
      if (!model.discriminators) {
        model.discriminators = {};
      }
      if (!model.schema.discriminatorMapping) {
        model.schema.discriminatorMapping = { key, value: null, isRoot: true };
      }
      if (!model.schema.discriminators) {
        model.schema.discriminators = {};
      }
      model.schema.discriminators[name] = schema;
      if (model.discriminators[name]) {
        throw new Error('Discriminator with name "' + name + '" already exists');
      }
      return schema;
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/handleIdOption.js
var require_handleIdOption = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/handleIdOption.js"(exports2, module2) {
    init_shims();
    "use strict";
    var addAutoId = require_addAutoId();
    module2.exports = function handleIdOption(schema, options2) {
      if (options2 == null || options2._id == null) {
        return schema;
      }
      schema = schema.clone();
      if (!options2._id) {
        schema.remove("_id");
        schema.options._id = false;
      } else if (!schema.paths["_id"]) {
        addAutoId(schema);
        schema.options._id = true;
      }
      return schema;
    };
  }
});

// node_modules/mongoose/lib/helpers/discriminator/getConstructor.js
var require_getConstructor = __commonJS({
  "node_modules/mongoose/lib/helpers/discriminator/getConstructor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    module2.exports = function getConstructor(Constructor, value) {
      const discriminatorKey = Constructor.schema.options.discriminatorKey;
      if (value != null && Constructor.discriminators && value[discriminatorKey] != null) {
        if (Constructor.discriminators[value[discriminatorKey]]) {
          Constructor = Constructor.discriminators[value[discriminatorKey]];
        } else {
          const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[discriminatorKey]);
          if (constructorByValue) {
            Constructor = constructorByValue;
          }
        }
      }
      return Constructor;
    };
  }
});

// node_modules/mongoose/lib/schema/documentarray.js
var require_documentarray2 = __commonJS({
  "node_modules/mongoose/lib/schema/documentarray.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ArrayType = require_array2();
    var CastError = require_cast();
    var EventEmitter = require("events").EventEmitter;
    var SchemaDocumentArrayOptions = require_SchemaDocumentArrayOptions();
    var SchemaType = require_schematype();
    var ValidationError = require_validation();
    var discriminator = require_discriminator();
    var get2 = require_get();
    var handleIdOption = require_handleIdOption();
    var util = require("util");
    var utils2 = require_utils6();
    var getConstructor = require_getConstructor();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var MongooseDocumentArray;
    var Subdocument;
    function DocumentArrayPath(key, schema, options2, schemaOptions) {
      if (schemaOptions != null && schemaOptions._id != null) {
        schema = handleIdOption(schema, schemaOptions);
      } else if (options2 != null && options2._id != null) {
        schema = handleIdOption(schema, options2);
      }
      const EmbeddedDocument = _createConstructor(schema, options2);
      EmbeddedDocument.prototype.$basePath = key;
      ArrayType.call(this, key, EmbeddedDocument, options2);
      this.schema = schema;
      this.schemaOptions = schemaOptions || {};
      this.$isMongooseDocumentArray = true;
      this.Constructor = EmbeddedDocument;
      EmbeddedDocument.base = schema.base;
      const fn = this.defaultValue;
      if (!("defaultValue" in this) || fn !== void 0) {
        this.default(function() {
          let arr = fn.call(this);
          if (!Array.isArray(arr)) {
            arr = [arr];
          }
          return arr;
        });
      }
      const parentSchemaType = this;
      this.$embeddedSchemaType = new SchemaType(key + ".$", {
        required: get2(this, "schemaOptions.required", false)
      });
      this.$embeddedSchemaType.cast = function(value, doc, init2) {
        return parentSchemaType.cast(value, doc, init2)[0];
      };
      this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;
      this.$embeddedSchemaType.caster = this.Constructor;
      this.$embeddedSchemaType.schema = this.schema;
    }
    DocumentArrayPath.schemaName = "DocumentArray";
    DocumentArrayPath.options = { castNonArrays: true };
    DocumentArrayPath.prototype = Object.create(ArrayType.prototype);
    DocumentArrayPath.prototype.constructor = DocumentArrayPath;
    DocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;
    function _createConstructor(schema, options2, baseClass) {
      Subdocument || (Subdocument = require_embedded());
      function EmbeddedDocument() {
        Subdocument.apply(this, arguments);
        this.$session(this.ownerDocument().$session());
      }
      const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
      EmbeddedDocument.prototype = Object.create(proto);
      EmbeddedDocument.prototype.$__setSchema(schema);
      EmbeddedDocument.schema = schema;
      EmbeddedDocument.prototype.constructor = EmbeddedDocument;
      EmbeddedDocument.$isArraySubdocument = true;
      EmbeddedDocument.events = new EventEmitter();
      for (const i in schema.methods) {
        EmbeddedDocument.prototype[i] = schema.methods[i];
      }
      for (const i in schema.statics) {
        EmbeddedDocument[i] = schema.statics[i];
      }
      for (const i in EventEmitter.prototype) {
        EmbeddedDocument[i] = EventEmitter.prototype[i];
      }
      EmbeddedDocument.options = options2;
      return EmbeddedDocument;
    }
    DocumentArrayPath.prototype.discriminator = function(name, schema, tiedValue) {
      if (typeof name === "function") {
        name = utils2.getFunctionName(name);
      }
      schema = discriminator(this.casterConstructor, name, schema, tiedValue);
      const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);
      EmbeddedDocument.baseCasterConstructor = this.casterConstructor;
      try {
        Object.defineProperty(EmbeddedDocument, "name", {
          value: name
        });
      } catch (error2) {
      }
      this.casterConstructor.discriminators[name] = EmbeddedDocument;
      return this.casterConstructor.discriminators[name];
    };
    DocumentArrayPath.prototype.doValidate = function(array, fn, scope, options2) {
      MongooseDocumentArray || (MongooseDocumentArray = require_documentarray());
      const _this = this;
      try {
        SchemaType.prototype.doValidate.call(this, array, cb, scope);
      } catch (err) {
        err.$isArrayValidatorError = true;
        return fn(err);
      }
      function cb(err) {
        if (err) {
          err.$isArrayValidatorError = true;
          return fn(err);
        }
        let count = array && array.length;
        let error2;
        if (!count) {
          return fn();
        }
        if (options2 && options2.updateValidator) {
          return fn();
        }
        if (!array.isMongooseDocumentArray) {
          array = new MongooseDocumentArray(array, _this.path, scope);
        }
        function callback(err2) {
          if (err2 != null) {
            error2 = err2;
            if (!(error2 instanceof ValidationError)) {
              error2.$isArrayValidatorError = true;
            }
          }
          --count || fn(error2);
        }
        for (let i = 0, len = count; i < len; ++i) {
          let doc = array[i];
          if (doc == null) {
            --count || fn(error2);
            continue;
          }
          if (!(doc instanceof Subdocument)) {
            const Constructor = getConstructor(_this.casterConstructor, array[i]);
            doc = array[i] = new Constructor(doc, array, void 0, void 0, i);
          }
          if (options2 != null && options2.validateModifiedOnly && !doc.isModified()) {
            --count || fn(error2);
            continue;
          }
          doc.$__validate(callback);
        }
      }
    };
    DocumentArrayPath.prototype.doValidateSync = function(array, scope, options2) {
      const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
      if (schemaTypeError != null) {
        schemaTypeError.$isArrayValidatorError = true;
        return schemaTypeError;
      }
      const count = array && array.length;
      let resultError = null;
      if (!count) {
        return;
      }
      for (let i = 0, len = count; i < len; ++i) {
        let doc = array[i];
        if (!doc) {
          continue;
        }
        if (!(doc instanceof Subdocument)) {
          const Constructor = getConstructor(this.casterConstructor, array[i]);
          doc = array[i] = new Constructor(doc, array, void 0, void 0, i);
        }
        if (options2 != null && options2.validateModifiedOnly && !doc.isModified()) {
          continue;
        }
        const subdocValidateError = doc.validateSync();
        if (subdocValidateError && resultError == null) {
          resultError = subdocValidateError;
        }
      }
      return resultError;
    };
    DocumentArrayPath.prototype.getDefault = function(scope) {
      let ret2 = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
      if (ret2 == null) {
        return ret2;
      }
      MongooseDocumentArray || (MongooseDocumentArray = require_documentarray());
      if (!Array.isArray(ret2)) {
        ret2 = [ret2];
      }
      ret2 = new MongooseDocumentArray(ret2, this.path, scope);
      for (let i = 0; i < ret2.length; ++i) {
        const Constructor = getConstructor(this.casterConstructor, ret2[i]);
        const _subdoc = new Constructor({}, ret2, void 0, void 0, i);
        _subdoc.init(ret2[i]);
        _subdoc.isNew = true;
        Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);
        _subdoc.$__.activePaths.init = {};
        ret2[i] = _subdoc;
      }
      return ret2;
    };
    DocumentArrayPath.prototype.cast = function(value, doc, init2, prev, options2) {
      MongooseDocumentArray || (MongooseDocumentArray = require_documentarray());
      if (value != null && value[arrayPathSymbol] != null && value === prev) {
        return value;
      }
      let selected;
      let subdoc;
      const _opts = { transform: false, virtuals: false };
      options2 = options2 || {};
      if (!Array.isArray(value)) {
        if (!init2 && !DocumentArrayPath.options.castNonArrays) {
          throw new CastError("DocumentArray", util.inspect(value), this.path, null, this);
        }
        if (!!doc && init2) {
          doc.markModified(this.path);
        }
        return this.cast([value], doc, init2, prev, options2);
      }
      if (!(value && value.isMongooseDocumentArray) && !options2.skipDocumentArrayCast) {
        value = new MongooseDocumentArray(value, this.path, doc);
      } else if (value && value.isMongooseDocumentArray) {
        value = new MongooseDocumentArray(value, this.path, doc);
      }
      if (prev != null) {
        value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};
      }
      if (options2.arrayPathIndex != null) {
        value[arrayPathSymbol] = this.path + "." + options2.arrayPathIndex;
      }
      const len = value.length;
      const initDocumentOptions = { skipId: true, willInit: true };
      for (let i = 0; i < len; ++i) {
        if (!value[i]) {
          continue;
        }
        const Constructor = getConstructor(this.casterConstructor, value[i]);
        if (value[i].$__ && (!(value[i] instanceof Constructor) || value[i][documentArrayParent] !== doc)) {
          value[i] = value[i].toObject({
            transform: false,
            virtuals: value[i].schema === Constructor.schema
          });
        }
        if (value[i] instanceof Subdocument) {
          if (value[i].__index == null) {
            value[i].$setIndex(i);
          }
        } else if (value[i] != null) {
          if (init2) {
            if (doc) {
              selected || (selected = scopePaths(this, doc.$__.selected, init2));
            } else {
              selected = true;
            }
            subdoc = new Constructor(null, value, initDocumentOptions, selected, i);
            value[i] = subdoc.init(value[i]);
          } else {
            if (prev && typeof prev.id === "function") {
              subdoc = prev.id(value[i]._id);
            }
            if (prev && subdoc && utils2.deepEqual(subdoc.toObject(_opts), value[i])) {
              subdoc.set(value[i]);
              value[i] = subdoc;
            } else {
              try {
                subdoc = new Constructor(value[i], value, void 0, void 0, i);
                value[i] = subdoc;
              } catch (error2) {
                const valueInErrorMessage = util.inspect(value[i]);
                throw new CastError("embedded", valueInErrorMessage, value[arrayPathSymbol], error2, this);
              }
            }
          }
        }
      }
      return value;
    };
    DocumentArrayPath.prototype.clone = function() {
      const options2 = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, this.schema, options2, this.schemaOptions);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);
      return schematype;
    };
    DocumentArrayPath.prototype.applyGetters = function(value, scope) {
      return SchemaType.prototype.applyGetters.call(this, value, scope);
    };
    function scopePaths(array, fields, init2) {
      if (!(init2 && fields)) {
        return void 0;
      }
      const path = array.path + ".";
      const keys = Object.keys(fields);
      let i = keys.length;
      const selected = {};
      let hasKeys;
      let key;
      let sub;
      while (i--) {
        key = keys[i];
        if (key.startsWith(path)) {
          sub = key.substring(path.length);
          if (sub === "$") {
            continue;
          }
          if (sub.startsWith("$.")) {
            sub = sub.substr(2);
          }
          hasKeys || (hasKeys = true);
          selected[sub] = fields[key];
        }
      }
      return hasKeys && selected || void 0;
    }
    DocumentArrayPath.defaultOptions = {};
    DocumentArrayPath.set = SchemaType.set;
    module2.exports = DocumentArrayPath;
  }
});

// node_modules/mongoose/lib/options/SchemaSingleNestedOptions.js
var require_SchemaSingleNestedOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaSingleNestedOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaSingleNestedOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaSingleNestedOptions.prototype, "_id", opts);
    module2.exports = SchemaSingleNestedOptions;
  }
});

// node_modules/mongoose/lib/schema/SingleNestedPath.js
var require_SingleNestedPath = __commonJS({
  "node_modules/mongoose/lib/schema/SingleNestedPath.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CastError = require_cast();
    var EventEmitter = require("events").EventEmitter;
    var ObjectExpectedError = require_objectExpected();
    var SchemaSingleNestedOptions = require_SchemaSingleNestedOptions();
    var SchemaType = require_schematype();
    var $exists = require_exists();
    var castToNumber = require_helpers().castToNumber;
    var discriminator = require_discriminator();
    var geospatial = require_geospatial();
    var get2 = require_get();
    var getConstructor = require_getConstructor();
    var handleIdOption = require_handleIdOption();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var Subdocument;
    module2.exports = SingleNestedPath;
    function SingleNestedPath(schema, path, options2) {
      schema = handleIdOption(schema, options2);
      this.caster = _createConstructor(schema);
      this.caster.path = path;
      this.caster.prototype.$basePath = path;
      this.schema = schema;
      this.$isSingleNested = true;
      SchemaType.call(this, path, options2, "Embedded");
    }
    SingleNestedPath.prototype = Object.create(SchemaType.prototype);
    SingleNestedPath.prototype.constructor = SingleNestedPath;
    SingleNestedPath.prototype.OptionsConstructor = SchemaSingleNestedOptions;
    function _createConstructor(schema, baseClass) {
      Subdocument || (Subdocument = require_subdocument());
      const _embedded = function SingleNested(value, path, parent) {
        const _this = this;
        this.$__parent = parent;
        Subdocument.apply(this, arguments);
        this.$session(this.ownerDocument().$session());
        if (parent) {
          parent.on("save", function() {
            _this.emit("save", _this);
            _this.constructor.emit("save", _this);
          });
          parent.on("isNew", function(val) {
            _this.isNew = val;
            _this.emit("isNew", val);
            _this.constructor.emit("isNew", val);
          });
        }
      };
      const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
      _embedded.prototype = Object.create(proto);
      _embedded.prototype.$__setSchema(schema);
      _embedded.prototype.constructor = _embedded;
      _embedded.schema = schema;
      _embedded.$isSingleNested = true;
      _embedded.events = new EventEmitter();
      _embedded.prototype.toBSON = function() {
        return this.toObject(internalToObjectOptions);
      };
      for (const i in schema.methods) {
        _embedded.prototype[i] = schema.methods[i];
      }
      for (const i in schema.statics) {
        _embedded[i] = schema.statics[i];
      }
      for (const i in EventEmitter.prototype) {
        _embedded[i] = EventEmitter.prototype[i];
      }
      return _embedded;
    }
    SingleNestedPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {
      return { $geometry: this.castForQuery(val.$geometry) };
    };
    SingleNestedPath.prototype.$conditionalHandlers.$near = SingleNestedPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
    SingleNestedPath.prototype.$conditionalHandlers.$within = SingleNestedPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
    SingleNestedPath.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;
    SingleNestedPath.prototype.$conditionalHandlers.$minDistance = castToNumber;
    SingleNestedPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;
    SingleNestedPath.prototype.$conditionalHandlers.$exists = $exists;
    SingleNestedPath.prototype.cast = function(val, doc, init2, priorVal, options2) {
      if (val && val.$isSingleNested && val.parent === doc) {
        return val;
      }
      if (val != null && (typeof val !== "object" || Array.isArray(val))) {
        throw new ObjectExpectedError(this.path, val);
      }
      const Constructor = getConstructor(this.caster, val);
      let subdoc;
      const parentSelected = get2(doc, "$__.selected", {});
      const path = this.path;
      const selected = Object.keys(parentSelected).reduce((obj, key) => {
        if (key.startsWith(path + ".")) {
          obj[key.substr(path.length + 1)] = parentSelected[key];
        }
        return obj;
      }, {});
      options2 = Object.assign({}, options2, { priorDoc: priorVal });
      if (init2) {
        subdoc = new Constructor(void 0, selected, doc);
        subdoc.init(val);
      } else {
        if (Object.keys(val).length === 0) {
          return new Constructor({}, selected, doc, void 0, options2);
        }
        return new Constructor(val, selected, doc, void 0, options2);
      }
      return subdoc;
    };
    SingleNestedPath.prototype.castForQuery = function($conditional, val, options2) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional);
        }
        return handler.call(this, val);
      }
      val = $conditional;
      if (val == null) {
        return val;
      }
      if (this.options.runSetters) {
        val = this._applySetters(val);
      }
      const Constructor = getConstructor(this.caster, val);
      const overrideStrict = options2 != null && options2.strict != null ? options2.strict : void 0;
      try {
        val = new Constructor(val, overrideStrict);
      } catch (error2) {
        if (!(error2 instanceof CastError)) {
          throw new CastError("Embedded", val, this.path, error2, this);
        }
        throw error2;
      }
      return val;
    };
    SingleNestedPath.prototype.doValidate = function(value, fn, scope, options2) {
      const Constructor = getConstructor(this.caster, value);
      if (options2 && options2.skipSchemaValidators) {
        if (!(value instanceof Constructor)) {
          value = new Constructor(value, null, scope);
        }
        return value.validate(fn);
      }
      SchemaType.prototype.doValidate.call(this, value, function(error2) {
        if (error2) {
          return fn(error2);
        }
        if (!value) {
          return fn(null);
        }
        value.validate(fn);
      }, scope, options2);
    };
    SingleNestedPath.prototype.doValidateSync = function(value, scope, options2) {
      if (!options2 || !options2.skipSchemaValidators) {
        const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
        if (schemaTypeError) {
          return schemaTypeError;
        }
      }
      if (!value) {
        return;
      }
      return value.validateSync();
    };
    SingleNestedPath.prototype.discriminator = function(name, schema, value) {
      schema = discriminator(this.caster, name, schema, value);
      this.caster.discriminators[name] = _createConstructor(schema, this.caster);
      return this.caster.discriminators[name];
    };
    SingleNestedPath.defaultOptions = {};
    SingleNestedPath.set = SchemaType.set;
    SingleNestedPath.prototype.clone = function() {
      const options2 = Object.assign({}, this.options);
      const schematype = new this.constructor(this.schema, this.path, options2);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);
      return schematype;
    };
  }
});

// node_modules/mongoose/lib/options/SchemaBufferOptions.js
var require_SchemaBufferOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaBufferOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaBufferOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaBufferOptions.prototype, "subtype", opts);
    module2.exports = SchemaBufferOptions;
  }
});

// node_modules/mongoose/lib/schema/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/mongoose/lib/schema/buffer.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseBuffer = require_buffer();
    var SchemaBufferOptions = require_SchemaBufferOptions();
    var SchemaType = require_schematype();
    var handleBitwiseOperator = require_bitwise();
    var utils2 = require_utils6();
    var Binary2 = MongooseBuffer.Binary;
    var CastError = SchemaType.CastError;
    function SchemaBuffer(key, options2) {
      SchemaType.call(this, key, options2, "Buffer");
    }
    SchemaBuffer.schemaName = "Buffer";
    SchemaBuffer.defaultOptions = {};
    SchemaBuffer.prototype = Object.create(SchemaType.prototype);
    SchemaBuffer.prototype.constructor = SchemaBuffer;
    SchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;
    SchemaBuffer._checkRequired = (v) => !!(v && v.length);
    SchemaBuffer.set = SchemaType.set;
    SchemaBuffer.checkRequired = SchemaType.checkRequired;
    SchemaBuffer.prototype.checkRequired = function(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      return this.constructor._checkRequired(value);
    };
    SchemaBuffer.prototype.cast = function(value, doc, init2) {
      let ret2;
      if (SchemaType._isRef(this, value, doc, init2)) {
        if (value && value.isMongooseBuffer) {
          return value;
        }
        if (Buffer.isBuffer(value)) {
          if (!value || !value.isMongooseBuffer) {
            value = new MongooseBuffer(value, [this.path, doc]);
            if (this.options.subtype != null) {
              value._subtype = this.options.subtype;
            }
          }
          return value;
        }
        if (value instanceof Binary2) {
          ret2 = new MongooseBuffer(value.value(true), [this.path, doc]);
          if (typeof value.sub_type !== "number") {
            throw new CastError("Buffer", value, this.path, null, this);
          }
          ret2._subtype = value.sub_type;
          return ret2;
        }
        return this._castRef(value, doc, init2);
      }
      if (value && value._id) {
        value = value._id;
      }
      if (value && value.isMongooseBuffer) {
        return value;
      }
      if (Buffer.isBuffer(value)) {
        if (!value || !value.isMongooseBuffer) {
          value = new MongooseBuffer(value, [this.path, doc]);
          if (this.options.subtype != null) {
            value._subtype = this.options.subtype;
          }
        }
        return value;
      }
      if (value instanceof Binary2) {
        ret2 = new MongooseBuffer(value.value(true), [this.path, doc]);
        if (typeof value.sub_type !== "number") {
          throw new CastError("Buffer", value, this.path, null, this);
        }
        ret2._subtype = value.sub_type;
        return ret2;
      }
      if (value === null) {
        return value;
      }
      const type = typeof value;
      if (type === "string" || type === "number" || Array.isArray(value) || type === "object" && value.type === "Buffer" && Array.isArray(value.data)) {
        if (type === "number") {
          value = [value];
        }
        ret2 = new MongooseBuffer(value, [this.path, doc]);
        if (this.options.subtype != null) {
          ret2._subtype = this.options.subtype;
        }
        return ret2;
      }
      throw new CastError("Buffer", value, this.path, null, this);
    };
    SchemaBuffer.prototype.subtype = function(subtype) {
      this.options.subtype = subtype;
      return this;
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    SchemaBuffer.prototype.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $bitsAllClear: handleBitwiseOperator,
      $bitsAnyClear: handleBitwiseOperator,
      $bitsAllSet: handleBitwiseOperator,
      $bitsAnySet: handleBitwiseOperator,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    SchemaBuffer.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional + " with Buffer.");
        }
        return handler.call(this, val);
      }
      val = $conditional;
      const casted = this._castForQuery(val);
      return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;
    };
    module2.exports = SchemaBuffer;
  }
});

// node_modules/mongoose/lib/options/SchemaDateOptions.js
var require_SchemaDateOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaDateOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaDateOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaDateOptions.prototype, "min", opts);
    Object.defineProperty(SchemaDateOptions.prototype, "max", opts);
    Object.defineProperty(SchemaDateOptions.prototype, "expires", opts);
    module2.exports = SchemaDateOptions;
  }
});

// node_modules/mongoose/lib/cast/date.js
var require_date = __commonJS({
  "node_modules/mongoose/lib/cast/date.js"(exports2, module2) {
    init_shims();
    "use strict";
    var assert = require("assert");
    module2.exports = function castDate(value) {
      if (value == null || value === "") {
        return null;
      }
      if (value instanceof Date) {
        assert.ok(!isNaN(value.valueOf()));
        return value;
      }
      let date;
      assert.ok(typeof value !== "boolean");
      if (value instanceof Number || typeof value === "number") {
        date = new Date(value);
      } else if (typeof value === "string" && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {
        date = new Date(Number(value));
      } else if (typeof value.valueOf === "function") {
        date = new Date(value.valueOf());
      } else {
        date = new Date(value);
      }
      if (!isNaN(date.valueOf())) {
        return date;
      }
      assert.ok(false);
    };
  }
});

// node_modules/mongoose/lib/schema/date.js
var require_date2 = __commonJS({
  "node_modules/mongoose/lib/schema/date.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var SchemaDateOptions = require_SchemaDateOptions();
    var SchemaType = require_schematype();
    var castDate = require_date();
    var utils2 = require_utils6();
    var CastError = SchemaType.CastError;
    function SchemaDate(key, options2) {
      SchemaType.call(this, key, options2, "Date");
    }
    SchemaDate.schemaName = "Date";
    SchemaDate.defaultOptions = {};
    SchemaDate.prototype = Object.create(SchemaType.prototype);
    SchemaDate.prototype.constructor = SchemaDate;
    SchemaDate.prototype.OptionsConstructor = SchemaDateOptions;
    SchemaDate._cast = castDate;
    SchemaDate.set = SchemaType.set;
    SchemaDate.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaDate._defaultCaster = (v) => {
      if (v != null && !(v instanceof Date)) {
        throw new Error();
      }
      return v;
    };
    SchemaDate.prototype.expires = function(when) {
      if (!this._index || this._index.constructor.name !== "Object") {
        this._index = {};
      }
      this._index.expires = when;
      utils2.expires(this._index);
      return this;
    };
    SchemaDate._checkRequired = (v) => v instanceof Date;
    SchemaDate.checkRequired = SchemaType.checkRequired;
    SchemaDate.prototype.checkRequired = function(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaDate.checkRequired();
      return _checkRequired(value);
    };
    SchemaDate.prototype.min = function(value, message) {
      if (this.minValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minValidator;
        }, this);
      }
      if (value) {
        let msg = message || MongooseError.messages.Date.min;
        if (typeof msg === "string") {
          msg = msg.replace(/{MIN}/, value === Date.now ? "Date.now()" : value.toString());
        }
        const _this = this;
        this.validators.push({
          validator: this.minValidator = function(val) {
            let _value = value;
            if (typeof value === "function" && value !== Date.now) {
              _value = _value.call(this);
            }
            const min = _value === Date.now ? _value() : _this.cast(_value);
            return val === null || val.valueOf() >= min.valueOf();
          },
          message: msg,
          type: "min",
          min: value
        });
      }
      return this;
    };
    SchemaDate.prototype.max = function(value, message) {
      if (this.maxValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxValidator;
        }, this);
      }
      if (value) {
        let msg = message || MongooseError.messages.Date.max;
        if (typeof msg === "string") {
          msg = msg.replace(/{MAX}/, value === Date.now ? "Date.now()" : value.toString());
        }
        const _this = this;
        this.validators.push({
          validator: this.maxValidator = function(val) {
            let _value = value;
            if (typeof _value === "function" && _value !== Date.now) {
              _value = _value.call(this);
            }
            const max = _value === Date.now ? _value() : _this.cast(_value);
            return val === null || val.valueOf() <= max.valueOf();
          },
          message: msg,
          type: "max",
          max: value
        });
      }
      return this;
    };
    SchemaDate.prototype.cast = function(value) {
      let castDate2;
      if (typeof this._castFunction === "function") {
        castDate2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castDate2 = this.constructor.cast();
      } else {
        castDate2 = SchemaDate.cast();
      }
      try {
        return castDate2(value);
      } catch (error2) {
        throw new CastError("date", value, this.path, error2, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    SchemaDate.prototype.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    SchemaDate.prototype.castForQuery = function($conditional, val) {
      if (arguments.length !== 2) {
        return this._castForQuery($conditional);
      }
      const handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can't use " + $conditional + " with Date.");
      }
      return handler.call(this, val);
    };
    module2.exports = SchemaDate;
  }
});

// node_modules/mongoose/lib/options/SchemaObjectIdOptions.js
var require_SchemaObjectIdOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaObjectIdOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaObjectIdOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaObjectIdOptions.prototype, "auto", opts);
    Object.defineProperty(SchemaObjectIdOptions.prototype, "populate", opts);
    module2.exports = SchemaObjectIdOptions;
  }
});

// node_modules/mongoose/lib/schema/objectid.js
var require_objectid5 = __commonJS({
  "node_modules/mongoose/lib/schema/objectid.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaObjectIdOptions = require_SchemaObjectIdOptions();
    var SchemaType = require_schematype();
    var castObjectId = require_objectid4();
    var oid = require_objectid3();
    var utils2 = require_utils6();
    var CastError = SchemaType.CastError;
    var Document;
    function ObjectId2(key, options2) {
      const isKeyHexStr = typeof key === "string" && key.length === 24 && /^[a-f0-9]+$/i.test(key);
      const suppressWarning = options2 && options2.suppressWarning;
      if ((isKeyHexStr || typeof key === "undefined") && !suppressWarning) {
        console.warn("mongoose: To create a new ObjectId please try `Mongoose.Types.ObjectId` instead of using `Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if you're trying to create a hex char path in your schema.");
        console.trace();
      }
      SchemaType.call(this, key, options2, "ObjectID");
    }
    ObjectId2.schemaName = "ObjectId";
    ObjectId2.defaultOptions = {};
    ObjectId2.prototype = Object.create(SchemaType.prototype);
    ObjectId2.prototype.constructor = ObjectId2;
    ObjectId2.prototype.OptionsConstructor = SchemaObjectIdOptions;
    ObjectId2.get = SchemaType.get;
    ObjectId2.set = SchemaType.set;
    ObjectId2.prototype.auto = function(turnOn) {
      if (turnOn) {
        this.default(defaultId);
        this.set(resetId);
      }
      return this;
    };
    ObjectId2._checkRequired = (v) => v instanceof oid;
    ObjectId2._cast = castObjectId;
    ObjectId2.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    ObjectId2._defaultCaster = (v) => {
      if (!(v instanceof oid)) {
        throw new Error(v + " is not an instance of ObjectId");
      }
      return v;
    };
    ObjectId2.checkRequired = SchemaType.checkRequired;
    ObjectId2.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : ObjectId2.checkRequired();
      return _checkRequired(value);
    };
    ObjectId2.prototype.cast = function(value, doc, init2) {
      if (SchemaType._isRef(this, value, doc, init2)) {
        if (value instanceof oid) {
          return value;
        } else if (value != null && (value.constructor.name || "").toLowerCase() === "objectid") {
          return new oid(value.toHexString());
        }
        return this._castRef(value, doc, init2);
      }
      let castObjectId2;
      if (typeof this._castFunction === "function") {
        castObjectId2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castObjectId2 = this.constructor.cast();
      } else {
        castObjectId2 = ObjectId2.cast();
      }
      try {
        return castObjectId2(value);
      } catch (error2) {
        throw new CastError("ObjectId", value, this.path, error2, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    ObjectId2.prototype.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    function defaultId() {
      return new oid();
    }
    defaultId.$runBeforeSetters = true;
    function resetId(v) {
      Document || (Document = require_document());
      if (this instanceof Document) {
        if (v === void 0) {
          const _v = new oid();
          this.$__._id = _v;
          return _v;
        }
        this.$__._id = v;
      }
      return v;
    }
    module2.exports = ObjectId2;
  }
});

// node_modules/mongoose/lib/cast/decimal128.js
var require_decimal1283 = __commonJS({
  "node_modules/mongoose/lib/cast/decimal128.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Decimal128Type = require_decimal1282();
    var assert = require("assert");
    module2.exports = function castDecimal128(value) {
      if (value == null) {
        return value;
      }
      if (typeof value === "object" && typeof value.$numberDecimal === "string") {
        return Decimal128Type.fromString(value.$numberDecimal);
      }
      if (value instanceof Decimal128Type) {
        return value;
      }
      if (typeof value === "string") {
        return Decimal128Type.fromString(value);
      }
      if (Buffer.isBuffer(value)) {
        return new Decimal128Type(value);
      }
      if (typeof value === "number") {
        return Decimal128Type.fromString(String(value));
      }
      if (typeof value.valueOf === "function" && typeof value.valueOf() === "string") {
        return Decimal128Type.fromString(value.valueOf());
      }
      assert.ok(false);
    };
  }
});

// node_modules/mongoose/lib/schema/decimal128.js
var require_decimal1284 = __commonJS({
  "node_modules/mongoose/lib/schema/decimal128.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaType = require_schematype();
    var CastError = SchemaType.CastError;
    var Decimal128Type = require_decimal1282();
    var castDecimal128 = require_decimal1283();
    var utils2 = require_utils6();
    function Decimal1282(key, options2) {
      SchemaType.call(this, key, options2, "Decimal128");
    }
    Decimal1282.schemaName = "Decimal128";
    Decimal1282.defaultOptions = {};
    Decimal1282.prototype = Object.create(SchemaType.prototype);
    Decimal1282.prototype.constructor = Decimal1282;
    Decimal1282._cast = castDecimal128;
    Decimal1282.set = SchemaType.set;
    Decimal1282.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    Decimal1282._defaultCaster = (v) => {
      if (v != null && !(v instanceof Decimal128Type)) {
        throw new Error();
      }
      return v;
    };
    Decimal1282._checkRequired = (v) => v instanceof Decimal128Type;
    Decimal1282.checkRequired = SchemaType.checkRequired;
    Decimal1282.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : Decimal1282.checkRequired();
      return _checkRequired(value);
    };
    Decimal1282.prototype.cast = function(value, doc, init2) {
      if (SchemaType._isRef(this, value, doc, init2)) {
        if (value instanceof Decimal128Type) {
          return value;
        }
        return this._castRef(value, doc, init2);
      }
      let castDecimal1282;
      if (typeof this._castFunction === "function") {
        castDecimal1282 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castDecimal1282 = this.constructor.cast();
      } else {
        castDecimal1282 = Decimal1282.cast();
      }
      try {
        return castDecimal1282(value);
      } catch (error2) {
        throw new CastError("Decimal128", value, this.path, error2, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    Decimal1282.prototype.$conditionalHandlers = utils2.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    module2.exports = Decimal1282;
  }
});

// node_modules/mongoose/lib/options/SchemaMapOptions.js
var require_SchemaMapOptions = __commonJS({
  "node_modules/mongoose/lib/options/SchemaMapOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaMapOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaMapOptions.prototype, "of", opts);
    module2.exports = SchemaMapOptions;
  }
});

// node_modules/mongoose/lib/schema/map.js
var require_map4 = __commonJS({
  "node_modules/mongoose/lib/schema/map.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseMap = require_map3();
    var SchemaMapOptions = require_SchemaMapOptions();
    var SchemaType = require_schematype();
    var Map2 = class extends SchemaType {
      constructor(key, options2) {
        super(key, options2, "Map");
        this.$isSchemaMap = true;
      }
      set(option, value) {
        return SchemaType.set(option, value);
      }
      cast(val, doc, init2) {
        if (val instanceof MongooseMap) {
          return val;
        }
        const path = this.path;
        if (init2) {
          const map = new MongooseMap({}, path, doc, this.$__schemaType);
          if (val instanceof global.Map) {
            for (const key of val.keys()) {
              let _val = val.get(key);
              if (_val == null) {
                _val = map.$__schemaType._castNullish(_val);
              } else {
                _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
              }
              map.$init(key, _val);
            }
          } else {
            for (const key of Object.keys(val)) {
              let _val = val[key];
              if (_val == null) {
                _val = map.$__schemaType._castNullish(_val);
              } else {
                _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
              }
              map.$init(key, _val);
            }
          }
          return map;
        }
        return new MongooseMap(val, path, doc, this.$__schemaType);
      }
      clone() {
        const schematype = super.clone();
        if (this.$__schemaType != null) {
          schematype.$__schemaType = this.$__schemaType.clone();
        }
        return schematype;
      }
    };
    Map2.prototype.OptionsConstructor = SchemaMapOptions;
    Map2.defaultOptions = {};
    module2.exports = Map2;
  }
});

// node_modules/mongoose/lib/schema/index.js
var require_schema = __commonJS({
  "node_modules/mongoose/lib/schema/index.js"(exports2) {
    init_shims();
    "use strict";
    exports2.String = require_string2();
    exports2.Number = require_number2();
    exports2.Boolean = require_boolean2();
    exports2.DocumentArray = require_documentarray2();
    exports2.Embedded = require_SingleNestedPath();
    exports2.Array = require_array2();
    exports2.Buffer = require_buffer2();
    exports2.Date = require_date2();
    exports2.ObjectId = require_objectid5();
    exports2.Mixed = require_mixed();
    exports2.Decimal128 = exports2.Decimal = require_decimal1284();
    exports2.Map = require_map4();
    exports2.Oid = exports2.ObjectId;
    exports2.Object = exports2.Mixed;
    exports2.Bool = exports2.Boolean;
    exports2.ObjectID = exports2.ObjectId;
  }
});

// node_modules/mongoose/lib/schema.js
var require_schema2 = __commonJS({
  "node_modules/mongoose/lib/schema.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var Kareem = require_kareem();
    var MongooseError = require_mongooseError();
    var SchemaType = require_schematype();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var VirtualOptions = require_VirtualOptions();
    var VirtualType = require_virtualtype();
    var addAutoId = require_addAutoId();
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var get2 = require_get();
    var getIndexes = require_getIndexes();
    var merge = require_merge();
    var mpath = require_mpath();
    var readPref = require_driver().get().ReadPreference;
    var setupTimestamps = require_setupTimestamps();
    var util = require("util");
    var utils2 = require_utils6();
    var validateRef = require_validateRef();
    var MongooseTypes;
    var queryHooks = require_applyQueryMiddleware().middlewareFunctions;
    var documentHooks = require_applyHooks().middlewareFunctions;
    var hookNames = queryHooks.concat(documentHooks).reduce((s2, hook) => s2.add(hook), new Set());
    var id = 0;
    function Schema(obj, options2) {
      if (!(this instanceof Schema)) {
        return new Schema(obj, options2);
      }
      this.obj = obj;
      this.paths = {};
      this.aliases = {};
      this.subpaths = {};
      this.virtuals = {};
      this.singleNestedPaths = {};
      this.nested = {};
      this.inherits = {};
      this.callQueue = [];
      this._indexes = [];
      this.methods = {};
      this.methodOptions = {};
      this.statics = {};
      this.tree = {};
      this.query = {};
      this.childSchemas = [];
      this.plugins = [];
      this.$id = ++id;
      this.mapPaths = [];
      this.s = {
        hooks: new Kareem()
      };
      this.options = this.defaultOptions(options2);
      if (Array.isArray(obj)) {
        for (const definition of obj) {
          this.add(definition);
        }
      } else if (obj) {
        this.add(obj);
      }
      const _idSubDoc = obj && obj._id && utils2.isObject(obj._id);
      const auto_id = !this.paths["_id"] && (!this.options.noId && this.options._id) && !_idSubDoc;
      if (auto_id) {
        addAutoId(this);
      }
      this.setupTimestamp(this.options.timestamps);
    }
    function aliasFields(schema, paths) {
      paths = paths || Object.keys(schema.paths);
      for (const path of paths) {
        const options2 = get2(schema.paths[path], "options");
        if (options2 == null) {
          continue;
        }
        const prop = schema.paths[path].path;
        const alias = options2.alias;
        if (!alias) {
          continue;
        }
        if (typeof alias !== "string") {
          throw new Error("Invalid value for alias option on " + prop + ", got " + alias);
        }
        schema.aliases[alias] = prop;
        schema.virtual(alias).get(function(p) {
          return function() {
            if (typeof this.get === "function") {
              return this.get(p);
            }
            return this[p];
          };
        }(prop)).set(function(p) {
          return function(v) {
            return this.$set(p, v);
          };
        }(prop));
      }
    }
    Schema.prototype = Object.create(EventEmitter.prototype);
    Schema.prototype.constructor = Schema;
    Schema.prototype.instanceOfSchema = true;
    Object.defineProperty(Schema.prototype, "$schemaType", {
      configurable: false,
      enumerable: false,
      writable: true
    });
    Object.defineProperty(Schema.prototype, "childSchemas", {
      configurable: false,
      enumerable: true,
      writable: true
    });
    Schema.prototype.obj;
    Schema.prototype.paths;
    Schema.prototype.tree;
    Schema.prototype.clone = function() {
      const Constructor = this.base == null ? Schema : this.base.Schema;
      const s2 = new Constructor({}, this._userProvidedOptions);
      s2.base = this.base;
      s2.obj = this.obj;
      s2.options = utils2.clone(this.options);
      s2.callQueue = this.callQueue.map(function(f) {
        return f;
      });
      s2.methods = utils2.clone(this.methods);
      s2.methodOptions = utils2.clone(this.methodOptions);
      s2.statics = utils2.clone(this.statics);
      s2.query = utils2.clone(this.query);
      s2.plugins = Array.prototype.slice.call(this.plugins);
      s2._indexes = utils2.clone(this._indexes);
      s2.s.hooks = this.s.hooks.clone();
      s2.tree = utils2.clone(this.tree);
      s2.paths = utils2.clone(this.paths);
      s2.nested = utils2.clone(this.nested);
      s2.subpaths = utils2.clone(this.subpaths);
      s2.singleNestedPaths = utils2.clone(this.singleNestedPaths);
      s2.childSchemas = gatherChildSchemas(s2);
      s2.virtuals = utils2.clone(this.virtuals);
      s2.$globalPluginsApplied = this.$globalPluginsApplied;
      s2.$isRootDiscriminator = this.$isRootDiscriminator;
      s2.$implicitlyCreated = this.$implicitlyCreated;
      s2.mapPaths = [].concat(this.mapPaths);
      if (this.discriminatorMapping != null) {
        s2.discriminatorMapping = Object.assign({}, this.discriminatorMapping);
      }
      if (this.discriminators != null) {
        s2.discriminators = Object.assign({}, this.discriminators);
      }
      s2.aliases = Object.assign({}, this.aliases);
      s2.on("init", (v) => this.emit("init", v));
      return s2;
    };
    Schema.prototype.pick = function(paths, options2) {
      const newSchema = new Schema({}, options2 || this.options);
      if (!Array.isArray(paths)) {
        throw new MongooseError('Schema#pick() only accepts an array argument, got "' + typeof paths + '"');
      }
      for (const path of paths) {
        if (this.nested[path]) {
          newSchema.add({ [path]: get2(this.tree, path) });
        } else {
          const schematype = this.path(path);
          if (schematype == null) {
            throw new MongooseError("Path `" + path + "` is not in the schema");
          }
          newSchema.add({ [path]: schematype });
        }
      }
      return newSchema;
    };
    Schema.prototype.defaultOptions = function(options2) {
      if (options2 && options2.safe === false) {
        options2.safe = { w: 0 };
      }
      if (options2 && options2.safe && options2.safe.w === 0) {
        options2.versionKey = false;
      }
      this._userProvidedOptions = options2 == null ? {} : utils2.clone(options2);
      const baseOptions = get2(this, "base.options", {});
      options2 = utils2.options({
        strict: "strict" in baseOptions ? baseOptions.strict : true,
        strictQuery: "strictQuery" in baseOptions ? baseOptions.strictQuery : false,
        bufferCommands: true,
        capped: false,
        versionKey: "__v",
        optimisticConcurrency: false,
        discriminatorKey: "__t",
        minimize: true,
        autoIndex: null,
        shardKey: null,
        read: null,
        validateBeforeSave: true,
        noId: false,
        _id: true,
        noVirtualId: false,
        id: true,
        typeKey: "type",
        typePojoToMixed: "typePojoToMixed" in baseOptions ? baseOptions.typePojoToMixed : true
      }, utils2.clone(options2));
      if (options2.read) {
        options2.read = readPref(options2.read);
      }
      if (options2.optimisticConcurrency && !options2.versionKey) {
        throw new MongooseError("Must set `versionKey` if using `optimisticConcurrency`");
      }
      return options2;
    };
    Schema.prototype.add = function add(obj, prefix) {
      if (obj instanceof Schema || obj != null && obj.instanceOfSchema) {
        merge(this, obj);
        return this;
      }
      if (obj._id === false && prefix == null) {
        this.options._id = false;
      }
      prefix = prefix || "";
      if (prefix === "__proto__." || prefix === "constructor." || prefix === "prototype.") {
        return this;
      }
      const keys = Object.keys(obj);
      for (const key of keys) {
        const fullPath = prefix + key;
        if (obj[key] == null) {
          throw new TypeError("Invalid value for schema path `" + fullPath + '`, got value "' + obj[key] + '"');
        }
        if (key === "_id" && obj[key] === false) {
          continue;
        }
        if (obj[key] instanceof VirtualType || get2(obj[key], "constructor.name", null) === "VirtualType") {
          this.virtual(obj[key]);
          continue;
        }
        if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) {
          throw new TypeError("Invalid value for schema Array path `" + fullPath + '`, got value "' + obj[key][0] + '"');
        }
        if (!(utils2.isPOJO(obj[key]) || obj[key] instanceof SchemaTypeOptions)) {
          if (prefix) {
            this.nested[prefix.substr(0, prefix.length - 1)] = true;
          }
          this.path(prefix + key, obj[key]);
        } else if (Object.keys(obj[key]).length < 1) {
          if (prefix) {
            this.nested[prefix.substr(0, prefix.length - 1)] = true;
          }
          this.path(fullPath, obj[key]);
        } else if (!obj[key][this.options.typeKey] || this.options.typeKey === "type" && obj[key].type.type) {
          this.nested[fullPath] = true;
          this.add(obj[key], fullPath + ".");
        } else {
          if (!this.options.typePojoToMixed && utils2.isPOJO(obj[key][this.options.typeKey])) {
            if (prefix) {
              this.nested[prefix.substr(0, prefix.length - 1)] = true;
            }
            const opts = { typePojoToMixed: false };
            const _schema = new Schema(obj[key][this.options.typeKey], opts);
            const schemaWrappedPath = Object.assign({}, obj[key], { [this.options.typeKey]: _schema });
            this.path(prefix + key, schemaWrappedPath);
          } else {
            if (prefix) {
              this.nested[prefix.substr(0, prefix.length - 1)] = true;
            }
            this.path(prefix + key, obj[key]);
          }
        }
      }
      const addedKeys = Object.keys(obj).map((key) => prefix ? prefix + key : key);
      aliasFields(this, addedKeys);
      return this;
    };
    Schema.reserved = Object.create(null);
    Schema.prototype.reserved = Schema.reserved;
    var reserved2 = Schema.reserved;
    reserved2["prototype"] = reserved2.emit = reserved2.listeners = reserved2.on = reserved2.removeListener = reserved2.collection = reserved2.errors = reserved2.get = reserved2.init = reserved2.isModified = reserved2.isNew = reserved2.populated = reserved2.remove = reserved2.save = reserved2.toObject = reserved2.validate = 1;
    Schema.prototype.path = function(path, obj) {
      const cleanPath = _pathToPositionalSyntax(path);
      if (obj === void 0) {
        let schematype = _getPath(this, path, cleanPath);
        if (schematype != null) {
          return schematype;
        }
        const mapPath = getMapPath(this, path);
        if (mapPath != null) {
          return mapPath;
        }
        schematype = this.hasMixedParent(cleanPath);
        if (schematype != null) {
          return schematype;
        }
        return /\.\d+\.?.*$/.test(path) ? getPositionalPath(this, path) : void 0;
      }
      const firstPieceOfPath = path.split(".")[0];
      if (reserved2[firstPieceOfPath]) {
        throw new Error("`" + firstPieceOfPath + "` may not be used as a schema pathname");
      }
      if (typeof obj === "object" && utils2.hasUserDefinedProperty(obj, "ref")) {
        validateRef(obj.ref, path);
      }
      const subpaths = path.split(/\./);
      const last = subpaths.pop();
      let branch = this.tree;
      let fullPath = "";
      for (const sub of subpaths) {
        fullPath = fullPath += (fullPath.length > 0 ? "." : "") + sub;
        if (!branch[sub]) {
          this.nested[fullPath] = true;
          branch[sub] = {};
        }
        if (typeof branch[sub] !== "object") {
          const msg = "Cannot set nested path `" + path + "`. Parent path `" + fullPath + "` already set to type " + branch[sub].name + ".";
          throw new Error(msg);
        }
        branch = branch[sub];
      }
      branch[last] = utils2.clone(obj);
      this.paths[path] = this.interpretAsType(path, obj, this.options);
      const schemaType = this.paths[path];
      if (schemaType.$isSchemaMap) {
        const mapPath = path + ".$*";
        let _mapType = { type: {} };
        if (utils2.hasUserDefinedProperty(obj, "of")) {
          const isInlineSchema = utils2.isPOJO(obj.of) && Object.keys(obj.of).length > 0 && !utils2.hasUserDefinedProperty(obj.of, this.options.typeKey);
          _mapType = isInlineSchema ? new Schema(obj.of) : obj.of;
        }
        if (utils2.hasUserDefinedProperty(obj, "ref")) {
          _mapType = { type: _mapType, ref: obj.ref };
        }
        this.paths[mapPath] = this.interpretAsType(mapPath, _mapType, this.options);
        this.mapPaths.push(this.paths[mapPath]);
        schemaType.$__schemaType = this.paths[mapPath];
      }
      if (schemaType.$isSingleNested) {
        for (const key of Object.keys(schemaType.schema.paths)) {
          this.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          this.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          this.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
        }
        for (const key of Object.keys(schemaType.schema.nested)) {
          this.singleNestedPaths[path + "." + key] = "nested";
        }
        Object.defineProperty(schemaType.schema, "base", {
          configurable: true,
          enumerable: false,
          writable: false,
          value: this.base
        });
        schemaType.caster.base = this.base;
        this.childSchemas.push({
          schema: schemaType.schema,
          model: schemaType.caster
        });
      } else if (schemaType.$isMongooseDocumentArray) {
        Object.defineProperty(schemaType.schema, "base", {
          configurable: true,
          enumerable: false,
          writable: false,
          value: this.base
        });
        schemaType.casterConstructor.base = this.base;
        this.childSchemas.push({
          schema: schemaType.schema,
          model: schemaType.casterConstructor
        });
      }
      if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {
        let arrayPath = path;
        let _schemaType = schemaType;
        const toAdd = [];
        while (_schemaType.$isMongooseArray) {
          arrayPath = arrayPath + ".$";
          if (_schemaType.$isMongooseDocumentArray) {
            _schemaType.$embeddedSchemaType._arrayPath = arrayPath;
            _schemaType.$embeddedSchemaType._arrayParentPath = path;
            _schemaType = _schemaType.$embeddedSchemaType.clone();
          } else {
            _schemaType.caster._arrayPath = arrayPath;
            _schemaType.caster._arrayParentPath = path;
            _schemaType = _schemaType.caster.clone();
          }
          _schemaType.path = arrayPath;
          toAdd.push(_schemaType);
        }
        for (const _schemaType2 of toAdd) {
          this.subpaths[_schemaType2.path] = _schemaType2;
        }
      }
      if (schemaType.$isMongooseDocumentArray) {
        for (const key of Object.keys(schemaType.schema.paths)) {
          const _schemaType = schemaType.schema.paths[key];
          this.subpaths[path + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          const _schemaType = schemaType.schema.subpaths[key];
          this.subpaths[path + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          const _schemaType = schemaType.schema.singleNestedPaths[key];
          this.subpaths[path + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
      }
      return this;
    };
    function gatherChildSchemas(schema) {
      const childSchemas = [];
      for (const path of Object.keys(schema.paths)) {
        const schematype = schema.paths[path];
        if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {
          childSchemas.push({ schema: schematype.schema, model: schematype.caster });
        }
      }
      return childSchemas;
    }
    function _getPath(schema, path, cleanPath) {
      if (schema.paths.hasOwnProperty(path)) {
        return schema.paths[path];
      }
      if (schema.subpaths.hasOwnProperty(cleanPath)) {
        return schema.subpaths[cleanPath];
      }
      if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === "object") {
        return schema.singleNestedPaths[cleanPath];
      }
      return null;
    }
    function _pathToPositionalSyntax(path) {
      if (!/\.\d+/.test(path)) {
        return path;
      }
      return path.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$");
    }
    function getMapPath(schema, path) {
      if (schema.mapPaths.length === 0) {
        return null;
      }
      for (const val of schema.mapPaths) {
        const _path = val.path;
        const re = new RegExp("^" + _path.replace(/\.\$\*/g, "\\.[^.]+") + "$");
        if (re.test(path)) {
          return schema.paths[_path];
        }
      }
      return null;
    }
    Object.defineProperty(Schema.prototype, "base", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: null
    });
    Schema.prototype.interpretAsType = function(path, obj, options2) {
      if (obj instanceof SchemaType) {
        if (obj.path === path) {
          return obj;
        }
        const clone2 = obj.clone();
        clone2.path = path;
        return clone2;
      }
      const MongooseTypes2 = this.base != null ? this.base.Schema.Types : Schema.Types;
      if (!utils2.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {
        const constructorName = utils2.getFunctionName(obj.constructor);
        if (constructorName !== "Object") {
          const oldObj = obj;
          obj = {};
          obj[options2.typeKey] = oldObj;
        }
      }
      let type = obj[options2.typeKey] && (options2.typeKey !== "type" || !obj.type.type) ? obj[options2.typeKey] : {};
      let name;
      if (utils2.isPOJO(type) || type === "mixed") {
        return new MongooseTypes2.Mixed(path, obj);
      }
      if (Array.isArray(type) || type === Array || type === "array" || type === MongooseTypes2.Array) {
        let cast = type === Array || type === "array" ? obj.cast || obj.of : type[0];
        if (cast && cast.instanceOfSchema) {
          return new MongooseTypes2.DocumentArray(path, cast, obj);
        }
        if (cast && cast[options2.typeKey] && cast[options2.typeKey].instanceOfSchema) {
          return new MongooseTypes2.DocumentArray(path, cast[options2.typeKey], obj, cast);
        }
        if (Array.isArray(cast)) {
          return new MongooseTypes2.Array(path, this.interpretAsType(path, cast, options2), obj);
        }
        if (typeof cast === "string") {
          cast = MongooseTypes2[cast.charAt(0).toUpperCase() + cast.substring(1)];
        } else if (cast && (!cast[options2.typeKey] || options2.typeKey === "type" && cast.type.type) && utils2.isPOJO(cast)) {
          if (Object.keys(cast).length) {
            const childSchemaOptions = { minimize: options2.minimize };
            if (options2.typeKey) {
              childSchemaOptions.typeKey = options2.typeKey;
            }
            if (options2.hasOwnProperty("strict")) {
              childSchemaOptions.strict = options2.strict;
            }
            if (options2.hasOwnProperty("typePojoToMixed")) {
              childSchemaOptions.typePojoToMixed = options2.typePojoToMixed;
            }
            if (this._userProvidedOptions.hasOwnProperty("_id")) {
              childSchemaOptions._id = this._userProvidedOptions._id;
            } else if (Schema.Types.DocumentArray.defaultOptions && Schema.Types.DocumentArray.defaultOptions._id != null) {
              childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;
            }
            const childSchema = new Schema(cast, childSchemaOptions);
            childSchema.$implicitlyCreated = true;
            return new MongooseTypes2.DocumentArray(path, childSchema, obj);
          } else {
            return new MongooseTypes2.Array(path, MongooseTypes2.Mixed, obj);
          }
        }
        if (cast) {
          type = cast[options2.typeKey] && (options2.typeKey !== "type" || !cast.type.type) ? cast[options2.typeKey] : cast;
          name = typeof type === "string" ? type : type.schemaName || utils2.getFunctionName(type);
          if (name === "ClockDate") {
            name = "Date";
          }
          if (!MongooseTypes2.hasOwnProperty(name)) {
            throw new TypeError(`Invalid schema configuration: \`${name}\` is not a valid type within the array \`${path}\`.See http://bit.ly/mongoose-schematypes for a list of valid schema types.`);
          }
        }
        return new MongooseTypes2.Array(path, cast || MongooseTypes2.Mixed, obj, options2);
      }
      if (type && type.instanceOfSchema) {
        return new MongooseTypes2.Embedded(type, path, obj);
      }
      if (Buffer.isBuffer(type)) {
        name = "Buffer";
      } else if (typeof type === "function" || typeof type === "object") {
        name = type.schemaName || utils2.getFunctionName(type);
      } else {
        name = type == null ? "" + type : type.toString();
      }
      if (name) {
        name = name.charAt(0).toUpperCase() + name.substring(1);
      }
      if (name === "ObjectID") {
        name = "ObjectId";
      }
      if (name === "ClockDate") {
        name = "Date";
      }
      if (MongooseTypes2[name] == null) {
        throw new TypeError(`Invalid schema configuration: \`${name}\` is not a valid type at path \`${path}\`. See http://bit.ly/mongoose-schematypes for a list of valid schema types.`);
      }
      return new MongooseTypes2[name](path, obj);
    };
    Schema.prototype.eachPath = function(fn) {
      const keys = Object.keys(this.paths);
      const len = keys.length;
      for (let i = 0; i < len; ++i) {
        fn(keys[i], this.paths[keys[i]]);
      }
      return this;
    };
    Schema.prototype.requiredPaths = function requiredPaths(invalidate) {
      if (this._requiredpaths && !invalidate) {
        return this._requiredpaths;
      }
      const paths = Object.keys(this.paths);
      let i = paths.length;
      const ret2 = [];
      while (i--) {
        const path = paths[i];
        if (this.paths[path].isRequired) {
          ret2.push(path);
        }
      }
      this._requiredpaths = ret2;
      return this._requiredpaths;
    };
    Schema.prototype.indexedPaths = function indexedPaths() {
      if (this._indexedpaths) {
        return this._indexedpaths;
      }
      this._indexedpaths = this.indexes();
      return this._indexedpaths;
    };
    Schema.prototype.pathType = function(path) {
      const cleanPath = _pathToPositionalSyntax(path);
      if (this.paths.hasOwnProperty(path)) {
        return "real";
      }
      if (this.virtuals.hasOwnProperty(path)) {
        return "virtual";
      }
      if (this.nested.hasOwnProperty(path)) {
        return "nested";
      }
      if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {
        return "real";
      }
      const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);
      if (singleNestedPath) {
        return singleNestedPath === "nested" ? "nested" : "real";
      }
      const mapPath = getMapPath(this, path);
      if (mapPath != null) {
        return "real";
      }
      if (/\.\d+\.|\.\d+$/.test(path)) {
        return getPositionalPathType(this, path);
      }
      return "adhocOrUndefined";
    };
    Schema.prototype.hasMixedParent = function(path) {
      const subpaths = path.split(/\./g);
      path = "";
      for (let i = 0; i < subpaths.length; ++i) {
        path = i > 0 ? path + "." + subpaths[i] : subpaths[i];
        if (this.paths.hasOwnProperty(path) && this.paths[path] instanceof MongooseTypes.Mixed) {
          return this.paths[path];
        }
      }
      return null;
    };
    Schema.prototype.setupTimestamp = function(timestamps) {
      return setupTimestamps(this, timestamps);
    };
    function getPositionalPathType(self2, path) {
      const subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
      if (subpaths.length < 2) {
        return self2.paths.hasOwnProperty(subpaths[0]) ? self2.paths[subpaths[0]] : "adhocOrUndefined";
      }
      let val = self2.path(subpaths[0]);
      let isNested = false;
      if (!val) {
        return "adhocOrUndefined";
      }
      const last = subpaths.length - 1;
      for (let i = 1; i < subpaths.length; ++i) {
        isNested = false;
        const subpath = subpaths[i];
        if (i === last && val && !/\D/.test(subpath)) {
          if (val.$isMongooseDocumentArray) {
            val = val.$embeddedSchemaType;
          } else if (val instanceof MongooseTypes.Array) {
            val = val.caster;
          } else {
            val = void 0;
          }
          break;
        }
        if (!/\D/.test(subpath)) {
          if (val instanceof MongooseTypes.Array && i !== last) {
            val = val.caster;
          }
          continue;
        }
        if (!(val && val.schema)) {
          val = void 0;
          break;
        }
        const type = val.schema.pathType(subpath);
        isNested = type === "nested";
        val = val.schema.path(subpath);
      }
      self2.subpaths[path] = val;
      if (val) {
        return "real";
      }
      if (isNested) {
        return "nested";
      }
      return "adhocOrUndefined";
    }
    function getPositionalPath(self2, path) {
      getPositionalPathType(self2, path);
      return self2.subpaths[path];
    }
    Schema.prototype.queue = function(name, args) {
      this.callQueue.push([name, args]);
      return this;
    };
    Schema.prototype.pre = function(name) {
      if (name instanceof RegExp) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const fn of hookNames) {
          if (name.test(fn)) {
            this.pre.apply(this, [fn].concat(remainingArgs));
          }
        }
        return this;
      }
      if (Array.isArray(name)) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const el of name) {
          this.pre.apply(this, [el].concat(remainingArgs));
        }
        return this;
      }
      this.s.hooks.pre.apply(this.s.hooks, arguments);
      return this;
    };
    Schema.prototype.post = function(name) {
      if (name instanceof RegExp) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const fn of hookNames) {
          if (name.test(fn)) {
            this.post.apply(this, [fn].concat(remainingArgs));
          }
        }
        return this;
      }
      if (Array.isArray(name)) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const el of name) {
          this.post.apply(this, [el].concat(remainingArgs));
        }
        return this;
      }
      this.s.hooks.post.apply(this.s.hooks, arguments);
      return this;
    };
    Schema.prototype.plugin = function(fn, opts) {
      if (typeof fn !== "function") {
        throw new Error('First param to `schema.plugin()` must be a function, got "' + typeof fn + '"');
      }
      if (opts && opts.deduplicate) {
        for (const plugin of this.plugins) {
          if (plugin.fn === fn) {
            return this;
          }
        }
      }
      this.plugins.push({ fn, opts });
      fn(this, opts);
      return this;
    };
    Schema.prototype.method = function(name, fn, options2) {
      if (typeof name !== "string") {
        for (const i in name) {
          this.methods[i] = name[i];
          this.methodOptions[i] = utils2.clone(options2);
        }
      } else {
        this.methods[name] = fn;
        this.methodOptions[name] = utils2.clone(options2);
      }
      return this;
    };
    Schema.prototype.static = function(name, fn) {
      if (typeof name !== "string") {
        for (const i in name) {
          this.statics[i] = name[i];
        }
      } else {
        this.statics[name] = fn;
      }
      return this;
    };
    Schema.prototype.index = function(fields, options2) {
      fields || (fields = {});
      options2 || (options2 = {});
      if (options2.expires) {
        utils2.expires(options2);
      }
      this._indexes.push([fields, options2]);
      return this;
    };
    Schema.prototype.set = function(key, value, _tags) {
      if (arguments.length === 1) {
        return this.options[key];
      }
      switch (key) {
        case "read":
          this.options[key] = readPref(value, _tags);
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "safe":
          setSafe(this.options, value);
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "timestamps":
          this.setupTimestamp(value);
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "_id":
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          if (value && !this.paths["_id"]) {
            addAutoId(this);
          } else if (!value && this.paths["_id"] != null && this.paths["_id"].auto) {
            this.remove("_id");
          }
          break;
        default:
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          break;
      }
      return this;
    };
    var safeDeprecationWarning = "Mongoose: The `safe` option for schemas is deprecated. Use the `writeConcern` option instead: http://bit.ly/mongoose-write-concern";
    var setSafe = util.deprecate(function setSafe2(options2, value) {
      options2.safe = value === false ? { w: 0 } : value;
    }, safeDeprecationWarning);
    Schema.prototype.get = function(key) {
      return this.options[key];
    };
    var indexTypes = "2d 2dsphere hashed text".split(" ");
    Object.defineProperty(Schema, "indexTypes", {
      get: function() {
        return indexTypes;
      },
      set: function() {
        throw new Error("Cannot overwrite Schema.indexTypes");
      }
    });
    Schema.prototype.indexes = function() {
      return getIndexes(this);
    };
    Schema.prototype.virtual = function(name, options2) {
      if (name instanceof VirtualType || name != null && name.constructor.name === "VirtualType") {
        return this.virtual(name.path, name.options);
      }
      options2 = new VirtualOptions(options2);
      if (utils2.hasUserDefinedProperty(options2, ["ref", "refPath"])) {
        if (options2.localField == null) {
          throw new Error("Reference virtuals require `localField` option");
        }
        if (options2.foreignField == null) {
          throw new Error("Reference virtuals require `foreignField` option");
        }
        this.pre("init", function(obj) {
          if (mpath.has(name, obj)) {
            const _v = mpath.get(name, obj);
            if (!this.$$populatedVirtuals) {
              this.$$populatedVirtuals = {};
            }
            if (options2.justOne || options2.count) {
              this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
            } else {
              this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
            }
            mpath.unset(name, obj);
          }
        });
        const virtual = this.virtual(name);
        virtual.options = options2;
        virtual.set(function(_v) {
          if (!this.$$populatedVirtuals) {
            this.$$populatedVirtuals = {};
          }
          if (options2.justOne || options2.count) {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
            if (typeof this.$$populatedVirtuals[name] !== "object") {
              this.$$populatedVirtuals[name] = options2.count ? _v : null;
            }
          } else {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
            this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {
              return doc && typeof doc === "object";
            });
          }
        });
        if (typeof options2.get === "function") {
          virtual.get(options2.get);
        }
        return virtual;
      }
      const virtuals = this.virtuals;
      const parts = name.split(".");
      if (this.pathType(name) === "real") {
        throw new Error('Virtual path "' + name + '" conflicts with a real path in the schema');
      }
      virtuals[name] = parts.reduce(function(mem, part, i) {
        mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options2, name) : {});
        return mem[part];
      }, this.tree);
      let cur = parts[0];
      for (let i = 0; i < parts.length - 1; ++i) {
        if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {
          const remnant = parts.slice(i + 1).join(".");
          const v = this.paths[cur].schema.virtual(remnant);
          v.get((v2, virtual, doc) => {
            const parent = doc.__parentArray[arrayParentSymbol];
            const path = cur + "." + doc.__index + "." + remnant;
            return parent.get(path);
          });
          break;
        }
        cur += "." + parts[i + 1];
      }
      return virtuals[name];
    };
    Schema.prototype.virtualpath = function(name) {
      return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;
    };
    Schema.prototype.remove = function(path) {
      if (typeof path === "string") {
        path = [path];
      }
      if (Array.isArray(path)) {
        path.forEach(function(name) {
          if (this.path(name) == null && !this.nested[name]) {
            return;
          }
          if (this.nested[name]) {
            const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));
            for (const path2 of allKeys) {
              if (path2.startsWith(name + ".")) {
                delete this.paths[path2];
                delete this.nested[path2];
                _deletePath(this, path2);
              }
            }
            delete this.nested[name];
            _deletePath(this, name);
            return;
          }
          delete this.paths[name];
          _deletePath(this, name);
        }, this);
      }
      return this;
    };
    function _deletePath(schema, name) {
      const pieces = name.split(".");
      const last = pieces.pop();
      let branch = schema.tree;
      for (const piece of pieces) {
        branch = branch[piece];
      }
      delete branch[last];
    }
    Schema.prototype.loadClass = function(model, virtualsOnly) {
      if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty("$isMongooseModelPrototype")) {
        return this;
      }
      this.loadClass(Object.getPrototypeOf(model), virtualsOnly);
      if (!virtualsOnly) {
        Object.getOwnPropertyNames(model).forEach(function(name) {
          if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {
            return;
          }
          const prop = Object.getOwnPropertyDescriptor(model, name);
          if (prop.hasOwnProperty("value")) {
            this.static(name, prop.value);
          }
        }, this);
      }
      Object.getOwnPropertyNames(model.prototype).forEach(function(name) {
        if (name.match(/^(constructor)$/)) {
          return;
        }
        const method = Object.getOwnPropertyDescriptor(model.prototype, name);
        if (!virtualsOnly) {
          if (typeof method.value === "function") {
            this.method(name, method.value);
          }
        }
        if (typeof method.get === "function") {
          if (this.virtuals[name]) {
            this.virtuals[name].getters = [];
          }
          this.virtual(name).get(method.get);
        }
        if (typeof method.set === "function") {
          if (this.virtuals[name]) {
            this.virtuals[name].setters = [];
          }
          this.virtual(name).set(method.set);
        }
      }, this);
      return this;
    };
    Schema.prototype._getSchema = function(path) {
      const _this = this;
      const pathschema = _this.path(path);
      const resultPath = [];
      if (pathschema) {
        pathschema.$fullPath = path;
        return pathschema;
      }
      function search(parts2, schema) {
        let p = parts2.length + 1;
        let foundschema;
        let trypath;
        while (p--) {
          trypath = parts2.slice(0, p).join(".");
          foundschema = schema.path(trypath);
          if (foundschema) {
            resultPath.push(trypath);
            if (foundschema.caster) {
              if (foundschema.caster instanceof MongooseTypes.Mixed) {
                foundschema.caster.$fullPath = resultPath.join(".");
                return foundschema.caster;
              }
              if (p !== parts2.length) {
                if (foundschema.schema) {
                  let ret2;
                  if (parts2[p] === "$" || isArrayFilter(parts2[p])) {
                    if (p + 1 === parts2.length) {
                      return foundschema;
                    }
                    ret2 = search(parts2.slice(p + 1), foundschema.schema);
                    if (ret2) {
                      ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                    }
                    return ret2;
                  }
                  ret2 = search(parts2.slice(p), foundschema.schema);
                  if (ret2) {
                    ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                  }
                  return ret2;
                }
              }
            } else if (foundschema.$isSchemaMap) {
              if (p + 1 >= parts2.length) {
                return foundschema;
              }
              const ret2 = search(parts2.slice(p + 1), foundschema.$__schemaType.schema);
              return ret2;
            }
            foundschema.$fullPath = resultPath.join(".");
            return foundschema;
          }
        }
      }
      const parts = path.split(".");
      for (let i = 0; i < parts.length; ++i) {
        if (parts[i] === "$" || isArrayFilter(parts[i])) {
          parts[i] = "0";
        }
      }
      return search(parts, _this);
    };
    Schema.prototype._getPathType = function(path) {
      const _this = this;
      const pathschema = _this.path(path);
      if (pathschema) {
        return "real";
      }
      function search(parts, schema) {
        let p = parts.length + 1, foundschema, trypath;
        while (p--) {
          trypath = parts.slice(0, p).join(".");
          foundschema = schema.path(trypath);
          if (foundschema) {
            if (foundschema.caster) {
              if (foundschema.caster instanceof MongooseTypes.Mixed) {
                return { schema: foundschema, pathType: "mixed" };
              }
              if (p !== parts.length && foundschema.schema) {
                if (parts[p] === "$" || isArrayFilter(parts[p])) {
                  if (p === parts.length - 1) {
                    return { schema: foundschema, pathType: "nested" };
                  }
                  return search(parts.slice(p + 1), foundschema.schema);
                }
                return search(parts.slice(p), foundschema.schema);
              }
              return {
                schema: foundschema,
                pathType: foundschema.$isSingleNested ? "nested" : "array"
              };
            }
            return { schema: foundschema, pathType: "real" };
          } else if (p === parts.length && schema.nested[trypath]) {
            return { schema, pathType: "nested" };
          }
        }
        return { schema: foundschema || schema, pathType: "undefined" };
      }
      return search(path.split("."), _this);
    };
    function isArrayFilter(piece) {
      return piece.startsWith("$[") && piece.endsWith("]");
    }
    module2.exports = exports2 = Schema;
    Schema.Types = MongooseTypes = require_schema();
    exports2.ObjectId = MongooseTypes.ObjectId;
  }
});

// node_modules/mongoose/lib/helpers/common.js
var require_common4 = __commonJS({
  "node_modules/mongoose/lib/helpers/common.js"(exports2) {
    init_shims();
    "use strict";
    var Binary2 = require_driver().get().Binary;
    var Decimal1282 = require_decimal1282();
    var ObjectId2 = require_objectid3();
    var isMongooseObject = require_isMongooseObject();
    exports2.flatten = flatten;
    exports2.modifiedPaths = modifiedPaths;
    function flatten(update, path, options2, schema) {
      let keys;
      if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {
        keys = Object.keys(update.toObject({ transform: false, virtuals: false }));
      } else {
        keys = Object.keys(update || {});
      }
      const numKeys = keys.length;
      const result = {};
      path = path ? path + "." : "";
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        const val = update[key];
        result[path + key] = val;
        const keySchema = schema && schema.path && schema.path(path + key);
        const isNested = schema && schema.nested && schema.nested[path + key];
        if (keySchema && keySchema.instance === "Mixed")
          continue;
        if (shouldFlatten(val)) {
          if (options2 && options2.skipArrays && Array.isArray(val)) {
            continue;
          }
          const flat = flatten(val, path + key, options2, schema);
          for (const k in flat) {
            result[k] = flat[k];
          }
          if (Array.isArray(val)) {
            result[path + key] = val;
          }
        }
        if (isNested) {
          const paths = Object.keys(schema.paths);
          for (const p of paths) {
            if (p.startsWith(path + key + ".") && !result.hasOwnProperty(p)) {
              result[p] = void 0;
            }
          }
        }
      }
      return result;
    }
    function modifiedPaths(update, path, result) {
      const keys = Object.keys(update || {});
      const numKeys = keys.length;
      result = result || {};
      path = path ? path + "." : "";
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        let val = update[key];
        result[path + key] = true;
        if (isMongooseObject(val) && !Buffer.isBuffer(val)) {
          val = val.toObject({ transform: false, virtuals: false });
        }
        if (shouldFlatten(val)) {
          modifiedPaths(val, path + key, result);
        }
      }
      return result;
    }
    function shouldFlatten(val) {
      return val && typeof val === "object" && !(val instanceof Date) && !(val instanceof ObjectId2) && (!Array.isArray(val) || val.length > 0) && !(val instanceof Buffer) && !(val instanceof Decimal1282) && !(val instanceof Binary2);
    }
  }
});

// node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath = __commonJS({
  "node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js"(exports2, module2) {
    init_shims();
    "use strict";
    var get2 = require_get();
    module2.exports = function getEmbeddedDiscriminatorPath(doc, path, options2) {
      options2 = options2 || {};
      const typeOnly = options2.typeOnly;
      const parts = path.split(".");
      let schema = null;
      let type = "adhocOrUndefined";
      for (let i = 0; i < parts.length; ++i) {
        const subpath = parts.slice(0, i + 1).join(".");
        schema = doc.schema.path(subpath);
        if (schema == null) {
          type = "adhocOrUndefined";
          continue;
        }
        if (schema.instance === "Mixed") {
          return typeOnly ? "real" : schema;
        }
        type = doc.schema.pathType(subpath);
        if ((schema.$isSingleNested || schema.$isMongooseDocumentArrayElement) && schema.schema.discriminators != null) {
          const discriminators = schema.schema.discriminators;
          const discriminatorKey = doc.get(subpath + "." + get2(schema, "schema.options.discriminatorKey"));
          if (discriminatorKey == null || discriminators[discriminatorKey] == null) {
            continue;
          }
          const rest = parts.slice(i + 1).join(".");
          return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options2);
        }
      }
      return typeOnly ? type : schema;
    };
  }
});

// node_modules/mongoose/lib/plugins/idGetter.js
var require_idGetter = __commonJS({
  "node_modules/mongoose/lib/plugins/idGetter.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(schema) {
      const autoIdGetter = !schema.paths["id"] && (!schema.options.noVirtualId && schema.options.id);
      if (!autoIdGetter) {
        return;
      }
      schema.virtual("id").get(idGetter);
    };
    function idGetter() {
      if (this._id != null) {
        return String(this._id);
      }
      return null;
    }
  }
});

// node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js
var require_isDefiningProjection = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function isDefiningProjection(val) {
      if (val == null) {
        return true;
      }
      if (typeof val === "object") {
        return !("$meta" in val) && !("$slice" in val);
      }
      return true;
    };
  }
});

// node_modules/mongoose/lib/helpers/projection/isExclusive.js
var require_isExclusive = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/isExclusive.js"(exports2, module2) {
    init_shims();
    "use strict";
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isExclusive(projection) {
      if (projection == null) {
        return null;
      }
      const keys = Object.keys(projection);
      let ki = keys.length;
      let exclude = null;
      if (ki === 1 && keys[0] === "_id") {
        exclude = !!projection[keys[ki]];
      } else {
        while (ki--) {
          if (keys[ki] !== "_id" && isDefiningProjection(projection[keys[ki]])) {
            exclude = !projection[keys[ki]];
            break;
          }
        }
      }
      return exclude;
    };
  }
});

// node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js
var require_checkEmbeddedDiscriminatorKeyProjection = __commonJS({
  "node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {
      const userProjectedInPath = Object.keys(userProjection).reduce((cur, key) => cur || key.startsWith(path + "."), false);
      const _discriminatorKey = path + "." + schema.options.discriminatorKey;
      if (!userProjectedInPath && addedPaths.length === 1 && addedPaths[0] === _discriminatorKey) {
        selected.splice(selected.indexOf(_discriminatorKey), 1);
      }
    };
  }
});

// node_modules/mongoose/lib/queryhelpers.js
var require_queryhelpers = __commonJS({
  "node_modules/mongoose/lib/queryhelpers.js"(exports2) {
    init_shims();
    "use strict";
    var checkEmbeddedDiscriminatorKeyProjection = require_checkEmbeddedDiscriminatorKeyProjection();
    var get2 = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var isDefiningProjection = require_isDefiningProjection();
    var clone2 = require_clone();
    exports2.preparePopulationOptions = function preparePopulationOptions(query, options2) {
      const _populate = query.options.populate;
      const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
      if (options2.lean != null) {
        pop.filter((p) => get2(p, "options.lean") == null).forEach(makeLean(options2.lean));
      }
      pop.forEach((opts) => {
        opts._localModel = query.model;
      });
      return pop;
    };
    exports2.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options2) {
      const _populate = query._mongooseOptions.populate;
      const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
      if (options2.lean != null) {
        pop.filter((p) => get2(p, "options.lean") == null).forEach(makeLean(options2.lean));
      }
      const session = get2(query, "options.session", null);
      if (session != null) {
        pop.forEach((path) => {
          if (path.options == null) {
            path.options = { session };
            return;
          }
          if (!("session" in path.options)) {
            path.options.session = session;
          }
        });
      }
      const projection = query._fieldsForExec();
      pop.forEach((p) => {
        p._queryProjection = projection;
      });
      pop.forEach((opts) => {
        opts._localModel = query.model;
      });
      return pop;
    };
    exports2.createModel = function createModel(model, doc, fields, userProvidedFields, options2) {
      model.hooks.execPreSync("createModel", doc);
      const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;
      const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;
      const value = doc[key];
      if (key && value && model.discriminators) {
        const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);
        if (discriminator) {
          const _fields = clone2(userProvidedFields);
          exports2.applyPaths(_fields, discriminator.schema);
          return new discriminator(void 0, _fields, true);
        }
      }
      if (typeof options2 === "undefined") {
        options2 = {};
        options2.defaults = true;
      }
      return new model(void 0, fields, {
        skipId: true,
        isNew: false,
        willInit: true,
        defaults: options2.defaults
      });
    };
    exports2.applyPaths = function applyPaths(fields, schema) {
      let exclude;
      let keys;
      let keyIndex;
      if (fields) {
        keys = Object.keys(fields);
        keyIndex = keys.length;
        while (keyIndex--) {
          if (keys[keyIndex][0] === "+") {
            continue;
          }
          const field = fields[keys[keyIndex]];
          if (!isDefiningProjection(field)) {
            continue;
          }
          exclude = !field;
          break;
        }
      }
      const selected = [];
      const excluded = [];
      const stack = [];
      analyzeSchema(schema);
      switch (exclude) {
        case true:
          for (const fieldName of excluded) {
            fields[fieldName] = 0;
          }
          break;
        case false:
          if (schema && schema.paths["_id"] && schema.paths["_id"].options && schema.paths["_id"].options.select === false) {
            fields._id = 0;
          }
          for (const fieldName of selected) {
            fields[fieldName] = fields[fieldName] || 1;
          }
          break;
        case void 0:
          if (fields == null) {
            break;
          }
          for (const key of Object.keys(fields || {})) {
            if (key.startsWith("+")) {
              delete fields[key];
            }
          }
          for (const fieldName of excluded) {
            fields[fieldName] = 0;
          }
          break;
      }
      function analyzeSchema(schema2, prefix) {
        prefix || (prefix = "");
        if (stack.indexOf(schema2) !== -1) {
          return [];
        }
        stack.push(schema2);
        const addedPaths = [];
        schema2.eachPath(function(path, type) {
          if (prefix)
            path = prefix + "." + path;
          let addedPath = analyzePath(path, type);
          if (addedPath == null && type.$isMongooseArray && !type.$isMongooseDocumentArray) {
            addedPath = analyzePath(path, type.caster);
          }
          if (addedPath != null) {
            addedPaths.push(addedPath);
          }
          if (type.schema) {
            const _addedPaths = analyzeSchema(type.schema, path);
            if (exclude === false) {
              checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);
            }
          }
        });
        stack.pop();
        return addedPaths;
      }
      function analyzePath(path, type) {
        const plusPath = "+" + path;
        const hasPlusPath = fields && plusPath in fields;
        if (hasPlusPath) {
          delete fields[plusPath];
        }
        if (typeof type.selected !== "boolean")
          return;
        if (hasPlusPath) {
          delete fields[plusPath];
          if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {
            fields[path] = 1;
          }
          return;
        }
        const pieces = path.split(".");
        let cur = "";
        for (let i = 0; i < pieces.length; ++i) {
          cur += cur.length ? "." + pieces[i] : pieces[i];
          if (excluded.indexOf(cur) !== -1) {
            return;
          }
        }
        if (!exclude && get2(type, "options.$skipDiscriminatorCheck", false)) {
          let cur2 = "";
          for (let i = 0; i < pieces.length; ++i) {
            cur2 += (cur2.length === 0 ? "" : ".") + pieces[i];
            const projection = get2(fields, cur2, false) || get2(fields, cur2 + ".$", false);
            if (projection && typeof projection !== "object") {
              return;
            }
          }
        }
        (type.selected ? selected : excluded).push(path);
        return path;
      }
    };
    function makeLean(val) {
      return function(option) {
        option.options || (option.options = {});
        if (val != null && Array.isArray(val.virtuals)) {
          val = Object.assign({}, val);
          val.virtuals = val.virtuals.filter((path) => typeof path === "string" && path.startsWith(option.path + ".")).map((path) => path.slice(option.path.length + 1));
        }
        option.options.lean = val;
      };
    }
    exports2.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {
      return function _handleDeleteWriteOpResult(error2, res) {
        if (error2) {
          return callback(error2);
        }
        const mongooseResult = Object.assign({}, res.result);
        if (get2(res, "result.n", null) != null) {
          mongooseResult.deletedCount = res.result.n;
        }
        if (res.deletedCount != null) {
          mongooseResult.deletedCount = res.deletedCount;
        }
        return callback(null, mongooseResult);
      };
    };
  }
});

// node_modules/mongoose/lib/helpers/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/mongoose/lib/helpers/isPromise.js"(exports2, module2) {
    init_shims();
    "use strict";
    function isPromise(val) {
      return !!val && (typeof val === "object" || typeof val === "function") && typeof val.then === "function";
    }
    module2.exports = isPromise;
  }
});

// node_modules/mongoose/lib/document.js
var require_document = __commonJS({
  "node_modules/mongoose/lib/document.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var InternalCache = require_internal();
    var MongooseError = require_error3();
    var MixedSchema = require_mixed();
    var ObjectExpectedError = require_objectExpected();
    var ObjectParameterError = require_objectParameter();
    var ParallelValidateError = require_parallelValidate();
    var Schema = require_schema2();
    var StrictModeError = require_strict();
    var ValidationError = require_validation();
    var ValidatorError = require_validator();
    var VirtualType = require_virtualtype();
    var promiseOrCallback = require_promiseOrCallback();
    var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
    var compile = require_compile().compile;
    var defineKey = require_compile().defineKey;
    var flatten = require_common4().flatten;
    var get2 = require_get();
    var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath();
    var handleSpreadDoc = require_handleSpreadDoc();
    var idGetter = require_idGetter();
    var immediate = require_immediate();
    var isDefiningProjection = require_isDefiningProjection();
    var isExclusive = require_isExclusive();
    var inspect = require("util").inspect;
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var mpath = require_mpath();
    var queryhelpers = require_queryhelpers();
    var utils2 = require_utils6();
    var isPromise = require_isPromise();
    var clone2 = utils2.clone;
    var deepEqual = utils2.deepEqual;
    var isMongooseObject = utils2.isMongooseObject;
    var arrayAtomicsBackupSymbol = Symbol("mongoose.Array#atomicsBackup");
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var documentIsModified = require_symbols().documentIsModified;
    var documentModifiedPaths = require_symbols().documentModifiedPaths;
    var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
    var getSymbol = require_symbols().getSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var scopeSymbol = require_symbols().scopeSymbol;
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    var DocumentArray;
    var MongooseArray;
    var Embedded;
    var specialProperties = utils2.specialProperties;
    function Document(obj, fields, skipId, options2) {
      if (typeof skipId === "object" && skipId != null) {
        options2 = skipId;
        skipId = options2.skipId;
      }
      options2 = Object.assign({}, options2);
      const defaults = get2(options2, "defaults", true);
      options2.defaults = defaults;
      if (this.$__schema == null) {
        const _schema = utils2.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;
        this.$__setSchema(_schema);
        fields = skipId;
        skipId = options2;
        options2 = arguments[4] || {};
      }
      this.$__ = new InternalCache();
      this.$__.emitter = new EventEmitter();
      this.isNew = "isNew" in options2 ? options2.isNew : true;
      this.errors = void 0;
      this.$__.$options = options2 || {};
      this.$locals = {};
      this.$op = null;
      if (obj != null && typeof obj !== "object") {
        throw new ObjectParameterError(obj, "obj", "Document");
      }
      const schema = this.$__schema;
      if (typeof fields === "boolean" || fields === "throw") {
        this.$__.strictMode = fields;
        fields = void 0;
      } else {
        this.$__.strictMode = schema.options.strict;
        this.$__.selected = fields;
      }
      const requiredPaths = schema.requiredPaths(true);
      for (const path of requiredPaths) {
        this.$__.activePaths.require(path);
      }
      this.$__.emitter.setMaxListeners(0);
      let exclude = null;
      if (utils2.isPOJO(fields)) {
        exclude = isExclusive(fields);
      }
      const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : {};
      if (this._doc == null) {
        this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);
        if (defaults) {
          $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {
            isNew: this.isNew
          });
        }
      }
      if (obj) {
        if (this.$__original_set) {
          this.$__original_set(obj, void 0, true);
        } else {
          this.$set(obj, void 0, true);
        }
        if (obj instanceof Document) {
          this.isNew = obj.isNew;
        }
      }
      if (options2.willInit && defaults) {
        EventEmitter.prototype.once.call(this, "init", () => {
          $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options2.skipDefaults, {
            isNew: this.isNew
          });
        });
      } else if (defaults) {
        $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options2.skipDefaults, {
          isNew: this.isNew
        });
      }
      this.$__._id = this._id;
      if (!this.$__.strictMode && obj) {
        const _this = this;
        const keys = Object.keys(this._doc);
        keys.forEach(function(key) {
          if (!(key in schema.tree)) {
            defineKey(key, null, _this);
          }
        });
      }
      applyQueue(this);
    }
    utils2.each([
      "on",
      "once",
      "emit",
      "listeners",
      "removeListener",
      "setMaxListeners",
      "removeAllListeners",
      "addListener"
    ], function(emitterFn) {
      Document.prototype[emitterFn] = function() {
        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
      };
    });
    Document.prototype.constructor = Document;
    for (const i in EventEmitter.prototype) {
      Document[i] = EventEmitter.prototype[i];
    }
    Document.prototype.$__schema;
    Document.prototype.schema;
    Object.defineProperty(Document.prototype, "$locals", {
      configurable: false,
      enumerable: false,
      writable: true
    });
    Document.prototype.isNew;
    Document.prototype.id;
    Document.prototype.errors;
    Document.prototype.$op;
    function $__hasIncludedChildren(fields) {
      const hasIncludedChildren = {};
      const keys = Object.keys(fields);
      for (const key of keys) {
        const parts = key.split(".");
        const c = [];
        for (const part of parts) {
          c.push(part);
          hasIncludedChildren[c.join(".")] = 1;
        }
      }
      return hasIncludedChildren;
    }
    function $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {
      const paths = Object.keys(doc.$__schema.paths);
      const plen = paths.length;
      for (let i = 0; i < plen; ++i) {
        let def;
        let curPath = "";
        const p = paths[i];
        if (p === "_id" && skipId) {
          continue;
        }
        const type = doc.$__schema.paths[p];
        const path = type.splitPath();
        const len = path.length;
        let included = false;
        let doc_ = doc._doc;
        for (let j = 0; j < len; ++j) {
          if (doc_ == null) {
            break;
          }
          const piece = path[j];
          curPath += (!curPath.length ? "" : ".") + piece;
          if (exclude === true) {
            if (curPath in fields) {
              break;
            }
          } else if (exclude === false && fields && !included) {
            if (curPath in fields) {
              included = true;
            } else if (!hasIncludedChildren[curPath]) {
              break;
            }
          }
          if (j === len - 1) {
            if (doc_[piece] !== void 0) {
              break;
            }
            if (typeof type.defaultValue === "function") {
              if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
                break;
              }
              if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
                break;
              }
            } else if (!isBeforeSetters) {
              continue;
            }
            if (pathsToSkip && pathsToSkip[curPath]) {
              break;
            }
            if (fields && exclude !== null) {
              if (exclude === true) {
                if (p in fields) {
                  continue;
                }
                try {
                  def = type.getDefault(doc, false);
                } catch (err) {
                  doc.invalidate(p, err);
                  break;
                }
                if (typeof def !== "undefined") {
                  doc_[piece] = def;
                  doc.$__.activePaths.default(p);
                }
              } else if (included) {
                try {
                  def = type.getDefault(doc, false);
                } catch (err) {
                  doc.invalidate(p, err);
                  break;
                }
                if (typeof def !== "undefined") {
                  doc_[piece] = def;
                  doc.$__.activePaths.default(p);
                }
              }
            } else {
              try {
                def = type.getDefault(doc, false);
              } catch (err) {
                doc.invalidate(p, err);
                break;
              }
              if (typeof def !== "undefined") {
                doc_[piece] = def;
                doc.$__.activePaths.default(p);
              }
            }
          } else {
            doc_ = doc_[piece];
          }
        }
      }
    }
    Document.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {
      const doc = {};
      const paths = Object.keys(this.$__schema.paths).filter((p) => !p.includes("$*"));
      const plen = paths.length;
      let ii = 0;
      for (; ii < plen; ++ii) {
        const p = paths[ii];
        if (p === "_id") {
          if (skipId) {
            continue;
          }
          if (obj && "_id" in obj) {
            continue;
          }
        }
        const path = this.$__schema.paths[p].splitPath();
        const len = path.length;
        const last = len - 1;
        let curPath = "";
        let doc_ = doc;
        let included = false;
        for (let i = 0; i < len; ++i) {
          const piece = path[i];
          curPath += (!curPath.length ? "" : ".") + piece;
          if (exclude === true) {
            if (curPath in fields) {
              break;
            }
          } else if (exclude === false && fields && !included) {
            if (curPath in fields) {
              included = true;
            } else if (!hasIncludedChildren[curPath]) {
              break;
            }
          }
          if (i < last) {
            doc_ = doc_[piece] || (doc_[piece] = {});
          }
        }
      }
      this._doc = doc;
    };
    Document.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    Document.prototype.init = function(doc, opts, fn) {
      if (typeof opts === "function") {
        fn = opts;
        opts = null;
      }
      this.$__init(doc, opts);
      if (fn) {
        fn(null, this);
      }
      return this;
    };
    Document.prototype.$__init = function(doc, opts) {
      this.isNew = false;
      this.$init = true;
      opts = opts || {};
      if (doc._id != null && opts.populated && opts.populated.length) {
        const id = String(doc._id);
        for (const item of opts.populated) {
          if (item.isVirtual) {
            this.populated(item.path, utils2.getValue(item.path, doc), item);
          } else {
            this.populated(item.path, item._docs[id], item);
          }
          if (item._childDocs == null) {
            continue;
          }
          for (const child of item._childDocs) {
            if (child == null || child.$__ == null) {
              continue;
            }
            child.$__.parent = this;
          }
          item._childDocs = [];
        }
      }
      init2(this, doc, this._doc, opts);
      markArraySubdocsPopulated(this, opts.populated);
      this.emit("init", this);
      this.constructor.emit("init", this);
      this.$__._id = this._id;
      return this;
    };
    function markArraySubdocsPopulated(doc, populated) {
      if (doc._id == null || populated == null || populated.length === 0) {
        return;
      }
      const id = String(doc._id);
      for (const item of populated) {
        if (item.isVirtual) {
          continue;
        }
        const path = item.path;
        const pieces = path.split(".");
        for (let i = 0; i < pieces.length - 1; ++i) {
          const subpath = pieces.slice(0, i + 1).join(".");
          const rest = pieces.slice(i + 1).join(".");
          const val = doc.get(subpath);
          if (val == null) {
            continue;
          }
          if (val.isMongooseDocumentArray) {
            for (let j = 0; j < val.length; ++j) {
              val[j].populated(rest, item._docs[id] == null ? [] : item._docs[id][j], item);
            }
            break;
          }
        }
      }
    }
    function init2(self2, obj, doc, opts, prefix) {
      prefix = prefix || "";
      const keys = Object.keys(obj);
      const len = keys.length;
      let schema;
      let path;
      let i;
      let index2 = 0;
      while (index2 < len) {
        _init(index2++);
      }
      function _init(index3) {
        i = keys[index3];
        path = prefix + i;
        schema = self2.$__schema.path(path);
        if (self2.$__schema.$isRootDiscriminator && !self2.$__isSelected(path)) {
          return;
        }
        if (!schema && utils2.isPOJO(obj[i])) {
          if (!doc[i]) {
            doc[i] = {};
          }
          init2(self2, obj[i], doc[i], opts, path + ".");
        } else if (!schema) {
          doc[i] = obj[i];
        } else {
          if (obj[i] === null) {
            doc[i] = schema._castNullish(null);
          } else if (obj[i] !== void 0) {
            const intCache = obj[i].$__ || {};
            const wasPopulated = intCache.wasPopulated || null;
            if (schema && !wasPopulated) {
              try {
                doc[i] = schema.cast(obj[i], self2, true);
              } catch (e) {
                self2.invalidate(e.path, new ValidatorError({
                  path: e.path,
                  message: e.message,
                  type: "cast",
                  value: e.value,
                  reason: e
                }));
              }
            } else {
              doc[i] = obj[i];
            }
          }
          if (!self2.isModified(path)) {
            self2.$__.activePaths.init(path);
          }
        }
      }
    }
    Document.prototype.update = function update() {
      const args = utils2.args(arguments);
      args.unshift({ _id: this._id });
      const query = this.constructor.update.apply(this.constructor, args);
      if (this.$session() != null) {
        if (!("session" in query.options)) {
          query.options.session = this.$session();
        }
      }
      return query;
    };
    Document.prototype.updateOne = function updateOne(doc, options2, callback) {
      const query = this.constructor.updateOne({ _id: this._id }, doc, options2);
      query.pre((cb) => {
        this.constructor._middleware.execPre("updateOne", this, [this], cb);
      });
      query.post((cb) => {
        this.constructor._middleware.execPost("updateOne", this, [this], {}, cb);
      });
      if (this.$session() != null) {
        if (!("session" in query.options)) {
          query.options.session = this.$session();
        }
      }
      if (callback != null) {
        return query.exec(callback);
      }
      return query;
    };
    Document.prototype.replaceOne = function replaceOne() {
      const args = utils2.args(arguments);
      args.unshift({ _id: this._id });
      return this.constructor.replaceOne.apply(this.constructor, args);
    };
    Document.prototype.$session = function $session(session) {
      if (arguments.length === 0) {
        if (this.$__.session != null && this.$__.session.hasEnded) {
          this.$__.session = null;
          return null;
        }
        return this.$__.session;
      }
      if (session != null && session.hasEnded) {
        throw new MongooseError("Cannot set a document's session to a session that has ended. Make sure you haven't called `endSession()` on the session you are passing to `$session()`.");
      }
      this.$__.session = session;
      if (!this.ownerDocument) {
        const subdocs = this.$getAllSubdocs();
        for (const child of subdocs) {
          child.$session(session);
        }
      }
      return session;
    };
    Document.prototype.overwrite = function overwrite(obj) {
      const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));
      for (const key of keys) {
        if (key === "_id") {
          continue;
        }
        if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {
          continue;
        }
        if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {
          continue;
        }
        this.$set(key, obj[key]);
      }
      return this;
    };
    Document.prototype.$set = function $set(path, val, type, options2) {
      if (utils2.isPOJO(type)) {
        options2 = type;
        type = void 0;
      }
      options2 = options2 || {};
      const merge = options2.merge;
      const adhoc = type && type !== true;
      const constructing = type === true;
      const typeKey = this.$__schema.options.typeKey;
      let adhocs;
      let keys;
      let i = 0;
      let pathtype;
      let key;
      let prefix;
      const strict = "strict" in options2 ? options2.strict : this.$__.strictMode;
      if (adhoc) {
        adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
        adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);
      }
      if (path == null) {
        const _ = path;
        path = val;
        val = _;
      } else if (typeof path !== "string") {
        if (path instanceof Document) {
          if (path.$__isNested) {
            path = path.toObject();
          } else {
            path = path._doc;
          }
        }
        if (path == null) {
          const _ = path;
          path = val;
          val = _;
        }
        prefix = val ? val + "." : "";
        keys = Object.keys(path);
        const len = keys.length;
        const _skipMinimizeTopLevel = get2(options2, "_skipMinimizeTopLevel", false);
        if (len === 0 && _skipMinimizeTopLevel) {
          delete options2._skipMinimizeTopLevel;
          if (val) {
            this.$set(val, {});
          }
          return this;
        }
        for (let i2 = 0; i2 < len; ++i2) {
          key = keys[i2];
          const pathName = prefix + key;
          pathtype = this.$__schema.pathType(pathName);
          if (type === true && !prefix && path[key] != null && pathtype === "nested" && this._doc[key] != null && Object.keys(this._doc[key]).length === 0) {
            delete this._doc[key];
            options2 = Object.assign({}, options2, { _skipMinimizeTopLevel: true });
          } else {
            options2 = Object.assign({}, options2, { _skipMinimizeTopLevel: false });
          }
          const someCondition = typeof path[key] === "object" && !utils2.isNativeObject(path[key]) && !utils2.isMongooseType(path[key]) && path[key] != null && pathtype !== "virtual" && pathtype !== "real" && pathtype !== "adhocOrUndefined" && !(this.$__path(pathName) instanceof MixedSchema) && !(this.$__schema.paths[pathName] && this.$__schema.paths[pathName].options && this.$__schema.paths[pathName].options.ref);
          if (someCondition) {
            this.$__.$setCalled.add(prefix + key);
            this.$set(path[key], prefix + key, constructing, options2);
          } else if (strict) {
            if (constructing && path[key] === void 0 && this.get(pathName) !== void 0) {
              continue;
            }
            if (pathtype === "adhocOrUndefined") {
              pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
            }
            if (pathtype === "real" || pathtype === "virtual") {
              let p = path[key];
              if (this.$__schema.paths[pathName] && this.$__schema.paths[pathName].$isSingleNested && path[key] instanceof Document) {
                p = p.toObject({ virtuals: false, transform: false });
              }
              this.$set(prefix + key, p, constructing, options2);
            } else if (pathtype === "nested" && path[key] instanceof Document) {
              this.$set(prefix + key, path[key].toObject({ transform: false }), constructing, options2);
            } else if (strict === "throw") {
              if (pathtype === "nested") {
                throw new ObjectExpectedError(key, path[key]);
              } else {
                throw new StrictModeError(key);
              }
            }
          } else if (path[key] !== void 0) {
            this.$set(prefix + key, path[key], constructing, options2);
          }
        }
        return this;
      } else {
        this.$__.$setCalled.add(path);
      }
      let pathType = this.$__schema.pathType(path);
      if (pathType === "adhocOrUndefined") {
        pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
      }
      val = handleSpreadDoc(val);
      if (pathType === "nested" && val) {
        if (typeof val === "object" && val != null) {
          const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
          if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
            const priorVal2 = this.$__getValue(path);
            this.$__.savedState[path] = priorVal2;
            const keys3 = Object.keys(priorVal2 || {});
            for (const key2 of keys3) {
              this.$__.savedState[path + "." + key2] = priorVal2[key2];
            }
          }
          if (!merge) {
            this.$__setValue(path, null);
            cleanModifiedSubpaths(this, path);
          } else {
            return this.$set(val, path, constructing);
          }
          const keys2 = Object.keys(val);
          this.$__setValue(path, {});
          for (const key2 of keys2) {
            this.$set(path + "." + key2, val[key2], constructing);
          }
          if (hasPriorVal && utils2.deepEqual(this.$__.savedState[path], val)) {
            this.unmarkModified(path);
          } else {
            this.markModified(path);
          }
          cleanModifiedSubpaths(this, path, { skipDocArrays: true });
          return this;
        }
        this.invalidate(path, new MongooseError.CastError("Object", val, path));
        return this;
      }
      let schema;
      const parts = path.indexOf(".") === -1 ? [path] : path.split(".");
      if (typeof this.$__schema.aliases[parts[0]] == "string") {
        parts[0] = this.$__schema.aliases[parts[0]];
      }
      if (pathType === "adhocOrUndefined" && strict) {
        let mixed;
        for (i = 0; i < parts.length; ++i) {
          const subpath = parts.slice(0, i + 1).join(".");
          if (i + 1 < parts.length && this.$__schema.pathType(subpath) === "virtual") {
            mpath.set(path, val, this);
            return this;
          }
          schema = this.$__schema.path(subpath);
          if (schema == null) {
            continue;
          }
          if (schema instanceof MixedSchema) {
            mixed = true;
            break;
          }
        }
        if (schema == null) {
          schema = getEmbeddedDiscriminatorPath(this, path);
        }
        if (!mixed && !schema) {
          if (strict === "throw") {
            throw new StrictModeError(path);
          }
          return this;
        }
      } else if (pathType === "virtual") {
        schema = this.$__schema.virtualpath(path);
        schema.applySetters(val, this);
        return this;
      } else {
        schema = this.$__path(path);
      }
      let cur = this._doc;
      let curPath = "";
      for (i = 0; i < parts.length - 1; ++i) {
        cur = cur[parts[i]];
        curPath += (curPath.length > 0 ? "." : "") + parts[i];
        if (!cur) {
          this.$set(curPath, {});
          if (!this.$__isSelected(curPath)) {
            this.unmarkModified(curPath);
          }
          cur = this.$__getValue(curPath);
        }
      }
      let pathToMark;
      if (parts.length <= 1) {
        pathToMark = path;
      } else {
        for (i = 0; i < parts.length; ++i) {
          const subpath = parts.slice(0, i + 1).join(".");
          if (this.get(subpath, null, { getters: false }) === null) {
            pathToMark = subpath;
            break;
          }
        }
        if (!pathToMark) {
          pathToMark = path;
        }
      }
      const priorVal = (() => {
        if (this.$__.$options.priorDoc != null) {
          return this.$__.$options.priorDoc.$__getValue(path);
        }
        if (constructing) {
          return void 0;
        }
        return this.$__getValue(path);
      })();
      if (!schema) {
        this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
        return this;
      }
      if (schema.$isSingleNested || schema.$isMongooseArray) {
        _markValidSubpaths(this, path);
      }
      if (schema.$isSingleNested && val != null && merge) {
        if (val instanceof Document) {
          val = val.toObject({ virtuals: false, transform: false });
        }
        const keys2 = Object.keys(val);
        for (const key2 of keys2) {
          this.$set(path + "." + key2, val[key2], constructing, options2);
        }
        return this;
      }
      let shouldSet = true;
      try {
        const refMatches = (() => {
          if (schema.options == null) {
            return false;
          }
          if (!(val instanceof Document)) {
            return false;
          }
          const model = val.constructor;
          const ref = schema.options.ref;
          if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
            return true;
          }
          const refPath = schema.options.refPath;
          if (refPath == null) {
            return false;
          }
          const modelName = val.get(refPath);
          return modelName === model.modelName || modelName === model.baseModelName;
        })();
        let didPopulate = false;
        if (refMatches && val instanceof Document) {
          this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
          val.$__.wasPopulated = true;
          didPopulate = true;
        }
        let popOpts;
        if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {
          popOpts = { [populateModelSymbol]: val[0].constructor };
          this.populated(path, val.map(function(v) {
            return v._id;
          }), popOpts);
          for (const doc of val) {
            doc.$__.wasPopulated = true;
          }
          didPopulate = true;
        }
        if (this.$__schema.singleNestedPaths[path] == null) {
          val = schema.applySetters(val, this, false, priorVal);
        }
        if (schema.$isMongooseDocumentArray && Array.isArray(val) && val.length > 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {
          const populatedPaths = Object.keys(val[0].$__.populated);
          for (const populatedPath of populatedPaths) {
            this.populated(path + "." + populatedPath, val.map((v) => v.populated(populatedPath)), val[0].$__.populated[populatedPath].options);
          }
          didPopulate = true;
        }
        if (!didPopulate && this.$__.populated) {
          if (Array.isArray(val) && this.$__.populated[path]) {
            for (let i2 = 0; i2 < val.length; ++i2) {
              if (val[i2] instanceof Document) {
                val[i2] = val[i2]._id;
              }
            }
          }
          delete this.$__.populated[path];
        }
        if (schema.$isSingleNested && val != null) {
          _checkImmutableSubpaths(val, schema, priorVal);
        }
        this.$markValid(path);
      } catch (e) {
        if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
          this.invalidate(path, e);
        } else if (e instanceof MongooseError.CastError) {
          this.invalidate(e.path, e);
          if (e.$originalErrorPath) {
            this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
          }
        } else {
          this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));
        }
        shouldSet = false;
      }
      if (shouldSet) {
        this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
        if (this.$__.savedState != null) {
          if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
            this.$__.savedState[path] = priorVal;
          } else if (this.$__.savedState.hasOwnProperty(path) && utils2.deepEqual(val, this.$__.savedState[path])) {
            this.unmarkModified(path);
          }
        }
      }
      if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
        cleanModifiedSubpaths(this, path);
      }
      return this;
    };
    function _isManuallyPopulatedArray(val, ref) {
      if (!Array.isArray(val)) {
        return false;
      }
      if (val.length === 0) {
        return false;
      }
      for (const el of val) {
        if (!(el instanceof Document)) {
          return false;
        }
        const modelName = el.constructor.modelName;
        if (modelName == null) {
          return false;
        }
        if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {
          return false;
        }
      }
      return true;
    }
    Document.prototype.set = Document.prototype.$set;
    Document.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
      if (this.isNew) {
        return true;
      }
      if (this.$__schema.singleNestedPaths[path] != null) {
        return false;
      }
      if (val === void 0 && !this.$__isSelected(path)) {
        return true;
      }
      if (val === void 0 && path in this.$__.activePaths.states.default) {
        return false;
      }
      if (this.populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {
        return false;
      }
      if (!deepEqual(val, priorVal || utils2.getValue(path, this))) {
        return true;
      }
      if (!constructing && val !== null && val !== void 0 && path in this.$__.activePaths.states.default && deepEqual(val, schema.getDefault(this, constructing))) {
        return true;
      }
      return false;
    };
    Document.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
      Embedded = Embedded || require_embedded();
      const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts, schema, val, priorVal);
      const _this = this;
      if (shouldModify) {
        this.markModified(pathToMark);
        MongooseArray || (MongooseArray = require_array());
        if (val && val.isMongooseArray) {
          val._registerAtomic("$set", val);
          if (val.isMongooseDocumentArray) {
            val.forEach(function(item) {
              item && item.__parentArray && (item.__parentArray = val);
            });
          }
          this.$__.activePaths.forEach(function(modifiedPath) {
            if (modifiedPath.startsWith(path + ".")) {
              _this.$__.activePaths.ignore(modifiedPath);
            }
          });
        }
      }
      let obj = this._doc;
      let i = 0;
      const l = parts.length;
      let cur = "";
      for (; i < l; i++) {
        const next = i + 1;
        const last = next === l;
        cur += cur ? "." + parts[i] : parts[i];
        if (specialProperties.has(parts[i])) {
          return;
        }
        if (last) {
          if (obj instanceof Map) {
            obj.set(parts[i], val);
          } else {
            obj[parts[i]] = val;
          }
        } else {
          if (utils2.isPOJO(obj[parts[i]])) {
            obj = obj[parts[i]];
          } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
            obj = obj[parts[i]];
          } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
            obj = obj[parts[i]];
          } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
            obj = obj[parts[i]];
          } else {
            obj[parts[i]] = obj[parts[i]] || {};
            obj = obj[parts[i]];
          }
        }
      }
    };
    Document.prototype.$__getValue = function(path) {
      return utils2.getValue(path, this._doc);
    };
    Document.prototype.$__setValue = function(path, val) {
      utils2.setValue(path, val, this._doc);
      return this;
    };
    Document.prototype.get = function(path, type, options2) {
      let adhoc;
      options2 = options2 || {};
      if (type) {
        adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);
      }
      let schema = this.$__path(path);
      if (schema == null) {
        schema = this.$__schema.virtualpath(path);
      }
      if (schema instanceof MixedSchema) {
        const virtual = this.$__schema.virtualpath(path);
        if (virtual != null) {
          schema = virtual;
        }
      }
      const pieces = path.indexOf(".") === -1 ? [path] : path.split(".");
      let obj = this._doc;
      if (schema instanceof VirtualType) {
        return schema.applyGetters(void 0, this);
      }
      if (typeof this.$__schema.aliases[pieces[0]] == "string") {
        pieces[0] = this.$__schema.aliases[pieces[0]];
      }
      for (let i = 0, l = pieces.length; i < l; i++) {
        if (obj && obj._doc) {
          obj = obj._doc;
        }
        if (obj == null) {
          obj = void 0;
        } else if (obj instanceof Map) {
          obj = obj.get(pieces[i], { getters: false });
        } else if (i === l - 1) {
          obj = utils2.getValue(pieces[i], obj);
        } else {
          obj = obj[pieces[i]];
        }
      }
      if (adhoc) {
        obj = adhoc.cast(obj);
      }
      if (schema != null && options2.getters !== false) {
        obj = schema.applyGetters(obj, this);
      } else if (this.$__schema.nested[path] && options2.virtuals) {
        return applyVirtuals(this, utils2.clone(obj) || {}, { path });
      }
      return obj;
    };
    Document.prototype[getSymbol] = Document.prototype.get;
    Document.prototype.$__path = function(path) {
      const adhocs = this.$__.adhocPaths;
      const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;
      if (adhocType) {
        return adhocType;
      }
      return this.$__schema.path(path);
    };
    Document.prototype.markModified = function(path, scope) {
      this.$__.activePaths.modify(path);
      if (scope != null && !this.ownerDocument) {
        this.$__.pathsToScopes[path] = scope;
      }
    };
    Document.prototype.unmarkModified = function(path) {
      this.$__.activePaths.init(path);
      delete this.$__.pathsToScopes[path];
    };
    Document.prototype.$ignore = function(path) {
      this.$__.activePaths.ignore(path);
    };
    Document.prototype.directModifiedPaths = function() {
      return Object.keys(this.$__.activePaths.states.modify);
    };
    Document.prototype.$isEmpty = function(path) {
      const isEmptyOptions = {
        minimize: true,
        virtuals: false,
        getters: false,
        transform: false
      };
      if (arguments.length > 0) {
        const v = this.get(path);
        if (v == null) {
          return true;
        }
        if (typeof v !== "object") {
          return false;
        }
        if (utils2.isPOJO(v)) {
          return _isEmpty(v);
        }
        return Object.keys(v.toObject(isEmptyOptions)).length === 0;
      }
      return Object.keys(this.toObject(isEmptyOptions)).length === 0;
    };
    function _isEmpty(v) {
      if (v == null) {
        return true;
      }
      if (typeof v !== "object" || Array.isArray(v)) {
        return false;
      }
      for (const key of Object.keys(v)) {
        if (!_isEmpty(v[key])) {
          return false;
        }
      }
      return true;
    }
    Document.prototype.modifiedPaths = function(options2) {
      options2 = options2 || {};
      const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
      const _this = this;
      return directModifiedPaths.reduce(function(list, path) {
        const parts = path.split(".");
        list = list.concat(parts.reduce(function(chains, part, i) {
          return chains.concat(parts.slice(0, i).concat(part).join("."));
        }, []).filter(function(chain) {
          return list.indexOf(chain) === -1;
        }));
        if (!options2.includeChildren) {
          return list;
        }
        let cur = _this.get(path);
        if (cur != null && typeof cur === "object") {
          if (cur._doc) {
            cur = cur._doc;
          }
          if (Array.isArray(cur)) {
            const len = cur.length;
            for (let i = 0; i < len; ++i) {
              if (list.indexOf(path + "." + i) === -1) {
                list.push(path + "." + i);
                if (cur[i] != null && cur[i].$__) {
                  const modified = cur[i].modifiedPaths();
                  for (const childPath of modified) {
                    list.push(path + "." + i + "." + childPath);
                  }
                }
              }
            }
          } else {
            Object.keys(cur).filter(function(key) {
              return list.indexOf(path + "." + key) === -1;
            }).forEach(function(key) {
              list.push(path + "." + key);
            });
          }
        }
        return list;
      }, []);
    };
    Document.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;
    Document.prototype.isModified = function(paths, modifiedPaths) {
      if (paths) {
        if (!Array.isArray(paths)) {
          paths = paths.split(" ");
        }
        const modified = modifiedPaths || this[documentModifiedPaths]();
        const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
        const isModifiedChild = paths.some(function(path) {
          return !!~modified.indexOf(path);
        });
        return isModifiedChild || paths.some(function(path) {
          return directModifiedPaths.some(function(mod) {
            return mod === path || path.startsWith(mod + ".");
          });
        });
      }
      return this.$__.activePaths.some("modify");
    };
    Document.prototype[documentIsModified] = Document.prototype.isModified;
    Document.prototype.$isDefault = function(path) {
      if (path == null) {
        return this.$__.activePaths.some("default");
      }
      if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.states.default.hasOwnProperty(path);
      }
      let paths = path;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path2) => this.$__.activePaths.states.default.hasOwnProperty(path2));
    };
    Document.prototype.$isDeleted = function(val) {
      if (arguments.length === 0) {
        return !!this.$__.isDeleted;
      }
      this.$__.isDeleted = !!val;
      return this;
    };
    Document.prototype.isDirectModified = function(path) {
      if (path == null) {
        return this.$__.activePaths.some("modify");
      }
      if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.states.modify.hasOwnProperty(path);
      }
      let paths = path;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path2) => this.$__.activePaths.states.modify.hasOwnProperty(path2));
    };
    Document.prototype.isInit = function(path) {
      if (path == null) {
        return this.$__.activePaths.some("init");
      }
      if (typeof path === "string" && path.indexOf(" ") === -1) {
        return this.$__.activePaths.states.init.hasOwnProperty(path);
      }
      let paths = path;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path2) => this.$__.activePaths.states.init.hasOwnProperty(path2));
    };
    Document.prototype.isSelected = function isSelected(path) {
      if (this.$__.selected == null) {
        return true;
      }
      if (path === "_id") {
        return this.$__.selected._id !== 0;
      }
      if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
      }
      if (Array.isArray(path)) {
        return path.some((p) => this.$__isSelected(p));
      }
      const paths = Object.keys(this.$__.selected);
      let inclusive = null;
      if (paths.length === 1 && paths[0] === "_id") {
        return this.$__.selected._id === 0;
      }
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (!isDefiningProjection(this.$__.selected[cur])) {
          continue;
        }
        inclusive = !!this.$__.selected[cur];
        break;
      }
      if (inclusive === null) {
        return true;
      }
      if (path in this.$__.selected) {
        return inclusive;
      }
      const pathDot = path + ".";
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (cur.startsWith(pathDot)) {
          return inclusive || cur !== pathDot;
        }
        if (pathDot.startsWith(cur + ".")) {
          return inclusive;
        }
      }
      return !inclusive;
    };
    Document.prototype.$__isSelected = Document.prototype.isSelected;
    Document.prototype.isDirectSelected = function isDirectSelected(path) {
      if (this.$__.selected == null) {
        return true;
      }
      if (path === "_id") {
        return this.$__.selected._id !== 0;
      }
      if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
      }
      if (Array.isArray(path)) {
        return path.some((p) => this.isDirectSelected(p));
      }
      const paths = Object.keys(this.$__.selected);
      let inclusive = null;
      if (paths.length === 1 && paths[0] === "_id") {
        return this.$__.selected._id === 0;
      }
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (!isDefiningProjection(this.$__.selected[cur])) {
          continue;
        }
        inclusive = !!this.$__.selected[cur];
        break;
      }
      if (inclusive === null) {
        return true;
      }
      if (this.$__.selected.hasOwnProperty(path)) {
        return inclusive;
      }
      return !inclusive;
    };
    Document.prototype.validate = function(pathsToValidate, options2, callback) {
      let parallelValidate;
      this.$op = "validate";
      if (this.ownerDocument != null) {
      } else if (this.$__.validating) {
        parallelValidate = new ParallelValidateError(this, {
          parentStack: options2 && options2.parentStack,
          conflictStack: this.$__.validating.stack
        });
      } else {
        this.$__.validating = new ParallelValidateError(this, { parentStack: options2 && options2.parentStack });
      }
      if (arguments.length === 1) {
        if (typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
          options2 = arguments[0];
          callback = null;
          pathsToValidate = null;
        } else if (typeof arguments[0] === "function") {
          callback = arguments[0];
          options2 = null;
          pathsToValidate = null;
        }
      } else if (typeof pathsToValidate === "function") {
        callback = pathsToValidate;
        options2 = null;
        pathsToValidate = null;
      } else if (typeof options2 === "function") {
        callback = options2;
        options2 = pathsToValidate;
        pathsToValidate = null;
      }
      if (options2 && typeof options2.pathsToSkip === "string") {
        const isOnePathOnly = options2.pathsToSkip.indexOf(" ") === -1;
        options2.pathsToSkip = isOnePathOnly ? [options2.pathsToSkip] : options2.pathsToSkip.split(" ");
      }
      return promiseOrCallback(callback, (cb) => {
        if (parallelValidate != null) {
          return cb(parallelValidate);
        }
        this.$__validate(pathsToValidate, options2, (error2) => {
          this.$op = null;
          cb(error2);
        });
      }, this.constructor.events);
    };
    function _evaluateRequiredFunctions(doc) {
      Object.keys(doc.$__.activePaths.states.require).forEach((path) => {
        const p = doc.$__schema.path(path);
        if (p != null && typeof p.originalRequiredValue === "function") {
          doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);
        }
      });
    }
    function _getPathsToValidate(doc) {
      const skipSchemaValidators = {};
      _evaluateRequiredFunctions(doc);
      let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function(path) {
        if (!doc.$__isSelected(path) && !doc.isModified(path)) {
          return false;
        }
        if (path in doc.$__.cachedRequired) {
          return doc.$__.cachedRequired[path];
        }
        return true;
      }));
      Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);
      Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);
      Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);
      function addToPaths(p) {
        paths.add(p);
      }
      const subdocs = doc.$getAllSubdocs();
      const modifiedPaths = doc.modifiedPaths();
      for (const subdoc of subdocs) {
        if (subdoc.$basePath) {
          for (const p of paths) {
            if (p === null || p.startsWith(subdoc.$basePath + ".")) {
              paths.delete(p);
            }
          }
          if (doc.isModified(subdoc.$basePath, modifiedPaths) && !doc.isDirectModified(subdoc.$basePath) && !doc.$isDefault(subdoc.$basePath)) {
            paths.add(subdoc.$basePath);
            skipSchemaValidators[subdoc.$basePath] = true;
          }
        }
      }
      for (const path of paths) {
        const _pathType = doc.$__schema.path(path);
        if (!_pathType || !_pathType.$isMongooseArray || _pathType.$isMongooseDocumentArray && !get2(_pathType, "schemaOptions.required")) {
          continue;
        }
        const val = doc.$__getValue(path);
        _pushNestedArrayPaths(val, paths, path);
      }
      function _pushNestedArrayPaths(val, paths2, path) {
        if (val != null) {
          const numElements = val.length;
          for (let j = 0; j < numElements; ++j) {
            if (Array.isArray(val[j])) {
              _pushNestedArrayPaths(val[j], paths2, path + "." + j);
            } else {
              paths2.add(path + "." + j);
            }
          }
        }
      }
      const flattenOptions = { skipArrays: true };
      for (const pathToCheck of paths) {
        if (doc.$__schema.nested[pathToCheck]) {
          let _v = doc.$__getValue(pathToCheck);
          if (isMongooseObject(_v)) {
            _v = _v.toObject({ transform: false });
          }
          const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);
          Object.keys(flat).forEach(addToPaths);
        }
      }
      for (const path of paths) {
        if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {
          paths.delete(path);
          continue;
        }
        const _pathType = doc.$__schema.path(path);
        if (!_pathType || !_pathType.$isSchemaMap) {
          continue;
        }
        const val = doc.$__getValue(path);
        if (val == null) {
          continue;
        }
        for (const key of val.keys()) {
          paths.add(path + "." + key);
        }
      }
      paths = Array.from(paths);
      return [paths, skipSchemaValidators];
    }
    Document.prototype.$__validate = function(pathsToValidate, options2, callback) {
      if (typeof pathsToValidate === "function") {
        callback = pathsToValidate;
        options2 = null;
        pathsToValidate = null;
      } else if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      const hasValidateModifiedOnlyOption = options2 && typeof options2 === "object" && "validateModifiedOnly" in options2;
      const pathsToSkip = get2(options2, "pathsToSkip", null);
      let shouldValidateModifiedOnly;
      if (hasValidateModifiedOnlyOption) {
        shouldValidateModifiedOnly = !!options2.validateModifiedOnly;
      } else {
        shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
      }
      const _this = this;
      const _complete = () => {
        let validationError = this.$__.validationError;
        this.$__.validationError = void 0;
        if (shouldValidateModifiedOnly && validationError != null) {
          const errors = Object.keys(validationError.errors);
          for (const errPath of errors) {
            if (!this.isModified(errPath)) {
              delete validationError.errors[errPath];
            }
          }
          if (Object.keys(validationError.errors).length === 0) {
            validationError = void 0;
          }
        }
        this.$__.cachedRequired = {};
        this.emit("validate", _this);
        this.constructor.emit("validate", _this);
        this.$__.validating = null;
        if (validationError) {
          for (const key in validationError.errors) {
            if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {
              this.invalidate(key, validationError.errors[key]);
            }
          }
          return validationError;
        }
      };
      const pathDetails = _getPathsToValidate(this);
      let paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.isModified(path)) : pathDetails[0];
      const skipSchemaValidators = pathDetails[1];
      if (typeof pathsToValidate === "string") {
        pathsToValidate = pathsToValidate.split(" ");
      }
      if (Array.isArray(pathsToValidate)) {
        paths = _handlePathsToValidate(paths, pathsToValidate);
      } else if (pathsToSkip) {
        paths = _handlePathsToSkip(paths, pathsToSkip);
      }
      if (paths.length === 0) {
        return immediate(function() {
          const error2 = _complete();
          if (error2) {
            return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error: error2 }, function(error3) {
              callback(error3);
            });
          }
          callback(null, _this);
        });
      }
      const validated = {};
      let total = 0;
      for (const path of paths) {
        validatePath(path);
      }
      function validatePath(path) {
        if (path == null || validated[path]) {
          return;
        }
        validated[path] = true;
        total++;
        immediate(function() {
          const schemaType = _this.$__schema.path(path);
          if (!schemaType) {
            return --total || complete();
          }
          if (!_this.$isValid(path)) {
            --total || complete();
            return;
          }
          if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {
            return --total || complete();
          }
          let val = _this.$__getValue(path);
          let pop;
          if (val == null && (pop = _this.populated(path))) {
            val = pop;
          }
          const scope = path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;
          const doValidateOptions = {
            skipSchemaValidators: skipSchemaValidators[path],
            path,
            validateModifiedOnly: shouldValidateModifiedOnly
          };
          schemaType.doValidate(val, function(err) {
            if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
              if (schemaType.$isSingleNested && err instanceof ValidationError && schemaType.schema.options.storeSubdocValidationError === false) {
                return --total || complete();
              }
              _this.invalidate(path, err, void 0, true);
            }
            --total || complete();
          }, scope, doValidateOptions);
        });
      }
      function complete() {
        const error2 = _complete();
        if (error2) {
          return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error: error2 }, function(error3) {
            callback(error3);
          });
        }
        callback(null, _this);
      }
    };
    function _handlePathsToValidate(paths, pathsToValidate) {
      const _pathsToValidate = new Set(pathsToValidate);
      const parentPaths = new Map([]);
      for (const path of pathsToValidate) {
        if (path.indexOf(".") === -1) {
          continue;
        }
        const pieces = path.split(".");
        let cur = pieces[0];
        for (let i = 1; i < pieces.length; ++i) {
          parentPaths.set(cur, path);
          cur = cur + "." + pieces[i];
        }
      }
      const ret2 = [];
      for (const path of paths) {
        if (_pathsToValidate.has(path)) {
          ret2.push(path);
        } else if (parentPaths.has(path)) {
          ret2.push(parentPaths.get(path));
        }
      }
      return ret2;
    }
    function _handlePathsToSkip(paths, pathsToSkip) {
      pathsToSkip = new Set(pathsToSkip);
      paths = paths.filter((p) => !pathsToSkip.has(p));
      return paths;
    }
    Document.prototype.validateSync = function(pathsToValidate, options2) {
      const _this = this;
      if (arguments.length === 1 && typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
        options2 = arguments[0];
        pathsToValidate = null;
      }
      const hasValidateModifiedOnlyOption = options2 && typeof options2 === "object" && "validateModifiedOnly" in options2;
      let shouldValidateModifiedOnly;
      if (hasValidateModifiedOnlyOption) {
        shouldValidateModifiedOnly = !!options2.validateModifiedOnly;
      } else {
        shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
      }
      let pathsToSkip = options2 && options2.pathsToSkip;
      if (typeof pathsToValidate === "string") {
        const isOnePathOnly = pathsToValidate.indexOf(" ") === -1;
        pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(" ");
      } else if (typeof pathsToSkip === "string" && pathsToSkip.indexOf(" ") !== -1) {
        pathsToSkip = pathsToSkip.split(" ");
      }
      const pathDetails = _getPathsToValidate(this);
      let paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.isModified(path)) : pathDetails[0];
      const skipSchemaValidators = pathDetails[1];
      if (Array.isArray(pathsToValidate)) {
        paths = _handlePathsToValidate(paths, pathsToValidate);
      } else if (Array.isArray(pathsToSkip)) {
        paths = _handlePathsToSkip(paths, pathsToSkip);
      }
      const validating = {};
      paths.forEach(function(path) {
        if (validating[path]) {
          return;
        }
        validating[path] = true;
        const p = _this.$__schema.path(path);
        if (!p) {
          return;
        }
        if (!_this.$isValid(path)) {
          return;
        }
        const val = _this.$__getValue(path);
        const err2 = p.doValidateSync(val, _this, {
          skipSchemaValidators: skipSchemaValidators[path],
          path,
          validateModifiedOnly: shouldValidateModifiedOnly
        });
        if (err2 && (!p.$isMongooseDocumentArray || err2.$isArrayValidatorError)) {
          if (p.$isSingleNested && err2 instanceof ValidationError && p.schema.options.storeSubdocValidationError === false) {
            return;
          }
          _this.invalidate(path, err2, void 0, true);
        }
      });
      const err = _this.$__.validationError;
      _this.$__.validationError = void 0;
      _this.emit("validate", _this);
      _this.constructor.emit("validate", _this);
      if (err) {
        for (const key in err.errors) {
          if (err.errors[key] instanceof MongooseError.CastError) {
            _this.invalidate(key, err.errors[key]);
          }
        }
      }
      return err;
    };
    Document.prototype.invalidate = function(path, err, val, kind) {
      if (!this.$__.validationError) {
        this.$__.validationError = new ValidationError(this);
      }
      if (this.$__.validationError.errors[path]) {
        return;
      }
      if (!err || typeof err === "string") {
        err = new ValidatorError({
          path,
          message: err,
          type: kind || "user defined",
          value: val
        });
      }
      if (this.$__.validationError === err) {
        return this.$__.validationError;
      }
      this.$__.validationError.addError(path, err);
      return this.$__.validationError;
    };
    Document.prototype.$markValid = function(path) {
      if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
        return;
      }
      delete this.$__.validationError.errors[path];
      if (Object.keys(this.$__.validationError.errors).length === 0) {
        this.$__.validationError = null;
      }
    };
    function _markValidSubpaths(doc, path) {
      if (!doc.$__.validationError) {
        return;
      }
      const keys = Object.keys(doc.$__.validationError.errors);
      for (const key of keys) {
        if (key.startsWith(path + ".")) {
          delete doc.$__.validationError.errors[key];
        }
      }
      if (Object.keys(doc.$__.validationError.errors).length === 0) {
        doc.$__.validationError = null;
      }
    }
    function _checkImmutableSubpaths(subdoc, schematype, priorVal) {
      const schema = schematype.schema;
      if (schema == null) {
        return;
      }
      for (const key of Object.keys(schema.paths)) {
        const path = schema.paths[key];
        if (path.$immutableSetter == null) {
          continue;
        }
        const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);
        path.$immutableSetter.call(subdoc, oldVal);
      }
    }
    Document.prototype.$isValid = function(path) {
      if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {
        return true;
      }
      if (path == null) {
        return false;
      }
      if (path.indexOf(" ") !== -1) {
        path = path.split(" ");
      }
      if (Array.isArray(path)) {
        return path.some((p) => this.$__.validationError.errors[p] == null);
      }
      return this.$__.validationError.errors[path] == null;
    };
    Document.prototype.$__reset = function reset() {
      let _this = this;
      DocumentArray || (DocumentArray = require_documentarray());
      this.$__.activePaths.map("init", "modify", function(i) {
        return _this.$__getValue(i);
      }).filter(function(val) {
        return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
      }).forEach(function(array) {
        let i = array.length;
        while (i--) {
          const doc = array[i];
          if (!doc) {
            continue;
          }
          doc.$__reset();
        }
        _this.$__.activePaths.init(array.$path());
        array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
        array[arrayAtomicsSymbol] = {};
      });
      this.$__.activePaths.map("init", "modify", function(i) {
        return _this.$__getValue(i);
      }).filter(function(val) {
        return val && val.$isSingleNested;
      }).forEach(function(doc) {
        doc.$__reset();
        if (doc.$__parent === _this) {
          _this.$__.activePaths.init(doc.$basePath);
        } else if (doc.$__parent != null && doc.$__parent.ownerDocument) {
          doc.$__parent.$__reset();
        }
      });
      this.$__dirty().forEach(function(dirt) {
        const type = dirt.value;
        if (type && type[arrayAtomicsSymbol]) {
          type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
          type[arrayAtomicsSymbol] = {};
        }
      });
      this.$__.backup = {};
      this.$__.backup.activePaths = {
        modify: Object.assign({}, this.$__.activePaths.states.modify),
        default: Object.assign({}, this.$__.activePaths.states.default)
      };
      this.$__.backup.validationError = this.$__.validationError;
      this.$__.backup.errors = this.errors;
      this.$__.activePaths.clear("modify");
      this.$__.activePaths.clear("default");
      this.$__.validationError = void 0;
      this.errors = void 0;
      _this = this;
      this.$__schema.requiredPaths().forEach(function(path) {
        _this.$__.activePaths.require(path);
      });
      return this;
    };
    Document.prototype.$__undoReset = function $__undoReset() {
      if (this.$__.backup == null || this.$__.backup.activePaths == null) {
        return;
      }
      this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
      this.$__.activePaths.states.default = this.$__.backup.activePaths.default;
      this.$__.validationError = this.$__.backup.validationError;
      this.errors = this.$__.backup.errors;
      for (const dirt of this.$__dirty()) {
        const type = dirt.value;
        if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
          type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
        }
      }
      for (const subdoc of this.$getAllSubdocs()) {
        subdoc.$__undoReset();
      }
    };
    Document.prototype.$__dirty = function() {
      const _this = this;
      let all = this.$__.activePaths.map("modify", function(path) {
        return {
          path,
          value: _this.$__getValue(path),
          schema: _this.$__path(path)
        };
      });
      all = all.concat(this.$__.activePaths.map("default", function(path) {
        if (path === "_id" || _this.$__getValue(path) == null) {
          return;
        }
        return {
          path,
          value: _this.$__getValue(path),
          schema: _this.$__path(path)
        };
      }));
      all.sort(function(a, b) {
        return a.path < b.path ? -1 : a.path > b.path ? 1 : 0;
      });
      const minimal = [];
      let lastPath;
      let top;
      all.forEach(function(item) {
        if (!item) {
          return;
        }
        if (lastPath == null || item.path.indexOf(lastPath) !== 0) {
          lastPath = item.path + ".";
          minimal.push(item);
          top = item;
        } else if (top != null && top.value != null && top.value[arrayAtomicsSymbol] != null && top.value.hasAtomics()) {
          top.value[arrayAtomicsSymbol] = {};
          top.value[arrayAtomicsSymbol].$set = top.value;
        }
      });
      top = lastPath = null;
      return minimal;
    };
    Document.prototype.$__setSchema = function(schema) {
      schema.plugin(idGetter, { deduplicate: true });
      compile(schema.tree, this, void 0, schema.options);
      for (const key of Object.keys(schema.virtuals)) {
        schema.virtuals[key]._applyDefaultGetters();
      }
      if (schema.path("schema") == null) {
        this.schema = schema;
      }
      this.$__schema = schema;
      this[documentSchemaSymbol] = schema;
    };
    Document.prototype.$__getArrayPathsToValidate = function() {
      DocumentArray || (DocumentArray = require_documentarray());
      return this.$__.activePaths.map("init", "modify", function(i) {
        return this.$__getValue(i);
      }.bind(this)).filter(function(val) {
        return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
      }).reduce(function(seed, array) {
        return seed.concat(array);
      }, []).filter(function(doc) {
        return doc;
      });
    };
    Document.prototype.$getAllSubdocs = function $getAllSubdocs() {
      DocumentArray || (DocumentArray = require_documentarray());
      Embedded = Embedded || require_embedded();
      function docReducer(doc, seed, path) {
        let val = doc;
        let isNested = false;
        if (path) {
          if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {
            val = doc._doc[path];
          } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {
            val = doc._doc[path];
            isNested = true;
          } else {
            val = doc[path];
          }
        }
        if (val instanceof Embedded) {
          seed.push(val);
        } else if (val instanceof Map) {
          seed = Array.from(val.keys()).reduce(function(seed2, path2) {
            return docReducer(val.get(path2), seed2, null);
          }, seed);
        } else if (val && val.$isSingleNested) {
          seed = Object.keys(val._doc).reduce(function(seed2, path2) {
            return docReducer(val._doc, seed2, path2);
          }, seed);
          seed.push(val);
        } else if (val && val.isMongooseDocumentArray) {
          val.forEach(function _docReduce(doc2) {
            if (!doc2 || !doc2._doc) {
              return;
            }
            seed = Object.keys(doc2._doc).reduce(function(seed2, path2) {
              return docReducer(doc2._doc, seed2, path2);
            }, seed);
            if (doc2 instanceof Embedded) {
              seed.push(doc2);
            }
          });
        } else if (isNested && val != null) {
          for (const path2 of Object.keys(val)) {
            docReducer(val, seed, path2);
          }
        }
        return seed;
      }
      const subDocs = [];
      for (const path of Object.keys(this._doc)) {
        docReducer(this, subDocs, path);
      }
      return subDocs;
    };
    function applyQueue(doc) {
      const q = doc.$__schema && doc.$__schema.callQueue;
      if (!q.length) {
        return;
      }
      for (const pair of q) {
        if (pair[0] !== "pre" && pair[0] !== "post" && pair[0] !== "on") {
          doc[pair[0]].apply(doc, pair[1]);
        }
      }
    }
    Document.prototype.$__handleReject = function handleReject(err) {
      if (this.listeners("error").length) {
        this.emit("error", err);
      } else if (this.constructor.listeners && this.constructor.listeners("error").length) {
        this.constructor.emit("error", err);
      }
    };
    Document.prototype.$toObject = function(options2, json) {
      let defaultOptions = {
        transform: true,
        flattenDecimals: true
      };
      const path = json ? "toJSON" : "toObject";
      const baseOptions = get2(this, "constructor.base.options." + path, {});
      const schemaOptions = get2(this, "$__schema.options", {});
      defaultOptions = utils2.options(defaultOptions, clone2(baseOptions));
      defaultOptions = utils2.options(defaultOptions, clone2(schemaOptions[path] || {}));
      options2 = utils2.isPOJO(options2) ? clone2(options2) : {};
      options2._calledWithOptions = options2._calledWithOptions || clone2(options2);
      let _minimize;
      if (options2._calledWithOptions.minimize != null) {
        _minimize = options2.minimize;
      } else if (defaultOptions.minimize != null) {
        _minimize = defaultOptions.minimize;
      } else {
        _minimize = schemaOptions.minimize;
      }
      let flattenMaps;
      if (options2._calledWithOptions.flattenMaps != null) {
        flattenMaps = options2.flattenMaps;
      } else if (defaultOptions.flattenMaps != null) {
        flattenMaps = defaultOptions.flattenMaps;
      } else {
        flattenMaps = schemaOptions.flattenMaps;
      }
      const cloneOptions = Object.assign(utils2.clone(options2), {
        _isNested: true,
        json,
        minimize: _minimize,
        flattenMaps
      });
      if (utils2.hasUserDefinedProperty(options2, "getters")) {
        cloneOptions.getters = options2.getters;
      }
      if (utils2.hasUserDefinedProperty(options2, "virtuals")) {
        cloneOptions.virtuals = options2.virtuals;
      }
      const depopulate = options2.depopulate || get2(options2, "_parentOptions.depopulate", false);
      if (depopulate && options2._isNested && this.$__.wasPopulated) {
        return clone2(this._id, cloneOptions);
      }
      options2 = utils2.options(defaultOptions, options2);
      options2._isNested = true;
      options2.json = json;
      options2.minimize = _minimize;
      cloneOptions._parentOptions = options2;
      cloneOptions._skipSingleNestedGetters = true;
      const gettersOptions = Object.assign({}, cloneOptions);
      gettersOptions._skipSingleNestedGetters = false;
      const originalTransform = options2.transform;
      let ret2 = clone2(this._doc, cloneOptions) || {};
      if (options2.getters) {
        applyGetters(this, ret2, gettersOptions);
        if (options2.minimize) {
          ret2 = minimize(ret2) || {};
        }
      }
      if (options2.virtuals || options2.getters && options2.virtuals !== false) {
        applyVirtuals(this, ret2, gettersOptions, options2);
      }
      if (options2.versionKey === false && this.$__schema.options.versionKey) {
        delete ret2[this.$__schema.options.versionKey];
      }
      let transform = options2.transform;
      if (transform) {
        applySchemaTypeTransforms(this, ret2);
      }
      if (options2.useProjection) {
        omitDeselectedFields(this, ret2);
      }
      if (transform === true || schemaOptions.toObject && transform) {
        const opts = options2.json ? schemaOptions.toJSON : schemaOptions.toObject;
        if (opts) {
          transform = typeof options2.transform === "function" ? options2.transform : opts.transform;
        }
      } else {
        options2.transform = originalTransform;
      }
      if (typeof transform === "function") {
        const xformed = transform(this, ret2, options2);
        if (typeof xformed !== "undefined") {
          ret2 = xformed;
        }
      }
      return ret2;
    };
    Document.prototype.toObject = function(options2) {
      return this.$toObject(options2);
    };
    function minimize(obj) {
      const keys = Object.keys(obj);
      let i = keys.length;
      let hasKeys;
      let key;
      let val;
      while (i--) {
        key = keys[i];
        val = obj[key];
        if (utils2.isObject(val) && !Buffer.isBuffer(val)) {
          obj[key] = minimize(val);
        }
        if (obj[key] === void 0) {
          delete obj[key];
          continue;
        }
        hasKeys = true;
      }
      return hasKeys ? obj : void 0;
    }
    function applyVirtuals(self2, json, options2, toObjectOptions) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.virtuals);
      let i = paths.length;
      const numPaths = i;
      let path;
      let assignPath;
      let cur = self2._doc;
      let v;
      const aliases = get2(toObjectOptions, "aliases", true);
      let virtualsToApply = null;
      if (Array.isArray(options2.virtuals)) {
        virtualsToApply = new Set(options2.virtuals);
      } else if (options2.virtuals && options2.virtuals.pathsToSkip) {
        virtualsToApply = new Set(paths);
        for (let i2 = 0; i2 < options2.virtuals.pathsToSkip.length; i2++) {
          if (virtualsToApply.has(options2.virtuals.pathsToSkip[i2])) {
            virtualsToApply.delete(options2.virtuals.pathsToSkip[i2]);
          }
        }
      }
      if (!cur) {
        return json;
      }
      options2 = options2 || {};
      for (i = 0; i < numPaths; ++i) {
        path = paths[i];
        if (virtualsToApply != null && !virtualsToApply.has(path)) {
          continue;
        }
        if (!aliases && schema.aliases.hasOwnProperty(path)) {
          continue;
        }
        assignPath = path;
        if (options2.path != null) {
          if (!path.startsWith(options2.path + ".")) {
            continue;
          }
          assignPath = path.substr(options2.path.length + 1);
        }
        const parts = assignPath.split(".");
        v = clone2(self2.get(path), options2);
        if (v === void 0) {
          continue;
        }
        const plen = parts.length;
        cur = json;
        for (let j = 0; j < plen - 1; ++j) {
          cur[parts[j]] = cur[parts[j]] || {};
          cur = cur[parts[j]];
        }
        cur[parts[plen - 1]] = v;
      }
      return json;
    }
    function applyGetters(self2, json, options2) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths);
      let i = paths.length;
      let path;
      let cur = self2._doc;
      let v;
      if (!cur) {
        return json;
      }
      while (i--) {
        path = paths[i];
        const parts = path.split(".");
        const plen = parts.length;
        const last = plen - 1;
        let branch = json;
        let part;
        cur = self2._doc;
        if (!self2.$__isSelected(path)) {
          continue;
        }
        for (let ii = 0; ii < plen; ++ii) {
          part = parts[ii];
          v = cur[part];
          if (ii === last) {
            const val = self2.get(path);
            branch[part] = clone2(val, options2);
          } else if (v == null) {
            if (part in cur) {
              branch[part] = v;
            }
            break;
          } else {
            branch = branch[part] || (branch[part] = {});
          }
          cur = v;
        }
      }
      return json;
    }
    function applySchemaTypeTransforms(self2, json) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths || {});
      const cur = self2._doc;
      if (!cur) {
        return json;
      }
      for (const path of paths) {
        const schematype = schema.paths[path];
        if (typeof schematype.options.transform === "function") {
          const val = self2.get(path);
          const transformedValue = schematype.options.transform.call(self2, val);
          throwErrorIfPromise(path, transformedValue);
          utils2.setValue(path, transformedValue, json);
        } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === "function") {
          const vals = [].concat(self2.get(path));
          const transform = schematype.$embeddedSchemaType.options.transform;
          for (let i = 0; i < vals.length; ++i) {
            const transformedValue = transform.call(self2, vals[i]);
            vals[i] = transformedValue;
            throwErrorIfPromise(path, transformedValue);
          }
          json[path] = vals;
        }
      }
      return json;
    }
    function throwErrorIfPromise(path, transformedValue) {
      if (isPromise(transformedValue)) {
        throw new Error("`transform` function must be synchronous, but the transform on path `" + path + "` returned a promise.");
      }
    }
    function omitDeselectedFields(self2, json) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths || {});
      const cur = self2._doc;
      if (!cur) {
        return json;
      }
      let selected = self2.$__.selected;
      if (selected === void 0) {
        selected = {};
        queryhelpers.applyPaths(selected, schema);
      }
      if (selected == null || Object.keys(selected).length === 0) {
        return json;
      }
      for (const path of paths) {
        if (selected[path] != null && !selected[path]) {
          delete json[path];
        }
      }
      return json;
    }
    Document.prototype.toJSON = function(options2) {
      return this.$toObject(options2, true);
    };
    Document.prototype.parent = function() {
      return this.$__.parent;
    };
    Document.prototype.$parent = Document.prototype.parent;
    Document.prototype.inspect = function(options2) {
      const isPOJO = utils2.isPOJO(options2);
      let opts;
      if (isPOJO) {
        opts = options2;
        opts.minimize = false;
      }
      const ret2 = this.toObject(opts);
      if (ret2 == null) {
        return "MongooseDocument { " + ret2 + " }";
      }
      return ret2;
    };
    if (inspect.custom) {
      Document.prototype[inspect.custom] = Document.prototype.inspect;
    }
    Document.prototype.toString = function() {
      const ret2 = this.inspect();
      if (typeof ret2 === "string") {
        return ret2;
      }
      return inspect(ret2);
    };
    Document.prototype.equals = function(doc) {
      if (!doc) {
        return false;
      }
      const tid = this.$__getValue("_id");
      const docid = doc.$__ != null ? doc.$__getValue("_id") : doc;
      if (!tid && !docid) {
        return deepEqual(this, doc);
      }
      return tid && tid.equals ? tid.equals(docid) : tid === docid;
    };
    Document.prototype.populate = function populate() {
      if (arguments.length === 0) {
        return this;
      }
      const pop = this.$__.populate || (this.$__.populate = {});
      const args = utils2.args(arguments);
      let fn;
      if (typeof args[args.length - 1] === "function") {
        fn = args.pop();
      }
      if (args.length) {
        const res = utils2.populate.apply(null, args);
        for (const populateOptions of res) {
          pop[populateOptions.path] = populateOptions;
        }
      }
      if (fn) {
        const paths = utils2.object.vals(pop);
        this.$__.populate = void 0;
        let topLevelModel = this.constructor;
        if (this.$__isNested) {
          topLevelModel = this.$__[scopeSymbol].constructor;
          const nestedPath = this.$__.nestedPath;
          paths.forEach(function(populateOptions) {
            populateOptions.path = nestedPath + "." + populateOptions.path;
          });
        }
        if (this.$session() != null) {
          const session = this.$session();
          paths.forEach((path) => {
            if (path.options == null) {
              path.options = { session };
              return;
            }
            if (!("session" in path.options)) {
              path.options.session = session;
            }
          });
        }
        topLevelModel.populate(this, paths, fn);
      }
      return this;
    };
    Document.prototype.$getPopulatedDocs = function $getPopulatedDocs() {
      let keys = [];
      if (this.$__.populated != null) {
        keys = keys.concat(Object.keys(this.$__.populated));
      }
      if (this.$$populatedVirtuals != null) {
        keys = keys.concat(Object.keys(this.$$populatedVirtuals));
      }
      let result = [];
      for (const key of keys) {
        const value = this.get(key);
        if (Array.isArray(value)) {
          result = result.concat(value);
        } else if (value instanceof Document) {
          result.push(value);
        }
      }
      return result;
    };
    Document.prototype.execPopulate = function(callback) {
      const isUsingShorthand = callback != null && typeof callback !== "function";
      if (isUsingShorthand) {
        return this.populate.apply(this, arguments).execPopulate();
      }
      return promiseOrCallback(callback, (cb) => {
        this.populate(cb);
      }, this.constructor.events);
    };
    Document.prototype.populated = function(path, val, options2) {
      if (val == null || val === true) {
        if (!this.$__.populated) {
          return void 0;
        }
        const _path = path.endsWith(".$*") ? path.replace(/\.\$\*$/, "") : path;
        const v = this.$__.populated[_path];
        if (v) {
          return val === true ? v : v.value;
        }
        return void 0;
      }
      this.$__.populated || (this.$__.populated = {});
      this.$__.populated[path] = { value: val, options: options2 };
      const pieces = path.split(".");
      for (let i = 0; i < pieces.length - 1; ++i) {
        const subpath = pieces.slice(0, i + 1).join(".");
        const subdoc = this.get(subpath);
        if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {
          const rest = pieces.slice(i + 1).join(".");
          subdoc.populated(rest, val, options2);
          break;
        }
      }
      return val;
    };
    Document.prototype.depopulate = function(path) {
      if (typeof path === "string") {
        path = path.split(" ");
      }
      let populatedIds;
      const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
      const populated = get2(this, "$__.populated", {});
      if (arguments.length === 0) {
        for (const virtualKey of virtualKeys) {
          delete this.$$populatedVirtuals[virtualKey];
          delete this._doc[virtualKey];
          delete populated[virtualKey];
        }
        const keys = Object.keys(populated);
        for (const key of keys) {
          populatedIds = this.populated(key);
          if (!populatedIds) {
            continue;
          }
          delete populated[key];
          this.$set(key, populatedIds);
        }
        return this;
      }
      for (const singlePath of path) {
        populatedIds = this.populated(singlePath);
        delete populated[singlePath];
        if (virtualKeys.indexOf(singlePath) !== -1) {
          delete this.$$populatedVirtuals[singlePath];
          delete this._doc[singlePath];
        } else if (populatedIds) {
          this.$set(singlePath, populatedIds);
        }
      }
      return this;
    };
    Document.prototype.$__fullPath = function(path) {
      return path || "";
    };
    Document.prototype.getChanges = function() {
      const delta = this.$__delta();
      const changes = delta ? delta[1] : {};
      return changes;
    };
    Document.ValidationError = ValidationError;
    module2.exports = exports2 = Document;
  }
});

// node_modules/mongoose/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/mongoose/lib/utils.js"(exports2) {
    init_shims();
    "use strict";
    var ms = require_ms();
    var mpath = require_mpath();
    var sliced = require_sliced();
    var Buffer2 = require_safe_buffer().Buffer;
    var Decimal = require_decimal1282();
    var ObjectId2 = require_objectid3();
    var PopulateOptions = require_PopulateOptions();
    var clone2 = require_clone();
    var immediate = require_immediate();
    var isObject2 = require_isObject();
    var isBsonType = require_isBsonType();
    var getFunctionName = require_getFunctionName();
    var isMongooseObject = require_isMongooseObject();
    var promiseOrCallback = require_promiseOrCallback();
    var schemaMerge = require_merge();
    var specialProperties = require_specialProperties();
    var Document;
    exports2.specialProperties = specialProperties;
    exports2.toCollectionName = function(name, pluralize) {
      if (name === "system.profile") {
        return name;
      }
      if (name === "system.indexes") {
        return name;
      }
      if (typeof pluralize === "function") {
        return pluralize(name);
      }
      return name;
    };
    exports2.deepEqual = function deepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== "object" && typeof b !== "object") {
        return a === b;
      }
      if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      }
      if (isBsonType(a, "ObjectID") && isBsonType(b, "ObjectID") || isBsonType(a, "Decimal128") && isBsonType(b, "Decimal128")) {
        return a.toString() === b.toString();
      }
      if (a instanceof RegExp && b instanceof RegExp) {
        return a.source === b.source && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.global === b.global;
      }
      if (a == null || b == null) {
        return false;
      }
      if (a.prototype !== b.prototype) {
        return false;
      }
      if (a instanceof Map && b instanceof Map) {
        return deepEqual(Array.from(a.keys()), Array.from(b.keys())) && deepEqual(Array.from(a.values()), Array.from(b.values()));
      }
      if (a instanceof Number && b instanceof Number) {
        return a.valueOf() === b.valueOf();
      }
      if (Buffer2.isBuffer(a)) {
        return exports2.buffer.areEqual(a, b);
      }
      if (Array.isArray(a) && Array.isArray(b)) {
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        for (let i = 0; i < len; ++i) {
          if (!deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      if (a.$__ != null) {
        a = a._doc;
      } else if (isMongooseObject(a)) {
        a = a.toObject();
      }
      if (b.$__ != null) {
        b = b._doc;
      } else if (isMongooseObject(b)) {
        b = b.toObject();
      }
      const ka = Object.keys(a);
      const kb = Object.keys(b);
      const kaLength = ka.length;
      if (kaLength !== kb.length) {
        return false;
      }
      ka.sort();
      kb.sort();
      for (let i = kaLength - 1; i >= 0; i--) {
        if (ka[i] !== kb[i]) {
          return false;
        }
      }
      for (const key of ka) {
        if (!deepEqual(a[key], b[key])) {
          return false;
        }
      }
      return true;
    };
    exports2.last = function(arr) {
      if (arr.length > 0) {
        return arr[arr.length - 1];
      }
      return void 0;
    };
    exports2.clone = clone2;
    exports2.promiseOrCallback = promiseOrCallback;
    exports2.omit = function omit(obj, keys) {
      if (keys == null) {
        return Object.assign({}, obj);
      }
      if (!Array.isArray(keys)) {
        keys = [keys];
      }
      const ret2 = Object.assign({}, obj);
      for (const key of keys) {
        delete ret2[key];
      }
      return ret2;
    };
    exports2.options = function(defaults, options2) {
      const keys = Object.keys(defaults);
      let i = keys.length;
      let k;
      options2 = options2 || {};
      while (i--) {
        k = keys[i];
        if (!(k in options2)) {
          options2[k] = defaults[k];
        }
      }
      return options2;
    };
    exports2.random = function() {
      return Math.random().toString().substr(3);
    };
    exports2.merge = function merge(to, from, options2, path) {
      options2 = options2 || {};
      const keys = Object.keys(from);
      let i = 0;
      const len = keys.length;
      let key;
      path = path || "";
      const omitNested = options2.omitNested || {};
      while (i < len) {
        key = keys[i++];
        if (options2.omit && options2.omit[key]) {
          continue;
        }
        if (omitNested[path]) {
          continue;
        }
        if (specialProperties.has(key)) {
          continue;
        }
        if (to[key] == null) {
          to[key] = from[key];
        } else if (exports2.isObject(from[key])) {
          if (!exports2.isObject(to[key])) {
            to[key] = {};
          }
          if (from[key] != null) {
            if (options2.isDiscriminatorSchemaMerge && (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {
              continue;
            } else if (from[key].instanceOfSchema) {
              if (to[key].instanceOfSchema) {
                schemaMerge(to[key], from[key].clone(), options2.isDiscriminatorSchemaMerge);
              } else {
                to[key] = from[key].clone();
              }
              continue;
            } else if (from[key] instanceof ObjectId2) {
              to[key] = new ObjectId2(from[key]);
              continue;
            }
          }
          merge(to[key], from[key], options2, path ? path + "." + key : key);
        } else if (options2.overwrite) {
          to[key] = from[key];
        }
      }
    };
    exports2.toObject = function toObject(obj) {
      Document || (Document = require_document());
      let ret2;
      if (obj == null) {
        return obj;
      }
      if (obj instanceof Document) {
        return obj.toObject();
      }
      if (Array.isArray(obj)) {
        ret2 = [];
        for (const doc of obj) {
          ret2.push(toObject(doc));
        }
        return ret2;
      }
      if (exports2.isPOJO(obj)) {
        ret2 = {};
        for (const k of Object.keys(obj)) {
          if (specialProperties.has(k)) {
            continue;
          }
          ret2[k] = toObject(obj[k]);
        }
        return ret2;
      }
      return obj;
    };
    exports2.isObject = isObject2;
    exports2.isPOJO = function isPOJO(arg) {
      if (arg == null || typeof arg !== "object") {
        return false;
      }
      const proto = Object.getPrototypeOf(arg);
      return !proto || proto.constructor.name === "Object";
    };
    exports2.isNativeObject = function(arg) {
      return Array.isArray(arg) || arg instanceof Date || arg instanceof Boolean || arg instanceof Number || arg instanceof String;
    };
    exports2.isEmptyObject = function(val) {
      return val != null && typeof val === "object" && Object.keys(val).length === 0;
    };
    exports2.hasKey = function hasKey(obj, key) {
      const props = Object.keys(obj);
      for (const prop of props) {
        if (prop === key) {
          return true;
        }
        if (exports2.isPOJO(obj[prop]) && exports2.hasKey(obj[prop], key)) {
          return true;
        }
      }
      return false;
    };
    exports2.args = sliced;
    exports2.tick = function tick(callback) {
      if (typeof callback !== "function") {
        return;
      }
      return function() {
        try {
          callback.apply(this, arguments);
        } catch (err) {
          immediate(function() {
            throw err;
          });
        }
      };
    };
    exports2.isMongooseType = function(v) {
      return v instanceof ObjectId2 || v instanceof Decimal || v instanceof Buffer2;
    };
    exports2.isMongooseObject = isMongooseObject;
    exports2.expires = function expires(object) {
      if (!(object && object.constructor.name === "Object")) {
        return;
      }
      if (!("expires" in object)) {
        return;
      }
      let when;
      if (typeof object.expires !== "string") {
        when = object.expires;
      } else {
        when = Math.round(ms(object.expires) / 1e3);
      }
      object.expireAfterSeconds = when;
      delete object.expires;
    };
    exports2.populate = function populate(path, select, model, match, options2, subPopulate, justOne, count) {
      let obj = null;
      if (arguments.length === 1) {
        if (path instanceof PopulateOptions) {
          return [path];
        }
        if (Array.isArray(path)) {
          const singles = makeSingles(path);
          return singles.map((o) => exports2.populate(o)[0]);
        }
        if (exports2.isObject(path)) {
          obj = Object.assign({}, path);
        } else {
          obj = { path };
        }
      } else if (typeof model === "object") {
        obj = {
          path,
          select,
          match: model,
          options: match
        };
      } else {
        obj = {
          path,
          select,
          model,
          match,
          options: options2,
          populate: subPopulate,
          justOne,
          count
        };
      }
      if (typeof obj.path !== "string") {
        throw new TypeError("utils.populate: invalid path. Expected string. Got typeof `" + typeof path + "`");
      }
      return _populateObj(obj);
      function makeSingles(arr) {
        const ret2 = [];
        arr.forEach(function(obj2) {
          if (/[\s]/.test(obj2.path)) {
            const paths = obj2.path.split(" ");
            paths.forEach(function(p) {
              const copy = Object.assign({}, obj2);
              copy.path = p;
              ret2.push(copy);
            });
          } else {
            ret2.push(obj2);
          }
        });
        return ret2;
      }
    };
    function _populateObj(obj) {
      if (Array.isArray(obj.populate)) {
        const ret3 = [];
        obj.populate.forEach(function(obj2) {
          if (/[\s]/.test(obj2.path)) {
            const copy = Object.assign({}, obj2);
            const paths2 = copy.path.split(" ");
            paths2.forEach(function(p) {
              copy.path = p;
              ret3.push(exports2.populate(copy)[0]);
            });
          } else {
            ret3.push(exports2.populate(obj2)[0]);
          }
        });
        obj.populate = exports2.populate(ret3);
      } else if (obj.populate != null && typeof obj.populate === "object") {
        obj.populate = exports2.populate(obj.populate);
      }
      const ret2 = [];
      const paths = obj.path.split(" ");
      if (obj.options != null) {
        obj.options = exports2.clone(obj.options);
      }
      for (const path of paths) {
        ret2.push(new PopulateOptions(Object.assign({}, obj, { path })));
      }
      return ret2;
    }
    exports2.getValue = function(path, obj, map) {
      return mpath.get(path, obj, "_doc", map);
    };
    exports2.setValue = function(path, val, obj, map, _copying) {
      mpath.set(path, val, obj, "_doc", map, _copying);
    };
    exports2.object = {};
    exports2.object.vals = function vals(o) {
      const keys = Object.keys(o);
      let i = keys.length;
      const ret2 = [];
      while (i--) {
        ret2.push(o[keys[i]]);
      }
      return ret2;
    };
    exports2.object.shallowCopy = exports2.options;
    var hop = Object.prototype.hasOwnProperty;
    exports2.object.hasOwnProperty = function(obj, prop) {
      return hop.call(obj, prop);
    };
    exports2.isNullOrUndefined = function(val) {
      return val === null || val === void 0;
    };
    exports2.array = {};
    exports2.array.flatten = function flatten(arr, filter, ret2) {
      ret2 || (ret2 = []);
      arr.forEach(function(item) {
        if (Array.isArray(item)) {
          flatten(item, filter, ret2);
        } else {
          if (!filter || filter(item)) {
            ret2.push(item);
          }
        }
      });
      return ret2;
    };
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    exports2.hasUserDefinedProperty = function(obj, key) {
      if (obj == null) {
        return false;
      }
      if (Array.isArray(key)) {
        for (const k of key) {
          if (exports2.hasUserDefinedProperty(obj, k)) {
            return true;
          }
        }
        return false;
      }
      if (_hasOwnProperty.call(obj, key)) {
        return true;
      }
      if (typeof obj === "object" && key in obj) {
        const v = obj[key];
        return v !== Object.prototype[key] && v !== Array.prototype[key];
      }
      return false;
    };
    var MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;
    exports2.isArrayIndex = function(val) {
      if (typeof val === "number") {
        return val >= 0 && val <= MAX_ARRAY_INDEX;
      }
      if (typeof val === "string") {
        if (!/^\d+$/.test(val)) {
          return false;
        }
        val = +val;
        return val >= 0 && val <= MAX_ARRAY_INDEX;
      }
      return false;
    };
    exports2.array.unique = function(arr) {
      const primitives = new Set();
      const ids = new Set();
      const ret2 = [];
      for (const item of arr) {
        if (typeof item === "number" || typeof item === "string" || item == null) {
          if (primitives.has(item)) {
            continue;
          }
          ret2.push(item);
          primitives.add(item);
        } else if (item instanceof ObjectId2) {
          if (ids.has(item.toString())) {
            continue;
          }
          ret2.push(item);
          ids.add(item.toString());
        } else {
          ret2.push(item);
        }
      }
      return ret2;
    };
    exports2.buffer = {};
    exports2.buffer.areEqual = function(a, b) {
      if (!Buffer2.isBuffer(a)) {
        return false;
      }
      if (!Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0, len = a.length; i < len; ++i) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    };
    exports2.getFunctionName = getFunctionName;
    exports2.decorate = function(destination, source) {
      for (const key in source) {
        if (specialProperties.has(key)) {
          continue;
        }
        destination[key] = source[key];
      }
    };
    exports2.mergeClone = function(to, fromObj) {
      if (isMongooseObject(fromObj)) {
        fromObj = fromObj.toObject({
          transform: false,
          virtuals: false,
          depopulate: true,
          getters: false,
          flattenDecimals: false
        });
      }
      const keys = Object.keys(fromObj);
      const len = keys.length;
      let i = 0;
      let key;
      while (i < len) {
        key = keys[i++];
        if (specialProperties.has(key)) {
          continue;
        }
        if (typeof to[key] === "undefined") {
          to[key] = exports2.clone(fromObj[key], {
            transform: false,
            virtuals: false,
            depopulate: true,
            getters: false,
            flattenDecimals: false
          });
        } else {
          let val = fromObj[key];
          if (val != null && val.valueOf && !(val instanceof Date)) {
            val = val.valueOf();
          }
          if (exports2.isObject(val)) {
            let obj = val;
            if (isMongooseObject(val) && !val.isMongooseBuffer) {
              obj = obj.toObject({
                transform: false,
                virtuals: false,
                depopulate: true,
                getters: false,
                flattenDecimals: false
              });
            }
            if (val.isMongooseBuffer) {
              obj = Buffer2.from(obj);
            }
            exports2.mergeClone(to[key], obj);
          } else {
            to[key] = exports2.clone(val, {
              flattenDecimals: false
            });
          }
        }
      }
    };
    exports2.each = function(arr, fn) {
      for (const item of arr) {
        fn(item);
      }
    };
    exports2.getOption = function(name) {
      const sources = Array.prototype.slice.call(arguments, 1);
      for (const source of sources) {
        if (source[name] != null) {
          return source[name];
        }
      }
      return null;
    };
    exports2.noop = function() {
    };
    exports2.errorToPOJO = function errorToPOJO(error2) {
      const isError2 = error2 instanceof Error;
      if (!isError2) {
        throw new Error("`error` must be `instanceof Error`.");
      }
      const ret2 = {};
      for (const properyName of Object.getOwnPropertyNames(error2)) {
        ret2[properyName] = error2[properyName];
      }
      return ret2;
    };
  }
});

// node_modules/mongoose/lib/helpers/clone.js
var require_clone = __commonJS({
  "node_modules/mongoose/lib/helpers/clone.js"(exports2, module2) {
    init_shims();
    "use strict";
    var cloneRegExp = require_regexp_clone();
    var Decimal = require_decimal1282();
    var ObjectId2 = require_objectid3();
    var specialProperties = require_specialProperties();
    var isMongooseObject = require_isMongooseObject();
    var getFunctionName = require_getFunctionName();
    var isBsonType = require_isBsonType();
    var isObject2 = require_isObject();
    var symbols = require_symbols();
    var utils2 = require_utils6();
    function clone2(obj, options2, isArrayChild) {
      if (obj == null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return cloneArray(obj, options2);
      }
      if (isMongooseObject(obj)) {
        if (options2 && options2._skipSingleNestedGetters && obj.$isSingleNested) {
          options2 = Object.assign({}, options2, { getters: false });
        }
        if (utils2.isPOJO(obj) && obj.$__ != null && obj._doc != null) {
          return obj._doc;
        }
        if (options2 && options2.json && typeof obj.toJSON === "function") {
          return obj.toJSON(options2);
        }
        return obj.toObject(options2);
      }
      if (obj.constructor) {
        switch (getFunctionName(obj.constructor)) {
          case "Object":
            return cloneObject(obj, options2, isArrayChild);
          case "Date":
            return new obj.constructor(+obj);
          case "RegExp":
            return cloneRegExp(obj);
          default:
            break;
        }
      }
      if (obj instanceof ObjectId2) {
        return new ObjectId2(obj.id);
      }
      if (isBsonType(obj, "Decimal128")) {
        if (options2 && options2.flattenDecimals) {
          return obj.toJSON();
        }
        return Decimal.fromString(obj.toString());
      }
      if (!obj.constructor && isObject2(obj)) {
        return cloneObject(obj, options2, isArrayChild);
      }
      if (obj[symbols.schemaTypeSymbol]) {
        return obj.clone();
      }
      if (options2 && options2.bson && typeof obj.toBSON === "function") {
        return obj;
      }
      if (obj.valueOf != null) {
        return obj.valueOf();
      }
      return cloneObject(obj, options2, isArrayChild);
    }
    module2.exports = clone2;
    function cloneObject(obj, options2, isArrayChild) {
      const minimize = options2 && options2.minimize;
      const ret2 = {};
      let hasKeys;
      for (const k of Object.keys(obj)) {
        if (specialProperties.has(k)) {
          continue;
        }
        const val = clone2(obj[k], options2);
        if (!minimize || typeof val !== "undefined") {
          if (minimize === false && typeof val === "undefined") {
            delete ret2[k];
          } else {
            hasKeys || (hasKeys = true);
            ret2[k] = val;
          }
        }
      }
      return minimize && !isArrayChild ? hasKeys && ret2 : ret2;
    }
    function cloneArray(arr, options2) {
      const ret2 = [];
      for (const item of arr) {
        ret2.push(clone2(item, options2, true));
      }
      return ret2;
    }
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js
var require_collection5 = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseCollection = require_collection2();
    var MongooseError = require_mongooseError();
    var Collection = require_mongodb().Collection;
    var ObjectId2 = require_objectid2();
    var get2 = require_get();
    var sliced = require_sliced();
    var stream = require("stream");
    var util = require("util");
    function NativeCollection(name, conn, options2) {
      this.collection = null;
      this.Promise = options2.Promise || Promise;
      this.modelName = options2.modelName;
      delete options2.modelName;
      this._closed = false;
      MongooseCollection.apply(this, arguments);
    }
    NativeCollection.prototype.__proto__ = MongooseCollection.prototype;
    NativeCollection.prototype.onOpen = function() {
      const _this = this;
      if (!_this.opts.capped.size) {
        callback(null, _this.conn.db.collection(_this.name));
        return _this.collection;
      }
      if (_this.opts.autoCreate === false) {
        _this.collection = _this.conn.db.collection(_this.name);
        MongooseCollection.prototype.onOpen.call(_this);
        return _this.collection;
      }
      return _this.conn.db.collection(_this.name, function(err, c) {
        if (err)
          return callback(err);
        _this.conn.db.listCollections({ name: _this.name }).toArray(function(err2, docs) {
          if (err2) {
            return callback(err2);
          }
          const doc = docs[0];
          const exists = !!doc;
          if (exists) {
            if (doc.options && doc.options.capped) {
              callback(null, c);
            } else {
              const msg = "A non-capped collection exists with the name: " + _this.name + "\n\n To use this collection as a capped collection, please first convert it.\n http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped";
              err2 = new Error(msg);
              callback(err2);
            }
          } else {
            const opts = Object.assign({}, _this.opts.capped);
            opts.capped = true;
            _this.conn.db.createCollection(_this.name, opts, callback);
          }
        });
      });
      function callback(err, collection) {
        if (err) {
          _this.conn.emit("error", err);
        } else {
          _this.collection = collection;
          MongooseCollection.prototype.onOpen.call(_this);
        }
      }
    };
    NativeCollection.prototype.onClose = function(force) {
      MongooseCollection.prototype.onClose.call(this, force);
    };
    var syncCollectionMethods = { watch: true };
    function iter(i) {
      NativeCollection.prototype[i] = function() {
        const collection = this.collection;
        const args = Array.from(arguments);
        const _this = this;
        const debug = get2(_this, "conn.base.options.debug");
        const lastArg = arguments[arguments.length - 1];
        const opId = new ObjectId2();
        if (this.conn.$wasForceClosed) {
          const error2 = new MongooseError("Connection was force closed");
          if (args.length > 0 && typeof args[args.length - 1] === "function") {
            args[args.length - 1](error2);
            return;
          } else {
            throw error2;
          }
        }
        let _args = args;
        let callback = null;
        if (this._shouldBufferCommands() && this.buffer) {
          if (syncCollectionMethods[i]) {
            throw new Error("Collection method " + i + " is synchronous");
          }
          this.conn.emit("buffer", {
            _id: opId,
            modelName: _this.modelName,
            collectionName: _this.name,
            method: i,
            args
          });
          let callback2;
          let _args2;
          let promise = null;
          let timeout = null;
          if (typeof lastArg === "function") {
            callback2 = function collectionOperationCallback() {
              if (timeout != null) {
                clearTimeout(timeout);
              }
              return lastArg.apply(this, arguments);
            };
            _args2 = args.slice(0, args.length - 1).concat([callback2]);
          } else {
            promise = new this.Promise((resolve2, reject) => {
              callback2 = function collectionOperationCallback(err, res) {
                if (timeout != null) {
                  clearTimeout(timeout);
                }
                if (err != null) {
                  return reject(err);
                }
                resolve2(res);
              };
              _args2 = args.concat([callback2]);
              this.addQueue(i, _args2);
            });
          }
          const bufferTimeoutMS = this._getBufferTimeoutMS();
          timeout = setTimeout(() => {
            const removed = this.removeQueue(i, _args2);
            if (removed) {
              const message = "Operation `" + this.name + "." + i + "()` buffering timed out after " + bufferTimeoutMS + "ms";
              const err = new MongooseError(message);
              this.conn.emit("buffer-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
              callback2(err);
            }
          }, bufferTimeoutMS);
          if (typeof lastArg === "function") {
            this.addQueue(i, _args2);
            return;
          }
          return promise;
        } else if (!syncCollectionMethods[i] && typeof lastArg === "function") {
          callback = function collectionOperationCallback(err, res) {
            if (err != null) {
              _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
            } else {
              _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });
            }
            return lastArg.apply(this, arguments);
          };
          _args = args.slice(0, args.length - 1).concat([callback]);
        }
        if (debug) {
          if (typeof debug === "function") {
            debug.apply(_this, [_this.name, i].concat(sliced(args, 0, args.length - 1)));
          } else if (debug instanceof stream.Writable) {
            this.$printToStream(_this.name, i, args, debug);
          } else {
            const color = debug.color == null ? true : debug.color;
            const shell = debug.shell == null ? false : debug.shell;
            this.$print(_this.name, i, args, color, shell);
          }
        }
        this.conn.emit("operation-start", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });
        try {
          if (collection == null) {
            const message = "Cannot call `" + this.name + "." + i + "()` before initial connection is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if you have `bufferCommands = false`.";
            throw new MongooseError(message);
          }
          const ret2 = collection[i].apply(collection, _args);
          if (ret2 != null && typeof ret2.then === "function") {
            return ret2.then((res) => {
              this.conn.emit("operation-end", { _id: opId, modelName: this.modelName, collectionName: this.name, method: i, result: res });
              return res;
            }, (err) => {
              this.conn.emit("operation-end", { _id: opId, modelName: this.modelName, collectionName: this.name, method: i, error: err });
              throw err;
            });
          }
          return ret2;
        } catch (error2) {
          if (typeof callback === "function") {
            callback(error2);
          } else {
            this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error: error2 });
          }
          if (typeof lastArg === "function") {
            lastArg(error2);
          } else {
            throw error2;
          }
        }
      };
    }
    for (const key of Object.keys(Collection.prototype)) {
      const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);
      if (descriptor.get !== void 0) {
        continue;
      }
      if (typeof Collection.prototype[key] !== "function") {
        continue;
      }
      iter(key);
    }
    NativeCollection.prototype.$print = function(name, i, args, color, shell) {
      const moduleName = color ? "[0;36mMongoose:[0m " : "Mongoose: ";
      const functionCall = [name, i].join(".");
      const _args = [];
      for (let j = args.length - 1; j >= 0; --j) {
        if (this.$format(args[j]) || _args.length) {
          _args.unshift(this.$format(args[j], color, shell));
        }
      }
      const params = "(" + _args.join(", ") + ")";
      console.info(moduleName + functionCall + params);
    };
    NativeCollection.prototype.$printToStream = function(name, i, args, stream2) {
      const functionCall = [name, i].join(".");
      const _args = [];
      for (let j = args.length - 1; j >= 0; --j) {
        if (this.$format(args[j]) || _args.length) {
          _args.unshift(this.$format(args[j]));
        }
      }
      const params = "(" + _args.join(", ") + ")";
      stream2.write(functionCall + params, "utf8");
    };
    NativeCollection.prototype.$format = function(arg, color, shell) {
      const type = typeof arg;
      if (type === "function" || type === "undefined")
        return "";
      return format2(arg, false, color, shell);
    };
    function inspectable(representation) {
      const ret2 = {
        inspect: function() {
          return representation;
        }
      };
      if (util.inspect.custom) {
        ret2[util.inspect.custom] = ret2.inspect;
      }
      return ret2;
    }
    function map(o) {
      return format2(o, true);
    }
    function formatObjectId(x, key) {
      x[key] = inspectable('ObjectId("' + x[key].toHexString() + '")');
    }
    function formatDate(x, key, shell) {
      if (shell) {
        x[key] = inspectable('ISODate("' + x[key].toUTCString() + '")');
      } else {
        x[key] = inspectable('new Date("' + x[key].toUTCString() + '")');
      }
    }
    function format2(obj, sub, color, shell) {
      if (obj && typeof obj.toBSON === "function") {
        obj = obj.toBSON();
      }
      if (obj == null) {
        return obj;
      }
      const clone2 = require_clone();
      let x = clone2(obj, { transform: false });
      if (x.constructor.name === "Binary") {
        x = "BinData(" + x.sub_type + ', "' + x.toString("base64") + '")';
      } else if (x.constructor.name === "ObjectID") {
        x = inspectable('ObjectId("' + x.toHexString() + '")');
      } else if (x.constructor.name === "Date") {
        x = inspectable('new Date("' + x.toUTCString() + '")');
      } else if (x.constructor.name === "Object") {
        const keys = Object.keys(x);
        const numKeys = keys.length;
        let key;
        for (let i = 0; i < numKeys; ++i) {
          key = keys[i];
          if (x[key]) {
            let error2;
            if (typeof x[key].toBSON === "function") {
              try {
                x[key] = x[key].toBSON();
              } catch (_error2) {
                error2 = _error2;
              }
            }
            if (x[key].constructor.name === "Binary") {
              x[key] = "BinData(" + x[key].sub_type + ', "' + x[key].buffer.toString("base64") + '")';
            } else if (x[key].constructor.name === "Object") {
              x[key] = format2(x[key], true);
            } else if (x[key].constructor.name === "ObjectID") {
              formatObjectId(x, key);
            } else if (x[key].constructor.name === "Date") {
              formatDate(x, key, shell);
            } else if (x[key].constructor.name === "ClientSession") {
              x[key] = inspectable('ClientSession("' + get2(x[key], "id.id.buffer", "").toString("hex") + '")');
            } else if (Array.isArray(x[key])) {
              x[key] = x[key].map(map);
            } else if (error2 != null) {
              throw error2;
            }
          }
        }
      }
      if (sub) {
        return x;
      }
      return util.inspect(x, false, 10, color).replace(/\n/g, "").replace(/\s{2,}/g, " ");
    }
    NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
    module2.exports = NativeCollection;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/decimal128.js
var require_decimal1285 = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/decimal128.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = require_mongodb().Decimal128;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js
var require_ReadPreference = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js"(exports2, module2) {
    init_shims();
    "use strict";
    var mongodb = require_mongodb();
    var ReadPref = mongodb.ReadPreference;
    module2.exports = function readPref(pref, tags) {
      if (Array.isArray(pref)) {
        tags = pref[1];
        pref = pref[0];
      }
      if (pref instanceof ReadPref) {
        return pref;
      }
      switch (pref) {
        case "p":
          pref = "primary";
          break;
        case "pp":
          pref = "primaryPreferred";
          break;
        case "s":
          pref = "secondary";
          break;
        case "sp":
          pref = "secondaryPreferred";
          break;
        case "n":
          pref = "nearest";
          break;
      }
      return new ReadPref(pref, tags);
    };
  }
});

// node_modules/mongoose/lib/cursor/ChangeStream.js
var require_ChangeStream = __commonJS({
  "node_modules/mongoose/lib/cursor/ChangeStream.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var ChangeStream = class extends EventEmitter {
      constructor(changeStreamThunk, pipeline2, options2) {
        super();
        this.driverChangeStream = null;
        this.closed = false;
        this.pipeline = pipeline2;
        this.options = options2;
        changeStreamThunk((err, driverChangeStream) => {
          if (err != null) {
            this.emit("error", err);
            return;
          }
          this.driverChangeStream = driverChangeStream;
          this._bindEvents();
          this.emit("ready");
        });
      }
      _bindEvents() {
        this.driverChangeStream.on("close", () => {
          this.closed = true;
        });
        ["close", "change", "end", "error"].forEach((ev) => {
          this.driverChangeStream.on(ev, (data) => this.emit(ev, data));
        });
      }
      _queue(cb) {
        this.once("ready", () => cb());
      }
      close() {
        this.closed = true;
        if (this.driverChangeStream) {
          this.driverChangeStream.close();
        }
      }
    };
    module2.exports = ChangeStream;
  }
});

// node_modules/mongoose/lib/helpers/topology/allServersUnknown.js
var require_allServersUnknown = __commonJS({
  "node_modules/mongoose/lib/helpers/topology/allServersUnknown.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function allServersUnknown(topologyDescription) {
      if (topologyDescription == null || topologyDescription.constructor.name !== "TopologyDescription") {
        return false;
      }
      const servers = Array.from(topologyDescription.servers.values());
      return servers.length > 0 && servers.every((server) => server.type === "Unknown");
    };
  }
});

// node_modules/mongoose/lib/helpers/topology/isAtlas.js
var require_isAtlas = __commonJS({
  "node_modules/mongoose/lib/helpers/topology/isAtlas.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function isAtlas(topologyDescription) {
      if (topologyDescription == null || topologyDescription.constructor.name !== "TopologyDescription") {
        return false;
      }
      const hostnames = Array.from(topologyDescription.servers.keys());
      return hostnames.length > 0 && hostnames.every((host) => host.endsWith(".mongodb.net:27017"));
    };
  }
});

// node_modules/mongoose/lib/helpers/topology/isSSLError.js
var require_isSSLError = __commonJS({
  "node_modules/mongoose/lib/helpers/topology/isSSLError.js"(exports2, module2) {
    init_shims();
    "use strict";
    var nonSSLMessage = "Client network socket disconnected before secure TLS connection was established";
    module2.exports = function isSSLError(topologyDescription) {
      if (topologyDescription == null || topologyDescription.constructor.name !== "TopologyDescription") {
        return false;
      }
      const descriptions = Array.from(topologyDescription.servers.values());
      return descriptions.length > 0 && descriptions.every((descr) => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);
    };
  }
});

// node_modules/mongoose/lib/error/serverSelection.js
var require_serverSelection = __commonJS({
  "node_modules/mongoose/lib/error/serverSelection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_mongooseError();
    var allServersUnknown = require_allServersUnknown();
    var isAtlas = require_isAtlas();
    var isSSLError = require_isSSLError();
    var atlasMessage = "Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you're trying to access the database from an IP that isn't whitelisted. Make sure your current IP address is on your Atlas cluster's IP whitelist: https://docs.atlas.mongodb.com/security-whitelist/";
    var sslMessage = "Mongoose is connecting with SSL enabled, but the server is not accepting SSL connections. Please ensure that the MongoDB server you are connecting to is configured to accept SSL connections. Learn more: https://mongoosejs.com/docs/tutorials/ssl.html";
    var MongooseServerSelectionError = class extends MongooseError {
      assimilateError(err) {
        const reason = err.reason;
        const isAtlasWhitelistError = isAtlas(reason) && allServersUnknown(reason) && err.message.indexOf("bad auth") === -1 && err.message.indexOf("Authentication failed") === -1;
        if (isAtlasWhitelistError) {
          this.message = atlasMessage;
        } else if (isSSLError(reason)) {
          this.message = sslMessage;
        } else {
          this.message = err.message;
        }
        for (const key in err) {
          if (key !== "name") {
            this[key] = err[key];
          }
        }
        return this;
      }
    };
    Object.defineProperty(MongooseServerSelectionError.prototype, "name", {
      value: "MongooseServerSelectionError"
    });
    module2.exports = MongooseServerSelectionError;
  }
});

// node_modules/mongoose/lib/helpers/schema/applyPlugins.js
var require_applyPlugins = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/applyPlugins.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function applyPlugins(schema, plugins, options2, cacheKey) {
      if (schema[cacheKey]) {
        return;
      }
      schema[cacheKey] = true;
      if (!options2 || !options2.skipTopLevel) {
        for (const plugin of plugins) {
          schema.plugin(plugin[0], plugin[1]);
        }
      }
      options2 = Object.assign({}, options2);
      delete options2.skipTopLevel;
      if (options2.applyPluginsToChildSchemas !== false) {
        for (const path of Object.keys(schema.paths)) {
          const type = schema.paths[path];
          if (type.schema != null) {
            applyPlugins(type.schema, plugins, options2, cacheKey);
            type.caster.prototype.$__setSchema(type.schema);
          }
        }
      }
      const discriminators = schema.discriminators;
      if (discriminators == null) {
        return;
      }
      const applyPluginsToDiscriminators = options2.applyPluginsToDiscriminators;
      const keys = Object.keys(discriminators);
      for (const discriminatorKey of keys) {
        const discriminatorSchema = discriminators[discriminatorKey];
        applyPlugins(discriminatorSchema, plugins, { skipTopLevel: !applyPluginsToDiscriminators }, cacheKey);
      }
    };
  }
});

// node_modules/mongoose/package.json
var require_package2 = __commonJS({
  "node_modules/mongoose/package.json"(exports2, module2) {
    module2.exports = {
      name: "mongoose",
      description: "Mongoose MongoDB ODM",
      version: "5.13.5",
      author: "Guillermo Rauch <guillermo@learnboost.com>",
      keywords: [
        "mongodb",
        "document",
        "model",
        "schema",
        "database",
        "odm",
        "data",
        "datastore",
        "query",
        "nosql",
        "orm",
        "db"
      ],
      license: "MIT",
      dependencies: {
        "@types/mongodb": "^3.5.27",
        bson: "^1.1.4",
        kareem: "2.3.2",
        mongodb: "3.6.10",
        "mongoose-legacy-pluralize": "1.0.2",
        mpath: "0.8.3",
        mquery: "3.2.5",
        ms: "2.1.2",
        "optional-require": "1.0.x",
        "regexp-clone": "1.0.0",
        "safe-buffer": "5.2.1",
        sift: "13.5.2",
        sliced: "1.0.1"
      },
      devDependencies: {
        "@babel/core": "7.10.5",
        "@babel/preset-env": "7.10.4",
        "@typescript-eslint/eslint-plugin": "4.10.0",
        "@typescript-eslint/parser": "4.10.0",
        acquit: "1.x",
        "acquit-ignore": "0.1.x",
        "acquit-require": "0.1.x",
        "babel-loader": "8.1.0",
        benchmark: "2.1.4",
        bluebird: "3.5.5",
        chalk: "2.4.2",
        cheerio: "1.0.0-rc.2",
        co: "4.6.0",
        dox: "0.3.1",
        eslint: "7.1.0",
        "eslint-plugin-mocha-no-only": "1.1.0",
        "highlight.js": "9.18.2",
        "lodash.isequal": "4.5.0",
        "lodash.isequalwith": "4.4.0",
        marked: "1.1.1",
        mkdirp: "0.5.5",
        mocha: "5.x",
        moment: "2.x",
        "mongoose-long": "0.2.1",
        "node-static": "0.7.11",
        "object-sizeof": "1.3.0",
        pug: "2.0.3",
        q: "1.5.1",
        rimraf: "2.6.3",
        semver: "5.5.0",
        typescript: "4.1.x",
        uuid: "2.0.3",
        "uuid-parse": "1.0.0",
        validator: "10.8.0",
        webpack: "4.44.0"
      },
      directories: {
        lib: "./lib/mongoose"
      },
      scripts: {
        lint: "eslint .",
        "build-browser": "node build-browser.js",
        prepublishOnly: "npm run build-browser",
        release: "git pull && git push origin master --tags && npm publish",
        "release-legacy": "git pull origin 4.x && git push origin 4.x --tags && npm publish --tag legacy",
        test: "mocha --exit ./test/*.test.js ./test/typescript/main.test.js",
        tdd: "mocha ./test/*.test.js ./test/typescript/main.test.js --watch --recursive --watch-files ./**/*.js",
        "test-cov": "nyc --reporter=html --reporter=text npm test"
      },
      main: "./index.js",
      engines: {
        node: ">=4.0.0"
      },
      bugs: {
        url: "https://github.com/Automattic/mongoose/issues/new"
      },
      repository: {
        type: "git",
        url: "git://github.com/Automattic/mongoose.git"
      },
      homepage: "https://mongoosejs.com",
      browser: "./dist/browser.umd.js",
      mocha: {
        extension: [
          "test.js"
        ],
        "watch-files": [
          "test/**/*.js"
        ]
      },
      eslintConfig: {
        extends: [
          "eslint:recommended"
        ],
        overrides: [
          {
            files: [
              "**/*.{ts,tsx}"
            ],
            extends: [
              "plugin:@typescript-eslint/eslint-recommended",
              "plugin:@typescript-eslint/recommended"
            ],
            plugins: [
              "@typescript-eslint"
            ],
            rules: {
              "@typescript-eslint/no-explicit-any": "off",
              "@typescript-eslint/ban-types": "off",
              "@typescript-eslint/no-unused-vars": "off",
              "@typescript-eslint/explicit-module-boundary-types": "off"
            }
          }
        ],
        plugins: [
          "mocha-no-only"
        ],
        parserOptions: {
          ecmaVersion: 2015
        },
        env: {
          node: true,
          es6: true
        },
        rules: {
          "comma-style": "error",
          indent: [
            "error",
            2,
            {
              SwitchCase: 1,
              VariableDeclarator: 2
            }
          ],
          "keyword-spacing": "error",
          "no-whitespace-before-property": "error",
          "no-buffer-constructor": "warn",
          "no-console": "off",
          "no-multi-spaces": "error",
          "no-constant-condition": "off",
          "func-call-spacing": "error",
          "no-trailing-spaces": "error",
          "no-undef": "error",
          "no-unneeded-ternary": "error",
          "no-const-assign": "error",
          "no-useless-rename": "error",
          "no-dupe-keys": "error",
          "space-in-parens": [
            "error",
            "never"
          ],
          "spaced-comment": [
            "error",
            "always",
            {
              block: {
                markers: [
                  "!"
                ],
                balanced: true
              }
            }
          ],
          "key-spacing": [
            "error",
            {
              beforeColon: false,
              afterColon: true
            }
          ],
          "comma-spacing": [
            "error",
            {
              before: false,
              after: true
            }
          ],
          "array-bracket-spacing": 1,
          "arrow-spacing": [
            "error",
            {
              before: true,
              after: true
            }
          ],
          "object-curly-spacing": [
            "error",
            "always"
          ],
          "comma-dangle": [
            "error",
            "never"
          ],
          "no-unreachable": "error",
          quotes: [
            "error",
            "single"
          ],
          "quote-props": [
            "error",
            "as-needed"
          ],
          semi: "error",
          "no-extra-semi": "error",
          "semi-spacing": "error",
          "no-spaced-func": "error",
          "no-throw-literal": "error",
          "space-before-blocks": "error",
          "space-before-function-paren": [
            "error",
            "never"
          ],
          "space-infix-ops": "error",
          "space-unary-ops": "error",
          "no-var": "warn",
          "prefer-const": "warn",
          strict: [
            "error",
            "global"
          ],
          "no-restricted-globals": [
            "error",
            {
              name: "context",
              message: "Don't use Mocha's global context"
            }
          ],
          "no-prototype-builtins": "off",
          "mocha-no-only/mocha-no-only": [
            "error"
          ]
        }
      },
      funding: {
        type: "opencollective",
        url: "https://opencollective.com/mongoose"
      }
    };
  }
});

// node_modules/mongoose/lib/connection.js
var require_connection3 = __commonJS({
  "node_modules/mongoose/lib/connection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ChangeStream = require_ChangeStream();
    var EventEmitter = require("events").EventEmitter;
    var Schema = require_schema2();
    var Collection = require_driver().get().Collection;
    var STATES = require_connectionstate();
    var MongooseError = require_error3();
    var PromiseProvider = require_promise_provider();
    var ServerSelectionError = require_serverSelection();
    var applyPlugins = require_applyPlugins();
    var promiseOrCallback = require_promiseOrCallback();
    var get2 = require_get();
    var immediate = require_immediate();
    var mongodb = require_mongodb();
    var pkg = require_package2();
    var utils2 = require_utils6();
    var parseConnectionString = require_core().parseConnectionString;
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var sessionNewDocuments = require_symbols().sessionNewDocuments;
    var noPasswordAuthMechanisms = [
      "MONGODB-X509"
    ];
    function Connection(base) {
      this.base = base;
      this.collections = {};
      this.models = {};
      this.config = {};
      this.replica = false;
      this.options = null;
      this.otherDbs = [];
      this.relatedDbs = {};
      this.states = STATES;
      this._readyState = STATES.disconnected;
      this._closeCalled = false;
      this._hasOpened = false;
      this.plugins = [];
      if (typeof base === "undefined" || !base.connections.length) {
        this.id = 0;
      } else {
        this.id = base.connections.length;
      }
      this._queue = [];
    }
    Connection.prototype.__proto__ = EventEmitter.prototype;
    Object.defineProperty(Connection.prototype, "readyState", {
      get: function() {
        return this._readyState;
      },
      set: function(val) {
        if (!(val in STATES)) {
          throw new Error("Invalid connection state: " + val);
        }
        if (this._readyState !== val) {
          this._readyState = val;
          for (const db of this.otherDbs) {
            db.readyState = val;
          }
          if (STATES.connected === val) {
            this._hasOpened = true;
          }
          this.emit(STATES[val]);
        }
      }
    });
    Connection.prototype.get = function(key) {
      if (this.config.hasOwnProperty(key)) {
        return this.config[key];
      }
      return get2(this.options, key);
    };
    Connection.prototype.set = function(key, val) {
      if (this.config.hasOwnProperty(key)) {
        this.config[key] = val;
        return val;
      }
      this.options = this.options || {};
      this.options[key] = val;
      return val;
    };
    Connection.prototype.collections;
    Connection.prototype.name;
    Connection.prototype.models;
    Connection.prototype.id;
    Object.defineProperty(Connection.prototype, "plugins", {
      configurable: false,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "host", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "port", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "user", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection.prototype, "pass", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Connection.prototype.db;
    Connection.prototype.client;
    Connection.prototype.config;
    Connection.prototype.createCollection = _wrapConnHelper(function createCollection(collection, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      this.db.createCollection(collection, options2, cb);
    });
    Connection.prototype.startSession = _wrapConnHelper(function startSession(options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = null;
      }
      const session = this.client.startSession(options2);
      cb(null, session);
    });
    Connection.prototype.transaction = function transaction(fn, options2) {
      return this.startSession().then((session) => {
        session[sessionNewDocuments] = new Map();
        return session.withTransaction(() => fn(session), options2).then((res) => {
          delete session[sessionNewDocuments];
          return res;
        }).catch((err) => {
          for (const doc of session[sessionNewDocuments].keys()) {
            const state = session[sessionNewDocuments].get(doc);
            if (state.hasOwnProperty("isNew")) {
              doc.isNew = state.isNew;
            }
            if (state.hasOwnProperty("versionKey")) {
              doc.set(doc.schema.options.versionKey, state.versionKey);
            }
            for (const path of state.modifiedPaths) {
              doc.$__.activePaths.paths[path] = "modify";
              doc.$__.activePaths.states.modify[path] = true;
            }
            for (const path of state.atomics.keys()) {
              const val = doc.$__getValue(path);
              if (val == null) {
                continue;
              }
              val[arrayAtomicsSymbol] = state.atomics.get(path);
            }
          }
          delete session[sessionNewDocuments];
          throw err;
        });
      });
    };
    Connection.prototype.dropCollection = _wrapConnHelper(function dropCollection(collection, cb) {
      this.db.dropCollection(collection, cb);
    });
    Connection.prototype.dropDatabase = _wrapConnHelper(function dropDatabase(cb) {
      for (const name of Object.keys(this.models)) {
        delete this.models[name].$init;
      }
      this.db.dropDatabase(cb);
    });
    function _wrapConnHelper(fn) {
      return function() {
        const cb = arguments.length > 0 ? arguments[arguments.length - 1] : null;
        const argsWithoutCb = typeof cb === "function" ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : Array.prototype.slice.call(arguments);
        const disconnectedError = new MongooseError("Connection " + this.id + " was disconnected when calling `" + fn.name + "`");
        return promiseOrCallback(cb, (cb2) => {
          immediate(() => {
            if (this.readyState === STATES.connecting && this._shouldBufferCommands()) {
              this._queue.push({ fn, ctx: this, args: argsWithoutCb.concat([cb2]) });
            } else if (this.readyState === STATES.disconnected && this.db == null) {
              cb2(disconnectedError);
            } else {
              try {
                fn.apply(this, argsWithoutCb.concat([cb2]));
              } catch (err) {
                return cb2(err);
              }
            }
          });
        });
      };
    }
    Connection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
      if (this.config.bufferCommands != null) {
        return this.config.bufferCommands;
      }
      if (this.base.get("bufferCommands") != null) {
        return this.base.get("bufferCommands");
      }
      return true;
    };
    Connection.prototype.error = function(err, callback) {
      if (callback) {
        callback(err);
        return null;
      }
      if (this.listeners("error").length > 0) {
        this.emit("error", err);
      }
      return Promise.reject(err);
    };
    Connection.prototype.onOpen = function() {
      this.readyState = STATES.connected;
      for (const d2 of this._queue) {
        d2.fn.apply(d2.ctx, d2.args);
      }
      this._queue = [];
      for (const i in this.collections) {
        if (utils2.object.hasOwnProperty(this.collections, i)) {
          this.collections[i].onOpen();
        }
      }
      this.emit("open");
    };
    Connection.prototype.openUri = function(uri, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (["string", "number"].indexOf(typeof options2) !== -1) {
        throw new MongooseError("Mongoose 5.x no longer supports `mongoose.connect(host, dbname, port)` or `mongoose.createConnection(host, dbname, port)`. See http://mongoosejs.com/docs/connections.html for supported connection syntax");
      }
      if (typeof uri !== "string") {
        throw new MongooseError(`The \`uri\` parameter to \`openUri()\` must be a string, got "${typeof uri}". Make sure the first parameter to \`mongoose.connect()\` or \`mongoose.createConnection()\` is a string.`);
      }
      if (callback != null && typeof callback !== "function") {
        throw new MongooseError('3rd parameter to `mongoose.connect()` or `mongoose.createConnection()` must be a function, got "' + typeof callback + '"');
      }
      if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
        if (this._connectionString !== uri) {
          throw new MongooseError("Can't call `openUri()` on an active connection with different connection strings. Make sure you aren't calling `mongoose.connect()` multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections");
        }
        if (typeof callback === "function") {
          this.$initialConnection = this.$initialConnection.then(() => callback(null, this), (err) => callback(err));
        }
        return this;
      }
      this._connectionString = uri;
      this.readyState = STATES.connecting;
      this._closeCalled = false;
      const Promise2 = PromiseProvider.get();
      const _this = this;
      if (options2) {
        options2 = utils2.clone(options2);
        const autoIndex = options2.config && options2.config.autoIndex != null ? options2.config.autoIndex : options2.autoIndex;
        if (autoIndex != null) {
          this.config.autoIndex = autoIndex !== false;
          delete options2.config;
          delete options2.autoIndex;
        }
        if ("autoCreate" in options2) {
          this.config.autoCreate = !!options2.autoCreate;
          delete options2.autoCreate;
        }
        if ("useCreateIndex" in options2) {
          this.config.useCreateIndex = !!options2.useCreateIndex;
          delete options2.useCreateIndex;
        }
        if ("useFindAndModify" in options2) {
          this.config.useFindAndModify = !!options2.useFindAndModify;
          delete options2.useFindAndModify;
        }
        if (options2.user || options2.pass) {
          options2.auth = options2.auth || {};
          options2.auth.user = options2.user;
          options2.auth.password = options2.pass;
          this.user = options2.user;
          this.pass = options2.pass;
        }
        delete options2.user;
        delete options2.pass;
        if (options2.bufferCommands != null) {
          if (options2.bufferMaxEntries == null) {
            options2.bufferMaxEntries = 0;
          }
          this.config.bufferCommands = options2.bufferCommands;
          delete options2.bufferCommands;
        }
        if (options2.useMongoClient != null) {
          handleUseMongoClient(options2);
        }
      } else {
        options2 = {};
      }
      this._connectionOptions = options2;
      const dbName = options2.dbName;
      if (dbName != null) {
        this.$dbName = dbName;
      }
      delete options2.dbName;
      if (!("promiseLibrary" in options2)) {
        options2.promiseLibrary = PromiseProvider.get();
      }
      if (!("useNewUrlParser" in options2)) {
        if ("useNewUrlParser" in this.base.options) {
          options2.useNewUrlParser = this.base.options.useNewUrlParser;
        } else {
          options2.useNewUrlParser = false;
        }
      }
      if (!utils2.hasUserDefinedProperty(options2, "useUnifiedTopology")) {
        if (utils2.hasUserDefinedProperty(this.base.options, "useUnifiedTopology")) {
          options2.useUnifiedTopology = this.base.options.useUnifiedTopology;
        } else {
          options2.useUnifiedTopology = false;
        }
      }
      if (!utils2.hasUserDefinedProperty(options2, "driverInfo")) {
        options2.driverInfo = {
          name: "Mongoose",
          version: pkg.version
        };
      }
      const parsePromise = new Promise2((resolve2, reject) => {
        parseConnectionString(uri, options2, (err, parsed) => {
          if (err) {
            return reject(err);
          }
          if (dbName) {
            this.name = dbName;
          } else if (parsed.defaultDatabase) {
            this.name = parsed.defaultDatabase;
          } else {
            this.name = get2(parsed, "auth.db", null);
          }
          this.host = get2(parsed, "hosts.0.host", "localhost");
          this.port = get2(parsed, "hosts.0.port", 27017);
          this.user = this.user || get2(parsed, "auth.username");
          this.pass = this.pass || get2(parsed, "auth.password");
          resolve2();
        });
      });
      const promise = new Promise2((resolve2, reject) => {
        const client = new mongodb.MongoClient(uri, options2);
        _this.client = client;
        client.connect((error2) => {
          if (error2) {
            return reject(error2);
          }
          _setClient(_this, client, options2, dbName);
          resolve2(_this);
        });
      });
      const serverSelectionError = new ServerSelectionError();
      this.$initialConnection = Promise2.all([promise, parsePromise]).then((res) => res[0]).catch((err) => {
        this.readyState = STATES.disconnected;
        if (err != null && err.name === "MongoServerSelectionError") {
          err = serverSelectionError.assimilateError(err);
        }
        if (this.listeners("error").length > 0) {
          immediate(() => this.emit("error", err));
        }
        throw err;
      });
      this.then = function(resolve2, reject) {
        return this.$initialConnection.then(() => {
          if (typeof resolve2 === "function") {
            return resolve2(_this);
          }
        }, reject);
      };
      this.catch = function(reject) {
        return this.$initialConnection.catch(reject);
      };
      if (callback != null) {
        this.$initialConnection = this.$initialConnection.then(() => callback(null, this), (err) => callback(err));
      }
      return this;
    };
    function _setClient(conn, client, options2, dbName) {
      const db = dbName != null ? client.db(dbName) : client.db();
      conn.db = db;
      conn.client = client;
      conn._closeCalled = client._closeCalled;
      const _handleReconnect = () => {
        if (conn.readyState !== STATES.connected) {
          conn.readyState = STATES.connected;
          conn.emit("reconnect");
          conn.emit("reconnected");
          conn.onOpen();
        }
      };
      const type = get2(db, "s.topology.s.description.type", "");
      if (options2.useUnifiedTopology) {
        if (type === "Single") {
          const server = Array.from(db.s.topology.s.servers.values())[0];
          server.s.topology.on("serverHeartbeatSucceeded", () => {
            _handleReconnect();
          });
          server.s.pool.on("reconnect", () => {
            _handleReconnect();
          });
          client.on("serverDescriptionChanged", (ev) => {
            const newDescription = ev.newDescription;
            if (newDescription.type === "Standalone") {
              _handleReconnect();
            } else {
              conn.readyState = STATES.disconnected;
            }
          });
        } else if (type.startsWith("ReplicaSet")) {
          client.on("topologyDescriptionChanged", (ev) => {
            const description = ev.newDescription;
            const servers = Array.from(ev.newDescription.servers.values());
            const allServersDisconnected = description.type === "ReplicaSetNoPrimary" && servers.reduce((cur, d2) => cur || d2.type === "Unknown", false);
            if (conn.readyState === STATES.connected && allServersDisconnected) {
              conn.readyState = STATES.disconnected;
            } else if (conn.readyState === STATES.disconnected && !allServersDisconnected) {
              _handleReconnect();
            }
          });
          client.on("close", function() {
            const type2 = get2(db, "s.topology.s.description.type", "");
            if (type2 !== "ReplicaSetWithPrimary") {
              conn.readyState = STATES.disconnected;
            }
          });
        }
      }
      db.s.topology.on("reconnectFailed", function() {
        conn.emit("reconnectFailed");
      });
      if (!options2.useUnifiedTopology) {
        client.on("reconnect", function() {
          _handleReconnect();
        });
        db.s.topology.on("left", function(data) {
          conn.emit("left", data);
        });
      }
      db.s.topology.on("joined", function(data) {
        conn.emit("joined", data);
      });
      db.s.topology.on("fullsetup", function(data) {
        conn.emit("fullsetup", data);
      });
      if (get2(db, "s.topology.s.coreTopology.s.pool") != null) {
        db.s.topology.s.coreTopology.s.pool.on("attemptReconnect", function() {
          conn.emit("attemptReconnect");
        });
      }
      if (!options2.useUnifiedTopology) {
        client.on("close", function() {
          conn.readyState = STATES.disconnected;
        });
      } else if (!type.startsWith("ReplicaSet")) {
        client.on("close", function() {
          conn.readyState = STATES.disconnected;
        });
      }
      if (!options2.useUnifiedTopology) {
        client.on("left", function() {
          if (conn.readyState === STATES.connected && get2(db, "s.topology.s.coreTopology.s.replicaSetState.topologyType") === "ReplicaSetNoPrimary") {
            conn.readyState = STATES.disconnected;
          }
        });
        client.on("timeout", function() {
          conn.emit("timeout");
        });
      }
      delete conn.then;
      delete conn.catch;
      conn.onOpen();
    }
    var handleUseMongoClient = function handleUseMongoClient2(options2) {
      console.warn("WARNING: The `useMongoClient` option is no longer necessary in mongoose 5.x, please remove it.");
      const stack = new Error().stack;
      console.warn(stack.substr(stack.indexOf("\n") + 1));
      delete options2.useMongoClient;
    };
    Connection.prototype.close = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      this.$wasForceClosed = !!force;
      return promiseOrCallback(callback, (cb) => {
        this._close(force, cb);
      });
    };
    Connection.prototype._close = function(force, callback) {
      const _this = this;
      const closeCalled = this._closeCalled;
      this._closeCalled = true;
      if (this.client != null) {
        this.client._closeCalled = true;
      }
      switch (this.readyState) {
        case STATES.disconnected:
          if (closeCalled) {
            callback();
          } else {
            this.doClose(force, function(err) {
              if (err) {
                return callback(err);
              }
              _this.onClose(force);
              callback(null);
            });
          }
          break;
        case STATES.connected:
          this.readyState = STATES.disconnecting;
          this.doClose(force, function(err) {
            if (err) {
              return callback(err);
            }
            _this.onClose(force);
            callback(null);
          });
          break;
        case STATES.connecting:
          this.once("open", function() {
            _this.close(callback);
          });
          break;
        case STATES.disconnecting:
          this.once("close", function() {
            callback();
          });
          break;
      }
      return this;
    };
    Connection.prototype.onClose = function(force) {
      this.readyState = STATES.disconnected;
      for (const i in this.collections) {
        if (utils2.object.hasOwnProperty(this.collections, i)) {
          this.collections[i].onClose(force);
        }
      }
      this.emit("close", force);
    };
    Connection.prototype.collection = function(name, options2) {
      const defaultOptions = {
        autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,
        autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate
      };
      options2 = Object.assign({}, defaultOptions, options2 ? utils2.clone(options2) : {});
      options2.$wasForceClosed = this.$wasForceClosed;
      if (!(name in this.collections)) {
        this.collections[name] = new Collection(name, this, options2);
      }
      return this.collections[name];
    };
    Connection.prototype.plugin = function(fn, opts) {
      this.plugins.push([fn, opts]);
      return this;
    };
    Connection.prototype.model = function(name, schema, collection, options2) {
      if (!(this instanceof Connection)) {
        throw new MongooseError("`connection.model()` should not be run with `new`. If you are doing `new db.model(foo)(bar)`, use `db.model(foo)(bar)` instead");
      }
      let fn;
      if (typeof name === "function") {
        fn = name;
        name = fn.name;
      }
      if (typeof schema === "string") {
        collection = schema;
        schema = false;
      }
      if (utils2.isObject(schema) && !schema.instanceOfSchema) {
        schema = new Schema(schema);
      }
      if (schema && !schema.instanceOfSchema) {
        throw new Error("The 2nd parameter to `mongoose.model()` should be a schema or a POJO");
      }
      const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };
      const opts = Object.assign(defaultOptions, options2, { connection: this });
      if (this.models[name] && !collection && opts.overwriteModels !== true) {
        if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
          throw new MongooseError.OverwriteModelError(name);
        }
        return this.models[name];
      }
      let model;
      if (schema && schema.instanceOfSchema) {
        applyPlugins(schema, this.plugins, null, "$connectionPluginsApplied");
        model = this.base.model(fn || name, schema, collection, opts);
        if (!this.models[name]) {
          this.models[name] = model;
        }
        model.init(function $modelInitNoop() {
        });
        return model;
      }
      if (this.models[name] && collection) {
        model = this.models[name];
        schema = model.prototype.schema;
        const sub = model.__subclass(this, schema, collection);
        return sub;
      }
      model = this.base.models[name];
      if (!model) {
        throw new MongooseError.MissingSchemaError(name);
      }
      if (this === model.prototype.db && (!collection || collection === model.collection.name)) {
        if (!this.models[name]) {
          this.models[name] = model;
        }
        return model;
      }
      this.models[name] = model.__subclass(this, schema, collection);
      return this.models[name];
    };
    Connection.prototype.deleteModel = function(name) {
      if (typeof name === "string") {
        const model = this.model(name);
        if (model == null) {
          return this;
        }
        const collectionName = model.collection.name;
        delete this.models[name];
        delete this.collections[collectionName];
        delete this.base.modelSchemas[name];
        this.emit("deleteModel", model);
      } else if (name instanceof RegExp) {
        const pattern = name;
        const names = this.modelNames();
        for (const name2 of names) {
          if (pattern.test(name2)) {
            this.deleteModel(name2);
          }
        }
      } else {
        throw new Error('First parameter to `deleteModel()` must be a string or regexp, got "' + name + '"');
      }
      return this;
    };
    Connection.prototype.watch = function(pipeline2, options2) {
      const disconnectedError = new MongooseError("Connection " + this.id + " was disconnected when calling `watch()`");
      const changeStreamThunk = (cb) => {
        immediate(() => {
          if (this.readyState === STATES.connecting) {
            this.once("open", function() {
              const driverChangeStream = this.db.watch(pipeline2, options2);
              cb(null, driverChangeStream);
            });
          } else if (this.readyState === STATES.disconnected && this.db == null) {
            cb(disconnectedError);
          } else {
            const driverChangeStream = this.db.watch(pipeline2, options2);
            cb(null, driverChangeStream);
          }
        });
      };
      const changeStream = new ChangeStream(changeStreamThunk, pipeline2, options2);
      return changeStream;
    };
    Connection.prototype.modelNames = function() {
      return Object.keys(this.models);
    };
    Connection.prototype.shouldAuthenticate = function() {
      return this.user != null && (this.pass != null || this.authMechanismDoesNotRequirePassword());
    };
    Connection.prototype.authMechanismDoesNotRequirePassword = function() {
      if (this.options && this.options.auth) {
        return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;
      }
      return true;
    };
    Connection.prototype.optionsProvideAuthenticationData = function(options2) {
      return options2 && options2.user && (options2.pass || this.authMechanismDoesNotRequirePassword());
    };
    Connection.prototype.getClient = function getClient() {
      return this.client;
    };
    Connection.prototype.setClient = function setClient(client) {
      if (!(client instanceof mongodb.MongoClient)) {
        throw new MongooseError("Must call `setClient()` with an instance of MongoClient");
      }
      if (this.client != null || this.readyState !== STATES.disconnected) {
        throw new MongooseError("Cannot call `setClient()` on a connection that is already connected.");
      }
      if (!client.isConnected()) {
        throw new MongooseError("Cannot call `setClient()` with a MongoClient that is not connected.");
      }
      this._connectionString = client.s.url;
      _setClient(this, client, { useUnifiedTopology: client.s.options.useUnifiedTopology }, client.s.options.dbName);
      return this;
    };
    Connection.STATES = STATES;
    module2.exports = Connection;
  }
});

// node_modules/mongoose/lib/helpers/timers.js
var require_timers2 = __commonJS({
  "node_modules/mongoose/lib/helpers/timers.js"(exports2) {
    init_shims();
    "use strict";
    exports2.setTimeout = setTimeout;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js
var require_connection4 = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseConnection = require_connection3();
    var STATES = require_connectionstate();
    var immediate = require_immediate();
    var setTimeout2 = require_timers2().setTimeout;
    function NativeConnection() {
      MongooseConnection.apply(this, arguments);
      this._listening = false;
    }
    NativeConnection.STATES = STATES;
    NativeConnection.prototype.__proto__ = MongooseConnection.prototype;
    NativeConnection.prototype.useDb = function(name, options2) {
      options2 = options2 || {};
      if (options2.useCache && this.relatedDbs[name]) {
        return this.relatedDbs[name];
      }
      const newConn = new this.constructor();
      newConn.name = name;
      newConn.base = this.base;
      newConn.collections = {};
      newConn.models = {};
      newConn.replica = this.replica;
      newConn.config = Object.assign({}, this.config, newConn.config);
      newConn.name = this.name;
      newConn.options = this.options;
      newConn._readyState = this._readyState;
      newConn._closeCalled = this._closeCalled;
      newConn._hasOpened = this._hasOpened;
      newConn._listening = false;
      newConn.host = this.host;
      newConn.port = this.port;
      newConn.user = this.user;
      newConn.pass = this.pass;
      const _this = this;
      newConn.client = _this.client;
      if (this.db && this._readyState === STATES.connected) {
        wireup();
      } else {
        this.once("connected", wireup);
      }
      function wireup() {
        newConn.client = _this.client;
        const _opts = {};
        if (options2.hasOwnProperty("noListener")) {
          _opts.noListener = options2.noListener;
        }
        newConn.db = _this.client.db(name, _opts);
        newConn.onOpen();
        if (options2.noListener !== true) {
          listen(newConn);
        }
      }
      newConn.name = name;
      if (options2.noListener !== true) {
        this.otherDbs.push(newConn);
      }
      newConn.otherDbs.push(this);
      if (options2 && options2.useCache) {
        this.relatedDbs[newConn.name] = newConn;
        newConn.relatedDbs = this.relatedDbs;
      }
      return newConn;
    };
    function listen(conn) {
      if (conn._listening) {
        return;
      }
      conn._listening = true;
      conn.client.on("close", function(force) {
        if (conn._closeCalled) {
          return;
        }
        conn._closeCalled = conn.client._closeCalled;
        if (conn.db.serverConfig.autoReconnect) {
          conn.readyState = STATES.disconnected;
          conn.emit("close");
          return;
        }
        conn.onClose(force);
      });
      conn.client.on("error", function(err) {
        conn.emit("error", err);
      });
      if (!conn.client.s.options.useUnifiedTopology) {
        conn.db.on("reconnect", function() {
          conn.readyState = STATES.connected;
          conn.emit("reconnect");
          conn.emit("reconnected");
          conn.onOpen();
        });
        conn.db.on("open", function(err, db) {
          if (STATES.disconnected === conn.readyState && db && db.databaseName) {
            conn.readyState = STATES.connected;
            conn.emit("reconnect");
            conn.emit("reconnected");
          }
        });
      }
      conn.client.on("timeout", function(err) {
        conn.emit("timeout", err);
      });
      conn.client.on("parseError", function(err) {
        conn.emit("parseError", err);
      });
    }
    NativeConnection.prototype.doClose = function(force, fn) {
      if (this.client == null) {
        immediate(() => fn());
        return this;
      }
      this.client.close(force, (err, res) => {
        setTimeout2(() => fn(err, res), 1);
      });
      return this;
    };
    module2.exports = NativeConnection;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/index.js
var require_node_mongodb_native = __commonJS({
  "node_modules/mongoose/lib/drivers/node-mongodb-native/index.js"(exports2) {
    init_shims();
    "use strict";
    exports2.Binary = require_binary2();
    exports2.Collection = require_collection5();
    exports2.Decimal128 = require_decimal1285();
    exports2.ObjectId = require_objectid2();
    exports2.ReadPreference = require_ReadPreference();
    exports2.getConnection = () => require_connection4();
  }
});

// node_modules/mongoose/lib/validoptions.js
var require_validoptions = __commonJS({
  "node_modules/mongoose/lib/validoptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var VALID_OPTIONS = Object.freeze([
      "applyPluginsToChildSchemas",
      "applyPluginsToDiscriminators",
      "autoCreate",
      "autoIndex",
      "bufferCommands",
      "bufferTimeoutMS",
      "cloneSchemas",
      "debug",
      "maxTimeMS",
      "objectIdGetter",
      "overwriteModels",
      "returnOriginal",
      "runValidators",
      "sanitizeProjection",
      "selectPopulatedPaths",
      "setDefaultsOnInsert",
      "strict",
      "strictQuery",
      "toJSON",
      "toObject",
      "typePojoToMixed",
      "useCreateIndex",
      "useFindAndModify",
      "useNewUrlParser",
      "usePushEach",
      "useUnifiedTopology"
    ]);
    module2.exports = VALID_OPTIONS;
  }
});

// node_modules/mongoose/lib/helpers/cursor/eachAsync.js
var require_eachAsync = __commonJS({
  "node_modules/mongoose/lib/helpers/cursor/eachAsync.js"(exports2, module2) {
    init_shims();
    "use strict";
    var immediate = require_immediate();
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = function eachAsync(next, fn, options2, callback) {
      const parallel = options2.parallel || 1;
      const batchSize = options2.batchSize;
      const enqueue = asyncQueue();
      return promiseOrCallback(callback, (cb) => {
        if (batchSize != null) {
          if (typeof batchSize !== "number") {
            throw new TypeError("batchSize must be a number");
          }
          if (batchSize < 1) {
            throw new TypeError("batchSize must be at least 1");
          }
          if (batchSize !== Math.floor(batchSize)) {
            throw new TypeError("batchSize must be a positive integer");
          }
        }
        iterate(cb);
      });
      function iterate(finalCallback) {
        let drained = false;
        let handleResultsInProgress = 0;
        let currentDocumentIndex = 0;
        let documentsBatch = [];
        let error2 = null;
        for (let i = 0; i < parallel; ++i) {
          enqueue(fetch2);
        }
        function fetch2(done) {
          if (drained || error2) {
            return done();
          }
          next(function(err, doc) {
            if (drained || error2 != null) {
              return done();
            }
            if (err != null) {
              error2 = err;
              finalCallback(err);
              return done();
            }
            if (doc == null) {
              drained = true;
              if (handleResultsInProgress <= 0) {
                finalCallback(null);
              } else if (batchSize != null && documentsBatch.length) {
                handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);
              }
              return done();
            }
            ++handleResultsInProgress;
            immediate(() => done());
            if (batchSize != null) {
              documentsBatch.push(doc);
            }
            if (batchSize != null && documentsBatch.length !== batchSize) {
              setTimeout(() => enqueue(fetch2), 0);
              return;
            }
            const docsToProcess = batchSize != null ? documentsBatch : doc;
            function handleNextResultCallBack(err2) {
              if (batchSize != null) {
                handleResultsInProgress -= documentsBatch.length;
                documentsBatch = [];
              } else {
                --handleResultsInProgress;
              }
              if (err2 != null) {
                error2 = err2;
                return finalCallback(err2);
              }
              if (drained && handleResultsInProgress <= 0) {
                return finalCallback(null);
              }
              setTimeout(() => enqueue(fetch2), 0);
            }
            handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);
          });
        }
      }
      function handleNextResult(doc, i, callback2) {
        const promise = fn(doc, i);
        if (promise && typeof promise.then === "function") {
          promise.then(function() {
            callback2(null);
          }, function(error2) {
            callback2(error2 || new Error("`eachAsync()` promise rejected without error"));
          });
        } else {
          callback2(null);
        }
      }
    };
    function asyncQueue() {
      const _queue = [];
      let inProgress = null;
      let id = 0;
      return function enqueue(fn) {
        if (_queue.length === 0 && inProgress == null) {
          inProgress = id++;
          return fn(_step);
        }
        _queue.push(fn);
      };
      function _step() {
        inProgress = null;
        if (_queue.length > 0) {
          inProgress = id++;
          const fn = _queue.shift();
          fn(_step);
        }
      }
    }
  }
});

// node_modules/mongoose/lib/cursor/QueryCursor.js
var require_QueryCursor = __commonJS({
  "node_modules/mongoose/lib/cursor/QueryCursor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Readable2 = require("stream").Readable;
    var promiseOrCallback = require_promiseOrCallback();
    var eachAsync = require_eachAsync();
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    var util = require("util");
    function QueryCursor(query, options2) {
      Readable2.call(this, { objectMode: true });
      this.cursor = null;
      this.query = query;
      const _this = this;
      const model = query.model;
      this._mongooseOptions = {};
      this._transforms = [];
      this.model = model;
      this.options = options2 || {};
      model.hooks.execPre("find", query, () => {
        this._transforms = this._transforms.concat(query._transforms.slice());
        if (this.options.transform) {
          this._transforms.push(options2.transform);
        }
        if (this.options.batchSize) {
          this.options.cursor = options2.cursor || {};
          this.options.cursor.batchSize = options2.batchSize;
          this.options._populateBatchSize = Math.min(this.options.batchSize, 5e3);
        }
        model.collection.find(query._conditions, this.options, function(err, cursor) {
          if (_this._error) {
            if (cursor != null) {
              cursor.close(function() {
              });
            }
            _this.emit("cursor", null);
            _this.listeners("error").length > 0 && _this.emit("error", _this._error);
            return;
          }
          if (err) {
            return _this.emit("error", err);
          }
          _this.cursor = cursor;
          _this.emit("cursor", cursor);
        });
      });
    }
    util.inherits(QueryCursor, Readable2);
    QueryCursor.prototype._read = function() {
      const _this = this;
      _next(this, function(error2, doc) {
        if (error2) {
          return _this.emit("error", error2);
        }
        if (!doc) {
          _this.push(null);
          _this.cursor.close(function(error3) {
            if (error3) {
              return _this.emit("error", error3);
            }
            setTimeout(function() {
              const isNotClosedAutomatically = !_this.destroyed;
              if (isNotClosedAutomatically) {
                _this.emit("close");
              }
            }, 0);
          });
          return;
        }
        _this.push(doc);
      });
    };
    QueryCursor.prototype.map = function(fn) {
      this._transforms.push(fn);
      return this;
    };
    QueryCursor.prototype._markError = function(error2) {
      this._error = error2;
      return this;
    };
    QueryCursor.prototype.close = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        this.cursor.close((error2) => {
          if (error2) {
            cb(error2);
            return this.listeners("error").length > 0 && this.emit("error", error2);
          }
          this.emit("close");
          cb(null);
        });
      }, this.model.events);
    };
    QueryCursor.prototype.next = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        _next(this, function(error2, doc) {
          if (error2) {
            return cb(error2);
          }
          cb(null, doc);
        });
      }, this.model.events);
    };
    QueryCursor.prototype.eachAsync = function(fn, opts, callback) {
      const _this = this;
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      opts = opts || {};
      return eachAsync(function(cb) {
        return _next(_this, cb);
      }, fn, opts, callback);
    };
    QueryCursor.prototype.options;
    QueryCursor.prototype.addCursorFlag = function(flag, value) {
      const _this = this;
      _waitForCursor(this, function() {
        _this.cursor.addCursorFlag(flag, value);
      });
      return this;
    };
    QueryCursor.prototype.transformNull = function(val) {
      if (arguments.length === 0) {
        val = true;
      }
      this._mongooseOptions.transformNull = val;
      return this;
    };
    QueryCursor.prototype._transformForAsyncIterator = function() {
      if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
        this.map(_transformForAsyncIterator);
      }
      return this;
    };
    if (Symbol.asyncIterator != null) {
      QueryCursor.prototype[Symbol.asyncIterator] = function() {
        return this.transformNull()._transformForAsyncIterator();
      };
    }
    function _transformForAsyncIterator(doc) {
      return doc == null ? { done: true } : { value: doc, done: false };
    }
    function _next(ctx, cb) {
      let callback = cb;
      if (ctx._transforms.length) {
        callback = function(err, doc) {
          if (err || doc === null && !ctx._mongooseOptions.transformNull) {
            return cb(err, doc);
          }
          cb(err, ctx._transforms.reduce(function(doc2, fn) {
            return fn.call(ctx, doc2);
          }, doc));
        };
      }
      if (ctx._error) {
        return immediate(function() {
          callback(ctx._error);
        });
      }
      if (ctx.cursor) {
        if (ctx.query._mongooseOptions.populate && !ctx._pop) {
          ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query, ctx.query._mongooseOptions);
          ctx._pop.__noPromise = true;
        }
        if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {
          if (ctx._batchDocs && ctx._batchDocs.length) {
            return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);
          } else if (ctx._batchExhausted) {
            return callback(null, null);
          } else {
            ctx._batchDocs = [];
            return ctx.cursor.next(_onNext.bind({ ctx, callback }));
          }
        } else {
          return ctx.cursor.next(function(error2, doc) {
            if (error2) {
              return callback(error2);
            }
            if (!doc) {
              return callback(null, null);
            }
            if (!ctx.query._mongooseOptions.populate) {
              return _nextDoc(ctx, doc, null, callback);
            }
            ctx.query.model.populate(doc, ctx._pop, function(err, doc2) {
              if (err) {
                return callback(err);
              }
              return _nextDoc(ctx, doc2, ctx._pop, callback);
            });
          });
        }
      } else {
        ctx.once("cursor", function(cursor) {
          if (cursor == null) {
            return;
          }
          _next(ctx, cb);
        });
      }
    }
    function _onNext(error2, doc) {
      if (error2) {
        return this.callback(error2);
      }
      if (!doc) {
        this.ctx._batchExhausted = true;
        return _populateBatch.call(this);
      }
      this.ctx._batchDocs.push(doc);
      if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {
        this.ctx.cursor.next(_onNext.bind(this));
      } else {
        _populateBatch.call(this);
      }
    }
    function _populateBatch() {
      if (!this.ctx._batchDocs.length) {
        return this.callback(null, null);
      }
      const _this = this;
      this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop, function(err) {
        if (err) {
          return _this.callback(err);
        }
        _nextDoc(_this.ctx, _this.ctx._batchDocs.shift(), _this.ctx._pop, _this.callback);
      });
    }
    function _nextDoc(ctx, doc, pop, callback) {
      if (ctx.query._mongooseOptions.lean) {
        return ctx.model.hooks.execPost("find", ctx.query, [[doc]], (err) => {
          if (err != null) {
            return callback(err);
          }
          callback(null, doc);
        });
      }
      _create(ctx, doc, pop, (err, doc2) => {
        if (err != null) {
          return callback(err);
        }
        ctx.model.hooks.execPost("find", ctx.query, [[doc2]], (err2) => {
          if (err2 != null) {
            return callback(err2);
          }
          callback(null, doc2);
        });
      });
    }
    function _waitForCursor(ctx, cb) {
      if (ctx.cursor) {
        return cb();
      }
      ctx.once("cursor", function(cursor) {
        if (cursor == null) {
          return;
        }
        cb();
      });
    }
    function _create(ctx, doc, populatedIds, cb) {
      const instance = helpers.createModel(ctx.query.model, doc, ctx.query._fields);
      const opts = populatedIds ? { populated: populatedIds } : void 0;
      instance.init(doc, opts, function(err) {
        if (err) {
          return cb(err);
        }
        cb(null, instance);
      });
    }
    module2.exports = QueryCursor;
  }
});

// node_modules/mongoose/lib/helpers/query/applyGlobalMaxTimeMS.js
var require_applyGlobalMaxTimeMS = __commonJS({
  "node_modules/mongoose/lib/helpers/query/applyGlobalMaxTimeMS.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils6();
    module2.exports = function applyGlobalMaxTimeMS(options2, model) {
      if (utils2.hasUserDefinedProperty(options2, "maxTimeMS")) {
        return;
      }
      if (utils2.hasUserDefinedProperty(model.db.options, "maxTimeMS")) {
        options2.maxTimeMS = model.db.options.maxTimeMS;
      } else if (utils2.hasUserDefinedProperty(model.base.options, "maxTimeMS")) {
        options2.maxTimeMS = model.base.options.maxTimeMS;
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js
var require_applyWriteConcern = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js"(exports2, module2) {
    init_shims();
    "use strict";
    var get2 = require_get();
    module2.exports = function applyWriteConcern(schema, options2) {
      const writeConcern = get2(schema, "options.writeConcern", {});
      if (Object.keys(writeConcern).length != 0) {
        options2.writeConcern = {};
        if (!("w" in options2) && writeConcern.w != null) {
          options2.writeConcern.w = writeConcern.w;
        }
        if (!("j" in options2) && writeConcern.j != null) {
          options2.writeConcern.j = writeConcern.j;
        }
        if (!("wtimeout" in options2) && writeConcern.wtimeout != null) {
          options2.writeConcern.wtimeout = writeConcern.wtimeout;
        }
      } else {
        if (!("w" in options2) && writeConcern.w != null) {
          options2.w = writeConcern.w;
        }
        if (!("j" in options2) && writeConcern.j != null) {
          options2.j = writeConcern.j;
        }
        if (!("wtimeout" in options2) && writeConcern.wtimeout != null) {
          options2.wtimeout = writeConcern.wtimeout;
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/query/castFilterPath.js
var require_castFilterPath = __commonJS({
  "node_modules/mongoose/lib/helpers/query/castFilterPath.js"(exports2, module2) {
    init_shims();
    "use strict";
    var isOperator = require_isOperator();
    module2.exports = function castFilterPath(query, schematype, val) {
      const ctx = query;
      const any$conditionals = Object.keys(val).some(isOperator);
      if (!any$conditionals) {
        return schematype.castForQueryWrapper({
          val,
          context: ctx
        });
      }
      const ks = Object.keys(val);
      let k = ks.length;
      while (k--) {
        const $cond = ks[k];
        const nested = val[$cond];
        if ($cond === "$not") {
          if (nested && schematype && !schematype.caster) {
            const _keys = Object.keys(nested);
            if (_keys.length && isOperator(_keys[0])) {
              for (const key of Object.keys(nested)) {
                nested[key] = schematype.castForQueryWrapper({
                  $conditional: key,
                  val: nested[key],
                  context: ctx
                });
              }
            } else {
              val[$cond] = schematype.castForQueryWrapper({
                $conditional: $cond,
                val: nested,
                context: ctx
              });
            }
            continue;
          }
        } else {
          val[$cond] = schematype.castForQueryWrapper({
            $conditional: $cond,
            val: nested,
            context: ctx
          });
        }
      }
      return val;
    };
  }
});

// node_modules/mongoose/lib/helpers/schema/getPath.js
var require_getPath = __commonJS({
  "node_modules/mongoose/lib/helpers/schema/getPath.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function getPath(schema, path) {
      let schematype = schema.path(path);
      if (schematype != null) {
        return schematype;
      }
      const pieces = path.split(".");
      let cur = "";
      let isArray = false;
      for (const piece of pieces) {
        if (/^\d+$/.test(piece) && isArray) {
          continue;
        }
        cur = cur.length === 0 ? piece : cur + "." + piece;
        schematype = schema.path(cur);
        if (schematype != null && schematype.schema) {
          schema = schematype.schema;
          cur = "";
          if (schematype.$isMongooseDocumentArray) {
            isArray = true;
          }
        }
      }
      return schematype;
    };
  }
});

// node_modules/mongoose/lib/helpers/update/modifiedPaths.js
var require_modifiedPaths = __commonJS({
  "node_modules/mongoose/lib/helpers/update/modifiedPaths.js"(exports2, module2) {
    init_shims();
    "use strict";
    var _modifiedPaths = require_common4().modifiedPaths;
    module2.exports = function modifiedPaths(update) {
      const keys = Object.keys(update);
      const res = {};
      const withoutDollarKeys = {};
      for (const key of keys) {
        if (key.startsWith("$")) {
          _modifiedPaths(update[key], "", res);
          continue;
        }
        withoutDollarKeys[key] = update[key];
      }
      _modifiedPaths(withoutDollarKeys, "", res);
      return res;
    };
  }
});

// node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js
var require_updatedPathsByArrayFilter = __commonJS({
  "node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js"(exports2, module2) {
    init_shims();
    "use strict";
    var modifiedPaths = require_modifiedPaths();
    module2.exports = function updatedPathsByArrayFilter(update) {
      const updatedPaths = modifiedPaths(update);
      return Object.keys(updatedPaths).reduce((cur, path) => {
        const matches = path.match(/\$\[[^\]]+\]/g);
        if (matches == null) {
          return cur;
        }
        for (const match of matches) {
          const firstMatch = path.indexOf(match);
          if (firstMatch !== path.lastIndexOf(match)) {
            throw new Error(`Path '${path}' contains the same array filter multiple times`);
          }
          cur[match.substring(2, match.length - 1)] = path.substr(0, firstMatch - 1).replace(/\$\[[^\]]+\]/g, "0");
        }
        return cur;
      }, {});
    };
  }
});

// node_modules/mongoose/lib/helpers/update/castArrayFilters.js
var require_castArrayFilters = __commonJS({
  "node_modules/mongoose/lib/helpers/update/castArrayFilters.js"(exports2, module2) {
    init_shims();
    "use strict";
    var castFilterPath = require_castFilterPath();
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var getPath = require_getPath();
    var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
    module2.exports = function castArrayFilters(query) {
      const arrayFilters = query.options.arrayFilters;
      if (!Array.isArray(arrayFilters)) {
        return;
      }
      const update = query.getUpdate();
      const schema = query.schema;
      const strictQuery = schema.options.strictQuery;
      const updatedPathsByFilter = updatedPathsByArrayFilter(update);
      for (const filter of arrayFilters) {
        if (filter == null) {
          throw new Error(`Got null array filter in ${arrayFilters}`);
        }
        for (const key of Object.keys(filter)) {
          if (filter[key] == null) {
            continue;
          }
          const dot = key.indexOf(".");
          let filterPath = dot === -1 ? updatedPathsByFilter[key] + ".0" : updatedPathsByFilter[key.substr(0, dot)] + ".0" + key.substr(dot);
          if (filterPath == null) {
            throw new Error(`Filter path not found for ${key}`);
          }
          filterPath = cleanPositionalOperators(filterPath);
          const schematype = getPath(schema, filterPath);
          if (schematype == null) {
            if (!strictQuery) {
              return;
            }
            throw new Error(`Could not find path "${filterPath}" in schema`);
          }
          if (typeof filter[key] === "object") {
            filter[key] = castFilterPath(query, schematype, filter[key]);
          } else {
            filter[key] = schematype.castForQuery(filter[key]);
          }
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath2 = __commonJS({
  "node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js"(exports2, module2) {
    init_shims();
    "use strict";
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var get2 = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
    module2.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options2) {
      const parts = path.split(".");
      let schematype = null;
      let type = "adhocOrUndefined";
      filter = filter || {};
      update = update || {};
      const arrayFilters = options2 != null && Array.isArray(options2.arrayFilters) ? options2.arrayFilters : [];
      const updatedPathsByFilter = updatedPathsByArrayFilter(update);
      for (let i = 0; i < parts.length; ++i) {
        const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join("."));
        schematype = schema.path(subpath);
        if (schematype == null) {
          continue;
        }
        type = schema.pathType(subpath);
        if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {
          const key = get2(schematype, "schema.options.discriminatorKey");
          const discriminatorValuePath = subpath + "." + key;
          const discriminatorFilterPath = discriminatorValuePath.replace(/\.\d+\./, ".");
          let discriminatorKey = null;
          if (discriminatorValuePath in filter) {
            discriminatorKey = filter[discriminatorValuePath];
          }
          if (discriminatorFilterPath in filter) {
            discriminatorKey = filter[discriminatorFilterPath];
          }
          const wrapperPath = subpath.replace(/\.\d+$/, "");
          if (schematype.$isMongooseDocumentArrayElement && get2(filter[wrapperPath], "$elemMatch." + key) != null) {
            discriminatorKey = filter[wrapperPath].$elemMatch[key];
          }
          if (discriminatorValuePath in update) {
            discriminatorKey = update[discriminatorValuePath];
          }
          for (const filterKey of Object.keys(updatedPathsByFilter)) {
            const schemaKey = updatedPathsByFilter[filterKey] + "." + key;
            const arrayFilterKey = filterKey + "." + key;
            if (schemaKey === discriminatorFilterPath) {
              const filter2 = arrayFilters.find((filter3) => filter3.hasOwnProperty(arrayFilterKey));
              if (filter2 != null) {
                discriminatorKey = filter2[arrayFilterKey];
              }
            }
          }
          if (discriminatorKey == null) {
            continue;
          }
          const discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;
          const rest = parts.slice(i + 1).join(".");
          schematype = discriminatorSchema.path(rest);
          if (schematype != null) {
            type = discriminatorSchema._getPathType(rest);
            break;
          }
        }
      }
      return { type, schematype };
    };
  }
});

// node_modules/mongoose/lib/helpers/query/handleImmutable.js
var require_handleImmutable2 = __commonJS({
  "node_modules/mongoose/lib/helpers/query/handleImmutable.js"(exports2, module2) {
    init_shims();
    "use strict";
    var StrictModeError = require_strict();
    module2.exports = function handleImmutable(schematype, strict, obj, key, fullPath, ctx) {
      if (schematype == null || !schematype.options || !schematype.options.immutable) {
        return false;
      }
      let immutable = schematype.options.immutable;
      if (typeof immutable === "function") {
        immutable = immutable.call(ctx, ctx);
      }
      if (!immutable) {
        return false;
      }
      if (strict === false) {
        return false;
      }
      if (strict === "throw") {
        throw new StrictModeError(null, `Field ${fullPath} is immutable and strict = 'throw'`);
      }
      delete obj[key];
      return true;
    };
  }
});

// node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js
var require_moveImmutableProperties = __commonJS({
  "node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js"(exports2, module2) {
    init_shims();
    "use strict";
    var get2 = require_get();
    module2.exports = function moveImmutableProperties(schema, update, ctx) {
      if (update == null) {
        return;
      }
      const keys = Object.keys(update);
      for (const key of keys) {
        const isDollarKey = key.startsWith("$");
        if (key === "$set") {
          const updatedPaths = Object.keys(update[key]);
          for (const path of updatedPaths) {
            _walkUpdatePath(schema, update[key], path, update, ctx);
          }
        } else if (!isDollarKey) {
          _walkUpdatePath(schema, update, key, update, ctx);
        }
      }
    };
    function _walkUpdatePath(schema, op, path, update, ctx) {
      const schematype = schema.path(path);
      if (schematype == null) {
        return;
      }
      let immutable = get2(schematype, "options.immutable", null);
      if (immutable == null) {
        return;
      }
      if (typeof immutable === "function") {
        immutable = immutable.call(ctx, ctx);
      }
      if (!immutable) {
        return;
      }
      update.$setOnInsert = update.$setOnInsert || {};
      update.$setOnInsert[path] = op[path];
      delete op[path];
    }
  }
});

// node_modules/mongoose/lib/helpers/path/setDottedPath.js
var require_setDottedPath = __commonJS({
  "node_modules/mongoose/lib/helpers/path/setDottedPath.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function setDottedPath(obj, path, val) {
      const parts = path.split(".");
      let cur = obj;
      for (const part of parts.slice(0, -1)) {
        if (cur[part] == null) {
          cur[part] = {};
        }
        cur = cur[part];
      }
      const last = parts[parts.length - 1];
      cur[last] = val;
    };
  }
});

// node_modules/mongoose/lib/helpers/query/castUpdate.js
var require_castUpdate = __commonJS({
  "node_modules/mongoose/lib/helpers/query/castUpdate.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CastError = require_cast();
    var MongooseError = require_mongooseError();
    var StrictModeError = require_strict();
    var ValidationError = require_validation();
    var castNumber = require_number();
    var cast = require_cast2();
    var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath2();
    var handleImmutable = require_handleImmutable2();
    var moveImmutableProperties = require_moveImmutableProperties();
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    var setDottedPath = require_setDottedPath();
    var utils2 = require_utils6();
    module2.exports = function castUpdate(schema, obj, options2, context, filter) {
      if (obj == null) {
        return void 0;
      }
      options2 = options2 || {};
      if (Array.isArray(obj)) {
        const len = obj.length;
        for (let i2 = 0; i2 < len; ++i2) {
          const ops2 = Object.keys(obj[i2]);
          for (const op of ops2) {
            obj[i2][op] = castPipelineOperator(op, obj[i2][op]);
          }
        }
        return obj;
      }
      if (options2.upsert) {
        moveImmutableProperties(schema, obj, context);
      }
      const ops = Object.keys(obj);
      let i = ops.length;
      const ret2 = {};
      let val;
      let hasDollarKey = false;
      const overwrite = options2.overwrite;
      filter = filter || {};
      while (i--) {
        const op = ops[i];
        if (op[0] !== "$" && !overwrite) {
          if (!ret2.$set) {
            if (obj.$set) {
              ret2.$set = obj.$set;
            } else {
              ret2.$set = {};
            }
          }
          ret2.$set[op] = obj[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set"))
            ops.push("$set");
        } else if (op === "$set") {
          if (!ret2.$set) {
            ret2[op] = obj[op];
          }
        } else {
          ret2[op] = obj[op];
        }
      }
      i = ops.length;
      while (i--) {
        const op = ops[i];
        val = ret2[op];
        hasDollarKey = hasDollarKey || op.startsWith("$");
        if (val && typeof val === "object" && !Buffer.isBuffer(val) && (!overwrite || hasDollarKey)) {
          walkUpdatePath(schema, val, op, options2, context, filter);
        } else if (overwrite && ret2 && typeof ret2 === "object") {
          walkUpdatePath(schema, ret2, "$set", options2, context, filter);
        } else {
          const msg = "Invalid atomic update value for " + op + ". Expected an object, received " + typeof val;
          throw new Error(msg);
        }
        if (op.startsWith("$") && utils2.isEmptyObject(val)) {
          delete ret2[op];
        }
      }
      if (Object.keys(ret2).length === 0 && options2.upsert && Object.keys(filter).length > 0) {
        return { $setOnInsert: filter };
      }
      return ret2;
    };
    function castPipelineOperator(op, val) {
      if (op === "$unset") {
        if (!Array.isArray(val) || val.find((v) => typeof v !== "string")) {
          throw new MongooseError("Invalid $unset in pipeline, must be an array of strings");
        }
        return val;
      }
      if (op === "$project") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid $project in pipeline, must be an object");
        }
        return val;
      }
      if (op === "$addFields" || op === "$set") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
        }
        return val;
      } else if (op === "$replaceRoot" || op === "$replaceWith") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
        }
        return val;
      }
      throw new MongooseError('Invalid update pipeline operator: "' + op + '"');
    }
    function walkUpdatePath(schema, obj, op, options2, context, filter, pref) {
      const strict = options2.strict;
      const prefix = pref ? pref + "." : "";
      const keys = Object.keys(obj);
      let i = keys.length;
      let hasKeys = false;
      let schematype;
      let key;
      let val;
      let aggregatedError = null;
      let useNestedStrict;
      if (options2.useNestedStrict === void 0) {
        useNestedStrict = schema.options.useNestedStrict;
      } else {
        useNestedStrict = options2.useNestedStrict;
      }
      while (i--) {
        key = keys[i];
        val = obj[key];
        if (op === "$pull") {
          schematype = schema._getSchema(prefix + key);
          if (schematype != null && schematype.schema != null) {
            obj[key] = cast(schematype.schema, obj[key], options2, context);
            hasKeys = true;
            continue;
          }
        }
        if (val && val.constructor.name === "Object") {
          schematype = schema._getSchema(prefix + key);
          if (schematype == null) {
            const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options2);
            if (_res.schematype != null) {
              schematype = _res.schematype;
            }
          }
          if (op !== "$setOnInsert" && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
            continue;
          }
          if (schematype && schematype.caster && op in castOps) {
            if ("$each" in val) {
              hasKeys = true;
              try {
                obj[key] = {
                  $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)
                };
              } catch (error2) {
                aggregatedError = _handleCastError(error2, context, key, aggregatedError);
              }
              if (val.$slice != null) {
                obj[key].$slice = val.$slice | 0;
              }
              if (val.$sort) {
                obj[key].$sort = val.$sort;
              }
              if (val.$position != null) {
                obj[key].$position = castNumber(val.$position);
              }
            } else {
              if (schematype != null && schematype.$isSingleNested) {
                let _strict = strict;
                if (useNestedStrict !== false && schematype.schema.options.hasOwnProperty("strict")) {
                  _strict = schematype.schema.options.strict;
                } else if (useNestedStrict === false) {
                  _strict = schema.options.strict;
                }
                try {
                  obj[key] = schematype.castForQuery(val, context, { strict: _strict });
                } catch (error2) {
                  aggregatedError = _handleCastError(error2, context, key, aggregatedError);
                }
              } else {
                try {
                  obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
                } catch (error2) {
                  aggregatedError = _handleCastError(error2, context, key, aggregatedError);
                }
              }
              if (options2.omitUndefined && obj[key] === void 0) {
                delete obj[key];
                continue;
              }
              hasKeys = true;
            }
          } else if (op === "$currentDate" || op in castOps && schematype) {
            try {
              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
            } catch (error2) {
              aggregatedError = _handleCastError(error2, context, key, aggregatedError);
            }
            if (options2.omitUndefined && obj[key] === void 0) {
              delete obj[key];
              continue;
            }
            hasKeys = true;
          } else {
            const pathToCheck = prefix + key;
            const v = schema._getPathType(pathToCheck);
            let _strict = strict;
            if (useNestedStrict && v && v.schema && "strict" in v.schema.options) {
              _strict = v.schema.options.strict;
            }
            if (v.pathType === "undefined") {
              if (_strict === "throw") {
                throw new StrictModeError(pathToCheck);
              } else if (_strict) {
                delete obj[key];
                continue;
              }
            }
            hasKeys |= walkUpdatePath(schema, val, op, options2, context, filter, prefix + key) || utils2.isObject(val) && Object.keys(val).length === 0;
          }
        } else {
          const checkPath = key === "$each" || key === "$or" || key === "$and" || key === "$in" ? pref : prefix + key;
          schematype = schema._getSchema(checkPath);
          if (op !== "$setOnInsert" && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
            continue;
          }
          let pathDetails = schema._getPathType(checkPath);
          if (schematype == null) {
            const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options2);
            if (_res.schematype != null) {
              schematype = _res.schematype;
              pathDetails = _res.type;
            }
          }
          let isStrict = strict;
          if (useNestedStrict && pathDetails && pathDetails.schema && "strict" in pathDetails.schema.options) {
            isStrict = pathDetails.schema.options.strict;
          }
          const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);
          if (skip) {
            if (isStrict === "throw" && schema.virtuals[checkPath] == null) {
              throw new StrictModeError(prefix + key);
            } else {
              delete obj[key];
            }
          } else {
            if (op === "$rename") {
              hasKeys = true;
              continue;
            }
            try {
              if (prefix.length === 0 || key.indexOf(".") === -1) {
                obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
              } else {
                setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));
                delete obj[key];
              }
            } catch (error2) {
              aggregatedError = _handleCastError(error2, context, key, aggregatedError);
            }
            if (Array.isArray(obj[key]) && (op === "$addToSet" || op === "$push") && key !== "$each") {
              if (schematype && schematype.caster && !schematype.caster.$isMongooseArray) {
                obj[key] = { $each: obj[key] };
              }
            }
            if (options2.omitUndefined && obj[key] === void 0) {
              delete obj[key];
              continue;
            }
            hasKeys = true;
          }
        }
      }
      if (aggregatedError != null) {
        throw aggregatedError;
      }
      return hasKeys;
    }
    function _handleCastError(error2, query, key, aggregatedError) {
      if (typeof query !== "object" || !query.options.multipleCastError) {
        throw error2;
      }
      aggregatedError = aggregatedError || new ValidationError();
      aggregatedError.addError(key, error2);
      return aggregatedError;
    }
    var numberOps = {
      $pop: 1,
      $inc: 1
    };
    var noCastOps = {
      $unset: 1
    };
    var castOps = {
      $push: 1,
      $addToSet: 1,
      $set: 1,
      $setOnInsert: 1
    };
    var overwriteOps = {
      $set: 1,
      $setOnInsert: 1
    };
    function castUpdateVal(schema, val, op, $conditional, context, path) {
      if (!schema) {
        if (op in numberOps) {
          try {
            return castNumber(val);
          } catch (err) {
            throw new CastError("number", val, path);
          }
        }
        return val;
      }
      const cond = schema.caster && op in castOps && (utils2.isObject(val) || Array.isArray(val));
      if (cond && !overwriteOps[op]) {
        let schemaArrayDepth = 0;
        let cur = schema;
        while (cur.$isMongooseArray) {
          ++schemaArrayDepth;
          cur = cur.caster;
        }
        let arrayDepth = 0;
        let _val = val;
        while (Array.isArray(_val)) {
          ++arrayDepth;
          _val = _val[0];
        }
        const additionalNesting = schemaArrayDepth - arrayDepth;
        while (arrayDepth < schemaArrayDepth) {
          val = [val];
          ++arrayDepth;
        }
        let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);
        for (let i = 0; i < additionalNesting; ++i) {
          tmp = tmp[0];
        }
        return tmp;
      }
      if (op in noCastOps) {
        return val;
      }
      if (op in numberOps) {
        if (val == null) {
          throw new CastError("number", val, schema.path);
        }
        if (op === "$inc") {
          return schema.castForQueryWrapper({
            val,
            context
          });
        }
        try {
          return castNumber(val);
        } catch (error2) {
          throw new CastError("number", val, schema.path);
        }
      }
      if (op === "$currentDate") {
        if (typeof val === "object") {
          return { $type: val.$type };
        }
        return Boolean(val);
      }
      if (/^\$/.test($conditional)) {
        return schema.castForQueryWrapper({
          $conditional,
          val,
          context
        });
      }
      if (overwriteOps[op]) {
        return schema.castForQueryWrapper({
          val,
          context,
          $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\d+$/),
          $applySetters: schema[schemaMixedSymbol] != null
        });
      }
      return schema.castForQueryWrapper({ val, context });
    }
  }
});

// node_modules/mongoose/lib/helpers/query/completeMany.js
var require_completeMany = __commonJS({
  "node_modules/mongoose/lib/helpers/query/completeMany.js"(exports2, module2) {
    init_shims();
    "use strict";
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    module2.exports = completeMany;
    function completeMany(model, docs, fields, userProvidedFields, opts, callback) {
      const arr = [];
      let count = docs.length;
      const len = count;
      let error2 = null;
      function init2(_error2) {
        if (_error2 != null) {
          error2 = error2 || _error2;
        }
        if (error2 != null) {
          --count || immediate(() => callback(error2));
          return;
        }
        --count || immediate(() => callback(error2, arr));
      }
      for (let i = 0; i < len; ++i) {
        arr[i] = helpers.createModel(model, docs[i], fields, userProvidedFields);
        try {
          arr[i].init(docs[i], opts, init2);
        } catch (error3) {
          init2(error3);
        }
        if (opts.session != null) {
          arr[i].$session(opts.session);
        }
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/query/hasDollarKeys.js
var require_hasDollarKeys = __commonJS({
  "node_modules/mongoose/lib/helpers/query/hasDollarKeys.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(obj) {
      if (obj == null) {
        return false;
      }
      const keys = Object.keys(obj);
      const len = keys.length;
      for (let i = 0; i < len; ++i) {
        if (keys[i].startsWith("$")) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/mongoose/lib/helpers/projection/isInclusive.js
var require_isInclusive = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/isInclusive.js"(exports2, module2) {
    init_shims();
    "use strict";
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isInclusive(projection) {
      if (projection == null) {
        return false;
      }
      const props = Object.keys(projection);
      const numProps = props.length;
      if (numProps === 0) {
        return false;
      }
      for (let i = 0; i < numProps; ++i) {
        const prop = props[i];
        if (prop.startsWith("+")) {
          continue;
        }
        if (isDefiningProjection(projection[prop]) && !!projection[prop]) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/mongoose/lib/helpers/projection/parseProjection.js
var require_parseProjection = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/parseProjection.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function parseProjection(v, retainMinusPaths) {
      const type = typeof v;
      if (type === "string") {
        v = v.split(/\s+/);
      }
      if (!Array.isArray(v) && Object.prototype.toString.call(v) !== "[object Arguments]") {
        return v;
      }
      const len = v.length;
      const ret2 = {};
      for (let i = 0; i < len; ++i) {
        let field = v[i];
        if (!field) {
          continue;
        }
        const include = field[0] == "-" ? 0 : 1;
        if (!retainMinusPaths && include === 0) {
          field = field.substring(1);
        }
        ret2[field] = include;
      }
      return ret2;
    };
  }
});

// node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js
var require_removeUnusedArrayFilters = __commonJS({
  "node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function removeUnusedArrayFilters(update, arrayFilters) {
      const updateKeys = Object.keys(update).map((key) => Object.keys(update[key])).reduce((cur, arr) => cur.concat(arr), []);
      return arrayFilters.filter((obj) => {
        const firstKey = Object.keys(obj)[0];
        const firstDot = firstKey.indexOf(".");
        const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);
        return updateKeys.find((key) => key.includes("$[" + arrayFilterKey + "]")) != null;
      });
    };
  }
});

// node_modules/mongoose/lib/helpers/query/sanitizeProjection.js
var require_sanitizeProjection = __commonJS({
  "node_modules/mongoose/lib/helpers/query/sanitizeProjection.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function sanitizeProjection(projection) {
      if (projection == null) {
        return;
      }
      const keys = Object.keys(projection);
      for (let i = 0; i < keys.length; ++i) {
        if (typeof projection[keys[i]] === "string") {
          projection[keys[i]] = 1;
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js
var require_selectPopulatedFields = __commonJS({
  "node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js"(exports2, module2) {
    init_shims();
    "use strict";
    var isExclusive = require_isExclusive();
    var isInclusive = require_isInclusive();
    module2.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {
      if (populateOptions == null) {
        return;
      }
      const paths = Object.keys(populateOptions);
      userProvidedFields = userProvidedFields || {};
      if (isInclusive(fields)) {
        for (const path of paths) {
          if (!isPathInFields(userProvidedFields, path)) {
            fields[path] = 1;
          } else if (userProvidedFields[path] === 0) {
            delete fields[path];
          }
        }
      } else if (isExclusive(fields)) {
        for (const path of paths) {
          if (userProvidedFields[path] == null) {
            delete fields[path];
          }
        }
      }
    };
    function isPathInFields(userProvidedFields, path) {
      const pieces = path.split(".");
      const len = pieces.length;
      let cur = pieces[0];
      for (let i = 1; i < len; ++i) {
        if (userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null) {
          return true;
        }
        cur += "." + pieces[i];
      }
      return userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null;
    }
  }
});

// node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js
var require_setDefaultsOnInsert = __commonJS({
  "node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js"(exports2, module2) {
    init_shims();
    "use strict";
    var modifiedPaths = require_common4().modifiedPaths;
    var get2 = require_get();
    module2.exports = function(filter, schema, castedDoc, options2) {
      options2 = options2 || {};
      const shouldSetDefaultsOnInsert = options2.setDefaultsOnInsert != null ? options2.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;
      if (!options2.upsert || !shouldSetDefaultsOnInsert) {
        return castedDoc;
      }
      const keys = Object.keys(castedDoc || {});
      const updatedKeys = {};
      const updatedValues = {};
      const numKeys = keys.length;
      const modified = {};
      let hasDollarUpdate = false;
      for (let i = 0; i < numKeys; ++i) {
        if (keys[i].startsWith("$")) {
          modifiedPaths(castedDoc[keys[i]], "", modified);
          hasDollarUpdate = true;
        }
      }
      if (!hasDollarUpdate) {
        modifiedPaths(castedDoc, "", modified);
      }
      const paths = Object.keys(filter);
      const numPaths = paths.length;
      for (let i = 0; i < numPaths; ++i) {
        const path = paths[i];
        const condition = filter[path];
        if (condition && typeof condition === "object") {
          const conditionKeys = Object.keys(condition);
          const numConditionKeys = conditionKeys.length;
          let hasDollarKey = false;
          for (let j = 0; j < numConditionKeys; ++j) {
            if (conditionKeys[j].startsWith("$")) {
              hasDollarKey = true;
              break;
            }
          }
          if (hasDollarKey) {
            continue;
          }
        }
        updatedKeys[path] = true;
        modified[path] = true;
      }
      if (options2 && options2.overwrite && !hasDollarUpdate) {
        return castedDoc;
      }
      schema.eachPath(function(path, schemaType) {
        const isUnderneathMap = schemaType.path.endsWith(".$*") || schemaType.path.indexOf(".$*.") !== -1;
        if (schemaType.$isSingleNested && !isUnderneathMap) {
          schemaType.schema.eachPath(function(_path, _schemaType) {
            if (_path === "_id" && _schemaType.auto) {
              return;
            }
            const def = _schemaType.getDefault(null, true);
            if (!isModified(modified, path + "." + _path) && typeof def !== "undefined") {
              castedDoc = castedDoc || {};
              castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
              castedDoc.$setOnInsert[path + "." + _path] = def;
              updatedValues[path + "." + _path] = def;
            }
          });
        } else {
          const def = schemaType.getDefault(null, true);
          if (!isModified(modified, path) && typeof def !== "undefined") {
            castedDoc = castedDoc || {};
            castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
            if (get2(castedDoc, path) == null) {
              castedDoc.$setOnInsert[path] = def;
            }
            updatedValues[path] = def;
          }
        }
      });
      return castedDoc;
    };
    function isModified(modified, path) {
      if (modified[path]) {
        return true;
      }
      const sp = path.split(".");
      let cur = sp[0];
      for (let i = 1; i < sp.length; ++i) {
        if (modified[cur]) {
          return true;
        }
        cur += "." + sp[i];
      }
      return false;
    }
  }
});

// node_modules/mongoose/lib/helpers/updateValidators.js
var require_updateValidators = __commonJS({
  "node_modules/mongoose/lib/helpers/updateValidators.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ValidationError = require_validation();
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var flatten = require_common4().flatten;
    var modifiedPaths = require_common4().modifiedPaths;
    module2.exports = function(query, schema, castedDoc, options2, callback) {
      let _keys;
      const keys = Object.keys(castedDoc || {});
      let updatedKeys = {};
      let updatedValues = {};
      const isPull = {};
      const arrayAtomicUpdates = {};
      const numKeys = keys.length;
      let hasDollarUpdate = false;
      const modified = {};
      let currentUpdate;
      let key;
      let i;
      for (i = 0; i < numKeys; ++i) {
        if (keys[i].startsWith("$")) {
          hasDollarUpdate = true;
          if (keys[i] === "$push" || keys[i] === "$addToSet") {
            _keys = Object.keys(castedDoc[keys[i]]);
            for (let ii = 0; ii < _keys.length; ++ii) {
              currentUpdate = castedDoc[keys[i]][_keys[ii]];
              if (currentUpdate && currentUpdate.$each) {
                arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);
              } else {
                arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);
              }
            }
            continue;
          }
          modifiedPaths(castedDoc[keys[i]], "", modified);
          const flat = flatten(castedDoc[keys[i]], null, null, schema);
          const paths = Object.keys(flat);
          const numPaths = paths.length;
          for (let j = 0; j < numPaths; ++j) {
            const updatedPath = cleanPositionalOperators(paths[j]);
            key = keys[i];
            if (updatedPath.includes("$")) {
              continue;
            }
            if (key === "$set" || key === "$setOnInsert" || key === "$pull" || key === "$pullAll") {
              updatedValues[updatedPath] = flat[paths[j]];
              isPull[updatedPath] = key === "$pull" || key === "$pullAll";
            } else if (key === "$unset") {
              updatedValues[updatedPath] = void 0;
            }
            updatedKeys[updatedPath] = true;
          }
        }
      }
      if (!hasDollarUpdate) {
        modifiedPaths(castedDoc, "", modified);
        updatedValues = flatten(castedDoc, null, null, schema);
        updatedKeys = Object.keys(updatedValues);
      }
      const updates = Object.keys(updatedValues);
      const numUpdates = updates.length;
      const validatorsToExecute = [];
      const validationErrors = [];
      const alreadyValidated = [];
      const context = options2 && options2.context === "query" ? query : null;
      function iter(i2, v) {
        const schemaPath = schema._getSchema(updates[i2]);
        if (schemaPath == null) {
          return;
        }
        if (schemaPath.instance === "Mixed" && schemaPath.path !== updates[i2]) {
          return;
        }
        if (v && Array.isArray(v.$in)) {
          v.$in.forEach((v2, i3) => {
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(v2, function(err) {
                if (err) {
                  err.path = updates[i3] + ".$in." + i3;
                  validationErrors.push(err);
                }
                callback2(null);
              }, context, { updateValidator: true });
            });
          });
        } else {
          if (isPull[updates[i2]] && schemaPath.$isMongooseArray) {
            return;
          }
          if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {
            alreadyValidated.push(updates[i2]);
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(v, function(err) {
                if (err) {
                  err.path = updates[i2];
                  validationErrors.push(err);
                  return callback2(null);
                }
                v.validate(function(err2) {
                  if (err2) {
                    if (err2.errors) {
                      for (const key2 of Object.keys(err2.errors)) {
                        const _err = err2.errors[key2];
                        _err.path = updates[i2] + "." + key2;
                        validationErrors.push(_err);
                      }
                    } else {
                      err2.path = updates[i2];
                      validationErrors.push(err2);
                    }
                  }
                  callback2(null);
                });
              }, context, { updateValidator: true });
            });
          } else {
            validatorsToExecute.push(function(callback2) {
              for (const path of alreadyValidated) {
                if (updates[i2].startsWith(path + ".")) {
                  return callback2(null);
                }
              }
              schemaPath.doValidate(v, function(err) {
                if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {
                  return callback2(null);
                }
                if (err) {
                  err.path = updates[i2];
                  validationErrors.push(err);
                }
                callback2(null);
              }, context, { updateValidator: true });
            });
          }
        }
      }
      for (i = 0; i < numUpdates; ++i) {
        iter(i, updatedValues[updates[i]]);
      }
      const arrayUpdates = Object.keys(arrayAtomicUpdates);
      for (const arrayUpdate of arrayUpdates) {
        let schemaPath = schema._getSchema(arrayUpdate);
        if (schemaPath && schemaPath.$isMongooseDocumentArray) {
          validatorsToExecute.push(function(callback2) {
            schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], getValidationCallback(arrayUpdate, validationErrors, callback2), options2 && options2.context === "query" ? query : null);
          });
        } else {
          schemaPath = schema._getSchema(arrayUpdate + ".0");
          for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(atomicUpdate, getValidationCallback(arrayUpdate, validationErrors, callback2), options2 && options2.context === "query" ? query : null, { updateValidator: true });
            });
          }
        }
      }
      if (callback != null) {
        let numValidators = validatorsToExecute.length;
        if (numValidators === 0) {
          return _done(callback);
        }
        for (const validator of validatorsToExecute) {
          validator(function() {
            if (--numValidators <= 0) {
              _done(callback);
            }
          });
        }
        return;
      }
      return function(callback2) {
        let numValidators = validatorsToExecute.length;
        if (numValidators === 0) {
          return _done(callback2);
        }
        for (const validator of validatorsToExecute) {
          validator(function() {
            if (--numValidators <= 0) {
              _done(callback2);
            }
          });
        }
      };
      function _done(callback2) {
        if (validationErrors.length) {
          const err = new ValidationError(null);
          for (const validationError of validationErrors) {
            err.addError(validationError.path, validationError);
          }
          return callback2(err);
        }
        callback2(null);
      }
      function getValidationCallback(arrayUpdate, validationErrors2, callback2) {
        return function(err) {
          if (err) {
            err.path = arrayUpdate;
            validationErrors2.push(err);
          }
          callback2(null);
        };
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/query/wrapThunk.js
var require_wrapThunk = __commonJS({
  "node_modules/mongoose/lib/helpers/query/wrapThunk.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function wrapThunk(fn) {
      return function _wrappedThunk(cb) {
        ++this._executionCount;
        fn.call(this, cb);
      };
    };
  }
});

// node_modules/mongoose/lib/query.js
var require_query2 = __commonJS({
  "node_modules/mongoose/lib/query.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CastError = require_cast();
    var DocumentNotFoundError = require_notFound();
    var Kareem = require_kareem();
    var MongooseError = require_mongooseError();
    var ObjectParameterError = require_objectParameter();
    var QueryCursor = require_QueryCursor();
    var ReadPreference = require_driver().get().ReadPreference;
    var applyGlobalMaxTimeMS = require_applyGlobalMaxTimeMS();
    var applyWriteConcern = require_applyWriteConcern();
    var cast = require_cast2();
    var castArrayFilters = require_castArrayFilters();
    var castUpdate = require_castUpdate();
    var completeMany = require_completeMany();
    var get2 = require_get();
    var promiseOrCallback = require_promiseOrCallback();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var hasDollarKeys = require_hasDollarKeys();
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    var isExclusive = require_isExclusive();
    var isInclusive = require_isInclusive();
    var mquery = require_mquery();
    var parseProjection = require_parseProjection();
    var removeUnusedArrayFilters = require_removeUnusedArrayFilters();
    var sanitizeProjection = require_sanitizeProjection();
    var selectPopulatedFields = require_selectPopulatedFields();
    var setDefaultsOnInsert = require_setDefaultsOnInsert();
    var slice = require_sliced();
    var updateValidators = require_updateValidators();
    var util = require("util");
    var utils2 = require_utils6();
    var wrapThunk = require_wrapThunk();
    function Query(conditions, options2, model, collection) {
      if (!this._mongooseOptions) {
        this._mongooseOptions = {};
      }
      options2 = options2 || {};
      this._transforms = [];
      this._hooks = new Kareem();
      this._executionCount = 0;
      const keys = Object.keys(options2);
      for (const key of keys) {
        this._mongooseOptions[key] = options2[key];
      }
      if (collection) {
        this.mongooseCollection = collection;
      }
      if (model) {
        this.model = model;
        this.schema = model.schema;
      }
      if (this.model && this.model._mapreduce) {
        this.lean();
      }
      mquery.call(this, this.mongooseCollection, options2);
      if (conditions) {
        this.find(conditions);
      }
      this.options = this.options || {};
      this.$useProjection = true;
      const collation = get2(this, "schema.options.collation", null);
      if (collation != null) {
        this.options.collation = collation;
      }
    }
    Query.prototype = new mquery();
    Query.prototype.constructor = Query;
    Query.base = mquery.prototype;
    Query.use$geoWithin = mquery.use$geoWithin;
    Query.prototype.toConstructor = function toConstructor() {
      const model = this.model;
      const coll = this.mongooseCollection;
      const CustomQuery = function(criteria, options3) {
        if (!(this instanceof CustomQuery)) {
          return new CustomQuery(criteria, options3);
        }
        this._mongooseOptions = utils2.clone(p._mongooseOptions);
        Query.call(this, criteria, options3 || null, model, coll);
      };
      util.inherits(CustomQuery, model.Query);
      const p = CustomQuery.prototype;
      p.options = {};
      const options2 = Object.assign({}, this.options);
      if (options2.sort != null) {
        p.sort(options2.sort);
        delete options2.sort;
      }
      p.setOptions(options2);
      p.op = this.op;
      p._conditions = utils2.clone(this._conditions);
      p._fields = utils2.clone(this._fields);
      p._update = utils2.clone(this._update, {
        flattenDecimals: false
      });
      p._path = this._path;
      p._distinct = this._distinct;
      p._collection = this._collection;
      p._mongooseOptions = this._mongooseOptions;
      return CustomQuery;
    };
    Query.prototype.slice = function() {
      if (arguments.length === 0) {
        return this;
      }
      this._validate("slice");
      let path;
      let val;
      if (arguments.length === 1) {
        const arg = arguments[0];
        if (typeof arg === "object" && !Array.isArray(arg)) {
          const keys = Object.keys(arg);
          const numKeys = keys.length;
          for (let i = 0; i < numKeys; ++i) {
            this.slice(keys[i], arg[keys[i]]);
          }
          return this;
        }
        this._ensurePath("slice");
        path = this._path;
        val = arguments[0];
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === "number") {
          this._ensurePath("slice");
          path = this._path;
          val = slice(arguments);
        } else {
          path = arguments[0];
          val = arguments[1];
        }
      } else if (arguments.length === 3) {
        path = arguments[0];
        val = slice(arguments, 1);
      }
      const p = {};
      p[path] = { $slice: val };
      this.select(p);
      return this;
    };
    Query.prototype.mod = function() {
      let val;
      let path;
      if (arguments.length === 1) {
        this._ensurePath("mod");
        val = arguments[0];
        path = this._path;
      } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
        this._ensurePath("mod");
        val = slice(arguments);
        path = this._path;
      } else if (arguments.length === 3) {
        val = slice(arguments, 1);
        path = arguments[0];
      } else {
        val = arguments[1];
        path = arguments[0];
      }
      const conds = this._conditions[path] || (this._conditions[path] = {});
      conds.$mod = val;
      return this;
    };
    Query.prototype.projection = function(arg) {
      if (arguments.length === 0) {
        return this._fields;
      }
      this._fields = {};
      this._userProvidedFields = {};
      this.select(arg);
      return this._fields;
    };
    Query.prototype.select = function select() {
      let arg = arguments[0];
      if (!arg)
        return this;
      if (arguments.length !== 1) {
        throw new Error("Invalid select: select only takes 1 argument");
      }
      this._validate("select");
      const fields = this._fields || (this._fields = {});
      const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});
      let sanitizeProjection2 = void 0;
      if (this.model != null && utils2.hasUserDefinedProperty(this.model.db.options, "sanitizeProjection")) {
        sanitizeProjection2 = this.model.db.options.sanitizeProjection;
      } else if (this.model != null && utils2.hasUserDefinedProperty(this.model.base.options, "sanitizeProjection")) {
        sanitizeProjection2 = this.model.base.options.sanitizeProjection;
      } else {
        sanitizeProjection2 = this._mongooseOptions.sanitizeProjection;
      }
      arg = parseProjection(arg);
      if (utils2.isObject(arg)) {
        const keys = Object.keys(arg);
        for (let i = 0; i < keys.length; ++i) {
          let value = arg[keys[i]];
          if (typeof value === "string" && sanitizeProjection2) {
            value = 1;
          }
          fields[keys[i]] = value;
          userProvidedFields[keys[i]] = value;
        }
        return this;
      }
      throw new TypeError("Invalid select() argument. Must be string or object.");
    };
    Query.prototype.read = function read2(pref, tags) {
      const read3 = new ReadPreference(pref, tags);
      this.options.readPreference = read3;
      return this;
    };
    Query.prototype.session = function session(v) {
      if (v == null) {
        delete this.options.session;
      }
      this.options.session = v;
      return this;
    };
    Query.prototype.writeConcern = function writeConcern(val) {
      if (val == null) {
        delete this.options.writeConcern;
        return this;
      }
      this.options.writeConcern = val;
      return this;
    };
    Query.prototype.w = function w(val) {
      if (val == null) {
        delete this.options.w;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.w = val;
      } else {
        this.options.w = val;
      }
      return this;
    };
    Query.prototype.j = function j(val) {
      if (val == null) {
        delete this.options.j;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.j = val;
      } else {
        this.options.j = val;
      }
      return this;
    };
    Query.prototype.wtimeout = function wtimeout(ms) {
      if (ms == null) {
        delete this.options.wtimeout;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.wtimeout = ms;
      } else {
        this.options.wtimeout = ms;
      }
      return this;
    };
    Query.prototype.getOptions = function() {
      return this.options;
    };
    Query.prototype.setOptions = function(options2, overwrite) {
      if (overwrite) {
        this._mongooseOptions = options2 && utils2.clone(options2) || {};
        this.options = options2 || {};
        if ("populate" in options2) {
          this.populate(this._mongooseOptions);
        }
        return this;
      }
      if (options2 == null) {
        return this;
      }
      if (typeof options2 !== "object") {
        throw new Error('Options must be an object, got "' + options2 + '"');
      }
      if (Array.isArray(options2.populate)) {
        const populate = options2.populate;
        delete options2.populate;
        const _numPopulate = populate.length;
        for (let i = 0; i < _numPopulate; ++i) {
          this.populate(populate[i]);
        }
      }
      if ("useFindAndModify" in options2) {
        this._mongooseOptions.useFindAndModify = options2.useFindAndModify;
        delete options2.useFindAndModify;
      }
      if ("omitUndefined" in options2) {
        this._mongooseOptions.omitUndefined = options2.omitUndefined;
        delete options2.omitUndefined;
      }
      if ("setDefaultsOnInsert" in options2) {
        this._mongooseOptions.setDefaultsOnInsert = options2.setDefaultsOnInsert;
        delete options2.setDefaultsOnInsert;
      }
      if ("overwriteDiscriminatorKey" in options2) {
        this._mongooseOptions.overwriteDiscriminatorKey = options2.overwriteDiscriminatorKey;
        delete options2.overwriteDiscriminatorKey;
      }
      if ("sanitizeProjection" in options2) {
        if (options2.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {
          sanitizeProjection(this._fields);
        }
        this._mongooseOptions.sanitizeProjection = options2.sanitizeProjection;
        delete options2.sanitizeProjection;
      }
      if ("defaults" in options2) {
        this._mongooseOptions.defaults = options2.defaults;
      }
      return Query.base.setOptions.call(this, options2);
    };
    Query.prototype.explain = function(verbose) {
      if (arguments.length === 0) {
        this.options.explain = true;
      } else if (verbose === false) {
        delete this.options.explain;
      } else {
        this.options.explain = verbose;
      }
      return this;
    };
    Query.prototype.allowDiskUse = function(v) {
      if (arguments.length === 0) {
        this.options.allowDiskUse = true;
      } else if (v === false) {
        delete this.options.allowDiskUse;
      } else {
        this.options.allowDiskUse = v;
      }
      return this;
    };
    Query.prototype.maxTimeMS = function(ms) {
      this.options.maxTimeMS = ms;
      return this;
    };
    Query.prototype.getFilter = function() {
      return this._conditions;
    };
    Query.prototype.getQuery = function() {
      return this._conditions;
    };
    Query.prototype.setQuery = function(val) {
      this._conditions = val;
    };
    Query.prototype.getUpdate = function() {
      return this._update;
    };
    Query.prototype.setUpdate = function(val) {
      this._update = val;
    };
    Query.prototype._fieldsForExec = function() {
      return utils2.clone(this._fields);
    };
    Query.prototype._updateForExec = function() {
      const update = utils2.clone(this._update, {
        transform: false,
        depopulate: true
      });
      const ops = Object.keys(update);
      let i = ops.length;
      const ret2 = {};
      while (i--) {
        const op = ops[i];
        if (this.options.overwrite) {
          ret2[op] = update[op];
          continue;
        }
        if (op[0] !== "$") {
          if (!ret2.$set) {
            if (update.$set) {
              ret2.$set = update.$set;
            } else {
              ret2.$set = {};
            }
          }
          ret2.$set[op] = update[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set"))
            ops.push("$set");
        } else if (op === "$set") {
          if (!ret2.$set) {
            ret2[op] = update[op];
          }
        } else {
          ret2[op] = update[op];
        }
      }
      return ret2;
    };
    Query.prototype._optionsForExec = function(model) {
      const options2 = utils2.clone(this.options);
      delete options2.populate;
      model = model || this.model;
      if (!model) {
        return options2;
      }
      const safe = get2(model, "schema.options.safe", null);
      if (!("safe" in options2) && safe != null) {
        setSafe(options2, safe);
      }
      applyWriteConcern(model.schema, options2);
      const readPreference = get2(model, "schema.options.read");
      if (!("readPreference" in options2) && readPreference) {
        options2.readPreference = readPreference;
      }
      if (options2.upsert !== void 0) {
        options2.upsert = !!options2.upsert;
      }
      if (options2.writeConcern) {
        if (options2.j) {
          options2.writeConcern.j = options2.j;
          delete options2.j;
        }
        if (options2.w) {
          options2.writeConcern.w = options2.w;
          delete options2.w;
        }
        if (options2.wtimeout) {
          options2.writeConcern.wtimeout = options2.wtimeout;
          delete options2.wtimeout;
        }
      }
      return options2;
    };
    var safeDeprecationWarning = "Mongoose: the `safe` option is deprecated. Use write concerns instead: http://bit.ly/mongoose-w";
    var setSafe = util.deprecate(function setSafe2(options2, safe) {
      options2.safe = safe;
    }, safeDeprecationWarning);
    Query.prototype.lean = function(v) {
      this._mongooseOptions.lean = arguments.length ? v : true;
      return this;
    };
    Query.prototype.set = function(path, val) {
      if (typeof path === "object") {
        const keys = Object.keys(path);
        for (const key of keys) {
          this.set(key, path[key]);
        }
        return this;
      }
      this._update = this._update || {};
      this._update.$set = this._update.$set || {};
      this._update.$set[path] = val;
      return this;
    };
    Query.prototype.get = function get3(path) {
      const update = this._update;
      if (update == null) {
        return void 0;
      }
      const $set = update.$set;
      if ($set == null) {
        return update[path];
      }
      if (utils2.hasUserDefinedProperty(update, path)) {
        return update[path];
      }
      if (utils2.hasUserDefinedProperty($set, path)) {
        return $set[path];
      }
      return void 0;
    };
    Query.prototype.error = function error2(err) {
      if (arguments.length === 0) {
        return this._error;
      }
      this._error = err;
      return this;
    };
    Query.prototype._unsetCastError = function _unsetCastError() {
      if (this._error != null && !(this._error instanceof CastError)) {
        return;
      }
      return this.error(null);
    };
    Query.prototype.mongooseOptions = function(v) {
      if (arguments.length > 0) {
        this._mongooseOptions = v;
      }
      return this._mongooseOptions;
    };
    Query.prototype._castConditions = function() {
      try {
        this.cast(this.model);
        this._unsetCastError();
      } catch (err) {
        this.error(err);
      }
    };
    function _castArrayFilters(query) {
      try {
        castArrayFilters(query);
      } catch (err) {
        query.error(err);
      }
    }
    Query.prototype._find = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      callback = _wrapThunkCallback(this, callback);
      this._applyPaths();
      this._fields = this._castFields(this._fields);
      const fields = this._fieldsForExec();
      const mongooseOptions = this._mongooseOptions;
      const _this = this;
      const userProvidedFields = _this._userProvidedFields || {};
      applyGlobalMaxTimeMS(this.options, this.model);
      const completeManyOptions = Object.assign({}, {
        session: get2(this, "options.session", null)
      });
      const cb = (err, docs) => {
        if (err) {
          return callback(err);
        }
        if (docs.length === 0) {
          return callback(null, docs);
        }
        if (this.options.explain) {
          return callback(null, docs);
        }
        if (!mongooseOptions.populate) {
          return mongooseOptions.lean ? callback(null, docs) : completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);
        }
        const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);
        completeManyOptions.populated = pop;
        _this.model.populate(docs, pop, function(err2, docs2) {
          if (err2)
            return callback(err2);
          return mongooseOptions.lean ? callback(null, docs2) : completeMany(_this.model, docs2, fields, userProvidedFields, completeManyOptions, callback);
        });
      };
      const options2 = this._optionsForExec();
      options2.projection = this._fieldsForExec();
      const filter = this._conditions;
      this._collection.find(filter, options2, cb);
      return null;
    });
    Query.prototype.find = function(conditions, callback) {
      this.op = "find";
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      conditions = utils2.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "find"));
      }
      if (!callback) {
        return Query.base.find.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.merge = function(source) {
      if (!source) {
        return this;
      }
      const opts = { overwrite: true };
      if (source instanceof Query) {
        if (source._conditions) {
          utils2.merge(this._conditions, source._conditions, opts);
        }
        if (source._fields) {
          this._fields || (this._fields = {});
          utils2.merge(this._fields, source._fields, opts);
        }
        if (source.options) {
          this.options || (this.options = {});
          utils2.merge(this.options, source.options, opts);
        }
        if (source._update) {
          this._update || (this._update = {});
          utils2.mergeClone(this._update, source._update);
        }
        if (source._distinct) {
          this._distinct = source._distinct;
        }
        utils2.merge(this._mongooseOptions, source._mongooseOptions);
        return this;
      }
      utils2.merge(this._conditions, source, opts);
      return this;
    };
    Query.prototype.collation = function(value) {
      if (this.options == null) {
        this.options = {};
      }
      this.options.collation = value;
      return this;
    };
    Query.prototype._completeOne = function(doc, res, callback) {
      if (!doc && !this.options.rawResult) {
        return callback(null, null);
      }
      const model = this.model;
      const projection = utils2.clone(this._fields);
      const userProvidedFields = this._userProvidedFields || {};
      const mongooseOptions = this._mongooseOptions;
      const options2 = this.options;
      if (options2.explain) {
        return callback(null, doc);
      }
      if (!mongooseOptions.populate) {
        return mongooseOptions.lean ? _completeOneLean(doc, res, options2, callback) : completeOne(model, doc, res, options2, projection, userProvidedFields, null, callback);
      }
      const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);
      model.populate(doc, pop, (err, doc2) => {
        if (err) {
          return callback(err);
        }
        return mongooseOptions.lean ? _completeOneLean(doc2, res, options2, callback) : completeOne(model, doc2, res, options2, projection, userProvidedFields, pop, callback);
      });
    };
    Query.prototype._findOne = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error()) {
        callback(this.error());
        return null;
      }
      this._applyPaths();
      this._fields = this._castFields(this._fields);
      applyGlobalMaxTimeMS(this.options, this.model);
      Query.base.findOne.call(this, {}, (err, doc) => {
        if (err) {
          callback(err);
          return null;
        }
        this._completeOne(doc, null, _wrapThunkCallback(this, callback));
      });
    });
    Query.prototype.findOne = function(conditions, projection, options2, callback) {
      this.op = "findOne";
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = null;
        projection = null;
        options2 = null;
      } else if (typeof projection === "function") {
        callback = projection;
        options2 = null;
        projection = null;
      } else if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      conditions = utils2.toObject(conditions);
      if (options2) {
        this.setOptions(options2);
      }
      if (projection) {
        this.select(projection);
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "findOne"));
      }
      if (!callback) {
        return Query.base.findOne.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._count = wrapThunk(function(callback) {
      try {
        this.cast(this.model);
      } catch (err) {
        this.error(err);
      }
      if (this.error()) {
        return callback(this.error());
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      const conds = this._conditions;
      const options2 = this._optionsForExec();
      this._collection.count(conds, options2, utils2.tick(callback));
    });
    Query.prototype._countDocuments = wrapThunk(function(callback) {
      try {
        this.cast(this.model);
      } catch (err) {
        this.error(err);
      }
      if (this.error()) {
        return callback(this.error());
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      const conds = this._conditions;
      const options2 = this._optionsForExec();
      this._collection.collection.countDocuments(conds, options2, utils2.tick(callback));
    });
    Query.prototype._estimatedDocumentCount = wrapThunk(function(callback) {
      if (this.error()) {
        return callback(this.error());
      }
      const options2 = this._optionsForExec();
      this._collection.collection.estimatedDocumentCount(options2, utils2.tick(callback));
    });
    Query.prototype.count = function(filter, callback) {
      this.op = "count";
      if (typeof filter === "function") {
        callback = filter;
        filter = void 0;
      }
      filter = utils2.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.estimatedDocumentCount = function(options2, callback) {
      this.op = "estimatedDocumentCount";
      if (typeof options2 === "function") {
        callback = options2;
        options2 = void 0;
      }
      if (typeof options2 === "object" && options2 != null) {
        this.setOptions(options2);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.countDocuments = function(conditions, callback) {
      this.op = "countDocuments";
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
      }
      conditions = utils2.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.__distinct = wrapThunk(function __distinct(callback) {
      this._castConditions();
      if (this.error()) {
        callback(this.error());
        return null;
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      const options2 = this._optionsForExec();
      this._collection.collection.distinct(this._distinct, this._conditions, options2, callback);
    });
    Query.prototype.distinct = function(field, conditions, callback) {
      this.op = "distinct";
      if (!callback) {
        if (typeof conditions === "function") {
          callback = conditions;
          conditions = void 0;
        } else if (typeof field === "function") {
          callback = field;
          field = void 0;
          conditions = void 0;
        }
      }
      conditions = utils2.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "distinct"));
      }
      if (field != null) {
        this._distinct = field;
      }
      if (callback != null) {
        this.exec(callback);
      }
      return this;
    };
    Query.prototype.sort = function(arg) {
      if (arguments.length > 1) {
        throw new Error("sort() only takes 1 Argument");
      }
      return Query.base.sort.call(this, arg);
    };
    Query.prototype.remove = function(filter, callback) {
      this.op = "remove";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
      }
      filter = utils2.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "remove"));
      }
      if (!callback) {
        return Query.base.remove.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._remove = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.remove.call(this, helpers.handleDeleteWriteOpResult(callback));
    });
    Query.prototype.deleteOne = function(filter, options2, callback) {
      this.op = "deleteOne";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
        options2 = null;
      } else if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      } else {
        this.setOptions(options2);
      }
      filter = utils2.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "deleteOne"));
      }
      if (!callback) {
        return Query.base.deleteOne.call(this);
      }
      this.exec.call(this, callback);
      return this;
    };
    Query.prototype._deleteOne = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.deleteOne.call(this, helpers.handleDeleteWriteOpResult(callback));
    });
    Query.prototype.deleteMany = function(filter, options2, callback) {
      this.op = "deleteMany";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
        options2 = null;
      } else if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      } else {
        this.setOptions(options2);
      }
      filter = utils2.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "deleteMany"));
      }
      if (!callback) {
        return Query.base.deleteMany.call(this);
      }
      this.exec.call(this, callback);
      return this;
    };
    Query.prototype._deleteMany = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.deleteMany.call(this, helpers.handleDeleteWriteOpResult(callback));
    });
    function completeOne(model, doc, res, options2, fields, userProvidedFields, pop, callback) {
      const opts = pop ? { populated: pop } : void 0;
      if (options2.rawResult && doc == null) {
        _init(null);
        return null;
      }
      const casted = helpers.createModel(model, doc, fields, userProvidedFields, options2);
      try {
        casted.init(doc, opts, _init);
      } catch (error2) {
        _init(error2);
      }
      function _init(err) {
        if (err) {
          return immediate(() => callback(err));
        }
        if (options2.rawResult) {
          if (doc && casted) {
            if (options2.session != null) {
              casted.$session(options2.session);
            }
            res.value = casted;
          } else {
            res.value = null;
          }
          return immediate(() => callback(null, res));
        }
        if (options2.session != null) {
          casted.$session(options2.session);
        }
        immediate(() => callback(null, casted));
      }
    }
    function prepareDiscriminatorCriteria(query) {
      if (!query || !query.model || !query.model.schema) {
        return;
      }
      const schema = query.model.schema;
      if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
        query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
      }
    }
    Query.prototype.findOneAndUpdate = function(criteria, doc, options2, callback) {
      this.op = "findOneAndUpdate";
      this._validate();
      switch (arguments.length) {
        case 3:
          if (typeof options2 === "function") {
            callback = options2;
            options2 = {};
          }
          break;
        case 2:
          if (typeof doc === "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          options2 = void 0;
          break;
        case 1:
          if (typeof criteria === "function") {
            callback = criteria;
            criteria = options2 = doc = void 0;
          } else {
            doc = criteria;
            criteria = options2 = void 0;
          }
      }
      if (mquery.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (doc) {
        this._mergeUpdate(doc);
      }
      options2 = options2 ? utils2.clone(options2) : {};
      if (options2.projection) {
        this.select(options2.projection);
        delete options2.projection;
      }
      if (options2.fields) {
        this.select(options2.fields);
        delete options2.fields;
      }
      const returnOriginal = get2(this, "model.base.options.returnOriginal");
      if (options2.new == null && options2.returnDocument == null && options2.returnOriginal == null && returnOriginal != null) {
        options2.returnOriginal = returnOriginal;
      }
      this.setOptions(options2);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndUpdate = wrapThunk(function(callback) {
      if (this.error() != null) {
        return callback(this.error());
      }
      this._findAndModify("update", callback);
    });
    Query.prototype.findOneAndRemove = function(conditions, options2, callback) {
      this.op = "findOneAndRemove";
      this._validate();
      switch (arguments.length) {
        case 2:
          if (typeof options2 === "function") {
            callback = options2;
            options2 = {};
          }
          break;
        case 1:
          if (typeof conditions === "function") {
            callback = conditions;
            conditions = void 0;
            options2 = void 0;
          }
          break;
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      options2 && this.setOptions(options2);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.findOneAndDelete = function(conditions, options2, callback) {
      this.op = "findOneAndDelete";
      this._validate();
      switch (arguments.length) {
        case 2:
          if (typeof options2 === "function") {
            callback = options2;
            options2 = {};
          }
          break;
        case 1:
          if (typeof conditions === "function") {
            callback = conditions;
            conditions = void 0;
            options2 = void 0;
          }
          break;
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      options2 && this.setOptions(options2);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndDelete = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      const filter = this._conditions;
      const options2 = this._optionsForExec();
      let fields = null;
      if (this._fields != null) {
        options2.projection = this._castFields(utils2.clone(this._fields));
        fields = options2.projection;
        if (fields instanceof Error) {
          callback(fields);
          return null;
        }
      }
      this._collection.collection.findOneAndDelete(filter, options2, _wrapThunkCallback(this, (err, res) => {
        if (err) {
          return callback(err);
        }
        const doc = res.value;
        return this._completeOne(doc, res, callback);
      }));
    });
    Query.prototype.findOneAndReplace = function(filter, replacement, options2, callback) {
      this.op = "findOneAndReplace";
      this._validate();
      switch (arguments.length) {
        case 3:
          if (typeof options2 === "function") {
            callback = options2;
            options2 = void 0;
          }
          break;
        case 2:
          if (typeof replacement === "function") {
            callback = replacement;
            replacement = void 0;
          }
          break;
        case 1:
          if (typeof filter === "function") {
            callback = filter;
            filter = void 0;
            replacement = void 0;
            options2 = void 0;
          }
          break;
      }
      if (mquery.canMerge(filter)) {
        this.merge(filter);
      }
      if (replacement != null) {
        if (hasDollarKeys(replacement)) {
          throw new Error("The replacement document must not contain atomic operators.");
        }
        this._mergeUpdate(replacement);
      }
      options2 = options2 || {};
      const returnOriginal = get2(this, "model.base.options.returnOriginal");
      if (options2.new == null && options2.returnDocument == null && options2.returnOriginal == null && returnOriginal != null) {
        options2.returnOriginal = returnOriginal;
      }
      this.setOptions(options2);
      this.setOptions({ overwrite: true });
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndReplace = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      const filter = this._conditions;
      const options2 = this._optionsForExec();
      convertNewToReturnDocument(options2);
      let fields = null;
      let castedDoc = new this.model(this._update, null, true);
      this._update = castedDoc;
      this._applyPaths();
      if (this._fields != null) {
        options2.projection = this._castFields(utils2.clone(this._fields));
        fields = options2.projection;
        if (fields instanceof Error) {
          callback(fields);
          return null;
        }
      }
      castedDoc.validate((err) => {
        if (err != null) {
          return callback(err);
        }
        if (castedDoc.toBSON) {
          castedDoc = castedDoc.toBSON();
        }
        this._collection.collection.findOneAndReplace(filter, castedDoc, options2, _wrapThunkCallback(this, (err2, res) => {
          if (err2) {
            return callback(err2);
          }
          const doc = res.value;
          return this._completeOne(doc, res, callback);
        }));
      });
    });
    function convertNewToReturnDocument(options2) {
      if ("new" in options2) {
        options2.returnDocument = options2["new"] ? "after" : "before";
        delete options2["new"];
      }
      if ("returnOriginal" in options2) {
        options2.returnDocument = options2["returnOriginal"] ? "before" : "after";
        delete options2["returnOriginal"];
      }
    }
    Query.prototype._findOneAndRemove = wrapThunk(function(callback) {
      if (this.error() != null) {
        callback(this.error());
        return;
      }
      this._findAndModify("remove", callback);
    });
    function _getOption(query, option, def) {
      const opts = query._optionsForExec(query.model);
      if (option in opts) {
        return opts[option];
      }
      if (option in query.model.base.options) {
        return query.model.base.options[option];
      }
      return def;
    }
    Query.prototype._findAndModify = function(type, callback) {
      if (typeof callback !== "function") {
        throw new Error("Expected callback in _findAndModify");
      }
      const model = this.model;
      const schema = model.schema;
      const _this = this;
      let fields;
      const castedQuery = castQuery(this);
      if (castedQuery instanceof Error) {
        return callback(castedQuery);
      }
      _castArrayFilters(this);
      const opts = this._optionsForExec(model);
      if ("strict" in opts) {
        this._mongooseOptions.strict = opts.strict;
      }
      const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
      if (isOverwriting) {
        this._update = new this.model(this._update, null, true);
      }
      if (type === "remove") {
        opts.remove = true;
      } else {
        if (!("new" in opts) && !("returnOriginal" in opts) && !("returnDocument" in opts)) {
          opts.new = false;
        }
        if (!("upsert" in opts)) {
          opts.upsert = false;
        }
        if (opts.upsert || opts["new"]) {
          opts.remove = false;
        }
        if (!isOverwriting) {
          this._update = castDoc(this, opts.overwrite);
          const _opts = Object.assign({}, opts, {
            setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
          });
          this._update = setDefaultsOnInsert(this._conditions, schema, this._update, _opts);
          if (!this._update || Object.keys(this._update).length === 0) {
            if (opts.upsert) {
              const doc = utils2.clone(castedQuery);
              delete doc._id;
              this._update = { $set: doc };
            } else {
              this.findOne(callback);
              return this;
            }
          } else if (this._update instanceof Error) {
            return callback(this._update);
          } else {
            if (this._update.$set && Object.keys(this._update.$set).length === 0) {
              delete this._update.$set;
            }
          }
        }
        if (Array.isArray(opts.arrayFilters)) {
          opts.arrayFilters = removeUnusedArrayFilters(this._update, opts.arrayFilters);
        }
      }
      this._applyPaths();
      const options2 = this._mongooseOptions;
      if (this._fields) {
        fields = utils2.clone(this._fields);
        opts.projection = this._castFields(fields);
        if (opts.projection instanceof Error) {
          return callback(opts.projection);
        }
      }
      if (opts.sort)
        convertSortToArray(opts);
      const cb = function(err, doc, res) {
        if (err) {
          return callback(err);
        }
        _this._completeOne(doc, res, callback);
      };
      let useFindAndModify = true;
      const runValidators = _getOption(this, "runValidators", false);
      const base = _this.model && _this.model.base;
      const conn = get2(model, "collection.conn", {});
      if ("useFindAndModify" in base.options) {
        useFindAndModify = base.get("useFindAndModify");
      }
      if ("useFindAndModify" in conn.config) {
        useFindAndModify = conn.config.useFindAndModify;
      }
      if ("useFindAndModify" in options2) {
        useFindAndModify = options2.useFindAndModify;
      }
      if (useFindAndModify === false) {
        const collection = _this._collection.collection;
        convertNewToReturnDocument(opts);
        if (type === "remove") {
          collection.findOneAndDelete(castedQuery, opts, _wrapThunkCallback(_this, function(error2, res) {
            return cb(error2, res ? res.value : res, res);
          }));
          return this;
        }
        const updateMethod = isOverwriting ? "findOneAndReplace" : "findOneAndUpdate";
        if (runValidators) {
          this.validate(this._update, opts, isOverwriting, (error2) => {
            if (error2) {
              return callback(error2);
            }
            if (this._update && this._update.toBSON) {
              this._update = this._update.toBSON();
            }
            collection[updateMethod](castedQuery, this._update, opts, _wrapThunkCallback(_this, function(error3, res) {
              return cb(error3, res ? res.value : res, res);
            }));
          });
        } else {
          if (this._update && this._update.toBSON) {
            this._update = this._update.toBSON();
          }
          collection[updateMethod](castedQuery, this._update, opts, _wrapThunkCallback(_this, function(error2, res) {
            return cb(error2, res ? res.value : res, res);
          }));
        }
        return this;
      }
      if (runValidators) {
        this.validate(this._update, opts, isOverwriting, function(error2) {
          if (error2) {
            return callback(error2);
          }
          _legacyFindAndModify.call(_this, castedQuery, _this._update, opts, cb);
        });
      } else {
        _legacyFindAndModify.call(_this, castedQuery, _this._update, opts, cb);
      }
      return this;
    };
    function _completeOneLean(doc, res, opts, callback) {
      if (opts.rawResult) {
        return callback(null, res);
      }
      return callback(null, doc);
    }
    var _legacyFindAndModify = util.deprecate(function(filter, update, opts, cb) {
      if (update && update.toBSON) {
        update = update.toBSON();
      }
      const collection = this._collection;
      const sort = opts != null && Array.isArray(opts.sort) ? opts.sort : [];
      const _cb = _wrapThunkCallback(this, function(error2, res) {
        return cb(error2, res ? res.value : res, res);
      });
      collection.collection._findAndModify(filter, sort, update, opts, _cb);
    }, "Mongoose: `findOneAndUpdate()` and `findOneAndDelete()` without the `useFindAndModify` option set to false are deprecated. See: https://mongoosejs.com/docs/deprecations.html#findandmodify");
    Query.prototype._mergeUpdate = function(doc) {
      if (doc == null || typeof doc === "object" && Object.keys(doc).length === 0) {
        return;
      }
      if (!this._update) {
        this._update = Array.isArray(doc) ? [] : {};
      }
      if (doc instanceof Query) {
        if (Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        if (doc._update) {
          utils2.mergeClone(this._update, doc._update);
        }
      } else if (Array.isArray(doc)) {
        if (!Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        this._update = this._update.concat(doc);
      } else {
        if (Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        utils2.mergeClone(this._update, doc);
      }
    };
    function convertSortToArray(opts) {
      if (Array.isArray(opts.sort)) {
        return;
      }
      if (!utils2.isObject(opts.sort)) {
        return;
      }
      const sort = [];
      for (const key in opts.sort) {
        if (utils2.object.hasOwnProperty(opts.sort, key)) {
          sort.push([key, opts.sort[key]]);
        }
      }
      opts.sort = sort;
    }
    function _updateThunk(op, callback) {
      this._castConditions();
      _castArrayFilters(this);
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      callback = _wrapThunkCallback(this, callback);
      const oldCb = callback;
      callback = function(error2, result) {
        oldCb(error2, result ? result.result : { ok: 0, n: 0, nModified: 0 });
      };
      const castedQuery = this._conditions;
      const options2 = this._optionsForExec(this.model);
      ++this._executionCount;
      this._update = utils2.clone(this._update, options2);
      const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
      if (isOverwriting) {
        if (op === "updateOne" || op === "updateMany") {
          return callback(new MongooseError("The MongoDB server disallows overwriting documents using `" + op + "`. See: https://mongoosejs.com/docs/deprecations.html#update"));
        }
        this._update = new this.model(this._update, null, true);
      } else {
        this._update = castDoc(this, options2.overwrite);
        if (this._update instanceof Error) {
          callback(this._update);
          return null;
        }
        if (this._update == null || Object.keys(this._update).length === 0) {
          callback(null, 0);
          return null;
        }
        const _opts = Object.assign({}, options2, {
          setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
        });
        this._update = setDefaultsOnInsert(this._conditions, this.model.schema, this._update, _opts);
      }
      if (Array.isArray(options2.arrayFilters)) {
        options2.arrayFilters = removeUnusedArrayFilters(this._update, options2.arrayFilters);
      }
      const runValidators = _getOption(this, "runValidators", false);
      if (runValidators) {
        this.validate(this._update, options2, isOverwriting, (err) => {
          if (err) {
            return callback(err);
          }
          if (this._update.toBSON) {
            this._update = this._update.toBSON();
          }
          this._collection[op](castedQuery, this._update, options2, callback);
        });
        return null;
      }
      if (this._update.toBSON) {
        this._update = this._update.toBSON();
      }
      this._collection[op](castedQuery, this._update, options2, callback);
      return null;
    }
    Query.prototype.validate = function validate(castedDoc, options2, isOverwriting, callback) {
      return promiseOrCallback(callback, (cb) => {
        try {
          if (isOverwriting) {
            castedDoc.validate(cb);
          } else {
            updateValidators(this, this.model.schema, castedDoc, options2, cb);
          }
        } catch (err) {
          immediate(function() {
            cb(err);
          });
        }
      });
    };
    Query.prototype._execUpdate = wrapThunk(function(callback) {
      return _updateThunk.call(this, "update", callback);
    });
    Query.prototype._updateMany = wrapThunk(function(callback) {
      return _updateThunk.call(this, "updateMany", callback);
    });
    Query.prototype._updateOne = wrapThunk(function(callback) {
      return _updateThunk.call(this, "updateOne", callback);
    });
    Query.prototype._replaceOne = wrapThunk(function(callback) {
      return _updateThunk.call(this, "replaceOne", callback);
    });
    Query.prototype.update = function(conditions, doc, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options2 = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options2 = void 0;
      } else if (typeof conditions === "object" && !doc && !options2 && !callback) {
        doc = conditions;
        conditions = void 0;
        options2 = void 0;
        callback = void 0;
      }
      return _update(this, "update", conditions, doc, options2, callback);
    };
    Query.prototype.updateMany = function(conditions, doc, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options2 = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options2 = void 0;
      } else if (typeof conditions === "object" && !doc && !options2 && !callback) {
        doc = conditions;
        conditions = void 0;
        options2 = void 0;
        callback = void 0;
      }
      return _update(this, "updateMany", conditions, doc, options2, callback);
    };
    Query.prototype.updateOne = function(conditions, doc, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options2 = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options2 = void 0;
      } else if (typeof conditions === "object" && !doc && !options2 && !callback) {
        doc = conditions;
        conditions = void 0;
        options2 = void 0;
        callback = void 0;
      }
      return _update(this, "updateOne", conditions, doc, options2, callback);
    };
    Query.prototype.replaceOne = function(conditions, doc, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options2 = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options2 = void 0;
      } else if (typeof conditions === "object" && !doc && !options2 && !callback) {
        doc = conditions;
        conditions = void 0;
        options2 = void 0;
        callback = void 0;
      }
      this.setOptions({ overwrite: true });
      return _update(this, "replaceOne", conditions, doc, options2, callback);
    };
    function _update(query, op, filter, doc, options2, callback) {
      query.op = op;
      filter = utils2.toObject(filter);
      doc = doc || {};
      if (options2 != null) {
        if ("strict" in options2) {
          query._mongooseOptions.strict = options2.strict;
        }
      }
      if (!(filter instanceof Query) && filter != null && filter.toString() !== "[object Object]") {
        query.error(new ObjectParameterError(filter, "filter", op));
      } else {
        query.merge(filter);
      }
      if (utils2.isObject(options2)) {
        query.setOptions(options2);
      }
      query._mergeUpdate(doc);
      if (callback) {
        query.exec(callback);
        return query;
      }
      return Query.base[op].call(query, filter, void 0, options2, callback);
    }
    Query.prototype.map = function(fn) {
      this._transforms.push(fn);
      return this;
    };
    Query.prototype.orFail = function(err) {
      this.map((res) => {
        switch (this.op) {
          case "find":
            if (res.length === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOne":
            if (res == null) {
              throw _orFailError(err, this);
            }
            break;
          case "update":
          case "updateMany":
          case "updateOne":
            if (get2(res, "nModified") === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOneAndDelete":
          case "findOneAndRemove":
            if (get2(res, "lastErrorObject.n") === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOneAndUpdate":
          case "findOneAndReplace":
            if (get2(res, "lastErrorObject.updatedExisting") === false) {
              throw _orFailError(err, this);
            }
            break;
          case "deleteMany":
          case "deleteOne":
          case "remove":
            if (res.n === 0) {
              throw _orFailError(err, this);
            }
            break;
          default:
            break;
        }
        return res;
      });
      return this;
    };
    function _orFailError(err, query) {
      if (typeof err === "function") {
        err = err.call(query);
      }
      if (err == null) {
        err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);
      }
      return err;
    }
    Query.prototype.exec = function exec(op, callback) {
      const _this = this;
      const castError = new CastError();
      if (typeof op === "function") {
        callback = op;
        op = null;
      } else if (typeof op === "string") {
        this.op = op;
      }
      callback = this.model.$handleCallbackError(callback);
      return promiseOrCallback(callback, (cb) => {
        cb = this.model.$wrapCallback(cb);
        if (!_this.op) {
          cb();
          return;
        }
        this._hooks.execPre("exec", this, [], (error2) => {
          if (error2 != null) {
            return cb(_cleanCastErrorStack(castError, error2));
          }
          let thunk = "_" + this.op;
          if (this.op === "update") {
            thunk = "_execUpdate";
          } else if (this.op === "distinct") {
            thunk = "__distinct";
          }
          this[thunk].call(this, (error3, res) => {
            if (error3) {
              return cb(_cleanCastErrorStack(castError, error3));
            }
            this._hooks.execPost("exec", this, [], {}, (error4) => {
              if (error4) {
                return cb(_cleanCastErrorStack(castError, error4));
              }
              cb(null, res);
            });
          });
        });
      }, this.model.events);
    };
    function _cleanCastErrorStack(castError, error2) {
      if (error2 instanceof CastError) {
        castError.copy(error2);
        return castError;
      }
      return error2;
    }
    function _wrapThunkCallback(query, cb) {
      return function(error2, res) {
        if (error2 != null) {
          return cb(error2);
        }
        for (const fn of query._transforms) {
          try {
            res = fn(res);
          } catch (error3) {
            return cb(error3);
          }
        }
        return cb(null, res);
      };
    }
    Query.prototype.then = function(resolve2, reject) {
      return this.exec().then(resolve2, reject);
    };
    Query.prototype.catch = function(reject) {
      return this.exec().then(null, reject);
    };
    Query.prototype.pre = function(fn) {
      this._hooks.pre("exec", fn);
      return this;
    };
    Query.prototype.post = function(fn) {
      this._hooks.post("exec", fn);
      return this;
    };
    Query.prototype._castUpdate = function _castUpdate(obj, overwrite) {
      let strict;
      let schema = this.schema;
      const discriminatorKey = schema.options.discriminatorKey;
      const baseSchema = schema._baseSchema ? schema._baseSchema : schema;
      if (this._mongooseOptions.overwriteDiscriminatorKey && obj[discriminatorKey] != null && baseSchema.discriminators) {
        const _schema = baseSchema.discriminators[obj[discriminatorKey]];
        if (_schema != null) {
          schema = _schema;
        }
      }
      if ("strict" in this._mongooseOptions) {
        strict = this._mongooseOptions.strict;
      } else if (this.schema && this.schema.options) {
        strict = this.schema.options.strict;
      } else {
        strict = true;
      }
      let omitUndefined = false;
      if ("omitUndefined" in this._mongooseOptions) {
        omitUndefined = this._mongooseOptions.omitUndefined;
      }
      let useNestedStrict;
      if ("useNestedStrict" in this.options) {
        useNestedStrict = this.options.useNestedStrict;
      }
      let upsert;
      if ("upsert" in this.options) {
        upsert = this.options.upsert;
      }
      const filter = this._conditions;
      if (schema != null && utils2.hasUserDefinedProperty(filter, schema.options.discriminatorKey) && typeof filter[schema.options.discriminatorKey] !== "object" && schema.discriminators != null) {
        const discriminatorValue = filter[schema.options.discriminatorKey];
        const byValue = getDiscriminatorByValue(this.model.discriminators, discriminatorValue);
        schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
      }
      return castUpdate(schema, obj, {
        overwrite,
        strict,
        omitUndefined,
        useNestedStrict,
        upsert,
        arrayFilters: this.options.arrayFilters
      }, this, this._conditions);
    };
    function castQuery(query) {
      try {
        return query.cast(query.model);
      } catch (err) {
        return err;
      }
    }
    function castDoc(query, overwrite) {
      try {
        return query._castUpdate(query._update, overwrite);
      } catch (err) {
        return err;
      }
    }
    Query.prototype.populate = function() {
      if (!Array.from(arguments).some(Boolean)) {
        return this;
      }
      const res = utils2.populate.apply(null, arguments);
      if (this.options != null) {
        const readConcern = this.options.readConcern;
        const readPref = this.options.readPreference;
        for (const populateOptions of res) {
          if (readConcern != null && get2(populateOptions, "options.readConcern") == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.readConcern = readConcern;
          }
          if (readPref != null && get2(populateOptions, "options.readPreference") == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.readPreference = readPref;
          }
        }
      }
      const opts = this._mongooseOptions;
      if (opts.lean != null) {
        const lean = opts.lean;
        for (const populateOptions of res) {
          if (get2(populateOptions, "options.lean") == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.lean = lean;
          }
        }
      }
      if (!utils2.isObject(opts.populate)) {
        opts.populate = {};
      }
      const pop = opts.populate;
      for (const populateOptions of res) {
        const path = populateOptions.path;
        if (pop[path] && pop[path].populate && populateOptions.populate) {
          populateOptions.populate = pop[path].populate.concat(populateOptions.populate);
        }
        pop[populateOptions.path] = populateOptions;
      }
      return this;
    };
    Query.prototype.getPopulatedPaths = function getPopulatedPaths() {
      const obj = this._mongooseOptions.populate || {};
      const ret2 = Object.keys(obj);
      for (const path of Object.keys(obj)) {
        const pop = obj[path];
        if (!Array.isArray(pop.populate)) {
          continue;
        }
        _getPopulatedPaths(ret2, pop.populate, path + ".");
      }
      return ret2;
    };
    function _getPopulatedPaths(list, arr, prefix) {
      for (const pop of arr) {
        list.push(prefix + pop.path);
        if (!Array.isArray(pop.populate)) {
          continue;
        }
        _getPopulatedPaths(list, pop.populate, prefix + pop.path + ".");
      }
    }
    Query.prototype.cast = function(model, obj) {
      obj || (obj = this._conditions);
      model = model || this.model;
      const discriminatorKey = model.schema.options.discriminatorKey;
      if (obj != null && obj.hasOwnProperty(discriminatorKey)) {
        model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;
      }
      try {
        return cast(model.schema, obj, {
          upsert: this.options && this.options.upsert,
          strict: this.options && "strict" in this.options ? this.options.strict : get2(model, "schema.options.strict", null),
          strictQuery: this.options && this.options.strictQuery || get2(model, "schema.options.strictQuery", null)
        }, this);
      } catch (err) {
        if (typeof err.setModel === "function") {
          err.setModel(model);
        }
        throw err;
      }
    };
    Query.prototype._castFields = function _castFields(fields) {
      let selected, elemMatchKeys, keys, key, out, i;
      if (fields) {
        keys = Object.keys(fields);
        elemMatchKeys = [];
        i = keys.length;
        while (i--) {
          key = keys[i];
          if (fields[key].$elemMatch) {
            selected || (selected = {});
            selected[key] = fields[key];
            elemMatchKeys.push(key);
          }
        }
      }
      if (selected) {
        try {
          out = this.cast(this.model, selected);
        } catch (err) {
          return err;
        }
        i = elemMatchKeys.length;
        while (i--) {
          key = elemMatchKeys[i];
          fields[key] = out[key];
        }
      }
      return fields;
    };
    Query.prototype._applyPaths = function applyPaths() {
      this._fields = this._fields || {};
      helpers.applyPaths(this._fields, this.model.schema);
      let _selectPopulatedPaths = true;
      if ("selectPopulatedPaths" in this.model.base.options) {
        _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;
      }
      if ("selectPopulatedPaths" in this.model.schema.options) {
        _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;
      }
      if (_selectPopulatedPaths) {
        selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);
      }
    };
    Query.prototype.cursor = function cursor(opts) {
      this._applyPaths();
      this._fields = this._castFields(this._fields);
      this.setOptions({ projection: this._fieldsForExec() });
      if (opts) {
        this.setOptions(opts);
      }
      const options2 = Object.assign({}, this._optionsForExec(), {
        projection: this.projection()
      });
      try {
        this.cast(this.model);
      } catch (err) {
        return new QueryCursor(this, options2)._markError(err);
      }
      return new QueryCursor(this, options2);
    };
    Query.prototype.maxscan = Query.base.maxScan;
    Query.prototype.tailable = function(val, opts) {
      if (val && val.constructor.name === "Object") {
        opts = val;
        val = true;
      }
      if (val === void 0) {
        val = true;
      }
      if (opts && typeof opts === "object") {
        for (const key of Object.keys(opts)) {
          if (key === "awaitdata") {
            this.options[key] = !!opts[key];
          } else {
            this.options[key] = opts[key];
          }
        }
      }
      return Query.base.tailable.call(this, val);
    };
    Query.prototype.near = function() {
      const params = [];
      const sphere = this._mongooseOptions.nearSphere;
      if (arguments.length === 1) {
        if (Array.isArray(arguments[0])) {
          params.push({ center: arguments[0], spherical: sphere });
        } else if (typeof arguments[0] === "string") {
          params.push(arguments[0]);
        } else if (utils2.isObject(arguments[0])) {
          if (typeof arguments[0].spherical !== "boolean") {
            arguments[0].spherical = sphere;
          }
          params.push(arguments[0]);
        } else {
          throw new TypeError("invalid argument");
        }
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
          params.push({ center: [arguments[0], arguments[1]], spherical: sphere });
        } else if (typeof arguments[0] === "string" && Array.isArray(arguments[1])) {
          params.push(arguments[0]);
          params.push({ center: arguments[1], spherical: sphere });
        } else if (typeof arguments[0] === "string" && utils2.isObject(arguments[1])) {
          params.push(arguments[0]);
          if (typeof arguments[1].spherical !== "boolean") {
            arguments[1].spherical = sphere;
          }
          params.push(arguments[1]);
        } else {
          throw new TypeError("invalid argument");
        }
      } else if (arguments.length === 3) {
        if (typeof arguments[0] === "string" && typeof arguments[1] === "number" && typeof arguments[2] === "number") {
          params.push(arguments[0]);
          params.push({ center: [arguments[1], arguments[2]], spherical: sphere });
        } else {
          throw new TypeError("invalid argument");
        }
      } else {
        throw new TypeError("invalid argument");
      }
      return Query.base.near.apply(this, params);
    };
    Query.prototype.nearSphere = function() {
      this._mongooseOptions.nearSphere = true;
      this.near.apply(this, arguments);
      return this;
    };
    if (Symbol.asyncIterator != null) {
      Query.prototype[Symbol.asyncIterator] = function() {
        return this.cursor().transformNull()._transformForAsyncIterator();
      };
    }
    Query.prototype.box = function(ll, ur) {
      if (!Array.isArray(ll) && utils2.isObject(ll)) {
        ur = ll.ur;
        ll = ll.ll;
      }
      return Query.base.box.call(this, ll, ur);
    };
    Query.prototype.center = Query.base.circle;
    Query.prototype.centerSphere = function() {
      if (arguments[0] && arguments[0].constructor.name === "Object") {
        arguments[0].spherical = true;
      }
      if (arguments[1] && arguments[1].constructor.name === "Object") {
        arguments[1].spherical = true;
      }
      Query.base.circle.apply(this, arguments);
    };
    Query.prototype.selectedInclusively = function selectedInclusively() {
      return isInclusive(this._fields);
    };
    Query.prototype.selectedExclusively = function selectedExclusively() {
      return isExclusive(this._fields);
    };
    module2.exports = Query;
  }
});

// node_modules/mongoose/lib/cursor/AggregationCursor.js
var require_AggregationCursor = __commonJS({
  "node_modules/mongoose/lib/cursor/AggregationCursor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_mongooseError();
    var Readable2 = require("stream").Readable;
    var promiseOrCallback = require_promiseOrCallback();
    var eachAsync = require_eachAsync();
    var immediate = require_immediate();
    var util = require("util");
    function AggregationCursor(agg) {
      Readable2.call(this, { objectMode: true });
      this.cursor = null;
      this.agg = agg;
      this._transforms = [];
      const model = agg._model;
      delete agg.options.cursor.useMongooseAggCursor;
      this._mongooseOptions = {};
      _init(model, this, agg);
    }
    util.inherits(AggregationCursor, Readable2);
    function _init(model, c, agg) {
      if (!model.collection.buffer) {
        model.hooks.execPre("aggregate", agg, function() {
          c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
          c.emit("cursor", c.cursor);
        });
      } else {
        model.collection.emitter.once("queue", function() {
          model.hooks.execPre("aggregate", agg, function() {
            c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
            c.emit("cursor", c.cursor);
          });
        });
      }
    }
    AggregationCursor.prototype._read = function() {
      const _this = this;
      _next(this, function(error2, doc) {
        if (error2) {
          return _this.emit("error", error2);
        }
        if (!doc) {
          _this.push(null);
          _this.cursor.close(function(error3) {
            if (error3) {
              return _this.emit("error", error3);
            }
            setTimeout(function() {
              const isNotClosedAutomatically = !_this.destroyed;
              if (isNotClosedAutomatically) {
                _this.emit("close");
              }
            }, 0);
          });
          return;
        }
        _this.push(doc);
      });
    };
    if (Symbol.asyncIterator != null) {
      const msg = "Mongoose does not support using async iterators with an existing aggregation cursor. See http://bit.ly/mongoose-async-iterate-aggregation";
      AggregationCursor.prototype[Symbol.asyncIterator] = function() {
        throw new MongooseError(msg);
      };
    }
    AggregationCursor.prototype.map = function(fn) {
      this._transforms.push(fn);
      return this;
    };
    AggregationCursor.prototype._markError = function(error2) {
      this._error = error2;
      return this;
    };
    AggregationCursor.prototype.close = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        this.cursor.close((error2) => {
          if (error2) {
            cb(error2);
            return this.listeners("error").length > 0 && this.emit("error", error2);
          }
          this.emit("close");
          cb(null);
        });
      });
    };
    AggregationCursor.prototype.next = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        _next(this, cb);
      });
    };
    AggregationCursor.prototype.eachAsync = function(fn, opts, callback) {
      const _this = this;
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      opts = opts || {};
      return eachAsync(function(cb) {
        return _next(_this, cb);
      }, fn, opts, callback);
    };
    if (Symbol.asyncIterator != null) {
      AggregationCursor.prototype[Symbol.asyncIterator] = function() {
        return this.transformNull()._transformForAsyncIterator();
      };
    }
    AggregationCursor.prototype._transformForAsyncIterator = function() {
      if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
        this.map(_transformForAsyncIterator);
      }
      return this;
    };
    AggregationCursor.prototype.transformNull = function(val) {
      if (arguments.length === 0) {
        val = true;
      }
      this._mongooseOptions.transformNull = val;
      return this;
    };
    function _transformForAsyncIterator(doc) {
      return doc == null ? { done: true } : { value: doc, done: false };
    }
    AggregationCursor.prototype.addCursorFlag = function(flag, value) {
      const _this = this;
      _waitForCursor(this, function() {
        _this.cursor.addCursorFlag(flag, value);
      });
      return this;
    };
    function _waitForCursor(ctx, cb) {
      if (ctx.cursor) {
        return cb();
      }
      ctx.once("cursor", function() {
        cb();
      });
    }
    function _next(ctx, cb) {
      let callback = cb;
      if (ctx._transforms.length) {
        callback = function(err, doc) {
          if (err || doc === null && !ctx._mongooseOptions.transformNull) {
            return cb(err, doc);
          }
          cb(err, ctx._transforms.reduce(function(doc2, fn) {
            return fn(doc2);
          }, doc));
        };
      }
      if (ctx._error) {
        return immediate(function() {
          callback(ctx._error);
        });
      }
      if (ctx.cursor) {
        return ctx.cursor.next(function(error2, doc) {
          if (error2) {
            return callback(error2);
          }
          if (!doc) {
            return callback(null, null);
          }
          callback(null, doc);
        });
      } else {
        ctx.once("cursor", function() {
          _next(ctx, cb);
        });
      }
    }
    module2.exports = AggregationCursor;
  }
});

// node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js
var require_stringifyFunctionOperators = __commonJS({
  "node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function stringifyFunctionOperators(pipeline2) {
      if (!Array.isArray(pipeline2)) {
        return;
      }
      for (const stage of pipeline2) {
        if (stage == null) {
          continue;
        }
        const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;
        if (canHaveAccumulator != null) {
          for (const key of Object.keys(canHaveAccumulator)) {
            handleAccumulator(canHaveAccumulator[key]);
          }
        }
        const stageType = Object.keys(stage)[0];
        if (stageType && typeof stage[stageType] === "object") {
          const stageOptions = stage[stageType];
          for (const key of Object.keys(stageOptions)) {
            if (stageOptions[key] != null && stageOptions[key].$function != null && typeof stageOptions[key].$function.body === "function") {
              stageOptions[key].$function.body = stageOptions[key].$function.body.toString();
            }
          }
        }
        if (stage.$facet != null) {
          for (const key of Object.keys(stage.$facet)) {
            stringifyFunctionOperators(stage.$facet[key]);
          }
        }
      }
    };
    function handleAccumulator(operator) {
      if (operator == null || operator.$accumulator == null) {
        return;
      }
      for (const key of ["init", "accumulate", "merge", "finalize"]) {
        if (typeof operator.$accumulator[key] === "function") {
          operator.$accumulator[key] = String(operator.$accumulator[key]);
        }
      }
    }
  }
});

// node_modules/mongoose/lib/aggregate.js
var require_aggregate2 = __commonJS({
  "node_modules/mongoose/lib/aggregate.js"(exports2, module2) {
    init_shims();
    "use strict";
    var AggregationCursor = require_AggregationCursor();
    var Query = require_query2();
    var applyGlobalMaxTimeMS = require_applyGlobalMaxTimeMS();
    var promiseOrCallback = require_promiseOrCallback();
    var stringifyFunctionOperators = require_stringifyFunctionOperators();
    var util = require("util");
    var utils2 = require_utils6();
    var read2 = Query.prototype.read;
    var readConcern = Query.prototype.readConcern;
    function Aggregate(pipeline2) {
      this._pipeline = [];
      this._model = void 0;
      this.options = {};
      if (arguments.length === 1 && util.isArray(pipeline2)) {
        this.append.apply(this, pipeline2);
      }
    }
    Aggregate.prototype.options;
    Aggregate.prototype.model = function(model) {
      if (arguments.length === 0) {
        return this._model;
      }
      this._model = model;
      if (model.schema != null) {
        if (this.options.readPreference == null && model.schema.options.read != null) {
          this.options.readPreference = model.schema.options.read;
        }
        if (this.options.collation == null && model.schema.options.collation != null) {
          this.options.collation = model.schema.options.collation;
        }
      }
      return this;
    };
    Aggregate.prototype.append = function() {
      const args = arguments.length === 1 && util.isArray(arguments[0]) ? arguments[0] : utils2.args(arguments);
      if (!args.every(isOperator)) {
        throw new Error("Arguments must be aggregate pipeline operators");
      }
      this._pipeline = this._pipeline.concat(args);
      return this;
    };
    Aggregate.prototype.addFields = function(arg) {
      const fields = {};
      if (typeof arg === "object" && !util.isArray(arg)) {
        Object.keys(arg).forEach(function(field) {
          fields[field] = arg[field];
        });
      } else {
        throw new Error("Invalid addFields() argument. Must be an object");
      }
      return this.append({ $addFields: fields });
    };
    Aggregate.prototype.project = function(arg) {
      const fields = {};
      if (typeof arg === "object" && !util.isArray(arg)) {
        Object.keys(arg).forEach(function(field) {
          fields[field] = arg[field];
        });
      } else if (arguments.length === 1 && typeof arg === "string") {
        arg.split(/\s+/).forEach(function(field) {
          if (!field) {
            return;
          }
          const include = field[0] === "-" ? 0 : 1;
          if (include === 0) {
            field = field.substring(1);
          }
          fields[field] = include;
        });
      } else {
        throw new Error("Invalid project() argument. Must be string or object");
      }
      return this.append({ $project: fields });
    };
    Aggregate.prototype.near = function(arg) {
      const op = {};
      op.$geoNear = arg;
      return this.append(op);
    };
    "group match skip limit out".split(" ").forEach(function($operator) {
      Aggregate.prototype[$operator] = function(arg) {
        const op = {};
        op["$" + $operator] = arg;
        return this.append(op);
      };
    });
    Aggregate.prototype.unwind = function() {
      const args = utils2.args(arguments);
      const res = [];
      for (const arg of args) {
        if (arg && typeof arg === "object") {
          res.push({ $unwind: arg });
        } else if (typeof arg === "string") {
          res.push({
            $unwind: arg && arg.startsWith("$") ? arg : "$" + arg
          });
        } else {
          throw new Error('Invalid arg "' + arg + '" to unwind(), must be string or object');
        }
      }
      return this.append.apply(this, res);
    };
    Aggregate.prototype.replaceRoot = function(newRoot) {
      let ret2;
      if (typeof newRoot === "string") {
        ret2 = newRoot.startsWith("$") ? newRoot : "$" + newRoot;
      } else {
        ret2 = newRoot;
      }
      return this.append({
        $replaceRoot: {
          newRoot: ret2
        }
      });
    };
    Aggregate.prototype.count = function(countName) {
      return this.append({ $count: countName });
    };
    Aggregate.prototype.sortByCount = function(arg) {
      if (arg && typeof arg === "object") {
        return this.append({ $sortByCount: arg });
      } else if (typeof arg === "string") {
        return this.append({
          $sortByCount: arg && arg.startsWith("$") ? arg : "$" + arg
        });
      } else {
        throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), must be string or object');
      }
    };
    Aggregate.prototype.lookup = function(options2) {
      return this.append({ $lookup: options2 });
    };
    Aggregate.prototype.graphLookup = function(options2) {
      const cloneOptions = {};
      if (options2) {
        if (!utils2.isObject(options2)) {
          throw new TypeError("Invalid graphLookup() argument. Must be an object.");
        }
        utils2.mergeClone(cloneOptions, options2);
        const startWith = cloneOptions.startWith;
        if (startWith && typeof startWith === "string") {
          cloneOptions.startWith = cloneOptions.startWith.startsWith("$") ? cloneOptions.startWith : "$" + cloneOptions.startWith;
        }
      }
      return this.append({ $graphLookup: cloneOptions });
    };
    Aggregate.prototype.sample = function(size) {
      return this.append({ $sample: { size } });
    };
    Aggregate.prototype.sort = function(arg) {
      const sort = {};
      if (arg.constructor.name === "Object") {
        const desc = ["desc", "descending", -1];
        Object.keys(arg).forEach(function(field) {
          if (arg[field] instanceof Object && arg[field].$meta) {
            sort[field] = arg[field];
            return;
          }
          sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
        });
      } else if (arguments.length === 1 && typeof arg === "string") {
        arg.split(/\s+/).forEach(function(field) {
          if (!field) {
            return;
          }
          const ascend = field[0] === "-" ? -1 : 1;
          if (ascend === -1) {
            field = field.substring(1);
          }
          sort[field] = ascend;
        });
      } else {
        throw new TypeError("Invalid sort() argument. Must be a string or object.");
      }
      return this.append({ $sort: sort });
    };
    Aggregate.prototype.read = function(pref, tags) {
      if (!this.options) {
        this.options = {};
      }
      read2.call(this, pref, tags);
      return this;
    };
    Aggregate.prototype.readConcern = function(level) {
      if (!this.options) {
        this.options = {};
      }
      readConcern.call(this, level);
      return this;
    };
    Aggregate.prototype.redact = function(expression, thenExpr, elseExpr) {
      if (arguments.length === 3) {
        if (typeof thenExpr === "string" && !thenExpr.startsWith("$$") || typeof elseExpr === "string" && !elseExpr.startsWith("$$")) {
          throw new Error("If thenExpr or elseExpr is string, it must start with $$. e.g. $$DESCEND, $$PRUNE, $$KEEP");
        }
        expression = {
          $cond: {
            if: expression,
            then: thenExpr,
            else: elseExpr
          }
        };
      } else if (arguments.length !== 1) {
        throw new TypeError("Invalid arguments");
      }
      return this.append({ $redact: expression });
    };
    Aggregate.prototype.explain = function(callback) {
      const model = this._model;
      return promiseOrCallback(callback, (cb) => {
        if (!this._pipeline.length) {
          const err = new Error("Aggregate has empty pipeline");
          return cb(err);
        }
        prepareDiscriminatorPipeline(this);
        model.hooks.execPre("aggregate", this, (error2) => {
          if (error2) {
            const _opts = { error: error2 };
            return model.hooks.execPost("aggregate", this, [null], _opts, (error3) => {
              cb(error3);
            });
          }
          this.options.explain = true;
          model.collection.aggregate(this._pipeline, this.options || {}).explain((error3, result) => {
            const _opts = { error: error3 };
            return model.hooks.execPost("aggregate", this, [result], _opts, (error4) => {
              if (error4) {
                return cb(error4);
              }
              return cb(null, result);
            });
          });
        });
      }, model.events);
    };
    Aggregate.prototype.allowDiskUse = function(value) {
      this.options.allowDiskUse = value;
      return this;
    };
    Aggregate.prototype.hint = function(value) {
      this.options.hint = value;
      return this;
    };
    Aggregate.prototype.session = function(session) {
      if (session == null) {
        delete this.options.session;
      } else {
        this.options.session = session;
      }
      return this;
    };
    Aggregate.prototype.option = function(value) {
      for (const key in value) {
        this.options[key] = value[key];
      }
      return this;
    };
    Aggregate.prototype.cursor = function(options2) {
      if (!this.options) {
        this.options = {};
      }
      this.options.cursor = options2 || {};
      return this;
    };
    Aggregate.prototype.addCursorFlag = util.deprecate(function(flag, value) {
      if (!this.options) {
        this.options = {};
      }
      this.options[flag] = value;
      return this;
    }, "Mongoose: `Aggregate#addCursorFlag()` is deprecated, use `option()` instead");
    Aggregate.prototype.collation = function(collation) {
      if (!this.options) {
        this.options = {};
      }
      this.options.collation = collation;
      return this;
    };
    Aggregate.prototype.facet = function(options2) {
      return this.append({ $facet: options2 });
    };
    Aggregate.prototype.search = function(options2) {
      return this.append({ $search: options2 });
    };
    Aggregate.prototype.pipeline = function() {
      return this._pipeline;
    };
    Aggregate.prototype.exec = function(callback) {
      if (!this._model) {
        throw new Error("Aggregate not bound to any Model");
      }
      const model = this._model;
      const collection = this._model.collection;
      applyGlobalMaxTimeMS(this.options, model);
      if (this.options && this.options.cursor) {
        return new AggregationCursor(this);
      }
      return promiseOrCallback(callback, (cb) => {
        prepareDiscriminatorPipeline(this);
        stringifyFunctionOperators(this._pipeline);
        model.hooks.execPre("aggregate", this, (error2) => {
          if (error2) {
            const _opts = { error: error2 };
            return model.hooks.execPost("aggregate", this, [null], _opts, (error3) => {
              cb(error3);
            });
          }
          if (!this._pipeline.length) {
            return cb(new Error("Aggregate has empty pipeline"));
          }
          const options2 = utils2.clone(this.options || {});
          collection.aggregate(this._pipeline, options2, (error3, cursor) => {
            if (error3) {
              const _opts = { error: error3 };
              return model.hooks.execPost("aggregate", this, [null], _opts, (error4) => {
                if (error4) {
                  return cb(error4);
                }
                return cb(null);
              });
            }
            cursor.toArray((error4, result) => {
              const _opts = { error: error4 };
              model.hooks.execPost("aggregate", this, [result], _opts, (error5, result2) => {
                if (error5) {
                  return cb(error5);
                }
                cb(null, result2);
              });
            });
          });
        });
      }, model.events);
    };
    Aggregate.prototype.then = function(resolve2, reject) {
      return this.exec().then(resolve2, reject);
    };
    Aggregate.prototype.catch = function(reject) {
      return this.exec().then(null, reject);
    };
    if (Symbol.asyncIterator != null) {
      Aggregate.prototype[Symbol.asyncIterator] = function() {
        return this.cursor({ useMongooseAggCursor: true }).exec().transformNull()._transformForAsyncIterator();
      };
    }
    function isOperator(obj) {
      if (typeof obj !== "object") {
        return false;
      }
      const k = Object.keys(obj);
      return k.length === 1 && k.some((key) => {
        return key[0] === "$";
      });
    }
    Aggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;
    function prepareDiscriminatorPipeline(aggregate) {
      const schema = aggregate._model.schema;
      const discriminatorMapping = schema && schema.discriminatorMapping;
      if (discriminatorMapping && !discriminatorMapping.isRoot) {
        const originalPipeline = aggregate._pipeline;
        const discriminatorKey = discriminatorMapping.key;
        const discriminatorValue = discriminatorMapping.value;
        if (originalPipeline[0] && originalPipeline[0].$match && !originalPipeline[0].$match[discriminatorKey]) {
          originalPipeline[0].$match[discriminatorKey] = discriminatorValue;
        } else if (originalPipeline[0] && originalPipeline[0].$geoNear) {
          originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};
          originalPipeline[0].$geoNear.query[discriminatorKey] = discriminatorValue;
        } else if (originalPipeline[0] && originalPipeline[0].$search) {
          if (originalPipeline[1] && originalPipeline[1].$match != null) {
            originalPipeline[1].$match[discriminatorKey] = originalPipeline[1].$match[discriminatorKey] || discriminatorValue;
          } else {
            const match = {};
            match[discriminatorKey] = discriminatorValue;
            originalPipeline.splice(1, 0, { $match: match });
          }
        } else {
          const match = {};
          match[discriminatorKey] = discriminatorValue;
          aggregate._pipeline.unshift({ $match: match });
        }
      }
    }
    module2.exports = Aggregate;
  }
});

// node_modules/mongoose/lib/options/removeOptions.js
var require_removeOptions = __commonJS({
  "node_modules/mongoose/lib/options/removeOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var clone2 = require_clone();
    var RemoveOptions = class {
      constructor(obj) {
        if (obj == null) {
          return;
        }
        Object.assign(this, clone2(obj));
      }
    };
    module2.exports = RemoveOptions;
  }
});

// node_modules/mongoose/lib/options/saveOptions.js
var require_saveOptions = __commonJS({
  "node_modules/mongoose/lib/options/saveOptions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var clone2 = require_clone();
    var SaveOptions = class {
      constructor(obj) {
        if (obj == null) {
          return;
        }
        Object.assign(this, clone2(obj));
      }
    };
    module2.exports = SaveOptions;
  }
});

// node_modules/mongoose/lib/helpers/model/applyMethods.js
var require_applyMethods = __commonJS({
  "node_modules/mongoose/lib/helpers/model/applyMethods.js"(exports2, module2) {
    init_shims();
    "use strict";
    var get2 = require_get();
    module2.exports = function applyMethods(model, schema) {
      function apply(method, schema2) {
        Object.defineProperty(model.prototype, method, {
          get: function() {
            const h = {};
            for (const k in schema2.methods[method]) {
              h[k] = schema2.methods[method][k].bind(this);
            }
            return h;
          },
          configurable: true
        });
      }
      for (const method of Object.keys(schema.methods)) {
        const fn = schema.methods[method];
        if (schema.tree.hasOwnProperty(method)) {
          throw new Error('You have a method and a property in your schema both named "' + method + '"');
        }
        if (schema.reserved[method] && !get2(schema, `methodOptions.${method}.suppressWarning`, false)) {
          console.warn(`mongoose: the method name "${method}" is used by mongoose internally, overwriting it may cause bugs. If you're sure you know what you're doing, you can suppress this error by using \`schema.method('${method}', fn, { suppressWarning: true })\`.`);
        }
        if (typeof fn === "function") {
          model.prototype[method] = fn;
        } else {
          apply(method, schema);
        }
      }
      model.$appliedMethods = true;
      for (const key of Object.keys(schema.paths)) {
        const type = schema.paths[key];
        if (type.$isSingleNested && !type.caster.$appliedMethods) {
          applyMethods(type.caster, type.schema);
        }
        if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {
          applyMethods(type.Constructor, type.schema);
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/model/applyStaticHooks.js
var require_applyStaticHooks = __commonJS({
  "node_modules/mongoose/lib/helpers/model/applyStaticHooks.js"(exports2, module2) {
    init_shims();
    "use strict";
    var middlewareFunctions = require_applyQueryMiddleware().middlewareFunctions;
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = function applyStaticHooks(model, hooks, statics) {
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1
      };
      hooks = hooks.filter((hook) => {
        if (middlewareFunctions.indexOf(hook.name) !== -1) {
          return !!hook.model;
        }
        return hook.model !== false;
      });
      model.$__insertMany = hooks.createWrapper("insertMany", model.$__insertMany, model, kareemOptions);
      for (const key of Object.keys(statics)) {
        if (hooks.hasHooks(key)) {
          const original = model[key];
          model[key] = function() {
            const numArgs = arguments.length;
            const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;
            const cb = typeof lastArg === "function" ? lastArg : null;
            const args = Array.prototype.slice.call(arguments, 0, cb == null ? numArgs : numArgs - 1);
            return promiseOrCallback(cb, (callback) => {
              hooks.execPre(key, model, args, function(err) {
                if (err != null) {
                  return callback(err);
                }
                let postCalled = 0;
                const ret2 = original.apply(model, args.concat(post));
                if (ret2 != null && typeof ret2.then === "function") {
                  ret2.then((res) => post(null, res), (err2) => post(err2));
                }
                function post(error2, res) {
                  if (postCalled++ > 0) {
                    return;
                  }
                  if (error2 != null) {
                    return callback(error2);
                  }
                  hooks.execPost(key, model, [res], function(error3) {
                    if (error3 != null) {
                      return callback(error3);
                    }
                    callback(null, res);
                  });
                }
              });
            }, model.events);
          };
        }
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/model/applyStatics.js
var require_applyStatics = __commonJS({
  "node_modules/mongoose/lib/helpers/model/applyStatics.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function applyStatics(model, schema) {
      for (const i in schema.statics) {
        model[i] = schema.statics[i];
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js
var require_SkipPopulateValue = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function SkipPopulateValue(val) {
      if (!(this instanceof SkipPopulateValue)) {
        return new SkipPopulateValue(val);
      }
      this.val = val;
      return this;
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js
var require_leanPopulateMap = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = new WeakMap();
  }
});

// node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js
var require_assignRawDocsToIdStructure = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js"(exports2, module2) {
    init_shims();
    "use strict";
    var leanPopulateMap = require_leanPopulateMap();
    var modelSymbol = require_symbols().modelSymbol;
    var utils2 = require_utils6();
    module2.exports = assignRawDocsToIdStructure;
    function assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options2, recursed) {
      const newOrder = [];
      const sorting = options2.sort && rawIds.length > 1;
      const nullIfNotFound = options2.$nullIfNotFound;
      let doc;
      let sid;
      let id;
      for (let i = 0; i < rawIds.length; ++i) {
        id = rawIds[i];
        if (Array.isArray(id)) {
          assignRawDocsToIdStructure(id, resultDocs, resultOrder, options2, true);
          newOrder.push(id);
          continue;
        }
        if (id === null && !sorting) {
          newOrder.push(id);
          continue;
        }
        sid = String(id);
        doc = resultDocs[sid];
        if (options2.clone && doc != null) {
          if (options2.lean) {
            const _model = leanPopulateMap.get(doc);
            doc = utils2.clone(doc);
            leanPopulateMap.set(doc, _model);
          } else {
            doc = doc.constructor.hydrate(doc._doc);
          }
        }
        if (recursed) {
          if (doc) {
            if (sorting) {
              newOrder[resultOrder[sid]] = doc;
            } else {
              newOrder.push(doc);
            }
          } else if (id != null && id[modelSymbol] != null) {
            newOrder.push(id);
          } else {
            newOrder.push(options2.retainNullValues || nullIfNotFound ? null : id);
          }
        } else {
          newOrder[i] = doc || null;
        }
      }
      rawIds.length = 0;
      if (newOrder.length) {
        newOrder.forEach(function(doc2, i) {
          rawIds[i] = doc2;
        });
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/populate/getVirtual.js
var require_getVirtual = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/getVirtual.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = getVirtual;
    function getVirtual(schema, name) {
      if (schema.virtuals[name]) {
        return { virtual: schema.virtuals[name], path: void 0 };
      }
      const parts = name.split(".");
      let cur = "";
      let nestedSchemaPath = "";
      for (let i = 0; i < parts.length; ++i) {
        cur += (cur.length > 0 ? "." : "") + parts[i];
        if (schema.virtuals[cur]) {
          if (i === parts.length - 1) {
            return { virtual: schema.virtuals[cur], path: nestedSchemaPath };
          }
          continue;
        }
        if (schema.nested[cur]) {
          continue;
        }
        if (schema.paths[cur] && schema.paths[cur].schema) {
          schema = schema.paths[cur].schema;
          const rest = parts.slice(i + 1).join(".");
          if (schema.virtuals[rest]) {
            if (i === parts.length - 2) {
              return {
                virtual: schema.virtuals[rest],
                nestedSchemaPath: [nestedSchemaPath, cur].filter((v) => !!v).join(".")
              };
            }
            continue;
          }
          if (i + 1 < parts.length && schema.discriminators) {
            for (const key of Object.keys(schema.discriminators)) {
              const res = getVirtual(schema.discriminators[key], rest);
              if (res != null) {
                const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].filter((v) => !!v).join(".");
                return {
                  virtual: res.virtual,
                  nestedSchemaPath: _path
                };
              }
            }
          }
          nestedSchemaPath += (nestedSchemaPath.length > 0 ? "." : "") + cur;
          cur = "";
          continue;
        }
        if (schema.discriminators) {
          for (const discriminatorKey of Object.keys(schema.discriminators)) {
            const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);
            if (virtualFromDiscriminator)
              return virtualFromDiscriminator;
          }
        }
        return null;
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js
var require_lookupLocalFields = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function lookupLocalFields(cur, path, val) {
      if (cur == null) {
        return cur;
      }
      if (cur._doc != null) {
        cur = cur._doc;
      }
      if (arguments.length >= 3) {
        if (typeof cur !== "object") {
          return void 0;
        }
        cur[path] = val;
        return val;
      }
      if (path === "$*") {
        return cur instanceof Map ? Array.from(cur.values()) : Object.keys(cur).map((key) => cur[key]);
      }
      return cur[path];
    };
  }
});

// node_modules/sift/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/sift/lib/index.js"(exports2, module2) {
    init_shims();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.sift = {}));
    })(exports2, function(exports3) {
      "use strict";
      var extendStatics = function(d2, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
          d3.__proto__ = b2;
        } || function(d3, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d3[p] = b2[p];
        };
        return extendStatics(d2, b);
      };
      function __extends(d2, b) {
        extendStatics(d2, b);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var typeChecker = function(type) {
        var typeString = "[object " + type + "]";
        return function(value) {
          return getClassName(value) === typeString;
        };
      };
      var getClassName = function(value) {
        return Object.prototype.toString.call(value);
      };
      var comparable = function(value) {
        if (value instanceof Date) {
          return value.getTime();
        } else if (isArray(value)) {
          return value.map(comparable);
        } else if (value && typeof value.toJSON === "function") {
          return value.toJSON();
        }
        return value;
      };
      var isArray = typeChecker("Array");
      var isObject2 = typeChecker("Object");
      var isFunction = typeChecker("Function");
      var isVanillaObject = function(value) {
        return value && (value.constructor === Object || value.constructor === Array || value.constructor.toString() === "function Object() { [native code] }" || value.constructor.toString() === "function Array() { [native code] }") && !value.toJSON;
      };
      var equals = function(a, b) {
        if (a == null && a == b) {
          return true;
        }
        if (a === b) {
          return true;
        }
        if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {
          return false;
        }
        if (isArray(a)) {
          if (a.length !== b.length) {
            return false;
          }
          for (var i = 0, length_1 = a.length; i < length_1; i++) {
            if (!equals(a[i], b[i]))
              return false;
          }
          return true;
        } else if (isObject2(a)) {
          if (Object.keys(a).length !== Object.keys(b).length) {
            return false;
          }
          for (var key in a) {
            if (!equals(a[key], b[key]))
              return false;
          }
          return true;
        }
        return false;
      };
      var walkKeyPathValues = function(item, keyPath, next, depth, key, owner) {
        var currentKey = keyPath[depth];
        if (isArray(item) && isNaN(Number(currentKey))) {
          for (var i = 0, length_1 = item.length; i < length_1; i++) {
            if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {
              return false;
            }
          }
        }
        if (depth === keyPath.length || item == null) {
          return next(item, key, owner);
        }
        return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);
      };
      var BaseOperation = function() {
        function BaseOperation2(params, owneryQuery, options2) {
          this.params = params;
          this.owneryQuery = owneryQuery;
          this.options = options2;
          this.init();
        }
        BaseOperation2.prototype.init = function() {
        };
        BaseOperation2.prototype.reset = function() {
          this.done = false;
          this.keep = false;
        };
        return BaseOperation2;
      }();
      var NamedBaseOperation = function(_super) {
        __extends(NamedBaseOperation2, _super);
        function NamedBaseOperation2(params, owneryQuery, options2, name) {
          var _this = _super.call(this, params, owneryQuery, options2) || this;
          _this.name = name;
          return _this;
        }
        return NamedBaseOperation2;
      }(BaseOperation);
      var GroupOperation = function(_super) {
        __extends(GroupOperation2, _super);
        function GroupOperation2(params, owneryQuery, options2, children) {
          var _this = _super.call(this, params, owneryQuery, options2) || this;
          _this.children = children;
          return _this;
        }
        GroupOperation2.prototype.reset = function() {
          this.keep = false;
          this.done = false;
          for (var i = 0, length_2 = this.children.length; i < length_2; i++) {
            this.children[i].reset();
          }
        };
        GroupOperation2.prototype.childrenNext = function(item, key, owner) {
          var done = true;
          var keep = true;
          for (var i = 0, length_3 = this.children.length; i < length_3; i++) {
            var childOperation = this.children[i];
            childOperation.next(item, key, owner);
            if (!childOperation.keep) {
              keep = false;
            }
            if (childOperation.done) {
              if (!childOperation.keep) {
                break;
              }
            } else {
              done = false;
            }
          }
          this.done = done;
          this.keep = keep;
        };
        return GroupOperation2;
      }(BaseOperation);
      var NamedGroupOperation = function(_super) {
        __extends(NamedGroupOperation2, _super);
        function NamedGroupOperation2(params, owneryQuery, options2, children, name) {
          var _this = _super.call(this, params, owneryQuery, options2, children) || this;
          _this.name = name;
          return _this;
        }
        return NamedGroupOperation2;
      }(GroupOperation);
      var QueryOperation = function(_super) {
        __extends(QueryOperation2, _super);
        function QueryOperation2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        QueryOperation2.prototype.next = function(item, key, parent) {
          this.childrenNext(item, key, parent);
        };
        return QueryOperation2;
      }(GroupOperation);
      var NestedOperation = function(_super) {
        __extends(NestedOperation2, _super);
        function NestedOperation2(keyPath, params, owneryQuery, options2, children) {
          var _this = _super.call(this, params, owneryQuery, options2, children) || this;
          _this.keyPath = keyPath;
          _this._nextNestedValue = function(value, key, owner) {
            _this.childrenNext(value, key, owner);
            return !_this.done;
          };
          return _this;
        }
        NestedOperation2.prototype.next = function(item, key, parent) {
          walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);
        };
        return NestedOperation2;
      }(GroupOperation);
      var createTester = function(a, compare) {
        if (a instanceof Function) {
          return a;
        }
        if (a instanceof RegExp) {
          return function(b) {
            var result = typeof b === "string" && a.test(b);
            a.lastIndex = 0;
            return result;
          };
        }
        var comparableA = comparable(a);
        return function(b) {
          return compare(comparableA, comparable(b));
        };
      };
      var EqualsOperation = function(_super) {
        __extends(EqualsOperation2, _super);
        function EqualsOperation2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        EqualsOperation2.prototype.init = function() {
          this._test = createTester(this.params, this.options.compare);
        };
        EqualsOperation2.prototype.next = function(item, key, parent) {
          if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {
            if (this._test(item, key, parent)) {
              this.done = true;
              this.keep = true;
            }
          }
        };
        return EqualsOperation2;
      }(BaseOperation);
      var createEqualsOperation = function(params, owneryQuery, options2) {
        return new EqualsOperation(params, owneryQuery, options2);
      };
      var NopeOperation = function(_super) {
        __extends(NopeOperation2, _super);
        function NopeOperation2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NopeOperation2.prototype.next = function() {
          this.done = true;
          this.keep = false;
        };
        return NopeOperation2;
      }(BaseOperation);
      var numericalOperationCreator = function(createNumericalOperation) {
        return function(params, owneryQuery, options2, name) {
          if (params == null) {
            return new NopeOperation(params, owneryQuery, options2);
          }
          return createNumericalOperation(params, owneryQuery, options2, name);
        };
      };
      var numericalOperation = function(createTester2) {
        return numericalOperationCreator(function(params, owneryQuery, options2) {
          var typeofParams = typeof comparable(params);
          var test = createTester2(params);
          return new EqualsOperation(function(b) {
            return typeof comparable(b) === typeofParams && test(b);
          }, owneryQuery, options2);
        });
      };
      var createNamedOperation = function(name, params, parentQuery, options2) {
        var operationCreator = options2.operations[name];
        if (!operationCreator) {
          throw new Error("Unsupported operation: " + name);
        }
        return operationCreator(params, parentQuery, options2, name);
      };
      var containsOperation = function(query) {
        for (var key in query) {
          if (key.charAt(0) === "$")
            return true;
        }
        return false;
      };
      var createNestedOperation = function(keyPath, nestedQuery, owneryQuery, options2) {
        if (containsOperation(nestedQuery)) {
          var _a = createQueryOperations(nestedQuery, options2), selfOperations = _a[0], nestedOperations = _a[1];
          if (nestedOperations.length) {
            throw new Error("Property queries must contain only operations, or exact objects.");
          }
          return new NestedOperation(keyPath, nestedQuery, owneryQuery, options2, selfOperations);
        }
        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options2, [
          new EqualsOperation(nestedQuery, owneryQuery, options2)
        ]);
      };
      var createQueryOperation = function(query, owneryQuery, _a) {
        if (owneryQuery === void 0) {
          owneryQuery = null;
        }
        var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;
        var options2 = {
          compare: compare || equals,
          operations: Object.assign({}, operations || {})
        };
        var _c = createQueryOperations(query, options2), selfOperations = _c[0], nestedOperations = _c[1];
        var ops = [];
        if (selfOperations.length) {
          ops.push(new NestedOperation([], query, owneryQuery, options2, selfOperations));
        }
        ops.push.apply(ops, nestedOperations);
        if (ops.length === 1) {
          return ops[0];
        }
        return new QueryOperation(query, owneryQuery, options2, ops);
      };
      var createQueryOperations = function(query, options2) {
        var selfOperations = [];
        var nestedOperations = [];
        if (!isVanillaObject(query)) {
          selfOperations.push(new EqualsOperation(query, query, options2));
          return [selfOperations, nestedOperations];
        }
        for (var key in query) {
          if (key.charAt(0) === "$") {
            var op = createNamedOperation(key, query[key], query, options2);
            if (op != null) {
              selfOperations.push(op);
            }
          } else {
            nestedOperations.push(createNestedOperation(key.split("."), query[key], query, options2));
          }
        }
        return [selfOperations, nestedOperations];
      };
      var createOperationTester = function(operation) {
        return function(item, key, owner) {
          operation.reset();
          operation.next(item, key, owner);
          return operation.keep;
        };
      };
      var createQueryTester = function(query, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        return createOperationTester(createQueryOperation(query, null, options2));
      };
      var $Ne = function(_super) {
        __extends($Ne2, _super);
        function $Ne2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Ne2.prototype.init = function() {
          this._test = createTester(this.params, this.options.compare);
        };
        $Ne2.prototype.reset = function() {
          _super.prototype.reset.call(this);
          this.keep = true;
        };
        $Ne2.prototype.next = function(item) {
          if (this._test(item)) {
            this.done = true;
            this.keep = false;
          }
        };
        return $Ne2;
      }(NamedBaseOperation);
      var $ElemMatch = function(_super) {
        __extends($ElemMatch2, _super);
        function $ElemMatch2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $ElemMatch2.prototype.init = function() {
          this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
        };
        $ElemMatch2.prototype.reset = function() {
          _super.prototype.reset.call(this);
          this._queryOperation.reset();
        };
        $ElemMatch2.prototype.next = function(item) {
          if (isArray(item)) {
            for (var i = 0, length_1 = item.length; i < length_1; i++) {
              this._queryOperation.reset();
              this._queryOperation.next(item[i], i, item);
              this.keep = this.keep || this._queryOperation.keep;
            }
            this.done = true;
          } else {
            this.done = false;
            this.keep = false;
          }
        };
        return $ElemMatch2;
      }(NamedBaseOperation);
      var $Not = function(_super) {
        __extends($Not2, _super);
        function $Not2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Not2.prototype.init = function() {
          this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
        };
        $Not2.prototype.reset = function() {
          this._queryOperation.reset();
        };
        $Not2.prototype.next = function(item, key, owner) {
          this._queryOperation.next(item, key, owner);
          this.done = this._queryOperation.done;
          this.keep = !this._queryOperation.keep;
        };
        return $Not2;
      }(NamedBaseOperation);
      var $Size = function(_super) {
        __extends($Size2, _super);
        function $Size2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Size2.prototype.init = function() {
        };
        $Size2.prototype.next = function(item) {
          if (isArray(item) && item.length === this.params) {
            this.done = true;
            this.keep = true;
          }
        };
        return $Size2;
      }(NamedBaseOperation);
      var $Or = function(_super) {
        __extends($Or2, _super);
        function $Or2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Or2.prototype.init = function() {
          var _this = this;
          this._ops = this.params.map(function(op) {
            return createQueryOperation(op, null, _this.options);
          });
        };
        $Or2.prototype.reset = function() {
          this.done = false;
          this.keep = false;
          for (var i = 0, length_2 = this._ops.length; i < length_2; i++) {
            this._ops[i].reset();
          }
        };
        $Or2.prototype.next = function(item, key, owner) {
          var done = false;
          var success = false;
          for (var i = 0, length_3 = this._ops.length; i < length_3; i++) {
            var op = this._ops[i];
            op.next(item, key, owner);
            if (op.keep) {
              done = true;
              success = op.keep;
              break;
            }
          }
          this.keep = success;
          this.done = done;
        };
        return $Or2;
      }(NamedBaseOperation);
      var $Nor = function(_super) {
        __extends($Nor2, _super);
        function $Nor2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Nor2.prototype.next = function(item, key, owner) {
          _super.prototype.next.call(this, item, key, owner);
          this.keep = !this.keep;
        };
        return $Nor2;
      }($Or);
      var $In = function(_super) {
        __extends($In2, _super);
        function $In2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $In2.prototype.init = function() {
          var _this = this;
          this._testers = this.params.map(function(value) {
            if (containsOperation(value)) {
              throw new Error("cannot nest $ under " + _this.constructor.name.toLowerCase());
            }
            return createTester(value, _this.options.compare);
          });
        };
        $In2.prototype.next = function(item, key, owner) {
          var done = false;
          var success = false;
          for (var i = 0, length_4 = this._testers.length; i < length_4; i++) {
            var test = this._testers[i];
            if (test(item)) {
              done = true;
              success = true;
              break;
            }
          }
          this.keep = success;
          this.done = done;
        };
        return $In2;
      }(NamedBaseOperation);
      var $Nin = function(_super) {
        __extends($Nin2, _super);
        function $Nin2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Nin2.prototype.next = function(item, key, owner) {
          _super.prototype.next.call(this, item, key, owner);
          this.keep = !this.keep;
        };
        return $Nin2;
      }($In);
      var $Exists = function(_super) {
        __extends($Exists2, _super);
        function $Exists2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        $Exists2.prototype.next = function(item, key, owner) {
          if (owner.hasOwnProperty(key) === this.params) {
            this.done = true;
            this.keep = true;
          }
        };
        return $Exists2;
      }(NamedBaseOperation);
      var $And = function(_super) {
        __extends($And2, _super);
        function $And2(params, owneryQuery, options2, name) {
          return _super.call(this, params, owneryQuery, options2, params.map(function(query) {
            return createQueryOperation(query, owneryQuery, options2);
          }), name) || this;
        }
        $And2.prototype.next = function(item, key, owner) {
          this.childrenNext(item, key, owner);
        };
        return $And2;
      }(NamedGroupOperation);
      var $eq = function(params, owneryQuery, options2) {
        return new EqualsOperation(params, owneryQuery, options2);
      };
      var $ne = function(params, owneryQuery, options2, name) {
        return new $Ne(params, owneryQuery, options2, name);
      };
      var $or = function(params, owneryQuery, options2, name) {
        return new $Or(params, owneryQuery, options2, name);
      };
      var $nor = function(params, owneryQuery, options2, name) {
        return new $Nor(params, owneryQuery, options2, name);
      };
      var $elemMatch = function(params, owneryQuery, options2, name) {
        return new $ElemMatch(params, owneryQuery, options2, name);
      };
      var $nin = function(params, owneryQuery, options2, name) {
        return new $Nin(params, owneryQuery, options2, name);
      };
      var $in = function(params, owneryQuery, options2, name) {
        return new $In(params, owneryQuery, options2, name);
      };
      var $lt = numericalOperation(function(params) {
        return function(b) {
          return b < params;
        };
      });
      var $lte = numericalOperation(function(params) {
        return function(b) {
          return b <= params;
        };
      });
      var $gt = numericalOperation(function(params) {
        return function(b) {
          return b > params;
        };
      });
      var $gte = numericalOperation(function(params) {
        return function(b) {
          return b >= params;
        };
      });
      var $mod = function(_a, owneryQuery, options2) {
        var mod = _a[0], equalsValue = _a[1];
        return new EqualsOperation(function(b) {
          return comparable(b) % mod === equalsValue;
        }, owneryQuery, options2);
      };
      var $exists = function(params, owneryQuery, options2, name) {
        return new $Exists(params, owneryQuery, options2, name);
      };
      var $regex = function(pattern, owneryQuery, options2) {
        return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options2);
      };
      var $not = function(params, owneryQuery, options2, name) {
        return new $Not(params, owneryQuery, options2, name);
      };
      var typeAliases = {
        number: function(v) {
          return typeof v === "number";
        },
        string: function(v) {
          return typeof v === "string";
        },
        bool: function(v) {
          return typeof v === "boolean";
        },
        array: function(v) {
          return Array.isArray(v);
        },
        null: function(v) {
          return v === null;
        },
        timestamp: function(v) {
          return v instanceof Date;
        }
      };
      var $type = function(clazz, owneryQuery, options2) {
        return new EqualsOperation(function(b) {
          if (typeof clazz === "string") {
            if (!typeAliases[clazz]) {
              throw new Error("Type alias does not exist");
            }
            return typeAliases[clazz](b);
          }
          return b != null ? b instanceof clazz || b.constructor === clazz : false;
        }, owneryQuery, options2);
      };
      var $and = function(params, ownerQuery, options2, name) {
        return new $And(params, ownerQuery, options2, name);
      };
      var $all = $and;
      var $size = function(params, ownerQuery, options2) {
        return new $Size(params, ownerQuery, options2, "$size");
      };
      var $options = function() {
        return null;
      };
      var $where = function(params, ownerQuery, options2) {
        var test;
        if (isFunction(params)) {
          test = params;
        } else if (!process.env.CSP_ENABLED) {
          test = new Function("obj", "return " + params);
        } else {
          throw new Error('In CSP mode, sift does not support strings in "$where" condition');
        }
        return new EqualsOperation(function(b) {
          return test.bind(b)(b);
        }, ownerQuery, options2);
      };
      var defaultOperations = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        $Size,
        $eq,
        $ne,
        $or,
        $nor,
        $elemMatch,
        $nin,
        $in,
        $lt,
        $lte,
        $gt,
        $gte,
        $mod,
        $exists,
        $regex,
        $not,
        $type,
        $and,
        $all,
        $size,
        $options,
        $where
      });
      var createDefaultQueryOperation = function(query, ownerQuery, _a) {
        var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;
        return createQueryOperation(query, ownerQuery, {
          compare,
          operations: Object.assign({}, defaultOperations, operations || {})
        });
      };
      var createDefaultQueryTester = function(query, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        var op = createDefaultQueryOperation(query, null, options2);
        return createOperationTester(op);
      };
      exports3.$Size = $Size;
      exports3.$all = $all;
      exports3.$and = $and;
      exports3.$elemMatch = $elemMatch;
      exports3.$eq = $eq;
      exports3.$exists = $exists;
      exports3.$gt = $gt;
      exports3.$gte = $gte;
      exports3.$in = $in;
      exports3.$lt = $lt;
      exports3.$lte = $lte;
      exports3.$mod = $mod;
      exports3.$ne = $ne;
      exports3.$nin = $nin;
      exports3.$nor = $nor;
      exports3.$not = $not;
      exports3.$options = $options;
      exports3.$or = $or;
      exports3.$regex = $regex;
      exports3.$size = $size;
      exports3.$type = $type;
      exports3.$where = $where;
      exports3.EqualsOperation = EqualsOperation;
      exports3.createDefaultQueryOperation = createDefaultQueryOperation;
      exports3.createEqualsOperation = createEqualsOperation;
      exports3.createOperationTester = createOperationTester;
      exports3.createQueryOperation = createQueryOperation;
      exports3.createQueryTester = createQueryTester;
      exports3.default = createDefaultQueryTester;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/sift/index.js
var require_sift = __commonJS({
  "node_modules/sift/index.js"(exports2, module2) {
    init_shims();
    var lib = require_lib2();
    module2.exports = lib.default;
    Object.assign(module2.exports, lib);
  }
});

// node_modules/mongoose/lib/helpers/populate/assignVals.js
var require_assignVals = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/assignVals.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SkipPopulateValue = require_SkipPopulateValue();
    var assignRawDocsToIdStructure = require_assignRawDocsToIdStructure();
    var get2 = require_get();
    var getVirtual = require_getVirtual();
    var leanPopulateMap = require_leanPopulateMap();
    var lookupLocalFields = require_lookupLocalFields();
    var mpath = require_mpath();
    var sift = require_sift().default;
    var utils2 = require_utils6();
    module2.exports = function assignVals(o) {
      const userOptions = Object.assign({}, get2(o, "allOptions.options.options"), get2(o, "allOptions.options"));
      const populateOptions = Object.assign({}, o.options, userOptions, {
        justOne: o.justOne
      });
      populateOptions.$nullIfNotFound = o.isVirtual;
      const populatedModel = o.populatedModel;
      const originalIds = [].concat(o.rawIds);
      o.allIds = [].concat(o.allIds);
      assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);
      const docs = o.docs;
      const rawIds = o.rawIds;
      const options2 = o.options;
      const count = o.count && o.isVirtual;
      let i;
      function setValue(val) {
        if (count) {
          return val;
        }
        if (val instanceof SkipPopulateValue) {
          return val.val;
        }
        const _allIds = o.allIds[i];
        if (o.justOne === true && Array.isArray(val)) {
          const ret2 = [];
          for (const doc of val) {
            const _docPopulatedModel = leanPopulateMap.get(doc);
            if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {
              ret2.push(doc);
            }
          }
          while (val.length > ret2.length) {
            Array.prototype.pop.apply(val, []);
          }
          for (let i2 = 0; i2 < ret2.length; ++i2) {
            val[i2] = ret2[i2];
          }
          return valueFilter(val[0], options2, populateOptions, _allIds);
        } else if (o.justOne === false && !Array.isArray(val)) {
          return valueFilter([val], options2, populateOptions, _allIds);
        }
        return valueFilter(val, options2, populateOptions, _allIds);
      }
      for (i = 0; i < docs.length; ++i) {
        const _path = o.path.endsWith(".$*") ? o.path.slice(0, -3) : o.path;
        const existingVal = mpath.get(_path, docs[i], lookupLocalFields);
        if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {
          continue;
        }
        let valueToSet;
        if (count) {
          valueToSet = numDocs(rawIds[i]);
        } else if (Array.isArray(o.match)) {
          valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter(sift(o.match[i])) : [rawIds[i]].filter(sift(o.match[i]))[0];
        } else {
          valueToSet = rawIds[i];
        }
        const originalSchema = o.originalModel.schema;
        const isDoc = get2(docs[i], "$__", null) != null;
        let isMap = isDoc ? existingVal instanceof Map : utils2.isPOJO(existingVal);
        isMap = isMap && get2(originalSchema._getSchema(_path), "$isSchemaMap");
        if (!o.isVirtual && isMap) {
          const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);
          valueToSet = valueToSet.reduce((cur2, v, i2) => {
            cur2.set(_keys[i2], v);
            return cur2;
          }, new Map());
        }
        if (isDoc && Array.isArray(valueToSet)) {
          for (const val of valueToSet) {
            if (val != null && val.$__ != null) {
              val.$__.parent = docs[i];
            }
          }
        } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {
          valueToSet.$__.parent = docs[i];
        }
        if (o.isVirtual && isDoc) {
          docs[i].populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);
          mpath.set(_path, valueToSet, docs[i], setValue);
          continue;
        }
        const parts = _path.split(".");
        let cur = docs[i];
        const curPath = parts[0];
        for (let j = 0; j < parts.length - 1; ++j) {
          if (Array.isArray(cur) && !utils2.isArrayIndex(parts[j])) {
            break;
          }
          if (parts[j] === "$*") {
            break;
          }
          if (cur[parts[j]] == null) {
            const schematype = originalSchema._getSchema(curPath);
            if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {
              break;
            }
            cur[parts[j]] = {};
          }
          cur = cur[parts[j]];
          if (typeof cur !== "object") {
            break;
          }
        }
        if (docs[i].$__) {
          docs[i].populated(_path, o.allIds[i], o.allOptions);
        }
        mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);
      }
    };
    function numDocs(v) {
      if (Array.isArray(v)) {
        if (v.some((el) => Array.isArray(el))) {
          return v.map((el) => numDocs(el));
        }
        return v.length;
      }
      return v == null ? 0 : 1;
    }
    function valueFilter(val, assignmentOpts, populateOptions, allIds) {
      const userSpecifiedTransform = typeof populateOptions.transform === "function";
      const transform = userSpecifiedTransform ? populateOptions.transform : noop3;
      if (Array.isArray(val)) {
        const ret2 = [];
        const numValues = val.length;
        for (let i = 0; i < numValues; ++i) {
          let subdoc = val[i];
          const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;
          if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {
            continue;
          } else if (userSpecifiedTransform) {
            subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);
          }
          maybeRemoveId(subdoc, assignmentOpts);
          ret2.push(subdoc);
          if (assignmentOpts.originalLimit && ret2.length >= assignmentOpts.originalLimit) {
            break;
          }
        }
        while (val.length > ret2.length) {
          Array.prototype.pop.apply(val, []);
        }
        for (let i = 0; i < ret2.length; ++i) {
          val[i] = ret2[i];
        }
        return val;
      }
      if (isPopulatedObject(val) || utils2.isPOJO(val)) {
        maybeRemoveId(val, assignmentOpts);
        return transform(val, allIds);
      }
      if (val instanceof Map) {
        return val;
      }
      if (populateOptions.justOne === false) {
        return [];
      }
      return val == null ? transform(val, allIds) : transform(null, allIds);
    }
    function maybeRemoveId(subdoc, assignmentOpts) {
      if (subdoc != null && assignmentOpts.excludeId) {
        if (typeof subdoc.$__setValue === "function") {
          delete subdoc._doc._id;
        } else {
          delete subdoc._id;
        }
      }
    }
    function isPopulatedObject(obj) {
      if (obj == null) {
        return false;
      }
      return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);
    }
    function noop3(v) {
      return v;
    }
  }
});

// node_modules/mongoose/lib/helpers/model/castBulkWrite.js
var require_castBulkWrite = __commonJS({
  "node_modules/mongoose/lib/helpers/model/castBulkWrite.js"(exports2, module2) {
    init_shims();
    "use strict";
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var applyTimestampsToChildren = require_applyTimestampsToChildren();
    var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
    var cast = require_cast2();
    var castUpdate = require_castUpdate();
    var setDefaultsOnInsert = require_setDefaultsOnInsert();
    module2.exports = function castBulkWrite(originalModel, op, options2) {
      const now = originalModel.base.now();
      if (op["insertOne"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["insertOne"]["document"]);
          const doc = new model(op["insertOne"]["document"]);
          if (model.schema.options.timestamps) {
            doc.initializeTimestamps();
          }
          if (options2.session != null) {
            doc.$session(options2.session);
          }
          op["insertOne"]["document"] = doc;
          op["insertOne"]["document"].validate({ __noPromise: true }, function(error2) {
            if (error2) {
              return callback(error2, null);
            }
            callback(null);
          });
        };
      } else if (op["updateOne"]) {
        return (callback) => {
          try {
            if (!op["updateOne"]["filter"]) {
              throw new Error("Must provide a filter object.");
            }
            if (!op["updateOne"]["update"]) {
              throw new Error("Must provide an update object.");
            }
            const model = decideModelByObject(originalModel, op["updateOne"]["filter"]);
            const schema = model.schema;
            const strict = options2.strict != null ? options2.strict : model.schema.options.strict;
            _addDiscriminatorToObject(schema, op["updateOne"]["filter"]);
            if (model.schema.$timestamps != null && op["updateOne"].timestamps !== false) {
              const createdAt = model.schema.$timestamps.createdAt;
              const updatedAt = model.schema.$timestamps.updatedAt;
              applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateOne"]["update"], {});
            }
            applyTimestampsToChildren(now, op["updateOne"]["update"], model.schema);
            if (op["updateOne"].setDefaultsOnInsert) {
              setDefaultsOnInsert(op["updateOne"]["filter"], model.schema, op["updateOne"]["update"], {
                setDefaultsOnInsert: true,
                upsert: op["updateOne"].upsert
              });
            }
            op["updateOne"]["filter"] = cast(model.schema, op["updateOne"]["filter"], {
              strict,
              upsert: op["updateOne"].upsert
            });
            op["updateOne"]["update"] = castUpdate(model.schema, op["updateOne"]["update"], {
              strict,
              overwrite: false,
              upsert: op["updateOne"].upsert
            }, model, op["updateOne"]["filter"]);
          } catch (error2) {
            return callback(error2, null);
          }
          callback(null);
        };
      } else if (op["updateMany"]) {
        return (callback) => {
          try {
            if (!op["updateMany"]["filter"]) {
              throw new Error("Must provide a filter object.");
            }
            if (!op["updateMany"]["update"]) {
              throw new Error("Must provide an update object.");
            }
            const model = decideModelByObject(originalModel, op["updateMany"]["filter"]);
            const schema = model.schema;
            const strict = options2.strict != null ? options2.strict : model.schema.options.strict;
            if (op["updateMany"].setDefaultsOnInsert) {
              setDefaultsOnInsert(op["updateMany"]["filter"], model.schema, op["updateMany"]["update"], {
                setDefaultsOnInsert: true,
                upsert: op["updateMany"].upsert
              });
            }
            if (model.schema.$timestamps != null && op["updateMany"].timestamps !== false) {
              const createdAt = model.schema.$timestamps.createdAt;
              const updatedAt = model.schema.$timestamps.updatedAt;
              applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateMany"]["update"], {});
            }
            applyTimestampsToChildren(now, op["updateMany"]["update"], model.schema);
            _addDiscriminatorToObject(schema, op["updateMany"]["filter"]);
            op["updateMany"]["filter"] = cast(model.schema, op["updateMany"]["filter"], {
              strict,
              upsert: op["updateMany"].upsert
            });
            op["updateMany"]["update"] = castUpdate(model.schema, op["updateMany"]["update"], {
              strict,
              overwrite: false,
              upsert: op["updateMany"].upsert
            }, model, op["updateMany"]["filter"]);
          } catch (error2) {
            return callback(error2, null);
          }
          callback(null);
        };
      } else if (op["replaceOne"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["replaceOne"]["filter"]);
          const schema = model.schema;
          const strict = options2.strict != null ? options2.strict : model.schema.options.strict;
          _addDiscriminatorToObject(schema, op["replaceOne"]["filter"]);
          try {
            op["replaceOne"]["filter"] = cast(model.schema, op["replaceOne"]["filter"], {
              strict,
              upsert: op["replaceOne"].upsert
            });
          } catch (error2) {
            return callback(error2, null);
          }
          const doc = new model(op["replaceOne"]["replacement"], strict, true);
          if (model.schema.options.timestamps) {
            doc.initializeTimestamps();
          }
          if (options2.session != null) {
            doc.$session(options2.session);
          }
          op["replaceOne"]["replacement"] = doc;
          op["replaceOne"]["replacement"].validate({ __noPromise: true }, function(error2) {
            if (error2) {
              return callback(error2, null);
            }
            op["replaceOne"]["replacement"] = op["replaceOne"]["replacement"].toBSON();
            callback(null);
          });
        };
      } else if (op["deleteOne"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["deleteOne"]["filter"]);
          const schema = model.schema;
          _addDiscriminatorToObject(schema, op["deleteOne"]["filter"]);
          try {
            op["deleteOne"]["filter"] = cast(model.schema, op["deleteOne"]["filter"]);
          } catch (error2) {
            return callback(error2, null);
          }
          callback(null);
        };
      } else if (op["deleteMany"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["deleteMany"]["filter"]);
          const schema = model.schema;
          _addDiscriminatorToObject(schema, op["deleteMany"]["filter"]);
          try {
            op["deleteMany"]["filter"] = cast(model.schema, op["deleteMany"]["filter"]);
          } catch (error2) {
            return callback(error2, null);
          }
          callback(null);
        };
      } else {
        return (callback) => {
          callback(new Error("Invalid op passed to `bulkWrite()`"), null);
        };
      }
    };
    function _addDiscriminatorToObject(schema, obj) {
      if (schema == null) {
        return;
      }
      if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
        obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
      }
    }
    function decideModelByObject(model, object) {
      const discriminatorKey = model.schema.options.discriminatorKey;
      if (object != null && object.hasOwnProperty(discriminatorKey)) {
        model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;
      }
      return model;
    }
  }
});

// node_modules/mongoose/lib/helpers/path/parentPaths.js
var require_parentPaths = __commonJS({
  "node_modules/mongoose/lib/helpers/path/parentPaths.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function parentPaths(path) {
      const pieces = path.split(".");
      let cur = "";
      const ret2 = [];
      for (let i = 0; i < pieces.length; ++i) {
        cur += (cur.length > 0 ? "." : "") + pieces[i];
        ret2.push(cur);
      }
      return ret2;
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js
var require_createPopulateQueryFilter = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js"(exports2, module2) {
    init_shims();
    "use strict";
    var SkipPopulateValue = require_SkipPopulateValue();
    var parentPaths = require_parentPaths();
    module2.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {
      const match = _formatMatch(_match);
      if (_foreignField.size === 1) {
        const foreignField = Array.from(_foreignField)[0];
        const foreignSchemaType = model.schema.path(foreignField);
        if (foreignField !== "_id" || !match["_id"]) {
          ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
          match[foreignField] = { $in: ids };
        }
        const _parentPaths = parentPaths(foreignField);
        for (let i = 0; i < _parentPaths.length - 1; ++i) {
          const cur = _parentPaths[i];
          if (match[cur] != null && match[cur].$elemMatch != null) {
            match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = { $in: ids };
            delete match[foreignField];
            break;
          }
        }
      } else {
        const $or = [];
        if (Array.isArray(match.$or)) {
          match.$and = [{ $or: match.$or }, { $or }];
          delete match.$or;
        } else {
          match.$or = $or;
        }
        for (const foreignField of _foreignField) {
          if (foreignField !== "_id" || !match["_id"]) {
            const foreignSchemaType = model.schema.path(foreignField);
            ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
            $or.push({ [foreignField]: { $in: ids } });
          }
        }
      }
      return match;
    };
    function _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {
      ids = ids.filter((v) => !(v instanceof SkipPopulateValue));
      if (!skipInvalidIds) {
        return ids;
      }
      return ids.filter((id) => {
        try {
          foreignSchemaType.cast(id);
          return true;
        } catch (err) {
          return false;
        }
      });
    }
    function _formatMatch(match) {
      if (Array.isArray(match)) {
        if (match.length > 1) {
          return { $or: [].concat(match.map((m) => Object.assign({}, m))) };
        }
        return Object.assign({}, match[0]);
      }
      return Object.assign({}, match);
    }
  }
});

// node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js
var require_getDefaultBulkwriteResult = __commonJS({
  "node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js"(exports2, module2) {
    init_shims();
    "use strict";
    function getDefaultBulkwriteResult() {
      return {
        result: {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        },
        insertedCount: 0,
        matchedCount: 0,
        modifiedCount: 0,
        deletedCount: 0,
        upsertedCount: 0,
        upsertedIds: {},
        insertedIds: {},
        n: 0
      };
    }
    module2.exports = getDefaultBulkwriteResult;
  }
});

// node_modules/mongoose/lib/helpers/each.js
var require_each2 = __commonJS({
  "node_modules/mongoose/lib/helpers/each.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function each2(arr, cb, done) {
      if (arr.length === 0) {
        return done();
      }
      let remaining = arr.length;
      let err = null;
      for (const v of arr) {
        cb(v, function(_err) {
          if (err != null) {
            return;
          }
          if (_err != null) {
            err = _err;
            return done(err);
          }
          if (--remaining <= 0) {
            return done();
          }
        });
      }
    };
  }
});

// node_modules/mongoose/lib/helpers/projection/isPathExcluded.js
var require_isPathExcluded = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/isPathExcluded.js"(exports2, module2) {
    init_shims();
    "use strict";
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isPathExcluded(projection, path) {
      if (path === "_id") {
        return projection._id === 0;
      }
      const paths = Object.keys(projection);
      let type = null;
      for (const _path of paths) {
        if (isDefiningProjection(projection[_path])) {
          type = projection[path] === 1 ? "inclusive" : "exclusive";
          break;
        }
      }
      if (type === "inclusive") {
        return projection[path] !== 1;
      }
      if (type === "exclusive") {
        return projection[path] === 0;
      }
      return false;
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js
var require_getSchemaTypes = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Mixed = require_mixed();
    var get2 = require_get();
    var leanPopulateMap = require_leanPopulateMap();
    var mpath = require_mpath();
    var populateModelSymbol = require_symbols().populateModelSymbol;
    module2.exports = function getSchemaTypes(schema, doc, path) {
      const pathschema = schema.path(path);
      const topLevelDoc = doc;
      if (pathschema) {
        return pathschema;
      }
      function search(parts2, schema2, subdoc, nestedPath) {
        let p = parts2.length + 1;
        let foundschema;
        let trypath;
        while (p--) {
          trypath = parts2.slice(0, p).join(".");
          foundschema = schema2.path(trypath);
          if (foundschema == null) {
            continue;
          }
          if (foundschema.caster) {
            if (foundschema.caster instanceof Mixed) {
              return foundschema.caster;
            }
            let schemas = null;
            if (foundschema.schema != null && foundschema.schema.discriminators != null) {
              const discriminators = foundschema.schema.discriminators;
              const discriminatorKeyPath = trypath + "." + foundschema.schema.options.discriminatorKey;
              const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];
              schemas = Object.keys(discriminators).reduce(function(cur, discriminator) {
                const tiedValue = discriminators[discriminator].discriminatorMapping.value;
                if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {
                  cur.push(discriminators[discriminator]);
                }
                return cur;
              }, []);
            }
            if (p !== parts2.length && foundschema.schema) {
              let ret2;
              if (parts2[p] === "$") {
                if (p + 1 === parts2.length) {
                  return foundschema;
                }
                ret2 = search(parts2.slice(p + 1), schema2, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
                if (ret2) {
                  ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                }
                return ret2;
              }
              if (schemas != null && schemas.length > 0) {
                ret2 = [];
                for (const schema3 of schemas) {
                  const _ret = search(parts2.slice(p), schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
                  if (_ret != null) {
                    _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                    if (_ret.$isUnderneathDocArray) {
                      ret2.$isUnderneathDocArray = true;
                    }
                    ret2.push(_ret);
                  }
                }
                return ret2;
              } else {
                ret2 = search(parts2.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
                if (ret2) {
                  ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                }
                return ret2;
              }
            } else if (p !== parts2.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {
              let type = foundschema;
              while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {
                type = type.casterConstructor;
              }
              const ret2 = search(parts2.slice(p), type.schema, null, nestedPath.concat(parts2.slice(0, p)));
              if (ret2 != null) {
                return ret2;
              }
              if (type.schema.discriminators) {
                const discriminatorPaths = [];
                for (const discriminatorName of Object.keys(type.schema.discriminators)) {
                  const _schema = type.schema.discriminators[discriminatorName] || type.schema;
                  const ret3 = search(parts2.slice(p), _schema, null, nestedPath.concat(parts2.slice(0, p)));
                  if (ret3 != null) {
                    discriminatorPaths.push(ret3);
                  }
                }
                if (discriminatorPaths.length > 0) {
                  return discriminatorPaths;
                }
              }
            }
          }
          const fullPath = nestedPath.concat([trypath]).join(".");
          if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.populated(fullPath) && p < parts2.length) {
            const model = doc.$__.populated[fullPath].options[populateModelSymbol];
            if (model != null) {
              const ret2 = search(parts2.slice(p), model.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
              if (ret2) {
                ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !model.schema.$isSingleNested;
              }
              return ret2;
            }
          }
          const _val = get2(topLevelDoc, trypath);
          if (_val != null) {
            const model = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);
            const schema3 = model != null ? model.schema : null;
            if (schema3 != null) {
              const ret2 = search(parts2.slice(p), schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
              if (ret2 != null) {
                ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !schema3.$isSingleNested;
                return ret2;
              }
            }
          }
          return foundschema;
        }
      }
      const parts = path.split(".");
      for (let i = 0; i < parts.length; ++i) {
        if (parts[i] === "$") {
          parts[i] = "0";
        }
      }
      return search(parts, schema, doc, []);
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/normalizeRefPath.js
var require_normalizeRefPath = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/normalizeRefPath.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function normalizeRefPath(refPath, doc, populatedPath) {
      if (refPath == null) {
        return refPath;
      }
      if (typeof refPath === "function") {
        refPath = refPath.call(doc, doc, populatedPath);
      }
      const hasNumericProp = /(\.\d+$|\.\d+\.)/g;
      if (hasNumericProp.test(populatedPath)) {
        const chunks = populatedPath.split(hasNumericProp);
        if (chunks[chunks.length - 1] === "") {
          throw new Error("Can't populate individual element in an array");
        }
        let _refPath = "";
        let _remaining = refPath;
        for (let i = 0; i < chunks.length; i += 2) {
          const chunk = chunks[i];
          if (_remaining.startsWith(chunk + ".")) {
            _refPath += _remaining.substr(0, chunk.length) + chunks[i + 1];
            _remaining = _remaining.substr(chunk.length + 1);
          } else if (i === chunks.length - 1) {
            _refPath += _remaining;
            _remaining = "";
            break;
          } else {
            throw new Error("Could not normalize ref path, chunk " + chunk + " not in populated path");
          }
        }
        return _refPath;
      }
      return refPath;
    };
  }
});

// node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js
var require_getModelsMapForPopulate = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongooseError = require_error3();
    var SkipPopulateValue = require_SkipPopulateValue();
    var get2 = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var isPathExcluded = require_isPathExcluded();
    var getSchemaTypes = require_getSchemaTypes();
    var getVirtual = require_getVirtual();
    var lookupLocalFields = require_lookupLocalFields();
    var mpath = require_mpath();
    var normalizeRefPath = require_normalizeRefPath();
    var util = require("util");
    var utils2 = require_utils6();
    var modelSymbol = require_symbols().modelSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    module2.exports = function getModelsMapForPopulate(model, docs, options2) {
      let i;
      let doc;
      const len = docs.length;
      const available = {};
      const map = [];
      const modelNameFromQuery = options2.model && options2.model.modelName || options2.model;
      let schema;
      let refPath;
      let Model;
      let currentOptions;
      let modelNames;
      let modelName;
      const originalModel = options2.model;
      let isVirtual = false;
      const modelSchema = model.schema;
      let allSchemaTypes = getSchemaTypes(modelSchema, null, options2.path);
      allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter((v) => v != null);
      const _firstWithRefPath = allSchemaTypes.find((schematype) => get2(schematype, "options.refPath", null) != null);
      for (i = 0; i < len; i++) {
        doc = docs[i];
        let justOne = null;
        schema = getSchemaTypes(modelSchema, doc, options2.path);
        if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {
          continue;
        }
        if (options2._localModel != null && options2._localModel.schema.nested[options2.path]) {
          continue;
        }
        const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;
        if (isUnderneathDocArray && get2(options2, "options.sort") != null) {
          return new MongooseError("Cannot populate with `sort` on path " + options2.path + " because it is a subproperty of a document array");
        }
        modelNames = null;
        let isRefPath = !!_firstWithRefPath;
        let normalizedRefPath = _firstWithRefPath ? get2(_firstWithRefPath, "options.refPath", null) : null;
        let schemaOptions = null;
        if (Array.isArray(schema)) {
          const schemasArray = schema;
          for (const _schema of schemasArray) {
            let _modelNames;
            let res;
            try {
              res = _getModelNames(doc, _schema);
              _modelNames = res.modelNames;
              isRefPath = isRefPath || res.isRefPath;
              normalizedRefPath = normalizeRefPath(normalizedRefPath, doc, options2.path) || res.refPath;
              justOne = res.justOne;
            } catch (error2) {
              return error2;
            }
            if (isRefPath && !res.isRefPath) {
              continue;
            }
            if (!_modelNames) {
              continue;
            }
            modelNames = modelNames || [];
            for (const modelName2 of _modelNames) {
              if (modelNames.indexOf(modelName2) === -1) {
                modelNames.push(modelName2);
              }
            }
          }
        } else {
          try {
            const res = _getModelNames(doc, schema);
            modelNames = res.modelNames;
            isRefPath = res.isRefPath;
            normalizedRefPath = res.refPath;
            justOne = res.justOne;
            schemaOptions = get2(schema, "options.populate", null);
          } catch (error2) {
            return error2;
          }
          if (!modelNames) {
            continue;
          }
        }
        const _virtualRes = getVirtual(model.schema, options2.path);
        const virtual = _virtualRes == null ? null : _virtualRes.virtual;
        let localField;
        let count = false;
        if (virtual && virtual.options) {
          const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + "." : "";
          if (typeof virtual.options.localField === "function") {
            localField = virtualPrefix + virtual.options.localField.call(doc, doc);
          } else if (Array.isArray(virtual.options.localField)) {
            localField = virtual.options.localField.map((field) => virtualPrefix + field);
          } else {
            localField = virtualPrefix + virtual.options.localField;
          }
          count = virtual.options.count;
          if (virtual.options.skip != null && !options2.hasOwnProperty("skip")) {
            options2.skip = virtual.options.skip;
          }
          if (virtual.options.limit != null && !options2.hasOwnProperty("limit")) {
            options2.limit = virtual.options.limit;
          }
          if (virtual.options.perDocumentLimit != null && !options2.hasOwnProperty("perDocumentLimit")) {
            options2.perDocumentLimit = virtual.options.perDocumentLimit;
          }
        } else {
          localField = options2.path;
        }
        let foreignField = virtual && virtual.options ? virtual.options.foreignField : "_id";
        if ("justOne" in options2 && options2.justOne !== void 0) {
          justOne = options2.justOne;
        } else if (virtual && virtual.options && virtual.options.refPath) {
          const normalizedRefPath2 = normalizeRefPath(virtual.options.refPath, doc, options2.path);
          justOne = !!virtual.options.justOne;
          isVirtual = true;
          const refValue = utils2.getValue(normalizedRefPath2, doc);
          modelNames = Array.isArray(refValue) ? refValue : [refValue];
        } else if (virtual && virtual.options && virtual.options.ref) {
          let normalizedRef;
          if (typeof virtual.options.ref === "function") {
            normalizedRef = virtual.options.ref.call(doc, doc);
          } else {
            normalizedRef = virtual.options.ref;
          }
          justOne = !!virtual.options.justOne;
          isVirtual = true;
          if (!modelNames) {
            modelNames = [].concat(normalizedRef);
          }
        } else if (schema && !schema[schemaMixedSymbol]) {
          if (options2.path.endsWith("." + schema.path)) {
            justOne = Array.isArray(schema) ? schema.every((schema2) => !schema2.$isMongooseArray) : !schema.$isMongooseArray;
          }
        }
        if (!modelNames) {
          continue;
        }
        if (virtual && (!localField || !foreignField)) {
          return new MongooseError("If you are populating a virtual, you must set the localField and foreignField options");
        }
        options2.isVirtual = isVirtual;
        options2.virtual = virtual;
        if (typeof localField === "function") {
          localField = localField.call(doc, doc);
        }
        if (typeof foreignField === "function") {
          foreignField = foreignField.call(doc);
        }
        let match = get2(options2, "match", null) || get2(currentOptions, "match", null) || get2(options2, "virtual.options.match", null) || get2(options2, "virtual.options.options.match", null);
        let hasMatchFunction = typeof match === "function";
        if (hasMatchFunction) {
          match = match.call(doc, doc);
        }
        if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {
          match = Object.assign({}, match);
          for (let i2 = 1; i2 < localField.length; ++i2) {
            match[foreignField[i2]] = convertTo_id(mpath.get(localField[i2], doc, lookupLocalFields), schema);
            hasMatchFunction = true;
          }
          localField = localField[0];
          foreignField = foreignField[0];
        }
        const localFieldPathType = modelSchema._getPathType(localField);
        const localFieldPath = localFieldPathType === "real" ? modelSchema.path(localField) : localFieldPathType.schema;
        const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];
        let ret2;
        const _populateOptions = get2(options2, "options", {});
        const getters = "getters" in _populateOptions ? _populateOptions.getters : options2.isVirtual && get2(virtual, "options.getters", false);
        if (localFieldGetters.length > 0 && getters) {
          const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);
          const localFieldValue = mpath.get(localField, doc, lookupLocalFields);
          if (Array.isArray(localFieldValue)) {
            const localFieldHydratedValue = mpath.get(localField.split(".").slice(0, -1), hydratedDoc, lookupLocalFields);
            ret2 = localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));
          } else {
            ret2 = localFieldPath.applyGetters(localFieldValue, hydratedDoc);
          }
        } else {
          ret2 = convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);
        }
        const id = String(utils2.getValue(foreignField, doc));
        options2._docs[id] = Array.isArray(ret2) ? ret2.slice() : ret2;
        if (isRefPath && normalizedRefPath != null) {
          const pieces = normalizedRefPath.split(".");
          let cur = "";
          for (let j = 0; j < pieces.length; ++j) {
            const piece = pieces[j];
            cur = cur + (cur.length === 0 ? "" : ".") + piece;
            const schematype = modelSchema.path(cur);
            if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length > 0) {
              const subdocs = utils2.getValue(cur, doc);
              const remnant = options2.path.substr(cur.length + 1);
              const discriminatorKey = schematype.caster.schema.options.discriminatorKey;
              modelNames = [];
              for (const subdoc of subdocs) {
                const discriminatorName = utils2.getValue(discriminatorKey, subdoc);
                const discriminator = schematype.caster.discriminators[discriminatorName];
                const discriminatorSchema = discriminator && discriminator.schema;
                if (discriminatorSchema == null) {
                  continue;
                }
                const _path = discriminatorSchema.path(remnant);
                if (_path == null || _path.options.refPath == null) {
                  const docValue = utils2.getValue(localField.substr(cur.length + 1), subdoc);
                  ret2 = ret2.map((v) => v === docValue ? SkipPopulateValue(v) : v);
                  continue;
                }
                const modelName2 = utils2.getValue(pieces.slice(j + 1).join("."), subdoc);
                modelNames.push(modelName2);
              }
            }
          }
        }
        let k = modelNames.length;
        while (k--) {
          modelName = modelNames[k];
          if (modelName == null) {
            continue;
          }
          const connection = options2.connection != null ? options2.connection : model.db;
          try {
            Model = originalModel && originalModel[modelSymbol] ? originalModel : modelName[modelSymbol] ? modelName : connection.model(modelName);
          } catch (error2) {
            if (ret2 !== void 0) {
              return error2;
            }
          }
          let ids = ret2;
          const flat = Array.isArray(ret2) ? utils2.array.flatten(ret2) : [];
          if (isRefPath && Array.isArray(ret2) && flat.length === modelNames.length) {
            ids = flat.filter((val, i2) => modelNames[i2] === modelName);
          }
          if (!available[modelName] || currentOptions.perDocumentLimit != null || get2(currentOptions, "options.perDocumentLimit") != null) {
            currentOptions = {
              model: Model
            };
            if (isVirtual && get2(virtual, "options.options")) {
              currentOptions.options = utils2.clone(virtual.options.options);
            } else if (schemaOptions != null) {
              currentOptions.options = Object.assign({}, schemaOptions);
            }
            utils2.merge(currentOptions, options2);
            options2[populateModelSymbol] = Model;
            available[modelName] = {
              model: Model,
              options: currentOptions,
              match: hasMatchFunction ? [match] : match,
              docs: [doc],
              ids: [ids],
              allIds: [ret2],
              localField: new Set([localField]),
              foreignField: new Set([foreignField]),
              justOne,
              isVirtual,
              virtual,
              count,
              [populateModelSymbol]: Model
            };
            map.push(available[modelName]);
          } else {
            available[modelName].localField.add(localField);
            available[modelName].foreignField.add(foreignField);
            available[modelName].docs.push(doc);
            available[modelName].ids.push(ids);
            available[modelName].allIds.push(ret2);
            if (hasMatchFunction) {
              available[modelName].match.push(match);
            }
          }
        }
      }
      return map;
      function _getModelNames(doc2, schema2) {
        let modelNames2;
        let discriminatorKey;
        let isRefPath = false;
        let justOne = null;
        if (schema2 && schema2.caster) {
          schema2 = schema2.caster;
        }
        if (schema2 && schema2.$isSchemaMap) {
          schema2 = schema2.$__schemaType;
        }
        if (!schema2 && model.discriminators) {
          discriminatorKey = model.schema.discriminatorMapping.key;
        }
        refPath = schema2 && schema2.options && schema2.options.refPath;
        const normalizedRefPath = normalizeRefPath(refPath, doc2, options2.path);
        if (modelNameFromQuery) {
          modelNames2 = [modelNameFromQuery];
        } else if (normalizedRefPath) {
          if (options2._queryProjection != null && isPathExcluded(options2._queryProjection, normalizedRefPath)) {
            throw new MongooseError("refPath `" + normalizedRefPath + "` must not be excluded in projection, got " + util.inspect(options2._queryProjection));
          }
          if (modelSchema.virtuals.hasOwnProperty(normalizedRefPath) && doc2.$__ == null) {
            modelNames2 = [modelSchema.virtuals[normalizedRefPath].applyGetters(void 0, doc2)];
          } else {
            modelNames2 = utils2.getValue(normalizedRefPath, doc2);
          }
          if (Array.isArray(modelNames2)) {
            modelNames2 = utils2.array.flatten(modelNames2);
          }
          isRefPath = true;
        } else {
          let modelForCurrentDoc = model;
          let schemaForCurrentDoc;
          let discriminatorValue;
          if (!schema2 && discriminatorKey && (discriminatorValue = utils2.getValue(discriminatorKey, doc2))) {
            const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;
            if (discriminatorModel != null) {
              modelForCurrentDoc = discriminatorModel;
            } else {
              try {
                modelForCurrentDoc = model.db.model(discriminatorValue);
              } catch (error2) {
                return error2;
              }
            }
            schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options2.path);
            if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
              schemaForCurrentDoc = schemaForCurrentDoc.caster;
            }
          } else {
            schemaForCurrentDoc = schema2;
          }
          const _virtualRes = getVirtual(modelForCurrentDoc.schema, options2.path);
          const virtual = _virtualRes == null ? null : _virtualRes.virtual;
          if (schemaForCurrentDoc != null) {
            justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;
          }
          let ref;
          let refPath2;
          if ((ref = get2(schemaForCurrentDoc, "options.ref")) != null) {
            ref = handleRefFunction(ref, doc2);
            modelNames2 = [ref];
          } else if ((ref = get2(virtual, "options.ref")) != null) {
            ref = handleRefFunction(ref, doc2);
            if (Array.isArray(ref)) {
              modelNames2 = ref;
            } else {
              modelNames2 = [ref];
            }
            isVirtual = true;
          } else if ((refPath2 = get2(schemaForCurrentDoc, "options.refPath")) != null) {
            isRefPath = true;
            refPath2 = normalizeRefPath(refPath2, doc2, options2.path);
            modelNames2 = utils2.getValue(refPath2, doc2);
            if (Array.isArray(modelNames2)) {
              modelNames2 = utils2.array.flatten(modelNames2);
            }
          } else {
            modelNames2 = discriminatorKey ? null : [model.modelName];
          }
        }
        if (!modelNames2) {
          return { modelNames: modelNames2, isRefPath, refPath: normalizedRefPath, justOne };
        }
        if (!Array.isArray(modelNames2)) {
          modelNames2 = [modelNames2];
        }
        return { modelNames: modelNames2, isRefPath, refPath: normalizedRefPath, justOne };
      }
    };
    function handleRefFunction(ref, doc) {
      if (typeof ref === "function" && !ref[modelSymbol]) {
        return ref.call(doc, doc);
      }
      return ref;
    }
    function convertTo_id(val, schema) {
      if (val != null && val.$__ != null) {
        return val._id;
      }
      if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {
        return val._id;
      }
      if (Array.isArray(val)) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] != null && val[i].$__ != null) {
            val[i] = val[i]._id;
          }
        }
        if (val.isMongooseArray && val.$schema()) {
          return val.$schema()._castForPopulate(val, val.$parent());
        }
        return [].concat(val);
      }
      if (val != null && val.constructor.name === "Object" && (schema == null || schema[schemaMixedSymbol] == null)) {
        const ret2 = [];
        for (const key of Object.keys(val)) {
          ret2.push(val[key]);
        }
        return ret2;
      }
      if (val instanceof Map) {
        return Array.from(val.values());
      }
      return val;
    }
  }
});

// node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js
var require_isDefaultIdIndex = __commonJS({
  "node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js"(exports2, module2) {
    init_shims();
    "use strict";
    var get2 = require_get();
    module2.exports = function isDefaultIdIndex(index2) {
      if (Array.isArray(index2)) {
        const keys = Object.keys(index2[0]);
        return keys.length === 1 && keys[0] === "_id" && index2[0]._id !== "hashed";
      }
      if (typeof index2 !== "object") {
        return false;
      }
      const key = get2(index2, "key", {});
      return Object.keys(key).length === 1 && key.hasOwnProperty("_id");
    };
  }
});

// node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js
var require_isIndexEqual = __commonJS({
  "node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js"(exports2, module2) {
    init_shims();
    "use strict";
    var get2 = require_get();
    var utils2 = require_utils6();
    module2.exports = function isIndexEqual(key, options2, dbIndex) {
      if (dbIndex.textIndexVersion != null) {
        const weights = dbIndex.weights;
        if (Object.keys(weights).length !== Object.keys(key).length) {
          return false;
        }
        for (const prop of Object.keys(weights)) {
          if (!(prop in key)) {
            return false;
          }
          const weight = weights[prop];
          if (weight !== get2(options2, "weights." + prop) && !(weight === 1 && get2(options2, "weights." + prop) == null)) {
            return false;
          }
        }
        if (options2["default_language"] !== dbIndex["default_language"]) {
          return dbIndex["default_language"] === "english" && options2["default_language"] == null;
        }
        return true;
      }
      const optionKeys = [
        "unique",
        "partialFilterExpression",
        "sparse",
        "expireAfterSeconds",
        "collation"
      ];
      for (const key2 of optionKeys) {
        if (!(key2 in options2) && !(key2 in dbIndex)) {
          continue;
        }
        if (key2 === "collation") {
          if (options2[key2] == null || dbIndex[key2] == null) {
            return options2[key2] == null && dbIndex[key2] == null;
          }
          const definedKeys = Object.keys(options2.collation);
          const schemaCollation = options2.collation;
          const dbCollation = dbIndex.collation;
          for (const opt of definedKeys) {
            if (get2(schemaCollation, opt) !== get2(dbCollation, opt)) {
              return false;
            }
          }
        } else if (!utils2.deepEqual(options2[key2], dbIndex[key2])) {
          return false;
        }
      }
      const schemaIndexKeys = Object.keys(key);
      const dbIndexKeys = Object.keys(dbIndex.key);
      if (schemaIndexKeys.length !== dbIndexKeys.length) {
        return false;
      }
      for (let i = 0; i < schemaIndexKeys.length; ++i) {
        if (schemaIndexKeys[i] !== dbIndexKeys[i]) {
          return false;
        }
        if (!utils2.deepEqual(key[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js
var require_isPathSelectedInclusive = __commonJS({
  "node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function isPathSelectedInclusive(fields, path) {
      const chunks = path.split(".");
      let cur = "";
      let j;
      let keys;
      let numKeys;
      for (let i = 0; i < chunks.length; ++i) {
        cur += cur.length ? "." : "" + chunks[i];
        if (fields[cur]) {
          keys = Object.keys(fields);
          numKeys = keys.length;
          for (j = 0; j < numKeys; ++j) {
            if (keys[i].indexOf(cur + ".") === 0 && keys[i].indexOf(path) !== 0) {
              continue;
            }
          }
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/mongoose/lib/helpers/parallelLimit.js
var require_parallelLimit = __commonJS({
  "node_modules/mongoose/lib/helpers/parallelLimit.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = parallelLimit;
    function parallelLimit(fns, limit, callback) {
      let numInProgress = 0;
      let numFinished = 0;
      let error2 = null;
      if (limit <= 0) {
        throw new Error("Limit must be positive");
      }
      if (fns.length === 0) {
        return callback(null, []);
      }
      for (let i = 0; i < fns.length && i < limit; ++i) {
        _start();
      }
      function _start() {
        fns[numFinished + numInProgress](_done(numFinished + numInProgress));
        ++numInProgress;
      }
      const results = [];
      function _done(index2) {
        return (err, res) => {
          --numInProgress;
          ++numFinished;
          if (error2 != null) {
            return;
          }
          if (err != null) {
            error2 = err;
            return callback(error2);
          }
          results[index2] = res;
          if (numFinished === fns.length) {
            return callback(null, results);
          } else if (numFinished + numInProgress < fns.length) {
            _start();
          }
        };
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js
var require_removeDeselectedForeignField = __commonJS({
  "node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js"(exports2, module2) {
    init_shims();
    "use strict";
    var get2 = require_get();
    var mpath = require_mpath();
    var parseProjection = require_parseProjection();
    module2.exports = function removeDeselectedForeignField(foreignFields, options2, docs) {
      const projection = parseProjection(get2(options2, "select", null), true) || parseProjection(get2(options2, "options.select", null), true);
      if (projection == null) {
        return;
      }
      for (const foreignField of foreignFields) {
        if (!projection.hasOwnProperty("-" + foreignField)) {
          continue;
        }
        for (const val of docs) {
          if (val.$__ != null) {
            mpath.unset(foreignField, val._doc);
          } else {
            mpath.unset(foreignField, val);
          }
        }
      }
    };
  }
});

// node_modules/mongoose/lib/model.js
var require_model = __commonJS({
  "node_modules/mongoose/lib/model.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aggregate = require_aggregate2();
    var ChangeStream = require_ChangeStream();
    var Document = require_document();
    var DocumentNotFoundError = require_notFound();
    var DivergentArrayError = require_divergentArray();
    var EventEmitter = require("events").EventEmitter;
    var MongooseBuffer = require_buffer();
    var MongooseError = require_error3();
    var OverwriteModelError = require_overwriteModel();
    var PromiseProvider = require_promise_provider();
    var Query = require_query2();
    var RemoveOptions = require_removeOptions();
    var SaveOptions = require_saveOptions();
    var Schema = require_schema2();
    var ServerSelectionError = require_serverSelection();
    var ValidationError = require_validation();
    var VersionError = require_version();
    var ParallelSaveError = require_parallelSave();
    var applyQueryMiddleware = require_applyQueryMiddleware();
    var applyHooks = require_applyHooks();
    var applyMethods = require_applyMethods();
    var applyStaticHooks = require_applyStaticHooks();
    var applyStatics = require_applyStatics();
    var applyWriteConcern = require_applyWriteConcern();
    var assignVals = require_assignVals();
    var castBulkWrite = require_castBulkWrite();
    var createPopulateQueryFilter = require_createPopulateQueryFilter();
    var getDefaultBulkwriteResult = require_getDefaultBulkwriteResult();
    var discriminator = require_discriminator();
    var each2 = require_each2();
    var get2 = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var getModelsMapForPopulate = require_getModelsMapForPopulate();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var isDefaultIdIndex = require_isDefaultIdIndex();
    var isIndexEqual = require_isIndexEqual();
    var isPathSelectedInclusive = require_isPathSelectedInclusive();
    var leanPopulateMap = require_leanPopulateMap();
    var modifiedPaths = require_modifiedPaths();
    var parallelLimit = require_parallelLimit();
    var removeDeselectedForeignField = require_removeDeselectedForeignField();
    var util = require("util");
    var utils2 = require_utils6();
    var VERSION_WHERE = 1;
    var VERSION_INC = 2;
    var VERSION_ALL = VERSION_WHERE | VERSION_INC;
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var modelCollectionSymbol = Symbol("mongoose#Model#collection");
    var modelDbSymbol = Symbol("mongoose#Model#db");
    var modelSymbol = require_symbols().modelSymbol;
    var subclassedSymbol = Symbol("mongoose#Model#subclassed");
    var saveToObjectOptions = Object.assign({}, internalToObjectOptions, {
      bson: true
    });
    function Model(doc, fields, skipId) {
      if (fields instanceof Schema) {
        throw new TypeError("2nd argument to `Model` must be a POJO or string, **not** a schema. Make sure you're calling `mongoose.model()`, not `mongoose.Model()`.");
      }
      Document.call(this, doc, fields, skipId);
    }
    Model.prototype.__proto__ = Document.prototype;
    Model.prototype.$isMongooseModelPrototype = true;
    Model.prototype.db;
    Model.prototype.collection;
    Model.prototype.$__collection;
    Model.prototype.modelName;
    Model.prototype.$where;
    Model.prototype.baseModelName;
    Model.events;
    Model._middleware;
    function _applyCustomWhere(doc, where) {
      if (doc.$where == null) {
        return;
      }
      for (const key of Object.keys(doc.$where)) {
        where[key] = doc.$where[key];
      }
    }
    Model.prototype.$__handleSave = function(options2, callback) {
      const _this = this;
      let saveOptions = {};
      if ("safe" in options2) {
        _handleSafe(options2);
      }
      applyWriteConcern(this.$__schema, options2);
      if (typeof options2.writeConcern != "undefined") {
        saveOptions.writeConcern = {};
        if ("w" in options2.writeConcern) {
          saveOptions.writeConcern.w = options2.writeConcern.w;
        }
        if ("j" in options2.writeConcern) {
          saveOptions.writeConcern.j = options2.writeConcern.j;
        }
        if ("wtimeout" in options2.writeConcern) {
          saveOptions.writeConcern.wtimeout = options2.writeConcern.wtimeout;
        }
      } else {
        if ("w" in options2) {
          saveOptions.w = options2.w;
        }
        if ("j" in options2) {
          saveOptions.j = options2.j;
        }
        if ("wtimeout" in options2) {
          saveOptions.wtimeout = options2.wtimeout;
        }
      }
      if ("checkKeys" in options2) {
        saveOptions.checkKeys = options2.checkKeys;
      }
      const session = this.$session();
      if (!saveOptions.hasOwnProperty("session")) {
        saveOptions.session = session;
      }
      if (Object.keys(saveOptions).length === 0) {
        saveOptions = null;
      }
      if (this.isNew) {
        const obj = this.toObject(saveToObjectOptions);
        if ((obj || {})._id === void 0) {
          immediate(function() {
            callback(new MongooseError("document must have an _id before saving"));
          });
          return;
        }
        this.$__version(true, obj);
        this[modelCollectionSymbol].insertOne(obj, saveOptions, function(err, ret2) {
          if (err) {
            _setIsNew(_this, true);
            callback(err, null);
            return;
          }
          callback(null, ret2);
        });
        this.$__reset();
        _setIsNew(this, false);
        this.$__.inserting = true;
      } else {
        this.$__.inserting = false;
        const delta = this.$__delta();
        if (delta) {
          if (delta instanceof MongooseError) {
            callback(delta);
            return;
          }
          const where = this.$__where(delta[0]);
          if (where instanceof MongooseError) {
            callback(where);
            return;
          }
          _applyCustomWhere(this, where);
          this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions, (err, ret2) => {
            if (err) {
              this.$__undoReset();
              callback(err);
              return;
            }
            ret2.$where = where;
            callback(null, ret2);
          });
        } else {
          const optionsWithCustomValues = Object.assign({}, options2, saveOptions);
          const where = this.$__where();
          if (this.$__schema.options.optimisticConcurrency) {
            const key = this.$__schema.options.versionKey;
            const val = this.$__getValue(key);
            if (val != null) {
              where[key] = val;
            }
          }
          this.constructor.exists(where, optionsWithCustomValues).then((documentExists) => {
            if (!documentExists) {
              throw new DocumentNotFoundError(this.$__where(), this.constructor.modelName);
            }
            callback();
          }).catch(callback);
          return;
        }
        this.$__.modifiedPaths = this.modifiedPaths();
        this.$__reset();
        _setIsNew(this, false);
      }
    };
    Model.prototype.$__save = function(options2, callback) {
      this.$__handleSave(options2, (error2, result) => {
        const hooks = this.$__schema.s.hooks;
        if (error2) {
          return hooks.execPost("save:error", this, [this], { error: error2 }, (error3) => {
            callback(error3, this);
          });
        }
        let numAffected = 0;
        if (get2(options2, "safe.w") !== 0 && get2(options2, "w") !== 0) {
          if (result) {
            if (Array.isArray(result)) {
              numAffected = result.length;
            } else if (result.result && result.result.n !== void 0) {
              numAffected = result.result.n;
            } else if (result.result && result.result.nModified !== void 0) {
              numAffected = result.result.nModified;
            } else {
              numAffected = result;
            }
          }
          if (this.$__.version && !this.$__.inserting) {
            const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);
            this.$__.version = void 0;
            const key = this.$__schema.options.versionKey;
            const version = this.$__getValue(key) || 0;
            if (numAffected <= 0) {
              this.$__undoReset();
              const err = this.$__.$versionError || new VersionError(this, version, this.$__.modifiedPaths);
              return callback(err);
            }
            if (doIncrement) {
              this.$__setValue(key, version + 1);
            }
          }
          if (result != null && numAffected <= 0) {
            this.$__undoReset();
            error2 = new DocumentNotFoundError(result.$where, this.constructor.modelName, numAffected, result);
            return hooks.execPost("save:error", this, [this], { error: error2 }, (error3) => {
              callback(error3, this);
            });
          }
        }
        this.$__.saving = void 0;
        this.$__.savedState = {};
        this.emit("save", this, numAffected);
        this.constructor.emit("save", this, numAffected);
        callback(null, this);
      });
    };
    function generateVersionError(doc, modifiedPaths2) {
      const key = doc.$__schema.options.versionKey;
      if (!key) {
        return null;
      }
      const version = doc.$__getValue(key) || 0;
      return new VersionError(doc, version, modifiedPaths2);
    }
    Model.prototype.save = function(options2, fn) {
      let parallelSave;
      this.$op = "save";
      if (this.$__.saving) {
        parallelSave = new ParallelSaveError(this);
      } else {
        this.$__.saving = new ParallelSaveError(this);
      }
      if (typeof options2 === "function") {
        fn = options2;
        options2 = void 0;
      }
      options2 = new SaveOptions(options2);
      if (options2.hasOwnProperty("session")) {
        this.$session(options2.session);
      }
      this.$__.$versionError = generateVersionError(this, this.modifiedPaths());
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        if (parallelSave) {
          this.$__handleReject(parallelSave);
          return cb(parallelSave);
        }
        this.$__.saveOptions = options2;
        this.$__save(options2, (error2) => {
          this.$__.saving = void 0;
          delete this.$__.saveOptions;
          delete this.$__.$versionError;
          this.$op = null;
          if (error2) {
            this.$__handleReject(error2);
            return cb(error2);
          }
          cb(null, this);
        });
      }, this.constructor.events);
    };
    function shouldSkipVersioning(self2, path) {
      const skipVersioning = self2.$__schema.options.skipVersioning;
      if (!skipVersioning)
        return false;
      path = path.replace(/\.\d+\./, ".");
      return skipVersioning[path];
    }
    function operand(self2, where, delta, data, val, op) {
      op || (op = "$set");
      if (!delta[op])
        delta[op] = {};
      delta[op][data.path] = val;
      if (self2.$__schema.options.versionKey === false)
        return;
      if (shouldSkipVersioning(self2, data.path))
        return;
      if (VERSION_ALL === (VERSION_ALL & self2.$__.version))
        return;
      if (self2.$__schema.options.optimisticConcurrency) {
        self2.$__.version = VERSION_ALL;
        return;
      }
      switch (op) {
        case "$set":
        case "$unset":
        case "$pop":
        case "$pull":
        case "$pullAll":
        case "$push":
        case "$addToSet":
          break;
        default:
          return;
      }
      if (op === "$push" || op === "$addToSet" || op === "$pullAll" || op === "$pull") {
        self2.$__.version = VERSION_INC;
      } else if (/^\$p/.test(op)) {
        increment.call(self2);
      } else if (Array.isArray(val)) {
        increment.call(self2);
      } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
        self2.$__.version = VERSION_WHERE;
      }
    }
    function handleAtomics(self2, where, delta, data, value) {
      if (delta.$set && delta.$set[data.path]) {
        return;
      }
      if (typeof value.$__getAtomics === "function") {
        value.$__getAtomics().forEach(function(atomic) {
          const op2 = atomic[0];
          const val2 = atomic[1];
          operand(self2, where, delta, data, val2, op2);
        });
        return;
      }
      const atomics = value[arrayAtomicsSymbol];
      const ops = Object.keys(atomics);
      let i = ops.length;
      let val;
      let op;
      if (i === 0) {
        if (utils2.isMongooseObject(value)) {
          value = value.toObject({ depopulate: 1, _isNested: true });
        } else if (value.valueOf) {
          value = value.valueOf();
        }
        return operand(self2, where, delta, data, value);
      }
      function iter(mem) {
        return utils2.isMongooseObject(mem) ? mem.toObject({ depopulate: 1, _isNested: true }) : mem;
      }
      while (i--) {
        op = ops[i];
        val = atomics[op];
        if (utils2.isMongooseObject(val)) {
          val = val.toObject({ depopulate: true, transform: false, _isNested: true });
        } else if (Array.isArray(val)) {
          val = val.map(iter);
        } else if (val.valueOf) {
          val = val.valueOf();
        }
        if (op === "$addToSet") {
          val = { $each: val };
        }
        operand(self2, where, delta, data, val, op);
      }
    }
    Model.prototype.$__delta = function() {
      const dirty = this.$__dirty();
      if (!dirty.length && VERSION_ALL !== this.$__.version) {
        return;
      }
      const where = {};
      const delta = {};
      const len = dirty.length;
      const divergent = [];
      let d2 = 0;
      where._id = this._doc._id;
      if (get2(where, "_id.$__", null) != null) {
        where._id = where._id.toObject({ transform: false, depopulate: true });
      }
      for (; d2 < len; ++d2) {
        const data = dirty[d2];
        let value = data.value;
        const match = checkDivergentArray(this, data.path, value);
        if (match) {
          divergent.push(match);
          continue;
        }
        const pop = this.populated(data.path, true);
        if (!pop && this.$__.selected) {
          const pathSplit = data.path.split(".");
          const top = pathSplit[0];
          if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
            if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === "undefined") {
              where[top] = this.$__.selected[top];
              pathSplit[1] = "$";
              data.path = pathSplit.join(".");
            } else {
              divergent.push(data.path);
              continue;
            }
          }
        }
        if (divergent.length)
          continue;
        if (value === void 0) {
          operand(this, where, delta, data, 1, "$unset");
        } else if (value === null) {
          operand(this, where, delta, data, null);
        } else if (value.isMongooseArray && value.$path() && value[arrayAtomicsSymbol]) {
          handleAtomics(this, where, delta, data, value);
        } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {
          value = value.toObject();
          operand(this, where, delta, data, value);
        } else {
          value = utils2.clone(value, {
            depopulate: true,
            transform: false,
            virtuals: false,
            getters: false,
            _isNested: true
          });
          operand(this, where, delta, data, value);
        }
      }
      if (divergent.length) {
        return new DivergentArrayError(divergent);
      }
      if (this.$__.version) {
        this.$__version(where, delta);
      }
      return [where, delta];
    };
    function checkDivergentArray(doc, path, array) {
      const pop = doc.populated(path, true);
      if (!pop && doc.$__.selected) {
        const top = path.split(".")[0];
        if (doc.$__.selected[top + ".$"]) {
          return top;
        }
      }
      if (!(pop && array && array.isMongooseArray))
        return;
      const check = pop.options.match || pop.options.options && utils2.object.hasOwnProperty(pop.options.options, "limit") || pop.options.options && pop.options.options.skip || pop.options.select && (pop.options.select._id === 0 || /\s?-_id\s?/.test(pop.options.select));
      if (check) {
        const atomics = array[arrayAtomicsSymbol];
        if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
          return path;
        }
      }
    }
    Model.prototype.$__version = function(where, delta) {
      const key = this.$__schema.options.versionKey;
      if (where === true) {
        if (key) {
          this.$__setValue(key, delta[key] = 0);
        }
        return;
      }
      if (!this.$__isSelected(key)) {
        return;
      }
      if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
        const value = this.$__getValue(key);
        if (value != null)
          where[key] = value;
      }
      if (VERSION_INC === (VERSION_INC & this.$__.version)) {
        if (get2(delta.$set, key, null) != null) {
          ++delta.$set[key];
        } else {
          delta.$inc = delta.$inc || {};
          delta.$inc[key] = 1;
        }
      }
    };
    function increment() {
      this.$__.version = VERSION_ALL;
      return this;
    }
    Model.prototype.increment = increment;
    Model.prototype.$__where = function _where(where) {
      where || (where = {});
      if (!where._id) {
        where._id = this._doc._id;
      }
      if (this._doc._id === void 0) {
        return new MongooseError("No _id found on document!");
      }
      return where;
    };
    Model.prototype.remove = function remove(options2, fn) {
      if (typeof options2 === "function") {
        fn = options2;
        options2 = void 0;
      }
      options2 = new RemoveOptions(options2);
      if (options2.hasOwnProperty("session")) {
        this.$session(options2.session);
      }
      this.$op = "remove";
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        this.$__remove(options2, (err, res) => {
          this.$op = null;
          cb(err, res);
        });
      }, this.constructor.events);
    };
    Model.prototype.delete = Model.prototype.remove;
    Model.prototype.deleteOne = function deleteOne(options2, fn) {
      if (typeof options2 === "function") {
        fn = options2;
        options2 = void 0;
      }
      if (!options2) {
        options2 = {};
      }
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        this.$__deleteOne(options2, cb);
      }, this.constructor.events);
    };
    Model.prototype.$__remove = function $__remove(options2, cb) {
      if (this.$__.isDeleted) {
        return immediate(() => cb(null, this));
      }
      const where = this.$__where();
      if (where instanceof MongooseError) {
        return cb(where);
      }
      _applyCustomWhere(this, where);
      const session = this.$session();
      if (!options2.hasOwnProperty("session")) {
        options2.session = session;
      }
      this[modelCollectionSymbol].deleteOne(where, options2, (err) => {
        if (!err) {
          this.$__.isDeleted = true;
          this.emit("remove", this);
          this.constructor.emit("remove", this);
          return cb(null, this);
        }
        this.$__.isDeleted = false;
        cb(err);
      });
    };
    Model.prototype.$__deleteOne = Model.prototype.$__remove;
    Model.prototype.model = function model(name) {
      return this[modelDbSymbol].model(name);
    };
    Model.exists = function exists(filter, options2, callback) {
      _checkContext(this, "exists");
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      const query = this.findOne(filter).select({ _id: 1 }).lean().setOptions(options2);
      if (typeof callback === "function") {
        query.exec(function(err, doc) {
          if (err != null) {
            return callback(err);
          }
          callback(null, !!doc);
        });
        return;
      }
      options2 = options2 || {};
      if (!options2.explain) {
        return query.then((doc) => !!doc);
      }
      return query.exec();
    };
    Model.discriminator = function(name, schema, value) {
      let model;
      if (typeof name === "function") {
        model = name;
        name = utils2.getFunctionName(model);
        if (!(model.prototype instanceof Model)) {
          throw new MongooseError("The provided class " + name + " must extend Model");
        }
      }
      _checkContext(this, "discriminator");
      if (utils2.isObject(schema) && !schema.instanceOfSchema) {
        schema = new Schema(schema);
      }
      schema = discriminator(this, name, schema, value, true);
      if (this.db.models[name]) {
        throw new OverwriteModelError(name);
      }
      schema.$isRootDiscriminator = true;
      schema.$globalPluginsApplied = true;
      model = this.db.model(model || name, schema, this.$__collection.name);
      this.discriminators[name] = model;
      const d2 = this.discriminators[name];
      d2.prototype.__proto__ = this.prototype;
      Object.defineProperty(d2, "baseModelName", {
        value: this.modelName,
        configurable: true,
        writable: false
      });
      applyMethods(d2, schema);
      applyStatics(d2, schema);
      if (this[subclassedSymbol] != null) {
        for (const submodel of this[subclassedSymbol]) {
          submodel.discriminators = submodel.discriminators || {};
          submodel.discriminators[name] = model.__subclass(model.db, schema, submodel.collection.name);
        }
      }
      return d2;
    };
    function _checkContext(ctx, fnName) {
      if (ctx == null || ctx === global) {
        throw new MongooseError("`Model." + fnName + "()` cannot run without a model as `this`. Make sure you are calling `MyModel." + fnName + "()` where `MyModel` is a Mongoose model.");
      } else if (ctx[modelSymbol] == null) {
        throw new MongooseError("`Model." + fnName + "()` cannot run without a model as `this`. Make sure you are not calling `new Model." + fnName + "()`");
      }
    }
    for (const i in EventEmitter.prototype) {
      Model[i] = EventEmitter.prototype[i];
    }
    Model.init = function init2(callback) {
      _checkContext(this, "init");
      this.schema.emit("init", this);
      if (this.$init != null) {
        if (callback) {
          this.$init.then(() => callback(), (err) => callback(err));
          return null;
        }
        return this.$init;
      }
      const Promise2 = PromiseProvider.get();
      const autoIndex = utils2.getOption("autoIndex", this.schema.options, this.db.config, this.db.base.options);
      const autoCreate = utils2.getOption("autoCreate", this.schema.options, this.db.config, this.db.base.options);
      const _ensureIndexes2 = autoIndex ? (cb) => this.ensureIndexes({ _automatic: true }, cb) : (cb) => cb();
      const _createCollection = autoCreate ? (cb) => this.createCollection({}, cb) : (cb) => cb();
      this.$init = new Promise2((resolve2, reject) => {
        _createCollection((error2) => {
          if (error2) {
            return reject(error2);
          }
          _ensureIndexes2((error3) => {
            if (error3) {
              return reject(error3);
            }
            resolve2(this);
          });
        });
      });
      if (callback) {
        this.$init.then(() => callback(), (err) => callback(err));
        this.$caught = true;
        return null;
      } else {
        const _catch = this.$init.catch;
        const _this = this;
        this.$init.catch = function() {
          this.$caught = true;
          return _catch.apply(_this.$init, arguments);
        };
      }
      return this.$init;
    };
    Model.createCollection = function createCollection(options2, callback) {
      _checkContext(this, "createCollection");
      if (typeof options2 === "string") {
        throw new MongooseError("You can't specify a new collection name in Model.createCollection.This is not like Connection.createCollection. Only options are accepted here.");
      } else if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      const schemaCollation = get2(this, "schema.options.collation", null);
      if (schemaCollation != null) {
        options2 = Object.assign({ collation: schemaCollation }, options2);
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        this.db.createCollection(this.$__collection.collectionName, options2, utils2.tick((error2) => {
          if (error2 != null && error2.codeName !== "NamespaceExists") {
            return cb(error2);
          }
          this.$__collection = this.db.collection(this.$__collection.collectionName, options2);
          cb(null, this.$__collection);
        }));
      }, this.events);
    };
    Model.syncIndexes = function syncIndexes(options2, callback) {
      _checkContext(this, "syncIndexes");
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        this.createCollection((err) => {
          if (err != null && err.codeName !== "NamespaceExists") {
            return cb(err);
          }
          this.cleanIndexes((err2, dropped) => {
            if (err2 != null) {
              return cb(err2);
            }
            this.createIndexes(options2, (err3) => {
              if (err3 != null) {
                return cb(err3);
              }
              cb(null, dropped);
            });
          });
        });
      }, this.events);
    };
    Model.diffIndexes = function diffIndexes(options2, callback) {
      const toDrop = [];
      const toCreate = [];
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        this.listIndexes((err, indexes) => {
          const schemaIndexes = this.schema.indexes();
          for (const index2 of indexes) {
            let found = false;
            if (isDefaultIdIndex(index2)) {
              continue;
            }
            for (const schemaIndex of schemaIndexes) {
              const key = schemaIndex[0];
              const options3 = _decorateDiscriminatorIndexOptions(this, utils2.clone(schemaIndex[1]));
              if (isIndexEqual(key, options3, index2)) {
                found = true;
              }
            }
            if (!found) {
              toDrop.push(index2.name);
            }
          }
          for (const schemaIndex of schemaIndexes) {
            const key = schemaIndex[0];
            let found = false;
            const options3 = _decorateDiscriminatorIndexOptions(this, utils2.clone(schemaIndex[1]));
            for (const index2 of indexes) {
              if (isDefaultIdIndex(index2)) {
                continue;
              }
              if (isIndexEqual(key, options3, index2)) {
                found = true;
              }
            }
            if (!found) {
              toCreate.push(key);
            }
          }
          cb(null, { toDrop, toCreate });
        });
      });
    };
    Model.cleanIndexes = function cleanIndexes(callback) {
      _checkContext(this, "cleanIndexes");
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        const collection = this.$__collection;
        this.listIndexes((err, indexes) => {
          if (err != null) {
            return cb(err);
          }
          const schemaIndexes = this.schema.indexes();
          const toDrop = [];
          for (const index2 of indexes) {
            let found = false;
            if (isDefaultIdIndex(index2)) {
              continue;
            }
            for (const schemaIndex of schemaIndexes) {
              const key = schemaIndex[0];
              const options2 = _decorateDiscriminatorIndexOptions(this, utils2.clone(schemaIndex[1]));
              if (isIndexEqual(key, options2, index2)) {
                found = true;
              }
            }
            if (!found) {
              toDrop.push(index2.name);
            }
          }
          if (toDrop.length === 0) {
            return cb(null, []);
          }
          dropIndexes(toDrop, cb);
        });
        function dropIndexes(toDrop, cb2) {
          let remaining = toDrop.length;
          let error2 = false;
          toDrop.forEach((indexName) => {
            collection.dropIndex(indexName, (err) => {
              if (err != null) {
                error2 = true;
                return cb2(err);
              }
              if (!error2) {
                --remaining || cb2(null, toDrop);
              }
            });
          });
        }
      });
    };
    Model.listIndexes = function init2(callback) {
      _checkContext(this, "listIndexes");
      const _listIndexes = (cb) => {
        this.$__collection.listIndexes().toArray(cb);
      };
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        if (this.$__collection.buffer) {
          this.$__collection.addQueue(_listIndexes, [cb]);
        } else {
          _listIndexes(cb);
        }
      }, this.events);
    };
    Model.ensureIndexes = function ensureIndexes(options2, callback) {
      _checkContext(this, "ensureIndexes");
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        _ensureIndexes(this, options2 || {}, (error2) => {
          if (error2) {
            return cb(error2);
          }
          cb(null);
        });
      }, this.events);
    };
    Model.createIndexes = function createIndexes(options2, callback) {
      _checkContext(this, "createIndexes");
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      options2.createIndex = true;
      return this.ensureIndexes(options2, callback);
    };
    function _ensureIndexes(model, options2, callback) {
      const indexes = model.schema.indexes();
      let indexError;
      options2 = options2 || {};
      const done = function(err) {
        if (err && !model.$caught) {
          model.emit("error", err);
        }
        model.emit("index", err || indexError);
        callback && callback(err || indexError);
      };
      for (const index2 of indexes) {
        if (isDefaultIdIndex(index2)) {
          console.warn('mongoose: Cannot specify a custom index on `_id` for model name "' + model.modelName + '", MongoDB does not allow overwriting the default `_id` index. See http://bit.ly/mongodb-id-index');
        }
      }
      if (!indexes.length) {
        immediate(function() {
          done();
        });
        return;
      }
      const indexSingleDone = function(err, fields, options3, name) {
        model.emit("index-single-done", err, fields, options3, name);
      };
      const indexSingleStart = function(fields, options3) {
        model.emit("index-single-start", fields, options3);
      };
      const baseSchema = model.schema._baseSchema;
      const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];
      const create = function() {
        if (options2._automatic) {
          if (model.schema.options.autoIndex === false || model.schema.options.autoIndex == null && model.db.config.autoIndex === false) {
            return done();
          }
        }
        const index2 = indexes.shift();
        if (!index2) {
          return done();
        }
        if (options2._automatic && index2[1]._autoIndex === false) {
          return create();
        }
        if (baseSchemaIndexes.find((i) => utils2.deepEqual(i, index2))) {
          return create();
        }
        const indexFields = utils2.clone(index2[0]);
        const indexOptions = utils2.clone(index2[1]);
        let isTextIndex = false;
        for (const key of Object.keys(indexFields)) {
          if (indexFields[key] === "text") {
            isTextIndex = true;
          }
        }
        delete indexOptions._autoIndex;
        _decorateDiscriminatorIndexOptions(model, indexOptions);
        if ("safe" in options2) {
          _handleSafe(options2);
        }
        applyWriteConcern(model.schema, indexOptions);
        indexSingleStart(indexFields, options2);
        let useCreateIndex = !!model.base.options.useCreateIndex;
        if ("useCreateIndex" in model.db.config) {
          useCreateIndex = !!model.db.config.useCreateIndex;
        }
        if ("createIndex" in options2) {
          useCreateIndex = !!options2.createIndex;
        }
        if ("background" in options2) {
          indexOptions.background = options2.background;
        }
        if (model.schema.options.hasOwnProperty("collation") && !indexOptions.hasOwnProperty("collation") && !isTextIndex) {
          indexOptions.collation = model.schema.options.collation;
        }
        const methodName = useCreateIndex ? "createIndex" : "ensureIndex";
        model.collection[methodName](indexFields, indexOptions, utils2.tick(function(err, name) {
          indexSingleDone(err, indexFields, indexOptions, name);
          if (err) {
            if (!indexError) {
              indexError = err;
            }
            if (!model.$caught) {
              model.emit("error", err);
            }
          }
          create();
        }));
      };
      immediate(function() {
        if (options2._automatic && !model.collection.collection) {
          model.collection.addQueue(create, []);
        } else {
          create();
        }
      });
    }
    function _decorateDiscriminatorIndexOptions(model, indexOptions) {
      if (model.baseModelName != null && !("partialFilterExpression" in indexOptions) && !("sparse" in indexOptions)) {
        const value = model.schema.discriminatorMapping && model.schema.discriminatorMapping.value || model.modelName;
        const discriminatorKey = model.schema.options.discriminatorKey;
        indexOptions.partialFilterExpression = { [discriminatorKey]: value };
      }
      return indexOptions;
    }
    var safeDeprecationWarning = "Mongoose: the `safe` option for `save()` is deprecated. Use the `w` option instead: http://bit.ly/mongoose-save";
    var _handleSafe = util.deprecate(function _handleSafe2(options2) {
      if (options2.safe) {
        if (typeof options2.safe === "boolean") {
          options2.w = options2.safe;
          delete options2.safe;
        }
        if (typeof options2.safe === "object") {
          options2.w = options2.safe.w;
          options2.j = options2.safe.j;
          options2.wtimeout = options2.safe.wtimeout;
          delete options2.safe;
        }
      }
    }, safeDeprecationWarning);
    Model.schema;
    Model.db;
    Model.collection;
    Model.$__collection;
    Model.base;
    Model.discriminators;
    Model.translateAliases = function translateAliases(fields) {
      _checkContext(this, "translateAliases");
      const translate = (key, value) => {
        let alias;
        const translated = [];
        const fieldKeys = key.split(".");
        let currentSchema = this.schema;
        for (const i in fieldKeys) {
          const name = fieldKeys[i];
          if (currentSchema && currentSchema.aliases[name]) {
            alias = currentSchema.aliases[name];
            translated.push(alias);
          } else {
            translated.push(name);
          }
          if (currentSchema && currentSchema.paths[alias]) {
            currentSchema = currentSchema.paths[alias].schema;
          } else
            currentSchema = null;
        }
        const translatedKey = translated.join(".");
        if (fields instanceof Map)
          fields.set(translatedKey, value);
        else
          fields[translatedKey] = value;
        if (translatedKey !== key) {
          if (fields instanceof Map) {
            fields.delete(key);
          } else {
            delete fields[key];
          }
        }
        return fields;
      };
      if (typeof fields === "object") {
        if (fields instanceof Map) {
          for (const field of new Map(fields)) {
            fields = translate(field[0], field[1]);
          }
        } else {
          for (const key of Object.keys(fields)) {
            fields = translate(key, fields[key]);
            if (key[0] === "$") {
              if (Array.isArray(fields[key])) {
                for (const i in fields[key]) {
                  fields[key][i] = this.translateAliases(fields[key][i]);
                }
              }
            }
          }
        }
        return fields;
      } else {
        return fields;
      }
    };
    Model.remove = function remove(conditions, options2, callback) {
      _checkContext(this, "remove");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options2 = null;
      } else if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options2);
      callback = this.$handleCallbackError(callback);
      return mq.remove(conditions, callback);
    };
    Model.deleteOne = function deleteOne(conditions, options2, callback) {
      _checkContext(this, "deleteOne");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options2 = null;
      } else if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options2);
      callback = this.$handleCallbackError(callback);
      return mq.deleteOne(conditions, callback);
    };
    Model.deleteMany = function deleteMany(conditions, options2, callback) {
      _checkContext(this, "deleteMany");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options2 = null;
      } else if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options2);
      callback = this.$handleCallbackError(callback);
      return mq.deleteMany(conditions, callback);
    };
    Model.find = function find(conditions, projection, options2, callback) {
      _checkContext(this, "find");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        projection = null;
        options2 = null;
      } else if (typeof projection === "function") {
        callback = projection;
        projection = null;
        options2 = null;
      } else if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(projection);
      mq.setOptions(options2);
      if (this.schema.discriminatorMapping && this.schema.discriminatorMapping.isRoot && mq.selectedInclusively()) {
        mq.select(this.schema.options.discriminatorKey);
      }
      callback = this.$handleCallbackError(callback);
      return mq.find(conditions, callback);
    };
    Model.findById = function findById(id, projection, options2, callback) {
      _checkContext(this, "findById");
      if (typeof id === "undefined") {
        id = null;
      }
      callback = this.$handleCallbackError(callback);
      return this.findOne({ _id: id }, projection, options2, callback);
    };
    Model.findOne = function findOne(conditions, projection, options2, callback) {
      _checkContext(this, "findOne");
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      } else if (typeof projection === "function") {
        callback = projection;
        projection = null;
        options2 = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        projection = null;
        options2 = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(projection);
      mq.setOptions(options2);
      if (this.schema.discriminatorMapping && this.schema.discriminatorMapping.isRoot && mq.selectedInclusively()) {
        mq.select(this.schema.options.discriminatorKey);
      }
      callback = this.$handleCallbackError(callback);
      return mq.findOne(conditions, callback);
    };
    Model.estimatedDocumentCount = function estimatedDocumentCount(options2, callback) {
      _checkContext(this, "estimatedDocumentCount");
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.estimatedDocumentCount(options2, callback);
    };
    Model.countDocuments = function countDocuments(conditions, callback) {
      _checkContext(this, "countDocuments");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.countDocuments(conditions, callback);
    };
    Model.count = function count(conditions, callback) {
      _checkContext(this, "count");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.count(conditions, callback);
    };
    Model.distinct = function distinct(field, conditions, callback) {
      _checkContext(this, "distinct");
      const mq = new this.Query({}, {}, this, this.$__collection);
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      callback = this.$handleCallbackError(callback);
      return mq.distinct(field, conditions, callback);
    };
    Model.where = function where(path, val) {
      _checkContext(this, "where");
      void 0;
      const mq = new this.Query({}, {}, this, this.$__collection).find({});
      return mq.where.apply(mq, arguments);
    };
    Model.$where = function $where() {
      _checkContext(this, "$where");
      const mq = new this.Query({}, {}, this, this.$__collection).find({});
      return mq.$where.apply(mq, arguments);
    };
    Model.findOneAndUpdate = function(conditions, update, options2, callback) {
      _checkContext(this, "findOneAndUpdate");
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      } else if (arguments.length === 1) {
        if (typeof conditions === "function") {
          const msg = "Model.findOneAndUpdate(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndUpdate(conditions, update, options, callback)\n  " + this.modelName + ".findOneAndUpdate(conditions, update, options)\n  " + this.modelName + ".findOneAndUpdate(conditions, update)\n  " + this.modelName + ".findOneAndUpdate(update)\n  " + this.modelName + ".findOneAndUpdate()\n";
          throw new TypeError(msg);
        }
        update = conditions;
        conditions = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options2) {
        fields = options2.fields || options2.projection;
      }
      update = utils2.clone(update, {
        depopulate: true,
        _isNested: true
      });
      _decorateUpdateWithVersionKey(update, options2, this.schema.options.versionKey);
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndUpdate(conditions, update, options2, callback);
    };
    function _decorateUpdateWithVersionKey(update, options2, versionKey) {
      if (!versionKey || !get2(options2, "upsert", false)) {
        return;
      }
      const updatedPaths = modifiedPaths(update);
      if (!updatedPaths[versionKey]) {
        if (options2.overwrite) {
          update[versionKey] = 0;
        } else {
          if (!update.$setOnInsert) {
            update.$setOnInsert = {};
          }
          update.$setOnInsert[versionKey] = 0;
        }
      }
    }
    Model.findByIdAndUpdate = function(id, update, options2, callback) {
      _checkContext(this, "findByIdAndUpdate");
      callback = this.$handleCallbackError(callback);
      if (arguments.length === 1) {
        if (typeof id === "function") {
          const msg = "Model.findByIdAndUpdate(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndUpdate(id, callback)\n  " + this.modelName + ".findByIdAndUpdate(id)\n  " + this.modelName + ".findByIdAndUpdate()\n";
          throw new TypeError(msg);
        }
        return this.findOneAndUpdate({ _id: id }, void 0);
      }
      if (id instanceof Document) {
        id = id._id;
      }
      return this.findOneAndUpdate.call(this, { _id: id }, update, options2, callback);
    };
    Model.findOneAndDelete = function(conditions, options2, callback) {
      _checkContext(this, "findOneAndDelete");
      if (arguments.length === 1 && typeof conditions === "function") {
        const msg = "Model.findOneAndDelete(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndDelete(conditions, callback)\n  " + this.modelName + ".findOneAndDelete(conditions)\n  " + this.modelName + ".findOneAndDelete()\n";
        throw new TypeError(msg);
      }
      if (typeof options2 === "function") {
        callback = options2;
        options2 = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options2) {
        fields = options2.select;
        options2.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndDelete(conditions, options2, callback);
    };
    Model.findByIdAndDelete = function(id, options2, callback) {
      _checkContext(this, "findByIdAndDelete");
      if (arguments.length === 1 && typeof id === "function") {
        const msg = "Model.findByIdAndDelete(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndDelete(id, callback)\n  " + this.modelName + ".findByIdAndDelete(id)\n  " + this.modelName + ".findByIdAndDelete()\n";
        throw new TypeError(msg);
      }
      callback = this.$handleCallbackError(callback);
      return this.findOneAndDelete({ _id: id }, options2, callback);
    };
    Model.findOneAndReplace = function(filter, replacement, options2, callback) {
      _checkContext(this, "findOneAndReplace");
      if (arguments.length === 1 && typeof filter === "function") {
        const msg = "Model.findOneAndReplace(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndReplace(conditions, callback)\n  " + this.modelName + ".findOneAndReplace(conditions)\n  " + this.modelName + ".findOneAndReplace()\n";
        throw new TypeError(msg);
      }
      if (arguments.length === 3 && typeof options2 === "function") {
        callback = options2;
        options2 = replacement;
        replacement = void 0;
      }
      if (arguments.length === 2 && typeof replacement === "function") {
        callback = replacement;
        replacement = void 0;
        options2 = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options2) {
        fields = options2.select;
        options2.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndReplace(filter, replacement, options2, callback);
    };
    Model.findOneAndRemove = function(conditions, options2, callback) {
      _checkContext(this, "findOneAndRemove");
      if (arguments.length === 1 && typeof conditions === "function") {
        const msg = "Model.findOneAndRemove(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndRemove(conditions, callback)\n  " + this.modelName + ".findOneAndRemove(conditions)\n  " + this.modelName + ".findOneAndRemove()\n";
        throw new TypeError(msg);
      }
      if (typeof options2 === "function") {
        callback = options2;
        options2 = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options2) {
        fields = options2.select;
        options2.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndRemove(conditions, options2, callback);
    };
    Model.findByIdAndRemove = function(id, options2, callback) {
      _checkContext(this, "findByIdAndRemove");
      if (arguments.length === 1 && typeof id === "function") {
        const msg = "Model.findByIdAndRemove(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndRemove(id, callback)\n  " + this.modelName + ".findByIdAndRemove(id)\n  " + this.modelName + ".findByIdAndRemove()\n";
        throw new TypeError(msg);
      }
      callback = this.$handleCallbackError(callback);
      return this.findOneAndRemove({ _id: id }, options2, callback);
    };
    Model.create = function create(doc, options2, callback) {
      _checkContext(this, "create");
      let args;
      let cb;
      const discriminatorKey = this.schema.options.discriminatorKey;
      if (Array.isArray(doc)) {
        args = doc;
        cb = typeof options2 === "function" ? options2 : callback;
        options2 = options2 != null && typeof options2 === "object" ? options2 : {};
      } else {
        const last = arguments[arguments.length - 1];
        options2 = {};
        if (typeof last === "function" || arguments.length > 1 && !last) {
          cb = last;
          args = utils2.args(arguments, 0, arguments.length - 1);
        } else {
          args = utils2.args(arguments);
        }
        if (args.length === 2 && args[0] != null && args[1] != null && args[0].session == null && last.session != null && last.session.constructor.name === "ClientSession" && !this.schema.path("session")) {
          console.warn("WARNING: to pass a `session` to `Model.create()` in Mongoose, you **must** pass an array as the first argument. See: https://mongoosejs.com/docs/api.html#model_Model.create");
        }
      }
      return this.db.base._promiseOrCallback(cb, (cb2) => {
        cb2 = this.$wrapCallback(cb2);
        if (args.length === 0) {
          return cb2(null);
        }
        const toExecute = [];
        let firstError;
        args.forEach((doc2) => {
          toExecute.push((callback2) => {
            const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
            if (Model2 == null) {
              throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not found for model "${this.modelName}"`);
            }
            let toSave = doc2;
            const callbackWrapper = (error2, doc3) => {
              if (error2) {
                if (!firstError) {
                  firstError = error2;
                }
                return callback2(null, { error: error2 });
              }
              callback2(null, { doc: doc3 });
            };
            if (!(toSave instanceof Model2)) {
              try {
                toSave = new Model2(toSave);
              } catch (error2) {
                return callbackWrapper(error2);
              }
            }
            toSave.save(options2, callbackWrapper);
          });
        });
        let numFns = toExecute.length;
        if (numFns === 0) {
          return cb2(null, []);
        }
        const _done = (error2, res) => {
          const savedDocs = [];
          const len = res.length;
          for (let i = 0; i < len; ++i) {
            if (res[i].doc) {
              savedDocs.push(res[i].doc);
            }
          }
          if (firstError) {
            return cb2(firstError, savedDocs);
          }
          if (doc instanceof Array) {
            cb2(null, savedDocs);
          } else {
            cb2.apply(this, [null].concat(savedDocs));
          }
        };
        const _res = [];
        toExecute.forEach((fn, i) => {
          fn((err, res) => {
            _res[i] = res;
            if (--numFns <= 0) {
              return _done(null, _res);
            }
          });
        });
      }, this.events);
    };
    Model.watch = function(pipeline2, options2) {
      _checkContext(this, "watch");
      const changeStreamThunk = (cb) => {
        if (this.$__collection.buffer) {
          this.$__collection.addQueue(() => {
            if (this.closed) {
              return;
            }
            const driverChangeStream = this.$__collection.watch(pipeline2, options2);
            cb(null, driverChangeStream);
          });
        } else {
          const driverChangeStream = this.$__collection.watch(pipeline2, options2);
          cb(null, driverChangeStream);
        }
      };
      return new ChangeStream(changeStreamThunk, pipeline2, options2);
    };
    Model.startSession = function() {
      _checkContext(this, "startSession");
      return this.db.startSession.apply(this.db, arguments);
    };
    Model.insertMany = function(arr, options2, callback) {
      _checkContext(this, "insertMany");
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      return this.db.base._promiseOrCallback(callback, (cb) => {
        this.$__insertMany(arr, options2, cb);
      }, this.events);
    };
    Model.$__insertMany = function(arr, options2, callback) {
      const _this = this;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (callback) {
        callback = this.$handleCallbackError(callback);
        callback = this.$wrapCallback(callback);
      }
      callback = callback || utils2.noop;
      options2 = options2 || {};
      const limit = get2(options2, "limit", 1e3);
      const rawResult = get2(options2, "rawResult", false);
      const ordered = get2(options2, "ordered", true);
      const lean = get2(options2, "lean", false);
      if (!Array.isArray(arr)) {
        arr = [arr];
      }
      const validationErrors = [];
      const toExecute = arr.map((doc) => (callback2) => {
        if (!(doc instanceof _this)) {
          try {
            doc = new _this(doc);
          } catch (err) {
            return callback2(err);
          }
        }
        if (options2.session != null) {
          doc.$session(options2.session);
        }
        if (lean) {
          return immediate(() => callback2(null, doc));
        }
        doc.validate({ __noPromise: true }, function(error2) {
          if (error2) {
            if (ordered === false) {
              validationErrors.push(error2);
              return callback2(null, null);
            }
            return callback2(error2);
          }
          callback2(null, doc);
        });
      });
      parallelLimit(toExecute, limit, function(error2, docs) {
        if (error2) {
          callback(error2, null);
          return;
        }
        const docAttributes = docs.filter(function(doc) {
          return doc != null;
        });
        if (docAttributes.length < 1) {
          if (rawResult) {
            const res = {
              mongoose: {
                validationErrors
              }
            };
            return callback(null, res);
          }
          callback(null, []);
          return;
        }
        const docObjects = docAttributes.map(function(doc) {
          if (doc.$__schema.options.versionKey) {
            doc[doc.$__schema.options.versionKey] = 0;
          }
          if (doc.initializeTimestamps) {
            return doc.initializeTimestamps().toObject(internalToObjectOptions);
          }
          return doc.toObject(internalToObjectOptions);
        });
        _this.$__collection.insertMany(docObjects, options2, function(error3, res) {
          if (error3) {
            if (error3.writeErrors == null && get2(error3, "result.result.writeErrors") != null) {
              error3.writeErrors = error3.result.result.writeErrors;
            }
            const erroredIndexes = new Set(get2(error3, "writeErrors", []).map((err) => err.index));
            let firstErroredIndex = -1;
            error3.insertedDocs = docAttributes.filter((doc, i) => {
              const isErrored = erroredIndexes.has(i);
              if (ordered) {
                if (firstErroredIndex > -1) {
                  return i < firstErroredIndex;
                }
                if (isErrored) {
                  firstErroredIndex = i;
                }
              }
              return !isErrored;
            }).map(function setIsNewForInsertedDoc(doc) {
              doc.$__reset();
              _setIsNew(doc, false);
              return doc;
            });
            callback(error3, null);
            return;
          }
          for (const attribute of docAttributes) {
            attribute.$__reset();
            _setIsNew(attribute, false);
          }
          if (rawResult) {
            if (ordered === false) {
              res.mongoose = {
                validationErrors
              };
            }
            return callback(null, res);
          }
          if (options2.populate != null) {
            return _this.populate(docAttributes, options2.populate, (err) => {
              if (err != null) {
                error3.insertedDocs = docAttributes;
                return callback(err);
              }
              callback(null, docs);
            });
          }
          callback(null, docAttributes);
        });
      });
    };
    function _setIsNew(doc, val) {
      doc.isNew = val;
      doc.emit("isNew", val);
      doc.constructor.emit("isNew", val);
      const subdocs = doc.$getAllSubdocs();
      for (const subdoc of subdocs) {
        subdoc.isNew = val;
      }
    }
    Model.bulkWrite = function(ops, options2, callback) {
      _checkContext(this, "bulkWrite");
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      options2 = options2 || {};
      const validations = ops.map((op) => castBulkWrite(this, op, options2));
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        each2(validations, (fn, cb2) => fn(cb2), (error2) => {
          if (error2) {
            return cb(error2);
          }
          if (ops.length === 0) {
            return cb(null, getDefaultBulkwriteResult());
          }
          this.$__collection.bulkWrite(ops, options2, (error3, res) => {
            if (error3) {
              return cb(error3);
            }
            cb(null, res);
          });
        });
      }, this.events);
    };
    Model.bulkSave = function(documents) {
      const preSavePromises = documents.map(buildPreSavePromise);
      const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true });
      let bulkWriteResultPromise;
      return Promise.all(preSavePromises).then(() => bulkWriteResultPromise = this.bulkWrite(writeOperations)).then(() => documents.map(buildSuccessfulWriteHandlerPromise)).then(() => bulkWriteResultPromise).catch((err) => {
        if (!get2(err, "writeErrors.length")) {
          throw err;
        }
        return Promise.all(documents.map((document2) => {
          const documentError = err.writeErrors.find((writeError) => {
            const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;
            return writeErrorDocumentId.toString() === document2._id.toString();
          });
          if (documentError == null) {
            return buildSuccessfulWriteHandlerPromise(document2);
          }
        })).then(() => {
          throw err;
        });
      });
    };
    function buildPreSavePromise(document2) {
      return new Promise((resolve2, reject) => {
        document2.schema.s.hooks.execPre("save", document2, (err) => {
          if (err) {
            reject(err);
            return;
          }
          resolve2();
        });
      });
    }
    function buildSuccessfulWriteHandlerPromise(document2) {
      return new Promise((resolve2, reject) => {
        handleSuccessfulWrite(document2, resolve2, reject);
      });
    }
    function handleSuccessfulWrite(document2, resolve2, reject) {
      if (document2.isNew) {
        _setIsNew(document2, false);
      }
      document2.$__reset();
      document2.schema.s.hooks.execPost("save", document2, {}, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve2();
      });
    }
    Model.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options2) {
      if (!Array.isArray(documents)) {
        throw new Error(`bulkSave expects an array of documents to be passed, received \`${documents}\` instead`);
      }
      setDefaultOptions();
      const writeOperations = documents.reduce((accumulator, document2, i) => {
        if (!options2.skipValidation) {
          if (!(document2 instanceof Document)) {
            throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);
          }
          const validationError = document2.validateSync();
          if (validationError) {
            throw validationError;
          }
        }
        const isANewDocument = document2.isNew;
        if (isANewDocument) {
          accumulator.push({
            insertOne: { document: document2 }
          });
          return accumulator;
        }
        const delta = document2.$__delta();
        const isDocumentWithChanges = delta != null && !utils2.isEmptyObject(delta[0]);
        if (isDocumentWithChanges) {
          const where = document2.$__where(delta[0]);
          const changes = delta[1];
          _applyCustomWhere(document2, where);
          document2.$__version(where, delta);
          accumulator.push({
            updateOne: {
              filter: where,
              update: changes
            }
          });
          return accumulator;
        }
        return accumulator;
      }, []);
      return writeOperations;
      function setDefaultOptions() {
        options2 = options2 || {};
        if (options2.skipValidation == null) {
          options2.skipValidation = false;
        }
      }
    };
    Model.hydrate = function(obj, projection) {
      _checkContext(this, "hydrate");
      const model = require_queryhelpers().createModel(this, obj, projection);
      model.init(obj);
      return model;
    };
    Model.update = function update(conditions, doc, options2, callback) {
      _checkContext(this, "update");
      return _update(this, "update", conditions, doc, options2, callback);
    };
    Model.updateMany = function updateMany(conditions, doc, options2, callback) {
      _checkContext(this, "updateMany");
      return _update(this, "updateMany", conditions, doc, options2, callback);
    };
    Model.updateOne = function updateOne(conditions, doc, options2, callback) {
      _checkContext(this, "updateOne");
      return _update(this, "updateOne", conditions, doc, options2, callback);
    };
    Model.replaceOne = function replaceOne(conditions, doc, options2, callback) {
      _checkContext(this, "replaceOne");
      const versionKey = get2(this, "schema.options.versionKey", null);
      if (versionKey && !doc[versionKey]) {
        doc[versionKey] = 0;
      }
      return _update(this, "replaceOne", conditions, doc, options2, callback);
    };
    function _update(model, op, conditions, doc, options2, callback) {
      const mq = new model.Query({}, {}, model, model.collection);
      callback = model.$handleCallbackError(callback);
      if (conditions instanceof Document) {
        conditions = conditions.toObject();
      } else {
        conditions = utils2.clone(conditions);
      }
      options2 = typeof options2 === "function" ? options2 : utils2.clone(options2);
      const versionKey = get2(model, "schema.options.versionKey", null);
      _decorateUpdateWithVersionKey(doc, options2, versionKey);
      return mq[op](conditions, doc, options2, callback);
    }
    Model.mapReduce = function mapReduce(o, callback) {
      _checkContext(this, "mapReduce");
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        if (!Model.mapReduce.schema) {
          const opts = { noId: true, noVirtualId: true, strict: false };
          Model.mapReduce.schema = new Schema({}, opts);
        }
        if (!o.out)
          o.out = { inline: 1 };
        if (o.verbose !== false)
          o.verbose = true;
        o.map = String(o.map);
        o.reduce = String(o.reduce);
        if (o.query) {
          let q = new this.Query(o.query);
          q.cast(this);
          o.query = q._conditions;
          q = void 0;
        }
        this.$__collection.mapReduce(null, null, o, (err, res) => {
          if (err) {
            return cb(err);
          }
          if (res.collection) {
            const model = Model.compile("_mapreduce_" + res.collection.collectionName, Model.mapReduce.schema, res.collection.collectionName, this.db, this.base);
            model._mapreduce = true;
            res.model = model;
            return cb(null, res);
          }
          cb(null, res);
        });
      }, this.events);
    };
    Model.aggregate = function aggregate(pipeline2, callback) {
      _checkContext(this, "aggregate");
      if (arguments.length > 2 || get2(pipeline2, "constructor.name") === "Object") {
        throw new MongooseError("Mongoose 5.x disallows passing a spread of operators to `Model.aggregate()`. Instead of `Model.aggregate({ $match }, { $skip })`, do `Model.aggregate([{ $match }, { $skip }])`");
      }
      if (typeof pipeline2 === "function") {
        callback = pipeline2;
        pipeline2 = [];
      }
      const aggregate2 = new Aggregate(pipeline2 || []);
      aggregate2.model(this);
      if (typeof callback === "undefined") {
        return aggregate2;
      }
      callback = this.$handleCallbackError(callback);
      callback = this.$wrapCallback(callback);
      aggregate2.exec(callback);
      return aggregate2;
    };
    Model.validate = function validate(obj, pathsToValidate, context, callback) {
      if (arguments.length < 3 || arguments.length === 3 && typeof arguments[2] === "function") {
        context = obj;
      }
      return this.db.base._promiseOrCallback(callback, (cb) => {
        const schema = this.schema;
        let paths = Object.keys(schema.paths);
        if (pathsToValidate != null) {
          const _pathsToValidate = new Set(pathsToValidate);
          paths = paths.filter((p) => {
            const pieces = p.split(".");
            let cur = pieces[0];
            for (const piece of pieces) {
              if (_pathsToValidate.has(cur)) {
                return true;
              }
              cur += "." + piece;
            }
            return _pathsToValidate.has(p);
          });
        }
        for (const path of paths) {
          const schemaType = schema.path(path);
          if (!schemaType || !schemaType.$isMongooseArray) {
            continue;
          }
          const val = get2(obj, path);
          pushNestedArrayPaths(val, path);
        }
        let remaining = paths.length;
        let error2 = null;
        for (const path of paths) {
          const schemaType = schema.path(path);
          if (schemaType == null) {
            _checkDone();
            continue;
          }
          const pieces = path.split(".");
          let cur = obj;
          for (let i = 0; i < pieces.length - 1; ++i) {
            cur = cur[pieces[i]];
          }
          let val = get2(obj, path, void 0);
          if (val != null) {
            try {
              val = schemaType.cast(val);
              cur[pieces[pieces.length - 1]] = val;
            } catch (err) {
              error2 = error2 || new ValidationError();
              error2.addError(path, err);
              _checkDone();
              continue;
            }
          }
          schemaType.doValidate(val, (err) => {
            if (err) {
              error2 = error2 || new ValidationError();
              if (err instanceof ValidationError) {
                for (const _err of Object.keys(err.errors)) {
                  error2.addError(`${path}.${err.errors[_err].path}`, _err);
                }
              } else {
                error2.addError(err.path, err);
              }
            }
            _checkDone();
          }, context, { path });
        }
        function pushNestedArrayPaths(nestedArray, path) {
          if (nestedArray == null) {
            return;
          }
          for (let i = 0; i < nestedArray.length; ++i) {
            if (Array.isArray(nestedArray[i])) {
              pushNestedArrayPaths(nestedArray[i], path + "." + i);
            } else {
              paths.push(path + "." + i);
            }
          }
        }
        function _checkDone() {
          if (--remaining <= 0) {
            return cb(error2);
          }
        }
      });
    };
    Model.geoSearch = function(conditions, options2, callback) {
      _checkContext(this, "geoSearch");
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        let error2;
        if (conditions === void 0 || !utils2.isObject(conditions)) {
          error2 = new MongooseError("Must pass conditions to geoSearch");
        } else if (!options2.near) {
          error2 = new MongooseError("Must specify the near option in geoSearch");
        } else if (!Array.isArray(options2.near)) {
          error2 = new MongooseError("near option must be an array [x, y]");
        }
        if (error2) {
          return cb(error2);
        }
        options2.search = conditions;
        this.$__collection.geoHaystackSearch(options2.near[0], options2.near[1], options2, (err, res) => {
          if (err) {
            return cb(err);
          }
          let count = res.results.length;
          if (options2.lean || count === 0) {
            return cb(null, res.results);
          }
          const errSeen = false;
          function init2(err2) {
            if (err2 && !errSeen) {
              return cb(err2);
            }
            if (!--count && !errSeen) {
              cb(null, res.results);
            }
          }
          for (let i = 0; i < res.results.length; ++i) {
            const temp = res.results[i];
            res.results[i] = new this();
            res.results[i].init(temp, {}, init2);
          }
        });
      }, this.events);
    };
    Model.populate = function(docs, paths, callback) {
      _checkContext(this, "populate");
      const _this = this;
      paths = utils2.populate(paths);
      const cache = {};
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        _populate(_this, docs, paths, cache, cb);
      }, this.events);
    };
    function _populate(model, docs, paths, cache, callback) {
      let pending = paths.length;
      if (paths.length === 0) {
        return callback(null, docs);
      }
      for (const path of paths) {
        populate(model, docs, path, next);
      }
      function next(err) {
        if (err) {
          return callback(err, null);
        }
        if (--pending) {
          return;
        }
        callback(null, docs);
      }
    }
    var excludeIdReg = /\s?-_id\s?/;
    var excludeIdRegGlobal = /\s?-_id\s?/g;
    function populate(model, docs, options2, callback) {
      if (!Array.isArray(docs)) {
        docs = [docs];
      }
      if (docs.length === 0 || docs.every(utils2.isNullOrUndefined)) {
        return callback();
      }
      const modelsMap = getModelsMapForPopulate(model, docs, options2);
      if (modelsMap instanceof MongooseError) {
        return immediate(function() {
          callback(modelsMap);
        });
      }
      const len = modelsMap.length;
      let vals = [];
      function flatten(item) {
        return item !== void 0;
      }
      let _remaining = len;
      let hasOne = false;
      const params = [];
      for (let i = 0; i < len; ++i) {
        const mod = modelsMap[i];
        let select = mod.options.select;
        let ids = utils2.array.flatten(mod.ids, flatten);
        ids = utils2.array.unique(ids);
        const assignmentOpts = {};
        assignmentOpts.sort = get2(mod, "options.options.sort", void 0);
        assignmentOpts.excludeId = excludeIdReg.test(select) || select && select._id === 0;
        if (ids.length === 0 || ids.every(utils2.isNullOrUndefined)) {
          --_remaining;
          if (mod.count || mod.isVirtual) {
            _assign(model, [], mod, assignmentOpts);
          }
          continue;
        }
        hasOne = true;
        const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);
        if (assignmentOpts.excludeId) {
          if (typeof select === "string") {
            select = select.replace(excludeIdRegGlobal, " ");
          } else {
            select = utils2.object.shallowCopy(select);
            delete select._id;
          }
        }
        if (mod.options.options && mod.options.options.limit != null) {
          assignmentOpts.originalLimit = mod.options.options.limit;
        } else if (mod.options.limit != null) {
          assignmentOpts.originalLimit = mod.options.limit;
        }
        params.push([mod, match, select, assignmentOpts, _next]);
      }
      if (!hasOne) {
        if (options2.populate != null) {
          const opts = utils2.populate(options2.populate).map((pop) => Object.assign({}, pop, {
            path: options2.path + "." + pop.path
          }));
          return model.populate(docs, opts, callback);
        }
        return callback();
      }
      for (const arr of params) {
        _execPopulateQuery.apply(null, arr);
      }
      function _next(err, valsFromDb) {
        if (err != null) {
          return callback(err, null);
        }
        vals = vals.concat(valsFromDb);
        if (--_remaining === 0) {
          _done();
        }
      }
      function _done() {
        for (const arr of params) {
          const mod = arr[0];
          const assignmentOpts = arr[3];
          for (const val of vals) {
            mod.options._childDocs.push(val);
          }
          _assign(model, vals, mod, assignmentOpts);
        }
        for (const arr of params) {
          removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);
        }
        callback();
      }
    }
    function _execPopulateQuery(mod, match, select, assignmentOpts, callback) {
      const subPopulate = utils2.clone(mod.options.populate);
      const queryOptions = Object.assign({
        skip: mod.options.skip,
        limit: mod.options.limit,
        perDocumentLimit: mod.options.perDocumentLimit
      }, mod.options.options);
      if (mod.count) {
        delete queryOptions.skip;
      }
      if (queryOptions.perDocumentLimit != null) {
        queryOptions.limit = queryOptions.perDocumentLimit;
        delete queryOptions.perDocumentLimit;
      } else if (queryOptions.limit != null) {
        queryOptions.limit = queryOptions.limit * mod.ids.length;
      }
      const query = mod.model.find(match, select, queryOptions);
      for (const foreignField of mod.foreignField) {
        if (foreignField !== "_id" && query.selectedInclusively() && !isPathSelectedInclusive(query._fields, foreignField)) {
          query.select(foreignField);
        }
      }
      if (mod.count) {
        for (const foreignField of mod.foreignField) {
          query.select(foreignField);
        }
      }
      if (subPopulate) {
        query.populate(subPopulate);
      }
      query.exec((err, docs) => {
        if (err != null) {
          return callback(err);
        }
        for (const val of docs) {
          leanPopulateMap.set(val, mod.model);
        }
        callback(null, docs);
      });
    }
    function _assign(model, vals, mod, assignmentOpts) {
      const options2 = mod.options;
      const isVirtual = mod.isVirtual;
      const justOne = mod.justOne;
      let _val;
      const lean = get2(options2, "options.lean", false);
      const len = vals.length;
      const rawOrder = {};
      const rawDocs = {};
      let key;
      let val;
      const allIds = utils2.clone(mod.allIds);
      for (let i = 0; i < len; i++) {
        val = vals[i];
        if (val == null) {
          continue;
        }
        for (const foreignField of mod.foreignField) {
          _val = utils2.getValue(foreignField, val);
          if (Array.isArray(_val)) {
            _val = utils2.array.unique(utils2.array.flatten(_val));
            for (let __val of _val) {
              if (__val instanceof Document) {
                __val = __val._id;
              }
              key = String(__val);
              if (rawDocs[key]) {
                if (Array.isArray(rawDocs[key])) {
                  rawDocs[key].push(val);
                  rawOrder[key].push(i);
                } else {
                  rawDocs[key] = [rawDocs[key], val];
                  rawOrder[key] = [rawOrder[key], i];
                }
              } else {
                if (isVirtual && !justOne) {
                  rawDocs[key] = [val];
                  rawOrder[key] = [i];
                } else {
                  rawDocs[key] = val;
                  rawOrder[key] = i;
                }
              }
            }
          } else {
            if (_val instanceof Document) {
              _val = _val._id;
            }
            key = String(_val);
            if (rawDocs[key]) {
              if (Array.isArray(rawDocs[key])) {
                rawDocs[key].push(val);
                rawOrder[key].push(i);
              } else if (isVirtual || rawDocs[key].constructor !== val.constructor || String(rawDocs[key]._id) !== String(val._id)) {
                rawDocs[key] = [rawDocs[key], val];
                rawOrder[key] = [rawOrder[key], i];
              }
            } else {
              rawDocs[key] = val;
              rawOrder[key] = i;
            }
          }
          if (!lean) {
            val.$__.wasPopulated = true;
          }
        }
      }
      assignVals({
        originalModel: model,
        rawIds: mod.isVirtual ? allIds : mod.allIds,
        allIds,
        foreignField: mod.foreignField,
        rawDocs,
        rawOrder,
        docs: mod.docs,
        path: options2.path,
        options: assignmentOpts,
        justOne: mod.justOne,
        isVirtual: mod.isVirtual,
        allOptions: mod,
        populatedModel: mod.model,
        lean,
        virtual: mod.virtual,
        count: mod.count,
        match: mod.match
      });
    }
    Model.compile = function compile(name, schema, collectionName, connection, base) {
      const versioningEnabled = schema.options.versionKey !== false;
      if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
        const o = {};
        o[schema.options.versionKey] = Number;
        schema.add(o);
      }
      let model;
      if (typeof name === "function" && name.prototype instanceof Model) {
        model = name;
        name = model.name;
        schema.loadClass(model, false);
        model.prototype.$isMongooseModelPrototype = true;
      } else {
        model = function model2(doc, fields, skipId) {
          model2.hooks.execPreSync("createModel", doc);
          if (!(this instanceof model2)) {
            return new model2(doc, fields, skipId);
          }
          const discriminatorKey = model2.schema.options.discriminatorKey;
          if (model2.discriminators == null || doc == null || doc[discriminatorKey] == null) {
            Model.call(this, doc, fields, skipId);
            return;
          }
          const Discriminator = model2.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(model2.discriminators, doc[discriminatorKey]);
          if (Discriminator != null) {
            return new Discriminator(doc, fields, skipId);
          }
          Model.call(this, doc, fields, skipId);
        };
      }
      model.hooks = schema.s.hooks.clone();
      model.base = base;
      model.modelName = name;
      if (!(model.prototype instanceof Model)) {
        model.__proto__ = Model;
        model.prototype.__proto__ = Model.prototype;
      }
      model.model = function model2(name2) {
        return this.db.model(name2);
      };
      model.db = connection;
      model.prototype.db = connection;
      model.prototype[modelDbSymbol] = connection;
      model.discriminators = model.prototype.discriminators = void 0;
      model[modelSymbol] = true;
      model.events = new EventEmitter();
      model.prototype.$__setSchema(schema);
      const _userProvidedOptions = schema._userProvidedOptions || {};
      const collectionOptions = {
        schemaUserProvidedOptions: _userProvidedOptions,
        capped: schema.options.capped,
        Promise: model.base.Promise,
        modelName: name
      };
      if (schema.options.autoCreate !== void 0) {
        collectionOptions.autoCreate = schema.options.autoCreate;
      }
      model.prototype.collection = connection.collection(collectionName, collectionOptions);
      model.prototype[modelCollectionSymbol] = model.prototype.collection;
      applyMethods(model, schema);
      applyStatics(model, schema);
      applyHooks(model, schema);
      applyStaticHooks(model, schema.s.hooks, schema.statics);
      model.schema = model.prototype.$__schema;
      model.collection = model.prototype.collection;
      model.$__collection = model.collection;
      model.Query = function() {
        Query.apply(this, arguments);
      };
      model.Query.prototype = Object.create(Query.prototype);
      model.Query.base = Query.base;
      applyQueryMiddleware(model.Query, model);
      applyQueryMethods(model, schema.query);
      return model;
    };
    function applyQueryMethods(model, methods) {
      for (const i in methods) {
        model.Query.prototype[i] = methods[i];
      }
    }
    Model.__subclass = function subclass(conn, schema, collection) {
      const _this = this;
      const Model2 = function Model3(doc, fields, skipId) {
        if (!(this instanceof Model3)) {
          return new Model3(doc, fields, skipId);
        }
        _this.call(this, doc, fields, skipId);
      };
      Model2.__proto__ = _this;
      Model2.prototype.__proto__ = _this.prototype;
      Model2.db = conn;
      Model2.prototype.db = conn;
      Model2.prototype[modelDbSymbol] = conn;
      _this[subclassedSymbol] = _this[subclassedSymbol] || [];
      _this[subclassedSymbol].push(Model2);
      if (_this.discriminators != null) {
        Model2.discriminators = {};
        for (const key of Object.keys(_this.discriminators)) {
          Model2.discriminators[key] = _this.discriminators[key].__subclass(_this.db, _this.discriminators[key].schema, collection);
        }
      }
      const s2 = schema && typeof schema !== "string" ? schema : _this.prototype.$__schema;
      const options2 = s2.options || {};
      const _userProvidedOptions = s2._userProvidedOptions || {};
      if (!collection) {
        collection = _this.prototype.$__schema.get("collection") || utils2.toCollectionName(_this.modelName, this.base.pluralize());
      }
      const collectionOptions = {
        schemaUserProvidedOptions: _userProvidedOptions,
        capped: s2 && options2.capped
      };
      Model2.prototype.collection = conn.collection(collection, collectionOptions);
      Model2.prototype[modelCollectionSymbol] = Model2.prototype.collection;
      Model2.collection = Model2.prototype.collection;
      Model2.$__collection = Model2.collection;
      Model2.init(() => {
      });
      return Model2;
    };
    Model.$handleCallbackError = function(callback) {
      if (callback == null) {
        return callback;
      }
      if (typeof callback !== "function") {
        throw new MongooseError("Callback must be a function, got " + callback);
      }
      const _this = this;
      return function() {
        immediate(() => {
          try {
            callback.apply(null, arguments);
          } catch (error2) {
            _this.emit("error", error2);
          }
        });
      };
    };
    Model.$wrapCallback = function(callback) {
      const serverSelectionError = new ServerSelectionError();
      const _this = this;
      return function(err) {
        if (err != null && err.name === "MongoServerSelectionError") {
          arguments[0] = serverSelectionError.assimilateError(err);
        }
        if (err != null && err.name === "MongoNetworkTimeoutError" && err.message.endsWith("timed out")) {
          _this.db.emit("timeout");
        }
        return callback.apply(null, arguments);
      };
    };
    Model.inspect = function() {
      return `Model { ${this.modelName} }`;
    };
    if (util.inspect.custom) {
      Model[util.inspect.custom] = Model.inspect;
    }
    module2.exports = exports2 = Model;
  }
});

// node_modules/mongoose-legacy-pluralize/index.js
var require_mongoose_legacy_pluralize = __commonJS({
  "node_modules/mongoose-legacy-pluralize/index.js"(exports2, module2) {
    init_shims();
    module2.exports = pluralize;
    exports2.pluralization = [
      [/(m)an$/gi, "$1en"],
      [/(pe)rson$/gi, "$1ople"],
      [/(child)$/gi, "$1ren"],
      [/^(ox)$/gi, "$1en"],
      [/(ax|test)is$/gi, "$1es"],
      [/(octop|vir)us$/gi, "$1i"],
      [/(alias|status)$/gi, "$1es"],
      [/(bu)s$/gi, "$1ses"],
      [/(buffal|tomat|potat)o$/gi, "$1oes"],
      [/([ti])um$/gi, "$1a"],
      [/sis$/gi, "ses"],
      [/(?:([^f])fe|([lr])f)$/gi, "$1$2ves"],
      [/(hive)$/gi, "$1s"],
      [/([^aeiouy]|qu)y$/gi, "$1ies"],
      [/(x|ch|ss|sh)$/gi, "$1es"],
      [/(matr|vert|ind)ix|ex$/gi, "$1ices"],
      [/([m|l])ouse$/gi, "$1ice"],
      [/(kn|w|l)ife$/gi, "$1ives"],
      [/(quiz)$/gi, "$1zes"],
      [/s$/gi, "s"],
      [/([^a-z])$/, "$1"],
      [/$/gi, "s"]
    ];
    var rules = exports2.pluralization;
    exports2.uncountables = [
      "advice",
      "energy",
      "excretion",
      "digestion",
      "cooperation",
      "health",
      "justice",
      "labour",
      "machinery",
      "equipment",
      "information",
      "pollution",
      "sewage",
      "paper",
      "money",
      "species",
      "series",
      "rain",
      "rice",
      "fish",
      "sheep",
      "moose",
      "deer",
      "news",
      "expertise",
      "status",
      "media"
    ];
    var uncountables = exports2.uncountables;
    function pluralize(str) {
      var found;
      str = str.toLowerCase();
      if (!~uncountables.indexOf(str)) {
        found = rules.filter(function(rule) {
          return str.match(rule[0]);
        });
        if (found[0]) {
          return str.replace(found[0][0], found[0][1]);
        }
      }
      return str;
    }
  }
});

// node_modules/mongoose/lib/plugins/removeSubdocs.js
var require_removeSubdocs = __commonJS({
  "node_modules/mongoose/lib/plugins/removeSubdocs.js"(exports2, module2) {
    init_shims();
    "use strict";
    var each2 = require_each2();
    module2.exports = function(schema) {
      const unshift = true;
      schema.s.hooks.pre("remove", false, function(next) {
        if (this.ownerDocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        each2(subdocs, function(subdoc, cb) {
          subdoc.$__remove(cb);
        }, function(error2) {
          if (error2) {
            return _this.$__schema.s.hooks.execPost("remove:error", _this, [_this], { error: error2 }, function(error3) {
              next(error3);
            });
          }
          next();
        });
      }, null, unshift);
    };
  }
});

// node_modules/mongoose/lib/plugins/saveSubdocs.js
var require_saveSubdocs = __commonJS({
  "node_modules/mongoose/lib/plugins/saveSubdocs.js"(exports2, module2) {
    init_shims();
    "use strict";
    var each2 = require_each2();
    module2.exports = function(schema) {
      const unshift = true;
      schema.s.hooks.pre("save", false, function(next) {
        if (this.ownerDocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        if (!subdocs.length) {
          next();
          return;
        }
        each2(subdocs, function(subdoc, cb) {
          subdoc.$__schema.s.hooks.execPre("save", subdoc, function(err) {
            cb(err);
          });
        }, function(error2) {
          if (error2) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error: error2 }, function(error3) {
              next(error3);
            });
          }
          next();
        });
      }, null, unshift);
      schema.s.hooks.post("save", function(doc, next) {
        if (this.ownerDocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        if (!subdocs.length) {
          next();
          return;
        }
        each2(subdocs, function(subdoc, cb) {
          subdoc.$__schema.s.hooks.execPost("save", subdoc, [subdoc], function(err) {
            cb(err);
          });
        }, function(error2) {
          if (error2) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error: error2 }, function(error3) {
              next(error3);
            });
          }
          next();
        });
      }, null, unshift);
    };
  }
});

// node_modules/mongoose/lib/plugins/trackTransaction.js
var require_trackTransaction = __commonJS({
  "node_modules/mongoose/lib/plugins/trackTransaction.js"(exports2, module2) {
    init_shims();
    "use strict";
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var sessionNewDocuments = require_symbols().sessionNewDocuments;
    module2.exports = function trackTransaction(schema) {
      schema.pre("save", function() {
        const session = this.$session();
        if (session == null) {
          return;
        }
        if (session.transaction == null || session[sessionNewDocuments] == null) {
          return;
        }
        if (!session[sessionNewDocuments].has(this)) {
          const initialState = {};
          if (this.isNew) {
            initialState.isNew = true;
          }
          if (this.$__schema.options.versionKey) {
            initialState.versionKey = this.get(this.$__schema.options.versionKey);
          }
          initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.states.modify));
          initialState.atomics = _getAtomics(this);
          session[sessionNewDocuments].set(this, initialState);
        } else {
          const state = session[sessionNewDocuments].get(this);
          for (const path of Object.keys(this.$__.activePaths.states.modify)) {
            state.modifiedPaths.add(path);
          }
          state.atomics = _getAtomics(this, state.atomics);
        }
      });
    };
    function _getAtomics(doc, previous) {
      const pathToAtomics = new Map();
      previous = previous || new Map();
      const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));
      for (const path of pathsToCheck) {
        const val = doc.$__getValue(path);
        if (val != null && val instanceof Array && val.isMongooseDocumentArray && val.length && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length > 0) {
          const existing = previous.get(path) || {};
          pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
        }
      }
      const dirty = doc.$__dirty();
      for (const dirt of dirty) {
        const path = dirt.path;
        const val = dirt.value;
        if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length > 0) {
          const existing = previous.get(path) || {};
          pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
        }
      }
      return pathToAtomics;
    }
    function mergeAtomics(destination, source) {
      destination = destination || {};
      if (source.$pullAll != null) {
        destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);
      }
      if (source.$push != null) {
        destination.$push = destination.$push || {};
        destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);
      }
      if (source.$addToSet != null) {
        destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);
      }
      if (source.$set != null) {
        destination.$set = Object.assign(destination.$set || {}, source.$set);
      }
      return destination;
    }
  }
});

// node_modules/mongoose/lib/plugins/validateBeforeSave.js
var require_validateBeforeSave = __commonJS({
  "node_modules/mongoose/lib/plugins/validateBeforeSave.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(schema) {
      const unshift = true;
      schema.pre("save", false, function validateBeforeSave(next, options2) {
        const _this = this;
        if (this.ownerDocument) {
          return next();
        }
        const hasValidateBeforeSaveOption = options2 && typeof options2 === "object" && "validateBeforeSave" in options2;
        let shouldValidate;
        if (hasValidateBeforeSaveOption) {
          shouldValidate = !!options2.validateBeforeSave;
        } else {
          shouldValidate = this.$__schema.options.validateBeforeSave;
        }
        if (shouldValidate) {
          const hasValidateModifiedOnlyOption = options2 && typeof options2 === "object" && "validateModifiedOnly" in options2;
          const validateOptions = hasValidateModifiedOnlyOption ? { validateModifiedOnly: options2.validateModifiedOnly } : null;
          this.validate(validateOptions, function(error2) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error: error2 }, function(error3) {
              _this.$op = "save";
              next(error3);
            });
          });
        } else {
          next();
        }
      }, null, unshift);
    };
  }
});

// node_modules/mongoose/lib/plugins/sharding.js
var require_sharding = __commonJS({
  "node_modules/mongoose/lib/plugins/sharding.js"(exports2, module2) {
    init_shims();
    "use strict";
    var objectIdSymbol = require_symbols().objectIdSymbol;
    var utils2 = require_utils6();
    module2.exports = function shardingPlugin(schema) {
      schema.post("init", function() {
        storeShard.call(this);
        return this;
      });
      schema.pre("save", function(next) {
        applyWhere.call(this);
        next();
      });
      schema.pre("remove", function(next) {
        applyWhere.call(this);
        next();
      });
      schema.post("save", function() {
        storeShard.call(this);
      });
    };
    function applyWhere() {
      let paths;
      let len;
      if (this.$__.shardval) {
        paths = Object.keys(this.$__.shardval);
        len = paths.length;
        this.$where = this.$where || {};
        for (let i = 0; i < len; ++i) {
          this.$where[paths[i]] = this.$__.shardval[paths[i]];
        }
      }
    }
    module2.exports.storeShard = storeShard;
    function storeShard() {
      const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
      if (!utils2.isPOJO(key)) {
        return;
      }
      const orig = this.$__.shardval = {};
      const paths = Object.keys(key);
      const len = paths.length;
      let val;
      for (let i = 0; i < len; ++i) {
        val = this.$__getValue(paths[i]);
        if (val == null) {
          orig[paths[i]] = val;
        } else if (utils2.isMongooseObject(val)) {
          orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });
        } else if (val instanceof Date || val[objectIdSymbol]) {
          orig[paths[i]] = val;
        } else if (typeof val.valueOf === "function") {
          orig[paths[i]] = val.valueOf();
        } else {
          orig[paths[i]] = val;
        }
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/printJestWarning.js
var require_printJestWarning = __commonJS({
  "node_modules/mongoose/lib/helpers/printJestWarning.js"() {
    init_shims();
    "use strict";
    if (typeof jest !== "undefined" && typeof window !== "undefined") {
      console.warn("Mongoose: looks like you're trying to test a Mongoose app with Jest's default jsdom test environment. Please make sure you read Mongoose's docs on configuring Jest to test Node.js apps: http://mongoosejs.com/docs/jest.html");
    }
    if (typeof jest !== "undefined" && process.nextTick.toString().indexOf("nextTick") === -1) {
      console.warn("Mongoose: looks like you're trying to test a Mongoose app with Jest's mock timers enabled. Please make sure you read Mongoose's docs on configuring Jest to test Node.js apps: http://mongoosejs.com/docs/jest.html");
    }
  }
});

// node_modules/mongoose/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/mongoose/lib/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    if (global.MONGOOSE_DRIVER_PATH) {
      const deprecationWarning = "The `MONGOOSE_DRIVER_PATH` global property is deprecated. Use `mongoose.driver.set()` instead.";
      const setDriver = require("util").deprecate(function() {
        require_driver().set(require(global.MONGOOSE_DRIVER_PATH));
      }, deprecationWarning);
      setDriver();
    } else {
      require_driver().set(require_node_mongodb_native());
    }
    var Document = require_document();
    var EventEmitter = require("events").EventEmitter;
    var Schema = require_schema2();
    var SchemaType = require_schematype();
    var SchemaTypes = require_schema();
    var VirtualType = require_virtualtype();
    var STATES = require_connectionstate();
    var VALID_OPTIONS = require_validoptions();
    var Types = require_types();
    var Query = require_query2();
    var Model = require_model();
    var applyPlugins = require_applyPlugins();
    var driver = require_driver();
    var get2 = require_get();
    var promiseOrCallback = require_promiseOrCallback();
    var legacyPluralize = require_mongoose_legacy_pluralize();
    var utils2 = require_utils6();
    var pkg = require_package2();
    var cast = require_cast2();
    var removeSubdocs = require_removeSubdocs();
    var saveSubdocs = require_saveSubdocs();
    var trackTransaction = require_trackTransaction();
    var validateBeforeSave = require_validateBeforeSave();
    var Aggregate = require_aggregate2();
    var PromiseProvider = require_promise_provider();
    var shardingPlugin = require_sharding();
    var defaultMongooseSymbol = Symbol.for("mongoose:default");
    require_printJestWarning();
    function Mongoose(options2) {
      this.connections = [];
      this.models = {};
      this.modelSchemas = {};
      this.events = new EventEmitter();
      this.options = Object.assign({
        pluralization: true,
        autoIndex: true,
        useCreateIndex: false
      }, options2);
      const conn = this.createConnection();
      conn.models = this.models;
      if (this.options.pluralization) {
        this._pluralize = legacyPluralize;
      }
      if (!options2 || !options2[defaultMongooseSymbol]) {
        const _this = this;
        this.Schema = function() {
          this.base = _this;
          return Schema.apply(this, arguments);
        };
        this.Schema.prototype = Object.create(Schema.prototype);
        Object.assign(this.Schema, Schema);
        this.Schema.base = this;
        this.Schema.Types = Object.assign({}, Schema.Types);
      } else {
        for (const key of ["Schema", "model"]) {
          this[key] = Mongoose.prototype[key];
        }
      }
      this.Schema.prototype.base = this;
      Object.defineProperty(this, "plugins", {
        configurable: false,
        enumerable: true,
        writable: false,
        value: [
          [saveSubdocs, { deduplicate: true }],
          [validateBeforeSave, { deduplicate: true }],
          [shardingPlugin, { deduplicate: true }],
          [removeSubdocs, { deduplicate: true }],
          [trackTransaction, { deduplicate: true }]
        ]
      });
    }
    Mongoose.prototype.cast = cast;
    Mongoose.prototype.STATES = STATES;
    Mongoose.prototype.driver = driver;
    Mongoose.prototype.set = function(key, value) {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      if (VALID_OPTIONS.indexOf(key) === -1)
        throw new Error(`\`${key}\` is an invalid option.`);
      if (arguments.length === 1) {
        return _mongoose.options[key];
      }
      _mongoose.options[key] = value;
      if (key === "objectIdGetter") {
        if (value) {
          Object.defineProperty(mongoose2.Types.ObjectId.prototype, "_id", {
            enumerable: false,
            configurable: true,
            get: function() {
              return this;
            }
          });
        } else {
          delete mongoose2.Types.ObjectId.prototype._id;
        }
      }
      return _mongoose;
    };
    Mongoose.prototype.get = Mongoose.prototype.set;
    Mongoose.prototype.createConnection = function(uri, options2, callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      const conn = new Connection(_mongoose);
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      _mongoose.connections.push(conn);
      _mongoose.events.emit("createConnection", conn);
      if (arguments.length > 0) {
        return conn.openUri(uri, options2, callback);
      }
      return conn;
    };
    Mongoose.prototype.connect = function(uri, options2, callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      const conn = _mongoose.connection;
      return _mongoose._promiseOrCallback(callback, (cb) => {
        conn.openUri(uri, options2, (err) => {
          if (err != null) {
            return cb(err);
          }
          return cb(null, _mongoose);
        });
      });
    };
    Mongoose.prototype.disconnect = function(callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      return _mongoose._promiseOrCallback(callback, (cb) => {
        let remaining = _mongoose.connections.length;
        if (remaining <= 0) {
          return cb(null);
        }
        _mongoose.connections.forEach((conn) => {
          conn.close(function(error2) {
            if (error2) {
              return cb(error2);
            }
            if (!--remaining) {
              cb(null);
            }
          });
        });
      });
    };
    Mongoose.prototype.startSession = function() {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);
    };
    Mongoose.prototype.pluralize = function(fn) {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      if (arguments.length > 0) {
        _mongoose._pluralize = fn;
      }
      return _mongoose._pluralize;
    };
    Mongoose.prototype.model = function(name, schema, collection, skipInit) {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      let model;
      if (typeof name === "function") {
        model = name;
        name = model.name;
        if (!(model.prototype instanceof Model)) {
          throw new _mongoose.Error("The provided class " + name + " must extend Model");
        }
      }
      if (typeof schema === "string") {
        collection = schema;
        schema = false;
      }
      if (utils2.isObject(schema) && !(schema instanceof Schema)) {
        schema = new Schema(schema);
      }
      if (schema && !(schema instanceof Schema)) {
        throw new Error("The 2nd parameter to `mongoose.model()` should be a schema or a POJO");
      }
      if (typeof collection === "boolean") {
        skipInit = collection;
        collection = null;
      }
      let options2;
      if (skipInit && utils2.isObject(skipInit)) {
        options2 = skipInit;
        skipInit = true;
      } else {
        options2 = {};
      }
      if (!_mongoose.modelSchemas[name]) {
        if (schema) {
          _mongoose.modelSchemas[name] = schema;
        } else {
          throw new mongoose2.Error.MissingSchemaError(name);
        }
      }
      const originalSchema = schema;
      if (schema) {
        if (_mongoose.get("cloneSchemas")) {
          schema = schema.clone();
        }
        _mongoose._applyPlugins(schema);
      }
      let sub;
      const overwriteModels = _mongoose.options.hasOwnProperty("overwriteModels") ? _mongoose.options.overwriteModels : options2.overwriteModels;
      if (_mongoose.models[name] && options2.cache !== false && overwriteModels !== true) {
        if (originalSchema && originalSchema.instanceOfSchema && originalSchema !== _mongoose.models[name].schema) {
          throw new _mongoose.Error.OverwriteModelError(name);
        }
        if (collection && collection !== _mongoose.models[name].collection.name) {
          model = _mongoose.models[name];
          schema = model.prototype.schema;
          sub = model.__subclass(_mongoose.connection, schema, collection);
          return sub;
        }
        return _mongoose.models[name];
      }
      if (!schema) {
        schema = this.modelSchemas[name];
        if (!schema) {
          throw new mongoose2.Error.MissingSchemaError(name);
        }
      }
      if (!("pluralization" in schema.options)) {
        schema.options.pluralization = _mongoose.options.pluralization;
      }
      if (!collection) {
        collection = schema.get("collection") || utils2.toCollectionName(name, _mongoose.pluralize());
      }
      const connection = options2.connection || _mongoose.connection;
      model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);
      if (!skipInit) {
        model.init(function $modelInitNoop() {
        });
      }
      connection.emit("model", model);
      if (options2.cache === false) {
        return model;
      }
      _mongoose.models[name] = model;
      return _mongoose.models[name];
    };
    Mongoose.prototype.deleteModel = function(name) {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      _mongoose.connection.deleteModel(name);
      return _mongoose;
    };
    Mongoose.prototype.modelNames = function() {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      const names = Object.keys(_mongoose.models);
      return names;
    };
    Mongoose.prototype._applyPlugins = function(schema, options2) {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      options2 = options2 || {};
      options2.applyPluginsToDiscriminators = get2(_mongoose, "options.applyPluginsToDiscriminators", false);
      options2.applyPluginsToChildSchemas = get2(_mongoose, "options.applyPluginsToChildSchemas", true);
      applyPlugins(schema, _mongoose.plugins, options2, "$globalPluginsApplied");
    };
    Mongoose.prototype.plugin = function(fn, opts) {
      const _mongoose = this instanceof Mongoose ? this : mongoose2;
      _mongoose.plugins.push([fn, opts]);
      return _mongoose;
    };
    Mongoose.prototype.__defineGetter__("connection", function() {
      return this.connections[0];
    });
    Mongoose.prototype.__defineSetter__("connection", function(v) {
      if (v instanceof Connection) {
        this.connections[0] = v;
        this.models = v.models;
      }
    });
    Mongoose.prototype.connections;
    var Connection = driver.get().getConnection();
    var Collection = driver.get().Collection;
    Mongoose.prototype.Aggregate = Aggregate;
    Mongoose.prototype.Collection = Collection;
    Mongoose.prototype.Connection = Connection;
    Mongoose.prototype.version = pkg.version;
    Mongoose.prototype.Mongoose = Mongoose;
    Mongoose.prototype.Schema = Schema;
    Mongoose.prototype.SchemaType = SchemaType;
    Mongoose.prototype.SchemaTypes = Schema.Types;
    Mongoose.prototype.VirtualType = VirtualType;
    Mongoose.prototype.Types = Types;
    Mongoose.prototype.Query = Query;
    Object.defineProperty(Mongoose.prototype, "Promise", {
      get: function() {
        return PromiseProvider.get();
      },
      set: function(lib) {
        PromiseProvider.set(lib);
      }
    });
    Mongoose.prototype.PromiseProvider = PromiseProvider;
    Mongoose.prototype.Model = Model;
    Mongoose.prototype.Document = Document;
    Mongoose.prototype.DocumentProvider = require_document_provider();
    Mongoose.prototype.ObjectId = SchemaTypes.ObjectId;
    Mongoose.prototype.isValidObjectId = function(v) {
      if (v == null) {
        return true;
      }
      const base = this || mongoose2;
      const ObjectId2 = base.driver.get().ObjectId;
      if (v instanceof ObjectId2) {
        return true;
      }
      if (v._id != null) {
        if (v._id instanceof ObjectId2) {
          return true;
        }
        if (v._id.toString instanceof Function) {
          v = v._id.toString();
          if (typeof v === "string" && v.length === 12) {
            return true;
          }
          if (typeof v === "string" && v.length === 24 && /^[a-f0-9]*$/.test(v)) {
            return true;
          }
          return false;
        }
      }
      if (v.toString instanceof Function) {
        v = v.toString();
      }
      if (typeof v === "string" && v.length === 12) {
        return true;
      }
      if (typeof v === "string" && v.length === 24 && /^[a-f0-9]*$/.test(v)) {
        return true;
      }
      return false;
    };
    Mongoose.prototype.Decimal128 = SchemaTypes.Decimal128;
    Mongoose.prototype.Mixed = SchemaTypes.Mixed;
    Mongoose.prototype.Date = SchemaTypes.Date;
    Mongoose.prototype.Number = SchemaTypes.Number;
    Mongoose.prototype.Error = require_error3();
    Mongoose.prototype.now = function now() {
      return new Date();
    };
    Mongoose.prototype.CastError = require_cast();
    Mongoose.prototype.SchemaTypeOptions = require_SchemaTypeOptions();
    Mongoose.prototype.mongo = require_mongodb();
    Mongoose.prototype.mquery = require_mquery();
    Mongoose.prototype._promiseOrCallback = function(callback, fn, ee) {
      return promiseOrCallback(callback, fn, ee, this.Promise);
    };
    var mongoose2 = module2.exports = exports2 = new Mongoose({
      [defaultMongooseSymbol]: true
    });
  }
});

// node_modules/mongoose/index.js
var require_mongoose = __commonJS({
  "node_modules/mongoose/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = require_lib3();
  }
});

// node_modules/fuse.js/dist/fuse.common.js
var require_fuse_common = __commonJS({
  "node_modules/fuse.js/dist/fuse.common.js"(exports2, module2) {
    init_shims();
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function isArray(value) {
      return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
    }
    var INFINITY = 1 / 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function isString(value) {
      return typeof value === "string";
    }
    function isNumber(value) {
      return typeof value === "number";
    }
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
    }
    function isObject2(value) {
      return _typeof(value) === "object";
    }
    function isObjectLike(value) {
      return isObject2(value) && value !== null;
    }
    function isDefined(value) {
      return value !== void 0 && value !== null;
    }
    function isBlank(value) {
      return !value.trim().length;
    }
    function getTag(value) {
      return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
    }
    var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
    var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY2(key) {
      return "Invalid value for key ".concat(key);
    };
    var PATTERN_LENGTH_TOO_LARGE = function PATTERN_LENGTH_TOO_LARGE2(max) {
      return "Pattern length exceeds max of ".concat(max, ".");
    };
    var MISSING_KEY_PROPERTY = function MISSING_KEY_PROPERTY2(name) {
      return "Missing ".concat(name, " property in key");
    };
    var INVALID_KEY_WEIGHT_VALUE = function INVALID_KEY_WEIGHT_VALUE2(key) {
      return "Property 'weight' in key '".concat(key, "' must be a positive integer");
    };
    var hasOwn = Object.prototype.hasOwnProperty;
    var KeyStore = /* @__PURE__ */ function() {
      function KeyStore2(keys) {
        var _this = this;
        _classCallCheck(this, KeyStore2);
        this._keys = [];
        this._keyMap = {};
        var totalWeight = 0;
        keys.forEach(function(key) {
          var obj = createKey(key);
          totalWeight += obj.weight;
          _this._keys.push(obj);
          _this._keyMap[obj.id] = obj;
          totalWeight += obj.weight;
        });
        this._keys.forEach(function(key) {
          key.weight /= totalWeight;
        });
      }
      _createClass(KeyStore2, [{
        key: "get",
        value: function get3(keyId) {
          return this._keyMap[keyId];
        }
      }, {
        key: "keys",
        value: function keys() {
          return this._keys;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return JSON.stringify(this._keys);
        }
      }]);
      return KeyStore2;
    }();
    function createKey(key) {
      var path = null;
      var id = null;
      var src2 = null;
      var weight = 1;
      if (isString(key) || isArray(key)) {
        src2 = key;
        path = createKeyPath(key);
        id = createKeyId(key);
      } else {
        if (!hasOwn.call(key, "name")) {
          throw new Error(MISSING_KEY_PROPERTY("name"));
        }
        var name = key.name;
        src2 = name;
        if (hasOwn.call(key, "weight")) {
          weight = key.weight;
          if (weight <= 0) {
            throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
          }
        }
        path = createKeyPath(name);
        id = createKeyId(name);
      }
      return {
        path,
        id,
        weight,
        src: src2
      };
    }
    function createKeyPath(key) {
      return isArray(key) ? key : key.split(".");
    }
    function createKeyId(key) {
      return isArray(key) ? key.join(".") : key;
    }
    function get2(obj, path) {
      var list = [];
      var arr = false;
      var deepGet = function deepGet2(obj2, path2, index2) {
        if (!isDefined(obj2)) {
          return;
        }
        if (!path2[index2]) {
          list.push(obj2);
        } else {
          var key = path2[index2];
          var value = obj2[key];
          if (!isDefined(value)) {
            return;
          }
          if (index2 === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
            list.push(toString(value));
          } else if (isArray(value)) {
            arr = true;
            for (var i = 0, len = value.length; i < len; i += 1) {
              deepGet2(value[i], path2, index2 + 1);
            }
          } else if (path2.length) {
            deepGet2(value, path2, index2 + 1);
          }
        }
      };
      deepGet(obj, isString(path) ? path.split(".") : path, 0);
      return arr ? list : list[0];
    }
    var MatchOptions = {
      includeMatches: false,
      findAllMatches: false,
      minMatchCharLength: 1
    };
    var BasicOptions = {
      isCaseSensitive: false,
      includeScore: false,
      keys: [],
      shouldSort: true,
      sortFn: function sortFn(a, b) {
        return a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1;
      }
    };
    var FuzzyOptions = {
      location: 0,
      threshold: 0.6,
      distance: 100
    };
    var AdvancedOptions = {
      useExtendedSearch: false,
      getFn: get2,
      ignoreLocation: false,
      ignoreFieldNorm: false
    };
    var Config = _objectSpread2({}, BasicOptions, {}, MatchOptions, {}, FuzzyOptions, {}, AdvancedOptions);
    var SPACE = /[^ ]+/g;
    function norm() {
      var mantissa = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
      var cache = new Map();
      var m = Math.pow(10, mantissa);
      return {
        get: function get3(value) {
          var numTokens = value.match(SPACE).length;
          if (cache.has(numTokens)) {
            return cache.get(numTokens);
          }
          var norm2 = 1 / Math.sqrt(numTokens);
          var n = parseFloat(Math.round(norm2 * m) / m);
          cache.set(numTokens, n);
          return n;
        },
        clear: function clear() {
          cache.clear();
        }
      };
    }
    var FuseIndex = /* @__PURE__ */ function() {
      function FuseIndex2() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$getFn = _ref.getFn, getFn = _ref$getFn === void 0 ? Config.getFn : _ref$getFn;
        _classCallCheck(this, FuseIndex2);
        this.norm = norm(3);
        this.getFn = getFn;
        this.isCreated = false;
        this.setIndexRecords();
      }
      _createClass(FuseIndex2, [{
        key: "setSources",
        value: function setSources() {
          var docs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          this.docs = docs;
        }
      }, {
        key: "setIndexRecords",
        value: function setIndexRecords() {
          var records = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          this.records = records;
        }
      }, {
        key: "setKeys",
        value: function setKeys() {
          var _this = this;
          var keys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          this.keys = keys;
          this._keysMap = {};
          keys.forEach(function(key, idx) {
            _this._keysMap[key.id] = idx;
          });
        }
      }, {
        key: "create",
        value: function create() {
          var _this2 = this;
          if (this.isCreated || !this.docs.length) {
            return;
          }
          this.isCreated = true;
          if (isString(this.docs[0])) {
            this.docs.forEach(function(doc, docIndex) {
              _this2._addString(doc, docIndex);
            });
          } else {
            this.docs.forEach(function(doc, docIndex) {
              _this2._addObject(doc, docIndex);
            });
          }
          this.norm.clear();
        }
      }, {
        key: "add",
        value: function add(doc) {
          var idx = this.size();
          if (isString(doc)) {
            this._addString(doc, idx);
          } else {
            this._addObject(doc, idx);
          }
        }
      }, {
        key: "removeAt",
        value: function removeAt(idx) {
          this.records.splice(idx, 1);
          for (var i = idx, len = this.size(); i < len; i += 1) {
            this.records[i].i -= 1;
          }
        }
      }, {
        key: "getValueForItemAtKeyId",
        value: function getValueForItemAtKeyId(item, keyId) {
          return item[this._keysMap[keyId]];
        }
      }, {
        key: "size",
        value: function size() {
          return this.records.length;
        }
      }, {
        key: "_addString",
        value: function _addString(doc, docIndex) {
          if (!isDefined(doc) || isBlank(doc)) {
            return;
          }
          var record = {
            v: doc,
            i: docIndex,
            n: this.norm.get(doc)
          };
          this.records.push(record);
        }
      }, {
        key: "_addObject",
        value: function _addObject(doc, docIndex) {
          var _this3 = this;
          var record = {
            i: docIndex,
            $: {}
          };
          this.keys.forEach(function(key, keyIndex) {
            var value = _this3.getFn(doc, key.path);
            if (!isDefined(value)) {
              return;
            }
            if (isArray(value)) {
              (function() {
                var subRecords = [];
                var stack = [{
                  nestedArrIndex: -1,
                  value
                }];
                while (stack.length) {
                  var _stack$pop = stack.pop(), nestedArrIndex = _stack$pop.nestedArrIndex, _value = _stack$pop.value;
                  if (!isDefined(_value)) {
                    continue;
                  }
                  if (isString(_value) && !isBlank(_value)) {
                    var subRecord2 = {
                      v: _value,
                      i: nestedArrIndex,
                      n: _this3.norm.get(_value)
                    };
                    subRecords.push(subRecord2);
                  } else if (isArray(_value)) {
                    _value.forEach(function(item, k) {
                      stack.push({
                        nestedArrIndex: k,
                        value: item
                      });
                    });
                  }
                }
                record.$[keyIndex] = subRecords;
              })();
            } else if (!isBlank(value)) {
              var subRecord = {
                v: value,
                n: _this3.norm.get(value)
              };
              record.$[keyIndex] = subRecord;
            }
          });
          this.records.push(record);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            keys: this.keys,
            records: this.records
          };
        }
      }]);
      return FuseIndex2;
    }();
    function createIndex(keys, docs) {
      var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$getFn = _ref2.getFn, getFn = _ref2$getFn === void 0 ? Config.getFn : _ref2$getFn;
      var myIndex = new FuseIndex({
        getFn
      });
      myIndex.setKeys(keys.map(createKey));
      myIndex.setSources(docs);
      myIndex.create();
      return myIndex;
    }
    function parseIndex(data) {
      var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref3$getFn = _ref3.getFn, getFn = _ref3$getFn === void 0 ? Config.getFn : _ref3$getFn;
      var keys = data.keys, records = data.records;
      var myIndex = new FuseIndex({
        getFn
      });
      myIndex.setKeys(keys);
      myIndex.setIndexRecords(records);
      return myIndex;
    }
    function computeScore(pattern) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$errors = _ref.errors, errors = _ref$errors === void 0 ? 0 : _ref$errors, _ref$currentLocation = _ref.currentLocation, currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation, _ref$expectedLocation = _ref.expectedLocation, expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation, _ref$distance = _ref.distance, distance = _ref$distance === void 0 ? Config.distance : _ref$distance, _ref$ignoreLocation = _ref.ignoreLocation, ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
      var accuracy = errors / pattern.length;
      if (ignoreLocation) {
        return accuracy;
      }
      var proximity = Math.abs(expectedLocation - currentLocation);
      if (!distance) {
        return proximity ? 1 : accuracy;
      }
      return accuracy + proximity / distance;
    }
    function convertMaskToIndices() {
      var matchmask = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var minMatchCharLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Config.minMatchCharLength;
      var indices = [];
      var start = -1;
      var end = -1;
      var i = 0;
      for (var len = matchmask.length; i < len; i += 1) {
        var match = matchmask[i];
        if (match && start === -1) {
          start = i;
        } else if (!match && start !== -1) {
          end = i - 1;
          if (end - start + 1 >= minMatchCharLength) {
            indices.push([start, end]);
          }
          start = -1;
        }
      }
      if (matchmask[i - 1] && i - start >= minMatchCharLength) {
        indices.push([start, i - 1]);
      }
      return indices;
    }
    var MAX_BITS = 32;
    function search(text, pattern, patternAlphabet) {
      var _ref = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, _ref$location = _ref.location, location = _ref$location === void 0 ? Config.location : _ref$location, _ref$distance = _ref.distance, distance = _ref$distance === void 0 ? Config.distance : _ref$distance, _ref$threshold = _ref.threshold, threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold, _ref$findAllMatches = _ref.findAllMatches, findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches, _ref$minMatchCharLeng = _ref.minMatchCharLength, minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng, _ref$includeMatches = _ref.includeMatches, includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches, _ref$ignoreLocation = _ref.ignoreLocation, ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
      if (pattern.length > MAX_BITS) {
        throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
      }
      var patternLen = pattern.length;
      var textLen = text.length;
      var expectedLocation = Math.max(0, Math.min(location, textLen));
      var currentThreshold = threshold;
      var bestLocation = expectedLocation;
      var computeMatches = minMatchCharLength > 1 || includeMatches;
      var matchMask = computeMatches ? Array(textLen) : [];
      var index2;
      while ((index2 = text.indexOf(pattern, bestLocation)) > -1) {
        var score = computeScore(pattern, {
          currentLocation: index2,
          expectedLocation,
          distance,
          ignoreLocation
        });
        currentThreshold = Math.min(score, currentThreshold);
        bestLocation = index2 + patternLen;
        if (computeMatches) {
          var i = 0;
          while (i < patternLen) {
            matchMask[index2 + i] = 1;
            i += 1;
          }
        }
      }
      bestLocation = -1;
      var lastBitArr = [];
      var finalScore = 1;
      var binMax = patternLen + textLen;
      var mask = 1 << patternLen - 1;
      for (var _i = 0; _i < patternLen; _i += 1) {
        var binMin = 0;
        var binMid = binMax;
        while (binMin < binMid) {
          var _score2 = computeScore(pattern, {
            errors: _i,
            currentLocation: expectedLocation + binMid,
            expectedLocation,
            distance,
            ignoreLocation
          });
          if (_score2 <= currentThreshold) {
            binMin = binMid;
          } else {
            binMax = binMid;
          }
          binMid = Math.floor((binMax - binMin) / 2 + binMin);
        }
        binMax = binMid;
        var start = Math.max(1, expectedLocation - binMid + 1);
        var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
        var bitArr = Array(finish + 2);
        bitArr[finish + 1] = (1 << _i) - 1;
        for (var j = finish; j >= start; j -= 1) {
          var currentLocation = j - 1;
          var charMatch = patternAlphabet[text.charAt(currentLocation)];
          if (computeMatches) {
            matchMask[currentLocation] = +!!charMatch;
          }
          bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
          if (_i) {
            bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
          }
          if (bitArr[j] & mask) {
            finalScore = computeScore(pattern, {
              errors: _i,
              currentLocation,
              expectedLocation,
              distance,
              ignoreLocation
            });
            if (finalScore <= currentThreshold) {
              currentThreshold = finalScore;
              bestLocation = currentLocation;
              if (bestLocation <= expectedLocation) {
                break;
              }
              start = Math.max(1, 2 * expectedLocation - bestLocation);
            }
          }
        }
        var _score = computeScore(pattern, {
          errors: _i + 1,
          currentLocation: expectedLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (_score > currentThreshold) {
          break;
        }
        lastBitArr = bitArr;
      }
      var result = {
        isMatch: bestLocation >= 0,
        score: Math.max(1e-3, finalScore)
      };
      if (computeMatches) {
        var indices = convertMaskToIndices(matchMask, minMatchCharLength);
        if (!indices.length) {
          result.isMatch = false;
        } else if (includeMatches) {
          result.indices = indices;
        }
      }
      return result;
    }
    function createPatternAlphabet(pattern) {
      var mask = {};
      for (var i = 0, len = pattern.length; i < len; i += 1) {
        var char = pattern.charAt(i);
        mask[char] = (mask[char] || 0) | 1 << len - i - 1;
      }
      return mask;
    }
    var BitapSearch = /* @__PURE__ */ function() {
      function BitapSearch2(pattern) {
        var _this = this;
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$location = _ref.location, location = _ref$location === void 0 ? Config.location : _ref$location, _ref$threshold = _ref.threshold, threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold, _ref$distance = _ref.distance, distance = _ref$distance === void 0 ? Config.distance : _ref$distance, _ref$includeMatches = _ref.includeMatches, includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches, _ref$findAllMatches = _ref.findAllMatches, findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches, _ref$minMatchCharLeng = _ref.minMatchCharLength, minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng, _ref$isCaseSensitive = _ref.isCaseSensitive, isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive, _ref$ignoreLocation = _ref.ignoreLocation, ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
        _classCallCheck(this, BitapSearch2);
        this.options = {
          location,
          threshold,
          distance,
          includeMatches,
          findAllMatches,
          minMatchCharLength,
          isCaseSensitive,
          ignoreLocation
        };
        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
        this.chunks = [];
        if (!this.pattern.length) {
          return;
        }
        var addChunk = function addChunk2(pattern2, startIndex2) {
          _this.chunks.push({
            pattern: pattern2,
            alphabet: createPatternAlphabet(pattern2),
            startIndex: startIndex2
          });
        };
        var len = this.pattern.length;
        if (len > MAX_BITS) {
          var i = 0;
          var remainder = len % MAX_BITS;
          var end = len - remainder;
          while (i < end) {
            addChunk(this.pattern.substr(i, MAX_BITS), i);
            i += MAX_BITS;
          }
          if (remainder) {
            var startIndex = len - MAX_BITS;
            addChunk(this.pattern.substr(startIndex), startIndex);
          }
        } else {
          addChunk(this.pattern, 0);
        }
      }
      _createClass(BitapSearch2, [{
        key: "searchIn",
        value: function searchIn(text) {
          var _this$options = this.options, isCaseSensitive = _this$options.isCaseSensitive, includeMatches = _this$options.includeMatches;
          if (!isCaseSensitive) {
            text = text.toLowerCase();
          }
          if (this.pattern === text) {
            var _result = {
              isMatch: true,
              score: 0
            };
            if (includeMatches) {
              _result.indices = [[0, text.length - 1]];
            }
            return _result;
          }
          var _this$options2 = this.options, location = _this$options2.location, distance = _this$options2.distance, threshold = _this$options2.threshold, findAllMatches = _this$options2.findAllMatches, minMatchCharLength = _this$options2.minMatchCharLength, ignoreLocation = _this$options2.ignoreLocation;
          var allIndices = [];
          var totalScore = 0;
          var hasMatches = false;
          this.chunks.forEach(function(_ref2) {
            var pattern = _ref2.pattern, alphabet = _ref2.alphabet, startIndex = _ref2.startIndex;
            var _search = search(text, pattern, alphabet, {
              location: location + startIndex,
              distance,
              threshold,
              findAllMatches,
              minMatchCharLength,
              includeMatches,
              ignoreLocation
            }), isMatch = _search.isMatch, score = _search.score, indices = _search.indices;
            if (isMatch) {
              hasMatches = true;
            }
            totalScore += score;
            if (isMatch && indices) {
              allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
            }
          });
          var result = {
            isMatch: hasMatches,
            score: hasMatches ? totalScore / this.chunks.length : 1
          };
          if (hasMatches && includeMatches) {
            result.indices = allIndices;
          }
          return result;
        }
      }]);
      return BitapSearch2;
    }();
    var BaseMatch = /* @__PURE__ */ function() {
      function BaseMatch2(pattern) {
        _classCallCheck(this, BaseMatch2);
        this.pattern = pattern;
      }
      _createClass(BaseMatch2, [{
        key: "search",
        value: function search2() {
        }
      }], [{
        key: "isMultiMatch",
        value: function isMultiMatch(pattern) {
          return getMatch(pattern, this.multiRegex);
        }
      }, {
        key: "isSingleMatch",
        value: function isSingleMatch(pattern) {
          return getMatch(pattern, this.singleRegex);
        }
      }]);
      return BaseMatch2;
    }();
    function getMatch(pattern, exp) {
      var matches = pattern.match(exp);
      return matches ? matches[1] : null;
    }
    var ExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(ExactMatch2, _BaseMatch);
      var _super = _createSuper(ExactMatch2);
      function ExactMatch2(pattern) {
        _classCallCheck(this, ExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(ExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var isMatch = text === this.pattern;
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [0, this.pattern.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get3() {
          return "exact";
        }
      }, {
        key: "multiRegex",
        get: function get3() {
          return /^="(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get3() {
          return /^=(.*)$/;
        }
      }]);
      return ExactMatch2;
    }(BaseMatch);
    var InverseExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(InverseExactMatch2, _BaseMatch);
      var _super = _createSuper(InverseExactMatch2);
      function InverseExactMatch2(pattern) {
        _classCallCheck(this, InverseExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(InverseExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var index2 = text.indexOf(this.pattern);
          var isMatch = index2 === -1;
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [0, text.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get3() {
          return "inverse-exact";
        }
      }, {
        key: "multiRegex",
        get: function get3() {
          return /^!"(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get3() {
          return /^!(.*)$/;
        }
      }]);
      return InverseExactMatch2;
    }(BaseMatch);
    var PrefixExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(PrefixExactMatch2, _BaseMatch);
      var _super = _createSuper(PrefixExactMatch2);
      function PrefixExactMatch2(pattern) {
        _classCallCheck(this, PrefixExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(PrefixExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var isMatch = text.startsWith(this.pattern);
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [0, this.pattern.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get3() {
          return "prefix-exact";
        }
      }, {
        key: "multiRegex",
        get: function get3() {
          return /^\^"(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get3() {
          return /^\^(.*)$/;
        }
      }]);
      return PrefixExactMatch2;
    }(BaseMatch);
    var InversePrefixExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(InversePrefixExactMatch2, _BaseMatch);
      var _super = _createSuper(InversePrefixExactMatch2);
      function InversePrefixExactMatch2(pattern) {
        _classCallCheck(this, InversePrefixExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(InversePrefixExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var isMatch = !text.startsWith(this.pattern);
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [0, text.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get3() {
          return "inverse-prefix-exact";
        }
      }, {
        key: "multiRegex",
        get: function get3() {
          return /^!\^"(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get3() {
          return /^!\^(.*)$/;
        }
      }]);
      return InversePrefixExactMatch2;
    }(BaseMatch);
    var SuffixExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(SuffixExactMatch2, _BaseMatch);
      var _super = _createSuper(SuffixExactMatch2);
      function SuffixExactMatch2(pattern) {
        _classCallCheck(this, SuffixExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(SuffixExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var isMatch = text.endsWith(this.pattern);
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [text.length - this.pattern.length, text.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get3() {
          return "suffix-exact";
        }
      }, {
        key: "multiRegex",
        get: function get3() {
          return /^"(.*)"\$$/;
        }
      }, {
        key: "singleRegex",
        get: function get3() {
          return /^(.*)\$$/;
        }
      }]);
      return SuffixExactMatch2;
    }(BaseMatch);
    var InverseSuffixExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(InverseSuffixExactMatch2, _BaseMatch);
      var _super = _createSuper(InverseSuffixExactMatch2);
      function InverseSuffixExactMatch2(pattern) {
        _classCallCheck(this, InverseSuffixExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(InverseSuffixExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var isMatch = !text.endsWith(this.pattern);
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [0, text.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get3() {
          return "inverse-suffix-exact";
        }
      }, {
        key: "multiRegex",
        get: function get3() {
          return /^!"(.*)"\$$/;
        }
      }, {
        key: "singleRegex",
        get: function get3() {
          return /^!(.*)\$$/;
        }
      }]);
      return InverseSuffixExactMatch2;
    }(BaseMatch);
    var FuzzyMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(FuzzyMatch2, _BaseMatch);
      var _super = _createSuper(FuzzyMatch2);
      function FuzzyMatch2(pattern) {
        var _this;
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$location = _ref.location, location = _ref$location === void 0 ? Config.location : _ref$location, _ref$threshold = _ref.threshold, threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold, _ref$distance = _ref.distance, distance = _ref$distance === void 0 ? Config.distance : _ref$distance, _ref$includeMatches = _ref.includeMatches, includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches, _ref$findAllMatches = _ref.findAllMatches, findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches, _ref$minMatchCharLeng = _ref.minMatchCharLength, minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng, _ref$isCaseSensitive = _ref.isCaseSensitive, isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive, _ref$ignoreLocation = _ref.ignoreLocation, ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
        _classCallCheck(this, FuzzyMatch2);
        _this = _super.call(this, pattern);
        _this._bitapSearch = new BitapSearch(pattern, {
          location,
          threshold,
          distance,
          includeMatches,
          findAllMatches,
          minMatchCharLength,
          isCaseSensitive,
          ignoreLocation
        });
        return _this;
      }
      _createClass(FuzzyMatch2, [{
        key: "search",
        value: function search2(text) {
          return this._bitapSearch.searchIn(text);
        }
      }], [{
        key: "type",
        get: function get3() {
          return "fuzzy";
        }
      }, {
        key: "multiRegex",
        get: function get3() {
          return /^"(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get3() {
          return /^(.*)$/;
        }
      }]);
      return FuzzyMatch2;
    }(BaseMatch);
    var IncludeMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(IncludeMatch2, _BaseMatch);
      var _super = _createSuper(IncludeMatch2);
      function IncludeMatch2(pattern) {
        _classCallCheck(this, IncludeMatch2);
        return _super.call(this, pattern);
      }
      _createClass(IncludeMatch2, [{
        key: "search",
        value: function search2(text) {
          var location = 0;
          var index2;
          var indices = [];
          var patternLen = this.pattern.length;
          while ((index2 = text.indexOf(this.pattern, location)) > -1) {
            location = index2 + patternLen;
            indices.push([index2, location - 1]);
          }
          var isMatch = !!indices.length;
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices
          };
        }
      }], [{
        key: "type",
        get: function get3() {
          return "include";
        }
      }, {
        key: "multiRegex",
        get: function get3() {
          return /^'"(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get3() {
          return /^'(.*)$/;
        }
      }]);
      return IncludeMatch2;
    }(BaseMatch);
    var searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];
    var searchersLen = searchers.length;
    var SPACE_RE = / +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/;
    var OR_TOKEN = "|";
    function parseQuery(pattern) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return pattern.split(OR_TOKEN).map(function(item) {
        var query = item.trim().split(SPACE_RE).filter(function(item2) {
          return item2 && !!item2.trim();
        });
        var results = [];
        for (var i = 0, len = query.length; i < len; i += 1) {
          var queryItem = query[i];
          var found = false;
          var idx = -1;
          while (!found && ++idx < searchersLen) {
            var searcher = searchers[idx];
            var token2 = searcher.isMultiMatch(queryItem);
            if (token2) {
              results.push(new searcher(token2, options2));
              found = true;
            }
          }
          if (found) {
            continue;
          }
          idx = -1;
          while (++idx < searchersLen) {
            var _searcher = searchers[idx];
            var _token = _searcher.isSingleMatch(queryItem);
            if (_token) {
              results.push(new _searcher(_token, options2));
              break;
            }
          }
        }
        return results;
      });
    }
    var MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);
    var ExtendedSearch = /* @__PURE__ */ function() {
      function ExtendedSearch2(pattern) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$isCaseSensitive = _ref.isCaseSensitive, isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive, _ref$includeMatches = _ref.includeMatches, includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches, _ref$minMatchCharLeng = _ref.minMatchCharLength, minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng, _ref$ignoreLocation = _ref.ignoreLocation, ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation, _ref$findAllMatches = _ref.findAllMatches, findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches, _ref$location = _ref.location, location = _ref$location === void 0 ? Config.location : _ref$location, _ref$threshold = _ref.threshold, threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold, _ref$distance = _ref.distance, distance = _ref$distance === void 0 ? Config.distance : _ref$distance;
        _classCallCheck(this, ExtendedSearch2);
        this.query = null;
        this.options = {
          isCaseSensitive,
          includeMatches,
          minMatchCharLength,
          findAllMatches,
          ignoreLocation,
          location,
          threshold,
          distance
        };
        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
        this.query = parseQuery(this.pattern, this.options);
      }
      _createClass(ExtendedSearch2, [{
        key: "searchIn",
        value: function searchIn(text) {
          var query = this.query;
          if (!query) {
            return {
              isMatch: false,
              score: 1
            };
          }
          var _this$options = this.options, includeMatches = _this$options.includeMatches, isCaseSensitive = _this$options.isCaseSensitive;
          text = isCaseSensitive ? text : text.toLowerCase();
          var numMatches = 0;
          var allIndices = [];
          var totalScore = 0;
          for (var i = 0, qLen = query.length; i < qLen; i += 1) {
            var searchers2 = query[i];
            allIndices.length = 0;
            numMatches = 0;
            for (var j = 0, pLen = searchers2.length; j < pLen; j += 1) {
              var searcher = searchers2[j];
              var _searcher$search = searcher.search(text), isMatch = _searcher$search.isMatch, indices = _searcher$search.indices, score = _searcher$search.score;
              if (isMatch) {
                numMatches += 1;
                totalScore += score;
                if (includeMatches) {
                  var type = searcher.constructor.type;
                  if (MultiMatchSet.has(type)) {
                    allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
                  } else {
                    allIndices.push(indices);
                  }
                }
              } else {
                totalScore = 0;
                numMatches = 0;
                allIndices.length = 0;
                break;
              }
            }
            if (numMatches) {
              var result = {
                isMatch: true,
                score: totalScore / numMatches
              };
              if (includeMatches) {
                result.indices = allIndices;
              }
              return result;
            }
          }
          return {
            isMatch: false,
            score: 1
          };
        }
      }], [{
        key: "condition",
        value: function condition(_, options2) {
          return options2.useExtendedSearch;
        }
      }]);
      return ExtendedSearch2;
    }();
    var registeredSearchers = [];
    function register2() {
      registeredSearchers.push.apply(registeredSearchers, arguments);
    }
    function createSearcher(pattern, options2) {
      for (var i = 0, len = registeredSearchers.length; i < len; i += 1) {
        var searcherClass = registeredSearchers[i];
        if (searcherClass.condition(pattern, options2)) {
          return new searcherClass(pattern, options2);
        }
      }
      return new BitapSearch(pattern, options2);
    }
    var LogicalOperator = {
      AND: "$and",
      OR: "$or"
    };
    var KeyType = {
      PATH: "$path",
      PATTERN: "$val"
    };
    var isExpression = function isExpression2(query) {
      return !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
    };
    var isPath = function isPath2(query) {
      return !!query[KeyType.PATH];
    };
    var isLeaf = function isLeaf2(query) {
      return !isArray(query) && isObject2(query) && !isExpression(query);
    };
    var convertToExplicit = function convertToExplicit2(query) {
      return _defineProperty({}, LogicalOperator.AND, Object.keys(query).map(function(key) {
        return _defineProperty({}, key, query[key]);
      }));
    };
    function parse(query, options2) {
      var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref3$auto = _ref3.auto, auto = _ref3$auto === void 0 ? true : _ref3$auto;
      var next = function next2(query2) {
        var keys = Object.keys(query2);
        var isQueryPath = isPath(query2);
        if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
          return next2(convertToExplicit(query2));
        }
        if (isLeaf(query2)) {
          var key = isQueryPath ? query2[KeyType.PATH] : keys[0];
          var pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
          if (!isString(pattern)) {
            throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
          }
          var obj = {
            keyId: createKeyId(key),
            pattern
          };
          if (auto) {
            obj.searcher = createSearcher(pattern, options2);
          }
          return obj;
        }
        var node = {
          children: [],
          operator: keys[0]
        };
        keys.forEach(function(key2) {
          var value = query2[key2];
          if (isArray(value)) {
            value.forEach(function(item) {
              node.children.push(next2(item));
            });
          }
        });
        return node;
      };
      if (!isExpression(query)) {
        query = convertToExplicit(query);
      }
      return next(query);
    }
    function computeScore$1(results, _ref) {
      var _ref$ignoreFieldNorm = _ref.ignoreFieldNorm, ignoreFieldNorm = _ref$ignoreFieldNorm === void 0 ? Config.ignoreFieldNorm : _ref$ignoreFieldNorm;
      results.forEach(function(result) {
        var totalScore = 1;
        result.matches.forEach(function(_ref2) {
          var key = _ref2.key, norm2 = _ref2.norm, score = _ref2.score;
          var weight = key ? key.weight : null;
          totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm2));
        });
        result.score = totalScore;
      });
    }
    function transformMatches(result, data) {
      var matches = result.matches;
      data.matches = [];
      if (!isDefined(matches)) {
        return;
      }
      matches.forEach(function(match) {
        if (!isDefined(match.indices) || !match.indices.length) {
          return;
        }
        var indices = match.indices, value = match.value;
        var obj = {
          indices,
          value
        };
        if (match.key) {
          obj.key = match.key.src;
        }
        if (match.idx > -1) {
          obj.refIndex = match.idx;
        }
        data.matches.push(obj);
      });
    }
    function transformScore(result, data) {
      data.score = result.score;
    }
    function format2(results, docs) {
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref$includeMatches = _ref.includeMatches, includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches, _ref$includeScore = _ref.includeScore, includeScore = _ref$includeScore === void 0 ? Config.includeScore : _ref$includeScore;
      var transformers = [];
      if (includeMatches)
        transformers.push(transformMatches);
      if (includeScore)
        transformers.push(transformScore);
      return results.map(function(result) {
        var idx = result.idx;
        var data = {
          item: docs[idx],
          refIndex: idx
        };
        if (transformers.length) {
          transformers.forEach(function(transformer) {
            transformer(result, data);
          });
        }
        return data;
      });
    }
    var Fuse2 = /* @__PURE__ */ function() {
      function Fuse3(docs) {
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var index2 = arguments.length > 2 ? arguments[2] : void 0;
        _classCallCheck(this, Fuse3);
        this.options = _objectSpread2({}, Config, {}, options2);
        if (this.options.useExtendedSearch && false) {
          throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
        }
        this._keyStore = new KeyStore(this.options.keys);
        this.setCollection(docs, index2);
      }
      _createClass(Fuse3, [{
        key: "setCollection",
        value: function setCollection(docs, index2) {
          this._docs = docs;
          if (index2 && !(index2 instanceof FuseIndex)) {
            throw new Error(INCORRECT_INDEX_TYPE);
          }
          this._myIndex = index2 || createIndex(this.options.keys, this._docs, {
            getFn: this.options.getFn
          });
        }
      }, {
        key: "add",
        value: function add(doc) {
          if (!isDefined(doc)) {
            return;
          }
          this._docs.push(doc);
          this._myIndex.add(doc);
        }
      }, {
        key: "remove",
        value: function remove() {
          var predicate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
            return false;
          };
          var results = [];
          for (var i = 0, len = this._docs.length; i < len; i += 1) {
            var doc = this._docs[i];
            if (predicate(doc, i)) {
              this.removeAt(i);
              i -= 1;
              len -= 1;
              results.push(doc);
            }
          }
          return results;
        }
      }, {
        key: "removeAt",
        value: function removeAt(idx) {
          this._docs.splice(idx, 1);
          this._myIndex.removeAt(idx);
        }
      }, {
        key: "getIndex",
        value: function getIndex() {
          return this._myIndex;
        }
      }, {
        key: "search",
        value: function search2(query) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? -1 : _ref$limit;
          var _this$options = this.options, includeMatches = _this$options.includeMatches, includeScore = _this$options.includeScore, shouldSort = _this$options.shouldSort, sortFn = _this$options.sortFn, ignoreFieldNorm = _this$options.ignoreFieldNorm;
          var results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
          computeScore$1(results, {
            ignoreFieldNorm
          });
          if (shouldSort) {
            results.sort(sortFn);
          }
          if (isNumber(limit) && limit > -1) {
            results = results.slice(0, limit);
          }
          return format2(results, this._docs, {
            includeMatches,
            includeScore
          });
        }
      }, {
        key: "_searchStringList",
        value: function _searchStringList(query) {
          var searcher = createSearcher(query, this.options);
          var records = this._myIndex.records;
          var results = [];
          records.forEach(function(_ref2) {
            var text = _ref2.v, idx = _ref2.i, norm2 = _ref2.n;
            if (!isDefined(text)) {
              return;
            }
            var _searcher$searchIn = searcher.searchIn(text), isMatch = _searcher$searchIn.isMatch, score = _searcher$searchIn.score, indices = _searcher$searchIn.indices;
            if (isMatch) {
              results.push({
                item: text,
                idx,
                matches: [{
                  score,
                  value: text,
                  norm: norm2,
                  indices
                }]
              });
            }
          });
          return results;
        }
      }, {
        key: "_searchLogical",
        value: function _searchLogical(query) {
          var _this = this;
          var expression = parse(query, this.options);
          var evaluate = function evaluate2(node, item, idx) {
            if (!node.children) {
              var keyId = node.keyId, searcher = node.searcher;
              var matches = _this._findMatches({
                key: _this._keyStore.get(keyId),
                value: _this._myIndex.getValueForItemAtKeyId(item, keyId),
                searcher
              });
              if (matches && matches.length) {
                return [{
                  idx,
                  item,
                  matches
                }];
              }
              return [];
            }
            switch (node.operator) {
              case LogicalOperator.AND: {
                var res = [];
                for (var i = 0, len = node.children.length; i < len; i += 1) {
                  var child = node.children[i];
                  var result = evaluate2(child, item, idx);
                  if (result.length) {
                    res.push.apply(res, _toConsumableArray(result));
                  } else {
                    return [];
                  }
                }
                return res;
              }
              case LogicalOperator.OR: {
                var _res = [];
                for (var _i = 0, _len = node.children.length; _i < _len; _i += 1) {
                  var _child = node.children[_i];
                  var _result = evaluate2(_child, item, idx);
                  if (_result.length) {
                    _res.push.apply(_res, _toConsumableArray(_result));
                    break;
                  }
                }
                return _res;
              }
            }
          };
          var records = this._myIndex.records;
          var resultMap = {};
          var results = [];
          records.forEach(function(_ref3) {
            var item = _ref3.$, idx = _ref3.i;
            if (isDefined(item)) {
              var expResults = evaluate(expression, item, idx);
              if (expResults.length) {
                if (!resultMap[idx]) {
                  resultMap[idx] = {
                    idx,
                    item,
                    matches: []
                  };
                  results.push(resultMap[idx]);
                }
                expResults.forEach(function(_ref4) {
                  var _resultMap$idx$matche;
                  var matches = _ref4.matches;
                  (_resultMap$idx$matche = resultMap[idx].matches).push.apply(_resultMap$idx$matche, _toConsumableArray(matches));
                });
              }
            }
          });
          return results;
        }
      }, {
        key: "_searchObjectList",
        value: function _searchObjectList(query) {
          var _this2 = this;
          var searcher = createSearcher(query, this.options);
          var _this$_myIndex = this._myIndex, keys = _this$_myIndex.keys, records = _this$_myIndex.records;
          var results = [];
          records.forEach(function(_ref5) {
            var item = _ref5.$, idx = _ref5.i;
            if (!isDefined(item)) {
              return;
            }
            var matches = [];
            keys.forEach(function(key, keyIndex) {
              matches.push.apply(matches, _toConsumableArray(_this2._findMatches({
                key,
                value: item[keyIndex],
                searcher
              })));
            });
            if (matches.length) {
              results.push({
                idx,
                item,
                matches
              });
            }
          });
          return results;
        }
      }, {
        key: "_findMatches",
        value: function _findMatches(_ref6) {
          var key = _ref6.key, value = _ref6.value, searcher = _ref6.searcher;
          if (!isDefined(value)) {
            return [];
          }
          var matches = [];
          if (isArray(value)) {
            value.forEach(function(_ref7) {
              var text2 = _ref7.v, idx = _ref7.i, norm3 = _ref7.n;
              if (!isDefined(text2)) {
                return;
              }
              var _searcher$searchIn2 = searcher.searchIn(text2), isMatch2 = _searcher$searchIn2.isMatch, score2 = _searcher$searchIn2.score, indices2 = _searcher$searchIn2.indices;
              if (isMatch2) {
                matches.push({
                  score: score2,
                  key,
                  value: text2,
                  idx,
                  norm: norm3,
                  indices: indices2
                });
              }
            });
          } else {
            var text = value.v, norm2 = value.n;
            var _searcher$searchIn3 = searcher.searchIn(text), isMatch = _searcher$searchIn3.isMatch, score = _searcher$searchIn3.score, indices = _searcher$searchIn3.indices;
            if (isMatch) {
              matches.push({
                score,
                key,
                value: text,
                norm: norm2,
                indices
              });
            }
          }
          return matches;
        }
      }]);
      return Fuse3;
    }();
    Fuse2.version = "6.4.6";
    Fuse2.createIndex = createIndex;
    Fuse2.parseIndex = parseIndex;
    Fuse2.config = Config;
    {
      Fuse2.parseQuery = parse;
    }
    {
      register2(ExtendedSearch);
    }
    module2.exports = Fuse2;
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind2 = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils7 = __commonJS({
  "node_modules/axios/lib/utils.js"(exports2, module2) {
    init_shims();
    "use strict";
    var bind = require_bind2();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData2(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject2(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob2(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject2(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.replace(/^\s*/, "").replace(/\s*$/, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData: isFormData2,
      isArrayBufferView,
      isString,
      isNumber,
      isObject: isObject2,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob: isBlob2,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils2.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils2.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils2.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils2.forEach(val, function parseValue(v) {
            if (utils2.isDate(v)) {
              v = v.toISOString();
            } else if (utils2.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled,
        rejected
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils2.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    module2.exports = function transformData(data, headers, fns) {
      utils2.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils2.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function enhanceError(error2, config, code, request, response) {
      error2.config = config;
      if (code) {
        error2.code = code;
      }
      error2.request = request;
      error2.response = response;
      error2.isAxiosError = true;
      error2.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code
        };
      };
      return error2;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports2, module2) {
    init_shims();
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request, response) {
      var error2 = new Error(message);
      return enhanceError(error2, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle2 = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports2, module2) {
    init_shims();
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve2, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    module2.exports = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils2.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils2.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils2.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read2(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read2() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    init_shims();
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils2.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils2.trim(line.substr(0, i)).toLowerCase();
        val = utils2.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    module2.exports = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    var settle = require_settle2();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        if (utils2.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(resolve2, reject, response);
          request = null;
        };
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, "ECONNABORTED", request));
          request = null;
        };
        if (utils2.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils2.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            if (config.responseType !== "json") {
              throw e;
            }
          }
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject(cancel);
            request = null;
          });
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/debug/src/common.js
var require_common5 = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    init_shims();
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    init_shims();
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = require_common5()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node4 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    init_shims();
    var tty = require("tty");
    var util = require("util");
    exports2.init = init2;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common5()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    init_shims();
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node4();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    init_shims();
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src2()("follow-redirects");
        } catch (error2) {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    init_shims();
    var url = require("url");
    var URL2 = url.URL;
    var http2 = require("http");
    var https2 = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug2();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    function RedirectableRequest(options2, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options2);
      this._options = options2;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (typeof data === "function") {
        callback = data;
        data = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      if (callback) {
        this.on("timeout", callback);
      }
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        clearTimeout(this._timeout);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!this.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.once("response", clearTimer);
      this.once("error", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.substr(0, protocol.length - 1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url.format(this._options);
      request._redirectable = this;
      for (var e = 0; e < events.length; e++) {
        request.on(events[e], eventHandlers[events[e]]);
      }
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error2) {
          if (request === self2._currentRequest) {
            if (error2) {
              self2.emit("error", error2);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
        abortRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) || url.parse(this._currentUrl).hostname;
        var redirectUrl = url.resolve(this._currentUrl, location);
        debug("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);
        if (redirectUrlParts.hostname !== previousHostName) {
          removeMatchingHeaders(/^authorization$/i, this._options.headers);
        }
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          } catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }
        try {
          this._performRequest();
        } catch (cause) {
          var error2 = new RedirectionError("Redirected request failed: " + cause.message);
          error2.cause = cause;
          this.emit("error", error2);
        }
      } else {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options2, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL2(urlStr));
            } catch (err) {
              input = url.parse(urlStr);
            }
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options2;
            options2 = input;
            input = { protocol };
          }
          if (typeof options2 === "function") {
            callback = options2;
            options2 = null;
          }
          options2 = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options2);
          options2.nativeProtocols = nativeProtocols;
          assert.equal(options2.protocol, protocol, "protocol mismatch");
          debug("options", options2);
          return new RedirectableRequest(options2, callback);
        }
        function get2(input, options2, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options2, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get2, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop3() {
    }
    function urlToOptions(urlObject) {
      var options2 = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options2.port = Number(urlObject.port);
      }
      return options2;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue;
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(message) {
        Error.captureStackTrace(this, this.constructor);
        this.message = message || defaultMessage;
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    function abortRequest(request) {
      for (var e = 0; e < events.length; e++) {
        request.removeListener(events[e], eventHandlers[events[e]]);
      }
      request.on("error", noop3);
      request.abort();
    }
    module2.exports = wrap({ http: http2, https: https2 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/axios/package.json
var require_package3 = __commonJS({
  "node_modules/axios/package.json"(exports2, module2) {
    module2.exports = {
      name: "axios",
      version: "0.21.1",
      description: "Promise based HTTP client for the browser and node.js",
      main: "index.js",
      scripts: {
        test: "grunt test && bundlesize",
        start: "node ./sandbox/server.js",
        build: "NODE_ENV=production grunt build",
        preversion: "npm test",
        version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
        postversion: "git push && git push --tags",
        examples: "node ./examples/server.js",
        coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
        fix: "eslint --fix lib/**/*.js"
      },
      repository: {
        type: "git",
        url: "https://github.com/axios/axios.git"
      },
      keywords: [
        "xhr",
        "http",
        "ajax",
        "promise",
        "node"
      ],
      author: "Matt Zabriskie",
      license: "MIT",
      bugs: {
        url: "https://github.com/axios/axios/issues"
      },
      homepage: "https://github.com/axios/axios",
      devDependencies: {
        bundlesize: "^0.17.0",
        coveralls: "^3.0.0",
        "es6-promise": "^4.2.4",
        grunt: "^1.0.2",
        "grunt-banner": "^0.6.0",
        "grunt-cli": "^1.2.0",
        "grunt-contrib-clean": "^1.1.0",
        "grunt-contrib-watch": "^1.0.0",
        "grunt-eslint": "^20.1.0",
        "grunt-karma": "^2.0.0",
        "grunt-mocha-test": "^0.13.3",
        "grunt-ts": "^6.0.0-beta.19",
        "grunt-webpack": "^1.0.18",
        "istanbul-instrumenter-loader": "^1.0.0",
        "jasmine-core": "^2.4.1",
        karma: "^1.3.0",
        "karma-chrome-launcher": "^2.2.0",
        "karma-coverage": "^1.1.1",
        "karma-firefox-launcher": "^1.1.0",
        "karma-jasmine": "^1.1.1",
        "karma-jasmine-ajax": "^0.1.13",
        "karma-opera-launcher": "^1.0.0",
        "karma-safari-launcher": "^1.0.0",
        "karma-sauce-launcher": "^1.2.0",
        "karma-sinon": "^1.0.5",
        "karma-sourcemap-loader": "^0.3.7",
        "karma-webpack": "^1.7.0",
        "load-grunt-tasks": "^3.5.2",
        minimist: "^1.2.0",
        mocha: "^5.2.0",
        sinon: "^4.5.0",
        typescript: "^2.8.1",
        "url-search-params": "^0.10.0",
        webpack: "^1.13.1",
        "webpack-dev-server": "^1.14.1"
      },
      browser: {
        "./lib/adapters/http.js": "./lib/adapters/xhr.js"
      },
      jsdelivr: "dist/axios.min.js",
      unpkg: "dist/axios.min.js",
      typings: "./index.d.ts",
      dependencies: {
        "follow-redirects": "^1.10.0"
      },
      bundlesize: [
        {
          path: "./dist/axios.min.js",
          threshold: "5kB"
        }
      ]
    };
  }
});

// node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({
  "node_modules/axios/lib/adapters/http.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    var settle = require_settle2();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http2 = require("http");
    var https2 = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib2 = require("zlib");
    var pkg = require_package3();
    var createError = require_createError();
    var enhanceError = require_enhanceError();
    var isHttps = /https:?/;
    function setProxy(options2, proxy, location) {
      options2.hostname = proxy.host;
      options2.host = proxy.host;
      options2.port = proxy.port;
      options2.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options2.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options2.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var resolve2 = function resolve3(value) {
          resolvePromise(value);
        };
        var reject = function reject2(value) {
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        if (!headers["User-Agent"] && !headers["user-agent"]) {
          headers["User-Agent"] = "axios/" + pkg.version;
        }
        if (data && !utils2.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils2.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils2.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(createError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", config));
          }
          headers["Content-Length"] = data.length;
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth) {
          delete headers.Authorization;
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        var options2 = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options2.socketPath = config.socketPath;
        } else {
          options2.hostname = parsed.hostname;
          options2.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s2) {
                return s2.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options2.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options2, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options2.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https2 : http2;
        } else {
          if (config.maxRedirects) {
            options2.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options2.maxBodyLength = config.maxBodyLength;
        }
        var req = transport.request(options2, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib2.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve2, reject, response);
          } else {
            var responseBuffer = [];
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {
                stream.destroy();
                reject(createError("maxContentLength size of " + config.maxContentLength + " exceeded", config, null, lastRequest));
              }
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(enhanceError(err, config, null, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              var responseData = Buffer.concat(responseBuffer);
              if (config.responseType !== "arraybuffer") {
                responseData = responseData.toString(config.responseEncoding);
                if (!config.responseEncoding || config.responseEncoding === "utf8") {
                  responseData = utils2.stripBOM(responseData);
                }
              }
              response.data = responseData;
              settle(resolve2, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return;
          reject(enhanceError(err, config, null, req));
        });
        if (config.timeout) {
          req.setTimeout(config.timeout, function handleRequestTimeout() {
            req.abort();
            reject(createError("timeout of " + config.timeout + "ms exceeded", config, "ECONNABORTED", req));
          });
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(cancel);
          });
        }
        if (utils2.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    var normalizeHeaderName = require_normalizeHeaderName();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils2.isUndefined(headers) && utils2.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http();
      }
      return adapter;
    }
    var defaults = {
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils2.isFormData(data) || utils2.isArrayBuffer(data) || utils2.isBuffer(data) || utils2.isStream(data) || utils2.isFile(data) || utils2.isBlob(data)) {
          return data;
        }
        if (utils2.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils2.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils2.isObject(data)) {
          setContentTypeIfUnset(headers, "application/json;charset=utf-8");
          return JSON.stringify(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        if (typeof data === "string") {
          try {
            data = JSON.parse(data);
          } catch (e) {
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils2.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils2.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData(config.data, config.headers, config.transformRequest);
      config.headers = utils2.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils2.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData(response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ["url", "method", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
      var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
      ];
      var directMergeKeys = ["validateStatus"];
      function getMergedValue(target, source) {
        if (utils2.isPlainObject(target) && utils2.isPlainObject(source)) {
          return utils2.merge(target, source);
        } else if (utils2.isPlainObject(source)) {
          return utils2.merge({}, source);
        } else if (utils2.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils2.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils2.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      }
      utils2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils2.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        }
      });
      utils2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils2.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        } else if (!utils2.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      utils2.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils2.forEach(otherKeys, mergeDeepProperties);
      return config;
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var chain = [dispatchRequest, void 0];
      var promise = Promise.resolve(config);
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });
      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    init_shims();
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      var token2 = this;
      executor(function cancel(message) {
        if (token2.reason) {
          return;
        }
        token2.reason = new Cancel(message);
        resolvePromise(token2.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token2 = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token2,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports2, module2) {
    init_shims();
    "use strict";
    var utils2 = require_utils7();
    var bind = require_bind2();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils2.extend(instance, Axios.prototype, context);
      utils2.extend(instance, context);
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports2, module2) {
    init_shims();
    module2.exports = require_axios();
  }
});

// node_modules/marked/src/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/marked/src/defaults.js"(exports2, module2) {
    init_shims();
    function getDefaults() {
      return {
        baseUrl: null,
        breaks: false,
        extensions: null,
        gfm: true,
        headerIds: true,
        headerPrefix: "",
        highlight: null,
        langPrefix: "language-",
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }
    function changeDefaults(newDefaults) {
      module2.exports.defaults = newDefaults;
    }
    module2.exports = {
      defaults: getDefaults(),
      getDefaults,
      changeDefaults
    };
  }
});

// node_modules/marked/src/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/marked/src/helpers.js"(exports2, module2) {
    init_shims();
    var escapeTest = /[&<>"']/;
    var escapeReplace = /[&<>"']/g;
    var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape3(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html;
    }
    var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape2(html) {
      return html.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === "colon")
          return ":";
        if (n.charAt(0) === "#") {
          return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return "";
      });
    }
    var caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      regex = regex.source || regex;
      opt = opt || "";
      const obj = {
        replace: (name, val) => {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    var nonWordAndColonTest = /[^\w:]/g;
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        let prot;
        try {
          prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    var baseUrls = {};
    var justDomain = /^[^:]+:\/*[^/]*$/;
    var protocol = /^([^:]+:)[\s\S]*$/;
    var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      const relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    var noopTest = { exec: function noopTest2() {
    } };
    function merge(obj) {
      let i = 1, target, key;
      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }
      return obj;
    }
    function splitCells(tableRow, count) {
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
        let escaped3 = false, curr = offset;
        while (--curr >= 0 && str[curr] === "\\")
          escaped3 = !escaped3;
        if (escaped3) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      let i = 0;
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count)
          cells.push("");
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
        return "";
      }
      let suffLen = 0;
      while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.substr(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      const l = str.length;
      let level = 0, i = 0;
      for (; i < l; i++) {
        if (str[i] === "\\") {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
    }
    function repeatString(pattern, count) {
      if (count < 1) {
        return "";
      }
      let result = "";
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }
    module2.exports = {
      escape: escape3,
      unescape: unescape2,
      edit,
      cleanUrl,
      resolveUrl,
      noopTest,
      merge,
      splitCells,
      rtrim,
      findClosingBracket,
      checkSanitizeDeprecation,
      repeatString
    };
  }
});

// node_modules/marked/src/Tokenizer.js
var require_Tokenizer = __commonJS({
  "node_modules/marked/src/Tokenizer.js"(exports2, module2) {
    init_shims();
    var { defaults } = require_defaults2();
    var {
      rtrim,
      splitCells,
      escape: escape3,
      findClosingBracket
    } = require_helpers2();
    function outputLink(cap, link, raw) {
      const href = link.href;
      const title = link.title ? escape3(link.title) : null;
      const text = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        return {
          type: "link",
          raw,
          href,
          title,
          text
        };
      } else {
        return {
          type: "image",
          raw,
          href,
          title,
          text: escape3(text)
        };
      }
    }
    function indentCodeCompensation(raw, text) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      const indentToCode = matchIndentToCode[1];
      return text.split("\n").map((node) => {
        const matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    module2.exports = class Tokenizer {
      constructor(options2) {
        this.options = options2 || defaults;
      }
      space(src2) {
        const cap = this.rules.block.newline.exec(src2);
        if (cap) {
          if (cap[0].length > 1) {
            return {
              type: "space",
              raw: cap[0]
            };
          }
          return { raw: "\n" };
        }
      }
      code(src2) {
        const cap = this.rules.block.code.exec(src2);
        if (cap) {
          const text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      }
      fences(src2) {
        const cap = this.rules.block.fences.exec(src2);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text
          };
        }
      }
      heading(src2) {
        const cap = this.rules.block.heading.exec(src2);
        if (cap) {
          let text = cap[2].trim();
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text
          };
        }
      }
      nptable(src2) {
        const cap = this.rules.block.nptable.exec(src2);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, "")),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : [],
            raw: cap[0]
          };
          if (item.header.length === item.align.length) {
            let l = item.align.length;
            let i;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.cells.length;
            for (i = 0; i < l; i++) {
              item.cells[i] = splitCells(item.cells[i], item.header.length);
            }
            return item;
          }
        }
      }
      hr(src2) {
        const cap = this.rules.block.hr.exec(src2);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src2) {
        const cap = this.rules.block.blockquote.exec(src2);
        if (cap) {
          const text = cap[0].replace(/^ *> ?/gm, "");
          return {
            type: "blockquote",
            raw: cap[0],
            text
          };
        }
      }
      list(src2) {
        const cap = this.rules.block.list.exec(src2);
        if (cap) {
          let raw = cap[0];
          const bull = cap[2];
          const isordered = bull.length > 1;
          const list = {
            type: "list",
            raw,
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          const itemMatch = cap[0].match(this.rules.block.item);
          let next = false, item, space, bcurr, bnext, addBack, loose, istask, ischecked, endMatch;
          let l = itemMatch.length;
          bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);
          for (let i = 0; i < l; i++) {
            item = itemMatch[i];
            raw = item;
            if (!this.options.pedantic) {
              endMatch = item.match(new RegExp("\\n\\s*\\n {0," + (bcurr[0].length - 1) + "}\\S"));
              if (endMatch) {
                addBack = item.length - endMatch.index + itemMatch.slice(i + 1).join("\n").length;
                list.raw = list.raw.substring(0, list.raw.length - addBack);
                item = item.substring(0, endMatch.index);
                raw = item;
                l = i + 1;
              }
            }
            if (i !== l - 1) {
              bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);
              if (!this.options.pedantic ? bnext[1].length >= bcurr[0].length || bnext[1].length > 3 : bnext[1].length > bcurr[1].length) {
                itemMatch.splice(i, 2, itemMatch[i] + (!this.options.pedantic && bnext[1].length < bcurr[0].length && !itemMatch[i].match(/\n$/) ? "" : "\n") + itemMatch[i + 1]);
                i--;
                l--;
                continue;
              } else if (!this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {
                addBack = itemMatch.slice(i + 1).join("\n").length;
                list.raw = list.raw.substring(0, list.raw.length - addBack);
                i = l - 1;
              }
              bcurr = bnext;
            }
            space = item.length;
            item = item.replace(/^ *([*+-]|\d+[.)]) ?/, "");
            if (~item.indexOf("\n ")) {
              space -= item.length;
              item = !this.options.pedantic ? item.replace(new RegExp("^ {1," + space + "}", "gm"), "") : item.replace(/^ {1,4}/gm, "");
            }
            item = rtrim(item, "\n");
            if (i !== l - 1) {
              raw = raw + "\n";
            }
            loose = next || /\n\n(?!\s*$)/.test(raw);
            if (i !== l - 1) {
              next = raw.slice(-2) === "\n\n";
              if (!loose)
                loose = next;
            }
            if (loose) {
              list.loose = true;
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.test(item);
              ischecked = void 0;
              if (istask) {
                ischecked = item[1] !== " ";
                item = item.replace(/^\[[ xX]\] +/, "");
              }
            }
            list.items.push({
              type: "list_item",
              raw,
              task: istask,
              checked: ischecked,
              loose,
              text: item
            });
          }
          return list;
        }
      }
      html(src2) {
        const cap = this.rules.block.html.exec(src2);
        if (cap) {
          return {
            type: this.options.sanitize ? "paragraph" : "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape3(cap[0]) : cap[0]
          };
        }
      }
      def(src2) {
        const cap = this.rules.block.def.exec(src2);
        if (cap) {
          if (cap[3])
            cap[3] = cap[3].substring(1, cap[3].length - 1);
          const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          return {
            type: "def",
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      }
      table(src2) {
        const cap = this.rules.block.table.exec(src2);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, "")),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            let l = item.align.length;
            let i;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.cells.length;
            for (i = 0; i < l; i++) {
              item.cells[i] = splitCells(item.cells[i].replace(/^ *\| *| *\| *$/g, ""), item.header.length);
            }
            return item;
          }
        }
      }
      lheading(src2) {
        const cap = this.rules.block.lheading.exec(src2);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1]
          };
        }
      }
      paragraph(src2) {
        const cap = this.rules.block.paragraph.exec(src2);
        if (cap) {
          return {
            type: "paragraph",
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1]
          };
        }
      }
      text(src2) {
        const cap = this.rules.block.text.exec(src2);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0]
          };
        }
      }
      escape(src2) {
        const cap = this.rules.inline.escape.exec(src2);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape3(cap[1])
          };
        }
      }
      tag(src2, inLink, inRawBlock) {
        const cap = this.rules.inline.tag.exec(src2);
        if (cap) {
          if (!inLink && /^<a /i.test(cap[0])) {
            inLink = true;
          } else if (inLink && /^<\/a>/i.test(cap[0])) {
            inLink = false;
          }
          if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = true;
          } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink,
            inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape3(cap[0]) : cap[0]
          };
        }
      }
      link(src2) {
        const cap = this.rules.inline.link.exec(src2);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf("!") === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link) {
              href = link[1];
              title = link[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0]);
        }
      }
      reflink(src2, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src2)) || (cap = this.rules.inline.nolink.exec(src2))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links[link.toLowerCase()];
          if (!link || !link.href) {
            const text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0]);
        }
      }
      emStrong(src2, maskedSrc, prevChar = "") {
        let match = this.rules.inline.emStrong.lDelim.exec(src2);
        if (!match)
          return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
          return;
        const nextChar = match[1] || match[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          const lLength = match[0].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src2.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim)
              continue;
            rLength = rDelim.length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            if (Math.min(lLength, rLength) % 2) {
              return {
                type: "em",
                raw: src2.slice(0, lLength + match.index + rLength + 1),
                text: src2.slice(1, lLength + match.index + rLength)
              };
            }
            return {
              type: "strong",
              raw: src2.slice(0, lLength + match.index + rLength + 1),
              text: src2.slice(2, lLength + match.index + rLength - 1)
            };
          }
        }
      }
      codespan(src2) {
        const cap = this.rules.inline.code.exec(src2);
        if (cap) {
          let text = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape3(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      }
      br(src2) {
        const cap = this.rules.inline.br.exec(src2);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src2) {
        const cap = this.rules.inline.del.exec(src2);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2]
          };
        }
      }
      autolink(src2, mangle) {
        const cap = this.rules.inline.autolink.exec(src2);
        if (cap) {
          let text, href;
          if (cap[2] === "@") {
            text = escape3(this.options.mangle ? mangle(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape3(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      url(src2, mangle) {
        let cap;
        if (cap = this.rules.inline.url.exec(src2)) {
          let text, href;
          if (cap[2] === "@") {
            text = escape3(this.options.mangle ? mangle(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape3(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + text;
            } else {
              href = text;
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      inlineText(src2, inRawBlock, smartypants) {
        const cap = this.rules.inline.text.exec(src2);
        if (cap) {
          let text;
          if (inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape3(cap[0]) : cap[0];
          } else {
            text = escape3(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      }
    };
  }
});

// node_modules/marked/src/rules.js
var require_rules = __commonJS({
  "node_modules/marked/src/rules.js"(exports2, module2) {
    init_shims();
    var {
      noopTest,
      edit,
      merge
    } = require_helpers2();
    var block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
      nptable: noopTest,
      table: noopTest,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
    block.item = edit(block.item, "gm").replace(/bull/g, block.bullet).getRegex();
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = merge({}, block);
    block.gfm = merge({}, block.normal, {
      nptable: "^ *([^|\\n ].*\\|.*)\\n {0,3}([-:]+ *\\|[-| :]*)(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
      table: "^ *\\|(.+)\\n {0,3}\\|?( *[-:]+[-| :]*)(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    });
    block.gfm.nptable = edit(block.gfm.nptable).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = merge({}, block.normal, {
      html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    var inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
      nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        rDelimAst: /\_\_[^_*]*?\*[^_*]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /\*\*[^_*]*?\_[^_*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline.escapedEmSt = /\\\*|\\_/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = merge({}, inline);
    inline.pedantic = merge({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = merge({}, inline.normal, {
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = merge({}, inline.gfm, {
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    module2.exports = {
      block,
      inline
    };
  }
});

// node_modules/marked/src/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/marked/src/Lexer.js"(exports2, module2) {
    init_shims();
    var Tokenizer = require_Tokenizer();
    var { defaults } = require_defaults2();
    var { block, inline } = require_rules();
    var { repeatString } = require_helpers2();
    function smartypants(text) {
      return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
    }
    function mangle(text) {
      let out = "", i, ch;
      const l = text.length;
      for (i = 0; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    module2.exports = class Lexer {
      constructor(options2) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options2 || defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      static get rules() {
        return {
          block,
          inline
        };
      }
      static lex(src2, options2) {
        const lexer = new Lexer(options2);
        return lexer.lex(src2);
      }
      static lexInline(src2, options2) {
        const lexer = new Lexer(options2);
        return lexer.inlineTokens(src2);
      }
      lex(src2) {
        src2 = src2.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
        this.blockTokens(src2, this.tokens, true);
        this.inline(this.tokens);
        return this.tokens;
      }
      blockTokens(src2, tokens = [], top = true) {
        if (this.options.pedantic) {
          src2 = src2.replace(/^ +$/gm, "");
        }
        let token2, i, l, lastToken, cutSrc, lastParagraphClipped;
        while (src2) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
            if (token2 = extTokenizer.call(this, src2, tokens)) {
              src2 = src2.substring(token2.raw.length);
              tokens.push(token2);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token2 = this.tokenizer.space(src2)) {
            src2 = src2.substring(token2.raw.length);
            if (token2.type) {
              tokens.push(token2);
            }
            continue;
          }
          if (token2 = this.tokenizer.code(src2)) {
            src2 = src2.substring(token2.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token2.raw;
              lastToken.text += "\n" + token2.text;
            } else {
              tokens.push(token2);
            }
            continue;
          }
          if (token2 = this.tokenizer.fences(src2)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.heading(src2)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.nptable(src2)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.hr(src2)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.blockquote(src2)) {
            src2 = src2.substring(token2.raw.length);
            token2.tokens = this.blockTokens(token2.text, [], top);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.list(src2)) {
            src2 = src2.substring(token2.raw.length);
            l = token2.items.length;
            for (i = 0; i < l; i++) {
              token2.items[i].tokens = this.blockTokens(token2.items[i].text, [], false);
            }
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.html(src2)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          if (top && (token2 = this.tokenizer.def(src2))) {
            src2 = src2.substring(token2.raw.length);
            if (!this.tokens.links[token2.tag]) {
              this.tokens.links[token2.tag] = {
                href: token2.href,
                title: token2.title
              };
            }
            continue;
          }
          if (token2 = this.tokenizer.table(src2)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.lheading(src2)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          cutSrc = src2;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src2.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call(this, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src2.substring(0, startIndex + 1);
            }
          }
          if (top && (token2 = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token2.raw;
              lastToken.text += "\n" + token2.text;
            } else {
              tokens.push(token2);
            }
            lastParagraphClipped = cutSrc.length !== src2.length;
            src2 = src2.substring(token2.raw.length);
            continue;
          }
          if (token2 = this.tokenizer.text(src2)) {
            src2 = src2.substring(token2.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token2.raw;
              lastToken.text += "\n" + token2.text;
            } else {
              tokens.push(token2);
            }
            continue;
          }
          if (src2) {
            const errMsg = "Infinite loop on byte: " + src2.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
      inline(tokens) {
        let i, j, k, l2, row, token2;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token2 = tokens[i];
          switch (token2.type) {
            case "paragraph":
            case "text":
            case "heading": {
              token2.tokens = [];
              this.inlineTokens(token2.text, token2.tokens);
              break;
            }
            case "table": {
              token2.tokens = {
                header: [],
                cells: []
              };
              l2 = token2.header.length;
              for (j = 0; j < l2; j++) {
                token2.tokens.header[j] = [];
                this.inlineTokens(token2.header[j], token2.tokens.header[j]);
              }
              l2 = token2.cells.length;
              for (j = 0; j < l2; j++) {
                row = token2.cells[j];
                token2.tokens.cells[j] = [];
                for (k = 0; k < row.length; k++) {
                  token2.tokens.cells[j][k] = [];
                  this.inlineTokens(row[k], token2.tokens.cells[j][k]);
                }
              }
              break;
            }
            case "blockquote": {
              this.inline(token2.tokens);
              break;
            }
            case "list": {
              l2 = token2.items.length;
              for (j = 0; j < l2; j++) {
                this.inline(token2.items[j].tokens);
              }
              break;
            }
            default: {
            }
          }
        }
        return tokens;
      }
      inlineTokens(src2, tokens = [], inLink = false, inRawBlock = false) {
        let token2, lastToken, cutSrc;
        let maskedSrc = src2;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        }
        while (src2) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
            if (token2 = extTokenizer.call(this, src2, tokens)) {
              src2 = src2.substring(token2.raw.length);
              tokens.push(token2);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token2 = this.tokenizer.escape(src2)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.tag(src2, inLink, inRawBlock)) {
            src2 = src2.substring(token2.raw.length);
            inLink = token2.inLink;
            inRawBlock = token2.inRawBlock;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token2.type === "text" && lastToken.type === "text") {
              lastToken.raw += token2.raw;
              lastToken.text += token2.text;
            } else {
              tokens.push(token2);
            }
            continue;
          }
          if (token2 = this.tokenizer.link(src2)) {
            src2 = src2.substring(token2.raw.length);
            if (token2.type === "link") {
              token2.tokens = this.inlineTokens(token2.text, [], true, inRawBlock);
            }
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.reflink(src2, this.tokens.links)) {
            src2 = src2.substring(token2.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (token2.type === "link") {
              token2.tokens = this.inlineTokens(token2.text, [], true, inRawBlock);
              tokens.push(token2);
            } else if (lastToken && token2.type === "text" && lastToken.type === "text") {
              lastToken.raw += token2.raw;
              lastToken.text += token2.text;
            } else {
              tokens.push(token2);
            }
            continue;
          }
          if (token2 = this.tokenizer.emStrong(src2, maskedSrc, prevChar)) {
            src2 = src2.substring(token2.raw.length);
            token2.tokens = this.inlineTokens(token2.text, [], inLink, inRawBlock);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.codespan(src2)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.br(src2)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.del(src2)) {
            src2 = src2.substring(token2.raw.length);
            token2.tokens = this.inlineTokens(token2.text, [], inLink, inRawBlock);
            tokens.push(token2);
            continue;
          }
          if (token2 = this.tokenizer.autolink(src2, mangle)) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          if (!inLink && (token2 = this.tokenizer.url(src2, mangle))) {
            src2 = src2.substring(token2.raw.length);
            tokens.push(token2);
            continue;
          }
          cutSrc = src2;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src2.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call(this, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src2.substring(0, startIndex + 1);
            }
          }
          if (token2 = this.tokenizer.inlineText(cutSrc, inRawBlock, smartypants)) {
            src2 = src2.substring(token2.raw.length);
            if (token2.raw.slice(-1) !== "_") {
              prevChar = token2.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token2.raw;
              lastToken.text += token2.text;
            } else {
              tokens.push(token2);
            }
            continue;
          }
          if (src2) {
            const errMsg = "Infinite loop on byte: " + src2.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    };
  }
});

// node_modules/marked/src/Renderer.js
var require_Renderer = __commonJS({
  "node_modules/marked/src/Renderer.js"(exports2, module2) {
    init_shims();
    var { defaults } = require_defaults2();
    var {
      cleanUrl,
      escape: escape3
    } = require_helpers2();
    module2.exports = class Renderer {
      constructor(options2) {
        this.options = options2 || defaults;
      }
      code(code, infostring, escaped3) {
        const lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped3 = true;
            code = out;
          }
        }
        code = code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped3 ? code : escape3(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape3(lang, true) + '">' + (escaped3 ? code : escape3(code, true)) + "</code></pre>\n";
      }
      blockquote(quote) {
        return "<blockquote>\n" + quote + "</blockquote>\n";
      }
      html(html) {
        return html;
      }
      heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text + "</h" + level + ">\n";
      }
      hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }
      list(body, ordered, start) {
        const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }
      listitem(text) {
        return "<li>" + text + "</li>\n";
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }
      paragraph(text) {
        return "<p>" + text + "</p>\n";
      }
      table(header, body) {
        if (body)
          body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }
      tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
        return tag + content + "</" + type + ">\n";
      }
      strong(text) {
        return "<strong>" + text + "</strong>";
      }
      em(text) {
        return "<em>" + text + "</em>";
      }
      codespan(text) {
        return "<code>" + text + "</code>";
      }
      br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }
      del(text) {
        return "<del>" + text + "</del>";
      }
      link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<a href="' + escape3(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      }
      image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      }
      text(text) {
        return text;
      }
    };
  }
});

// node_modules/marked/src/TextRenderer.js
var require_TextRenderer = __commonJS({
  "node_modules/marked/src/TextRenderer.js"(exports2, module2) {
    init_shims();
    module2.exports = class TextRenderer {
      strong(text) {
        return text;
      }
      em(text) {
        return text;
      }
      codespan(text) {
        return text;
      }
      del(text) {
        return text;
      }
      html(text) {
        return text;
      }
      text(text) {
        return text;
      }
      link(href, title, text) {
        return "" + text;
      }
      image(href, title, text) {
        return "" + text;
      }
      br() {
        return "";
      }
    };
  }
});

// node_modules/marked/src/Slugger.js
var require_Slugger = __commonJS({
  "node_modules/marked/src/Slugger.js"(exports2, module2) {
    init_shims();
    module2.exports = class Slugger {
      constructor() {
        this.seen = {};
      }
      serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }
      slug(value, options2 = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options2.dryrun);
      }
    };
  }
});

// node_modules/marked/src/Parser.js
var require_Parser = __commonJS({
  "node_modules/marked/src/Parser.js"(exports2, module2) {
    init_shims();
    var Renderer = require_Renderer();
    var TextRenderer = require_TextRenderer();
    var Slugger = require_Slugger();
    var { defaults } = require_defaults2();
    var {
      unescape: unescape2
    } = require_helpers2();
    module2.exports = class Parser {
      constructor(options2) {
        this.options = options2 || defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }
      static parse(tokens, options2) {
        const parser = new Parser(options2);
        return parser.parse(tokens);
      }
      static parseInline(tokens, options2) {
        const parser = new Parser(options2);
        return parser.parseInline(tokens);
      }
      parse(tokens, top = true) {
        let out = "", i, j, k, l2, l3, row, cell, header, body, token2, ordered, start, loose, itemBody, item, checked, task, checkbox, ret2;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token2 = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {
            ret2 = this.options.extensions.renderers[token2.type].call(this, token2);
            if (ret2 !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token2.type)) {
              out += ret2 || "";
              continue;
            }
          }
          switch (token2.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(this.parseInline(token2.tokens), token2.depth, unescape2(this.parseInline(token2.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              out += this.renderer.code(token2.text, token2.lang, token2.escaped);
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token2.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token2.tokens.header[j]), { header: true, align: token2.align[j] });
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token2.cells.length;
              for (j = 0; j < l2; j++) {
                row = token2.tokens.cells[j];
                cell = "";
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k]), { header: false, align: token2.align[k] });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token2.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token2.ordered;
              start = token2.start;
              loose = token2.loose;
              l2 = token2.items.length;
              body = "";
              for (j = 0; j < l2; j++) {
                item = token2.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "text") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token2.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token2.tokens));
              continue;
            }
            case "text": {
              body = token2.tokens ? this.parseInline(token2.tokens) : token2.text;
              while (i + 1 < l && tokens[i + 1].type === "text") {
                token2 = tokens[++i];
                body += "\n" + (token2.tokens ? this.parseInline(token2.tokens) : token2.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token2.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = "", i, token2, ret2;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token2 = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token2.type]) {
            ret2 = this.options.extensions.renderers[token2.type].call(this, token2);
            if (ret2 !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token2.type)) {
              out += ret2 || "";
              continue;
            }
          }
          switch (token2.type) {
            case "escape": {
              out += renderer.text(token2.text);
              break;
            }
            case "html": {
              out += renderer.html(token2.text);
              break;
            }
            case "link": {
              out += renderer.link(token2.href, token2.title, this.parseInline(token2.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token2.href, token2.title, token2.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token2.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token2.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token2.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token2.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token2.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token2.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    };
  }
});

// node_modules/marked/src/marked.js
var require_marked = __commonJS({
  "node_modules/marked/src/marked.js"(exports2, module2) {
    init_shims();
    var Lexer = require_Lexer();
    var Parser = require_Parser();
    var Tokenizer = require_Tokenizer();
    var Renderer = require_Renderer();
    var TextRenderer = require_TextRenderer();
    var Slugger = require_Slugger();
    var {
      merge,
      checkSanitizeDeprecation,
      escape: escape3
    } = require_helpers2();
    var {
      getDefaults,
      changeDefaults,
      defaults
    } = require_defaults2();
    function marked2(src2, opt, callback) {
      if (typeof src2 === "undefined" || src2 === null) {
        throw new Error("marked(): input parameter is undefined or null");
      }
      if (typeof src2 !== "string") {
        throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src2) + ", string expected");
      }
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      opt = merge({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      if (callback) {
        const highlight = opt.highlight;
        let tokens;
        try {
          tokens = Lexer.lex(src2, opt);
        } catch (e) {
          return callback(e);
        }
        const done = function(err) {
          let out;
          if (!err) {
            try {
              if (opt.walkTokens) {
                marked2.walkTokens(tokens, opt.walkTokens);
              }
              out = Parser.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
          }
          opt.highlight = highlight;
          return err ? callback(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length)
          return done();
        let pending = 0;
        marked2.walkTokens(tokens, function(token2) {
          if (token2.type === "code") {
            pending++;
            setTimeout(() => {
              highlight(token2.text, token2.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token2.text) {
                  token2.text = code;
                  token2.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done();
        }
        return;
      }
      try {
        const tokens = Lexer.lex(src2, opt);
        if (opt.walkTokens) {
          marked2.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parse(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape3(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    }
    marked2.options = marked2.setOptions = function(opt) {
      merge(marked2.defaults, opt);
      changeDefaults(marked2.defaults);
      return marked2;
    };
    marked2.getDefaults = getDefaults;
    marked2.defaults = defaults;
    marked2.use = function(...args) {
      const opts = merge({}, ...args);
      const extensions = marked2.defaults.extensions || { renderers: {}, childTokens: {} };
      let hasExtensions;
      args.forEach((pack) => {
        if (pack.extensions) {
          hasExtensions = true;
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret2 = ext.renderer.apply(this, args2);
                  if (ret2 === false) {
                    ret2 = prevRenderer.apply(this, args2);
                  }
                  return ret2;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
        }
        if (pack.renderer) {
          const renderer = marked2.defaults.renderer || new Renderer();
          for (const prop in pack.renderer) {
            const prevRenderer = renderer[prop];
            renderer[prop] = (...args2) => {
              let ret2 = pack.renderer[prop].apply(renderer, args2);
              if (ret2 === false) {
                ret2 = prevRenderer.apply(renderer, args2);
              }
              return ret2;
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = marked2.defaults.tokenizer || new Tokenizer();
          for (const prop in pack.tokenizer) {
            const prevTokenizer = tokenizer[prop];
            tokenizer[prop] = (...args2) => {
              let ret2 = pack.tokenizer[prop].apply(tokenizer, args2);
              if (ret2 === false) {
                ret2 = prevTokenizer.apply(tokenizer, args2);
              }
              return ret2;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.walkTokens) {
          const walkTokens = marked2.defaults.walkTokens;
          opts.walkTokens = (token2) => {
            pack.walkTokens.call(this, token2);
            if (walkTokens) {
              walkTokens(token2);
            }
          };
        }
        if (hasExtensions) {
          opts.extensions = extensions;
        }
        marked2.setOptions(opts);
      });
    };
    marked2.walkTokens = function(tokens, callback) {
      for (const token2 of tokens) {
        callback(token2);
        switch (token2.type) {
          case "table": {
            for (const cell of token2.tokens.header) {
              marked2.walkTokens(cell, callback);
            }
            for (const row of token2.tokens.cells) {
              for (const cell of row) {
                marked2.walkTokens(cell, callback);
              }
            }
            break;
          }
          case "list": {
            marked2.walkTokens(token2.items, callback);
            break;
          }
          default: {
            if (marked2.defaults.extensions && marked2.defaults.extensions.childTokens && marked2.defaults.extensions.childTokens[token2.type]) {
              marked2.defaults.extensions.childTokens[token2.type].forEach(function(childTokens) {
                marked2.walkTokens(token2[childTokens], callback);
              });
            } else if (token2.tokens) {
              marked2.walkTokens(token2.tokens, callback);
            }
          }
        }
      }
    };
    marked2.parseInline = function(src2, opt) {
      if (typeof src2 === "undefined" || src2 === null) {
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      }
      if (typeof src2 !== "string") {
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src2) + ", string expected");
      }
      opt = merge({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      try {
        const tokens = Lexer.lexInline(src2, opt);
        if (opt.walkTokens) {
          marked2.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parseInline(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape3(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    };
    marked2.Parser = Parser;
    marked2.parser = Parser.parse;
    marked2.Renderer = Renderer;
    marked2.TextRenderer = TextRenderer;
    marked2.Lexer = Lexer;
    marked2.lexer = Lexer.lex;
    marked2.Tokenizer = Tokenizer;
    marked2.Slugger = Slugger;
    marked2.parse = marked2;
    module2.exports = marked2;
  }
});

// .svelte-kit/vercel/entry.js
__export(exports, {
  default: () => entry_default
});
init_shims();

// node_modules/@sveltejs/kit/dist/node.js
init_shims();

// node_modules/@sveltejs/kit/dist/adapter-utils.js
init_shims();
function isContentTypeTextual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}

// node_modules/@sveltejs/kit/dist/node.js
function getRawBody(req) {
  return new Promise((fulfil, reject) => {
    const h = req.headers;
    if (!h["content-type"]) {
      return fulfil("");
    }
    req.on("error", reject);
    const length = Number(h["content-length"]);
    if (isNaN(length) && h["transfer-encoding"] == null) {
      return fulfil("");
    }
    let data = new Uint8Array(length || 0);
    if (length > 0) {
      let offset = 0;
      req.on("data", (chunk) => {
        const new_len = offset + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data.set(chunk, offset);
        offset = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data, 0);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      const [type] = (h["content-type"] || "").split(/;\s*/);
      if (isContentTypeTextual(type)) {
        const encoding = h["content-encoding"] || "utf-8";
        return fulfil(new TextDecoder(encoding).decode(data));
      }
      fulfil(data);
    });
  });
}

// .svelte-kit/output/server/app.js
init_shims();

// node_modules/@sveltejs/kit/dist/ssr.js
init_shims();
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive2(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive2(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive2(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive2(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s2 = subscribers[i];
          s2[1]();
          subscriber_queue.push(s2, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  options: options2,
  $session,
  page_config,
  status,
  error: error2,
  branch,
  page
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (branch) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page && page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page && page.path)},
						query: new URLSearchParams(${page ? s$1(page.query.toString()) : ""}),
						params: ${page && s$1(page.params)}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url="${url}"`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n			")}
		`.replace(/^\t{2}/gm, "");
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(err);
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack } = error2;
    serialized = try_serialize({ ...error2, name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  return loaded;
}
var absolute = /^([a-z]+:)?\/?\//;
function resolve(base, path) {
  const base_match = absolute.exec(base);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base}"`);
  }
  const baseparts = path_match ? [] : base.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page,
  node,
  $session,
  context,
  is_leaf,
  is_error,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let loaded;
  if (module2.load) {
    const load_input = {
      page,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const filename = resolved.replace(options2.paths.assets, "").slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d2) => d2.file === filename || d2.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? {
              "content-type": asset.type
            } : {}
          }) : await fetch(`http://${page.host}/${asset.file}`, opts);
        } else if (resolved.startsWith(options2.paths.base || "/") && !resolved.startsWith("//")) {
          const relative = resolved.replace(options2.paths.base, "");
          const headers = { ...opts.headers };
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body,
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = {
                ...opts.headers,
                cookie: request.headers.cookie
              };
            }
          }
          const external_request = new Request(url, opts);
          response = await options2.hooks.serverFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 !== "etag" && key2 !== "set-cookie")
                    headers[key2] = value;
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      context: { ...context }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    context: loaded.context || context,
    fetched,
    uses_credentials
  };
}
var escaped = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function coalesce_to_error(err) {
  return err instanceof Error ? err : new Error(JSON.stringify(err));
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error2 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    context: {},
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      context: loaded ? loaded.context : {},
      is_leaf: false,
      is_error: true,
      status,
      error: error2
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error2,
      branch,
      page
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
async function respond$1({ request, options: options2, state, $session, route }) {
  const match = route.pattern.exec(request.path);
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => options2.load_component(id)));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  const page_config = {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: ""
    };
  }
  let branch;
  let status = 200;
  let error2;
  ssr:
    if (page_config.ssr) {
      let context = {};
      branch = [];
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              request,
              options: options2,
              state,
              route,
              page,
              node,
              $session,
              context,
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            if (loaded.loaded.redirect) {
              return {
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              };
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            } else {
              branch.push(loaded);
            }
          } catch (err) {
            const e = coalesce_to_error(err);
            options2.handle_error(e);
            status = 500;
            error2 = e;
          }
          if (error2) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let error_loaded;
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  error_loaded = await load_node({
                    request,
                    options: options2,
                    state,
                    route,
                    page,
                    node: error_node,
                    $session,
                    context: node_loaded.context,
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error2
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e = coalesce_to_error(err);
                  options2.handle_error(e);
                  continue;
                }
              }
            }
            return await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error2
            });
          }
        }
        if (loaded && loaded.loaded.context) {
          context = {
            ...context,
            ...loaded.loaded.context
          };
        }
      }
    }
  try {
    return await render_response({
      options: options2,
      $session,
      page_config,
      status,
      error: error2,
      branch: branch && branch.filter(Boolean),
      page
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
}
async function render_page(request, route, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const $session = await options2.hooks.getSession(request);
  if (route) {
    const response = await respond$1({
      request,
      options: options2,
      state,
      $session,
      route
    });
    if (response) {
      return response;
    }
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  } else {
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 404,
      error: new Error(`Not found: ${request.path}`)
    });
  }
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s2) {
  return typeof s2 === "string" || s2 instanceof String;
}
async function render_route(request, route) {
  const mod = await route.load();
  const handler = mod[request.method.toLowerCase().replace("delete", "del")];
  if (!handler) {
    return error("no handler");
  }
  const match = route.pattern.exec(request.path);
  if (!match) {
    return error("could not parse parameters from request path");
  }
  const params = route.params(match);
  const response = await handler({ ...request, params });
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return error("no response");
  }
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type = headers["content-type"];
  const is_type_textual = isContentTypeTextual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers = { ...headers, "content-type": "application/json; charset=utf-8" };
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        (map.get(key) || []).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  #map;
  constructor(map) {
    this.#map = map;
  }
  get(key) {
    const value = this.#map.get(key);
    return value && value[0];
  }
  getAll(key) {
    return this.#map.get(key);
  }
  has(key) {
    return this.#map.has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key] of this.#map)
      yield key;
  }
  *values() {
    for (const [, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield value[i];
      }
    }
  }
};
function parse_body(raw, headers) {
  if (!raw || typeof raw !== "string")
    return raw;
  const [type, ...directives] = headers["content-type"].split(/;\s*/);
  switch (type) {
    case "text/plain":
      return raw;
    case "application/json":
      return JSON.parse(raw);
    case "application/x-www-form-urlencoded":
      return get_urlencoded(raw);
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(raw, boundary.slice("boundary=".length));
    }
    default:
      throw new Error(`Invalid Content-Type ${type}`);
  }
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      headers[name] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: encodeURI(path + (q ? `?${q}` : ""))
        }
      };
    }
  }
  try {
    const headers = lowercase_keys(incoming.headers);
    return await options2.hooks.handle({
      request: {
        ...incoming,
        headers,
        body: parse_body(incoming.rawBody, headers),
        params: {},
        locals: {}
      },
      resolve: async (request) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        for (const route of options2.manifest.routes) {
          if (!route.pattern.test(request.path))
            continue;
          const response = route.type === "endpoint" ? await render_route(request, route) : await render_page(request, route, options2, state);
          if (response) {
            if (response.status === 200) {
              if (!/(no-store|immutable)/.test(response.headers["cache-control"])) {
                const etag = `"${hash(response.body || "")}"`;
                if (request.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: ""
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        return await render_page(request, null, options2, state);
      }
    });
  } catch (err) {
    const e = coalesce_to_error(err);
    options2.handle_error(e);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}

// .svelte-kit/output/server/app.js
var import_mongoose = __toModule(require_mongoose());
var import_fuse = __toModule(require_fuse_common());
var import_axios = __toModule(require_axios2());
var import_marked = __toModule(require_marked());
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function safe_not_equal2(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop2;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function set_store_value(store, ret2, value) {
  store.set(value);
  return ret2;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
Promise.resolve();
var escaped2 = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape2(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(parent_component ? parent_component.$$.context : context || []),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape2(value)) : `"${value}"`}`}`;
}
function afterUpdate() {
}
var css$2 = {
  code: "#svelte-announcer.svelte-1pdgbjn{clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;left:0;overflow:hidden;position:absolute;top:0;white-space:nowrap;width:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>#svelte-announcer{clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;left:0;overflow:hidden;position:absolute;top:0;white-space:nowrap;width:1px}</style>"],"names":[],"mappings":"AAqDO,gCAAiB,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,kBAAkB,MAAM,GAAG,CAAC,CAAC,UAAU,MAAM,GAAG,CAAC,CAAC,OAAO,GAAG,CAAC,KAAK,CAAC,CAAC,SAAS,MAAM,CAAC,SAAS,QAAQ,CAAC,IAAI,CAAC,CAAC,YAAY,MAAM,CAAC,MAAM,GAAG,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$2);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${``}`;
});
function set_paths(paths) {
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n\n<head>\n	<meta charset="utf-8" />\n	<link rel="icon" href="/favicon.png" />\n	<meta name="viewport" content="width=device-width, initial-scale=1" />\n	' + head + '\n</head>\n\n<body>\n	<div id="svelte">' + body + "</div>\n</body>\n\n</html>";
var options = null;
var default_settings = { paths: { "base": "", "assets": "/." } };
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-585ef274.js",
      css: ["/./_app/assets/start-0826e215.css"],
      js: ["/./_app/start-585ef274.js", "/./_app/chunks/vendor-026e69f7.js", "/./_app/chunks/preload-helper-08cc8e69.js", "/./_app/chunks/singletons-12a22614.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => "/./_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2) => {
      if (error2.frame) {
        console.error(error2.frame);
      }
      console.error(error2.stack);
      error2.stack = options.get_stack(error2);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var d = decodeURIComponent;
var empty = () => ({});
var manifest = {
  assets: [{ "file": "favicon.png", "size": 1571, "type": "image/png" }],
  layout: "src/routes/__layout.svelte",
  error: "src/routes/__error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/articles\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/articles/index.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/register\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/register.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/login\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/login.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "endpoint",
      pattern: /^\/posts\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return posts;
      })
    },
    {
      type: "page",
      pattern: /^\/blog\/new\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/blog/new.svelte"],
      b: ["src/routes/__error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/blog\/([^/]+?)\/?$/,
      params: (m) => ({ slug: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/blog/[slug].svelte"],
      b: ["src/routes/__error.svelte"]
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
  serverFetch: hooks.serverFetch || fetch
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  "src/routes/__error.svelte": () => Promise.resolve().then(function() {
    return __error;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$1;
  }),
  "src/routes/articles/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/register.svelte": () => Promise.resolve().then(function() {
    return register;
  }),
  "src/routes/login.svelte": () => Promise.resolve().then(function() {
    return login;
  }),
  "src/routes/blog/new.svelte": () => Promise.resolve().then(function() {
    return _new;
  }),
  "src/routes/blog/[slug].svelte": () => Promise.resolve().then(function() {
    return _slug_;
  })
};
var metadata_lookup = { "src/routes/__layout.svelte": { "entry": "/./_app/pages/__layout.svelte-c9d6daa8.js", "css": ["/./_app/assets/pages/__layout.svelte-da2edf22.css"], "js": ["/./_app/pages/__layout.svelte-c9d6daa8.js", "/./_app/chunks/vendor-026e69f7.js", "/./_app/chunks/Env-828c620c.js", "/./_app/chunks/postStore-a423fcad.js"], "styles": [] }, "src/routes/__error.svelte": { "entry": "/./_app/pages/__error.svelte-bbbb8ba1.js", "css": [], "js": ["/./_app/pages/__error.svelte-bbbb8ba1.js", "/./_app/chunks/vendor-026e69f7.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "/./_app/pages/index.svelte-92fe7f2a.js", "css": [], "js": ["/./_app/pages/index.svelte-92fe7f2a.js", "/./_app/chunks/vendor-026e69f7.js", "/./_app/chunks/postStore-a423fcad.js"], "styles": [] }, "src/routes/articles/index.svelte": { "entry": "/./_app/pages/articles/index.svelte-0b8be92b.js", "css": [], "js": ["/./_app/pages/articles/index.svelte-0b8be92b.js", "/./_app/chunks/vendor-026e69f7.js"], "styles": [] }, "src/routes/register.svelte": { "entry": "/./_app/pages/register.svelte-5fc684f1.js", "css": [], "js": ["/./_app/pages/register.svelte-5fc684f1.js", "/./_app/chunks/vendor-026e69f7.js"], "styles": [] }, "src/routes/login.svelte": { "entry": "/./_app/pages/login.svelte-8a045a4e.js", "css": ["/./_app/assets/pages/login.svelte-5e61719c.css"], "js": ["/./_app/pages/login.svelte-8a045a4e.js", "/./_app/chunks/vendor-026e69f7.js", "/./_app/chunks/navigation-2ffed81e.js", "/./_app/chunks/singletons-12a22614.js", "/./_app/chunks/Env-828c620c.js"], "styles": [] }, "src/routes/blog/new.svelte": { "entry": "/./_app/pages/blog/new.svelte-a93bfa4a.js", "css": ["/./_app/assets/pages/blog/new.svelte-aeff9b13.css"], "js": ["/./_app/pages/blog/new.svelte-a93bfa4a.js", "/./_app/chunks/vendor-026e69f7.js", "/./_app/chunks/Env-828c620c.js", "/./_app/chunks/navigation-2ffed81e.js", "/./_app/chunks/singletons-12a22614.js"], "styles": [] }, "src/routes/blog/[slug].svelte": { "entry": "/./_app/pages/blog/[slug].svelte-74951083.js", "css": [], "js": ["/./_app/pages/blog/[slug].svelte-74951083.js", "/./_app/chunks/preload-helper-08cc8e69.js", "/./_app/chunks/vendor-026e69f7.js", "/./_app/chunks/Env-828c620c.js", "/./_app/chunks/navigation-2ffed81e.js", "/./_app/chunks/singletons-12a22614.js"], "styles": [] } };
async function load_component(file) {
  return {
    module: await module_lookup[file](),
    ...metadata_lookup[file]
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender });
}
var MONGODB_URI = "mongodb+srv://worakrit:wor8016786216@cluster0.jyovn.mongodb.net/pbox?authSource=admin&replicaSet=atlas-gh4atu-shard-0&w=majority&readPreference=primary&appname=MongoDB%20Compass&retryWrites=true&ssl=true";
var cached = global.mongoose;
if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}
async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }
  if (!cached.promise) {
    const opts = {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      bufferCommands: false,
      bufferMaxEntries: 0,
      useFindAndModify: false,
      useCreateIndex: true
    };
    cached.promise = import_mongoose.default.connect(MONGODB_URI, opts).then((mongoose2) => {
      return mongoose2;
    });
  }
  cached.conn = await cached.promise;
  return cached.conn;
}
var API = "https://pboxapi.herokuapp.com";
var ArticleSchema = new import_mongoose.default.Schema({
  title: String,
  content: String,
  url: String,
  photoURL: String
});
var Article = import_mongoose.default.models.Article || import_mongoose.default.model("Article", ArticleSchema);
var baseAPI = API;
async function get() {
  const res = await fetch(`${baseAPI}/posts`);
  const data = await res.json();
  if (res.ok) {
    return { body: data };
  }
  await dbConnect();
  const articles = await Article.find({});
  return { body: articles };
}
var posts = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get
});
var subscriber_queue2 = [];
function writable2(value, start = noop2) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue2.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue2.length; i += 2) {
            subscriber_queue2[i][0](subscriber_queue2[i + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop2;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
var user = writable2(null);
var postStore = writable2([]);
var token = writable2("");
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_token;
  let $user, $$unsubscribe_user;
  let $$unsubscribe_userStore;
  $$unsubscribe_token = subscribe(token, (value) => value);
  $$unsubscribe_user = subscribe(user, (value) => $user = value);
  $$unsubscribe_userStore = subscribe(user, (value) => value);
  (function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  $$unsubscribe_token();
  $$unsubscribe_user();
  $$unsubscribe_userStore();
  return `


<nav class="${"bg-white border-b border-gray-500 py-6 px-4 w-full"}"><div class="${"flex items-center justify-between container mx-auto"}"><a href="${"/"}" class="${"font-bold no-underline"}">P B O X</a>
    <section>${!$user ? `<a href="${"/login"}" class="${"font-mono no-underline"}">Login</a>
        <a href="${"/register"}" class="${"font-mono no-underline"}">Register</a>` : `<a href="${"/blog/new"}" class="${"font-mono no-underline mr-3"}">New</a>
        <span class="${"font-mono text-gray-500"}">${escape2($user.username)}</span>
        <button>Logout</button>`}</section></div></nav>
${``}`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
var load$3 = ({ error: error2, status }) => {
  return { props: { error: error2, status } };
};
var _error = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { error: error2 } = $$props;
  let { status } = $$props;
  if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
    $$bindings.error(error2);
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  return `




<div class="${"fixed w-full h-full grid place-items-center"}"><section class="${"p-8 border-gray-500 rounded"}"><h1 class="${"text-center text-4xl font-mono-mt-4"}">${escape2(status)}</h1>
    <p class="${"text-center"}">${escape2(error2.message)}</p></section></div>`;
});
var __error = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _error,
  load: load$3
});
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var load$2 = ({ fetch: fetch2 }) => __awaiter$2(void 0, void 0, void 0, function* () {
  const res = yield fetch2("/posts");
  const data = yield res.json();
  return { props: { posts: data } };
});
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $postStore, $$unsubscribe_postStore;
  $$unsubscribe_postStore = subscribe(postStore, (value) => $postStore = value);
  let { posts: posts2 } = $$props;
  let q = "";
  new import_fuse.default(posts2, { keys: ["title", "content"] });
  if ($$props.posts === void 0 && $$bindings.posts && posts2 !== void 0)
    $$bindings.posts(posts2);
  set_store_value(postStore, $postStore = posts2, $postStore);
  $$unsubscribe_postStore();
  return `




<div class="${"my-4"}"><h1 class="${"text-center text-3xl font-bold"}">PBOX

    <button>${escape2("\u{1F7E3}")}</button></h1></div>
<div class="${"grid place-items-center"}"><input type="${"text"}" placeholder="${"Search"}" class="${"items-center text-3xl font-bold outline-none"}"${add_attribute("value", q, 0)}></div>

<div class="${"container mx-auto mt-4"}">${each($postStore, (post) => `${`<div class="${"shadow-md my-4 p-4 rounded-md hover:shadow-xl"}"><a sveltekit:prefetch href="${"/blog/" + escape2(post.id)}"><h4 class="${"font-bold hover:text-purple-400"}">${escape2(post.title)}</h4>
          <p class="${"mt-2 text-gray-800"}">${escape2(post.url)}</p>
          <p class="${"text-gray-500"}">By: ${escape2(post.author.username)}</p></a>
      </div>`}`)}</div>`;
});
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes,
  load: load$2
});
var Articles = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return ``;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Articles
});
var Register = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let username, email, password;
  return `<form><input type="${"text"}" placeholder="${"username"}"${add_attribute("value", username, 0)}>
    <input type="${"email"}" placeholder="${"email"}"${add_attribute("value", email, 0)}>
    <input type="${"password"}" placeholder="${"password"}"${add_attribute("value", password, 0)}>
    <button type="${"submit"}">Register  </button></form>

`;
});
var register = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Register
});
var css$1 = {
  code: "label.svelte-11g8bsn{display:block;font-weight:700;margin-bottom:.25rem}input.svelte-11g8bsn{--tw-border-opacity:1;background-color:rgba(255,255,255,var(--tw-bg-opacity));border-color:rgba(107,114,128,var(--tw-border-opacity));border-width:1px;outline:2px solid transparent;outline-offset:2px;width:100%}.submit.svelte-11g8bsn,input.svelte-11g8bsn{--tw-bg-opacity:1;border-radius:.25rem;padding:.5rem 1rem}.submit.svelte-11g8bsn{--tw-text-opacity:1;background-color:rgba(59,130,246,var(--tw-bg-opacity));border-color:transparent;color:rgba(255,255,255,var(--tw-text-opacity))}",
  map: `{"version":3,"file":"login.svelte","sources":["login.svelte"],"sourcesContent":["<script lang=\\"ts\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\n;\\r\\nimport { goto } from '$app/navigation';\\r\\nimport user from '$lib/user';\\r\\nimport { API } from '$lib/Env';\\r\\nlet email = '';\\r\\nlet password = '';\\r\\nfunction login() {\\r\\n    var _a, _b, _c, _d;\\r\\n    return __awaiter(this, void 0, void 0, function* () {\\r\\n        const res = yield fetch(\`\${API}/auth/local\`, {\\r\\n            method: 'POST',\\r\\n            headers: { 'Content-Type': 'application/json', Accept: 'application/json' },\\r\\n            body: JSON.stringify({ identifier: email, password })\\r\\n        });\\r\\n        if (res.ok) {\\r\\n            const data = yield res.json();\\r\\n            localStorage.setItem(\\"token\\", data.jwt);\\r\\n            if (data) {\\r\\n                $user = data.user;\\r\\n                goto('/');\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            const data = yield res.json();\\r\\n            if ((_d = (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data.message) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.messages) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.message) {\\r\\n                alert(data.message[0].messages[0].message);\\r\\n            }\\r\\n        }\\r\\n    });\\r\\n}\\r\\n<\/script>\\r\\n\\r\\n<form on:submit|preventDefault={login} class=\\"container mx-auto my-4\\">\\r\\n    <h1 class=\\"text-center text-2xl font-bold\\">Login</h1>\\r\\n\\r\\n    <div class=\\"my-1\\">\\r\\n        <label for=\\"email\\">Email</label>\\r\\n        <input type=\\"email\\" placeholder=\\"Enter your email\\" bind:value={email} name=\\"email\\"/>\\r\\n    </div>\\r\\n    <div class=\\"my-1\\">\\r\\n        <label for=\\"password\\">Password</label>\\r\\n        <input type=\\"password\\" placeholder=\\"Enter your password\\" bind:value={password}   name=\\"password\\"/>\\r\\n    </div>\\r\\n    <div class=\\"my-3\\">\\r\\n        <button class=\\"submit\\" type=\\"submit\\">Login</button>\\r\\n    </div>\\r\\n</form>\\r\\n\\r\\n<style lang=\\"postcss\\">label{display:block;font-weight:700;margin-bottom:.25rem}input{--tw-border-opacity:1;background-color:rgba(255,255,255,var(--tw-bg-opacity));border-color:rgba(107,114,128,var(--tw-border-opacity));border-width:1px;outline:2px solid transparent;outline-offset:2px;width:100%}.submit,input{--tw-bg-opacity:1;border-radius:.25rem;padding:.5rem 1rem}.submit{--tw-text-opacity:1;background-color:rgba(59,130,246,var(--tw-bg-opacity));border-color:transparent;color:rgba(255,255,255,var(--tw-text-opacity))}</style>"],"names":[],"mappings":"AAyDsB,oBAAK,CAAC,QAAQ,KAAK,CAAC,YAAY,GAAG,CAAC,cAAc,MAAM,CAAC,oBAAK,CAAC,oBAAoB,CAAC,CAAC,iBAAiB,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC,aAAa,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,mBAAmB,CAAC,CAAC,CAAC,aAAa,GAAG,CAAC,QAAQ,GAAG,CAAC,KAAK,CAAC,WAAW,CAAC,eAAe,GAAG,CAAC,MAAM,IAAI,CAAC,sBAAO,CAAC,oBAAK,CAAC,gBAAgB,CAAC,CAAC,cAAc,MAAM,CAAC,QAAQ,KAAK,CAAC,IAAI,CAAC,sBAAO,CAAC,kBAAkB,CAAC,CAAC,iBAAiB,KAAK,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC,aAAa,WAAW,CAAC,MAAM,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,iBAAiB,CAAC,CAAC,CAAC"}`
};
var Login = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_user;
  $$unsubscribe_user = subscribe(user, (value) => value);
  (function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let email = "";
  let password = "";
  $$result.css.add(css$1);
  $$unsubscribe_user();
  return `<form class="${"container mx-auto my-4"}"><h1 class="${"text-center text-2xl font-bold"}">Login</h1>

    <div class="${"my-1"}"><label for="${"email"}" class="${"svelte-11g8bsn"}">Email</label>
        <input type="${"email"}" placeholder="${"Enter your email"}" name="${"email"}" class="${"svelte-11g8bsn"}"${add_attribute("value", email, 0)}></div>
    <div class="${"my-1"}"><label for="${"password"}" class="${"svelte-11g8bsn"}">Password</label>
        <input type="${"password"}" placeholder="${"Enter your password"}" name="${"password"}" class="${"svelte-11g8bsn"}"${add_attribute("value", password, 0)}></div>
    <div class="${"my-3"}"><button class="${"submit svelte-11g8bsn"}" type="${"submit"}">Login</button></div>
</form>`;
});
var login = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Login
});
var css = {
  code: "label.svelte-1gr50x2{display:block;font-weight:700;margin-bottom:.25rem}input.svelte-1gr50x2,textarea.svelte-1gr50x2{--tw-border-opacity:1;--tw-bg-opacity:1;background-color:rgba(255,255,255,var(--tw-bg-opacity));border-color:rgba(107,114,128,var(--tw-border-opacity));border-radius:.25rem;border-width:1px;outline:2px solid transparent;outline-offset:2px;padding:.5rem 1rem;width:100%}textarea.svelte-1gr50x2{resize:vertical}.submit.svelte-1gr50x2{--tw-bg-opacity:1;--tw-text-opacity:1;background-color:rgba(59,130,246,var(--tw-bg-opacity));border-color:transparent;border-radius:.25rem;color:rgba(255,255,255,var(--tw-text-opacity));padding:.5rem 1rem}",
  map: '{"version":3,"file":"new.svelte","sources":["new.svelte"],"sourcesContent":["<!-- src/routes/new.svelte -->\\r\\n<script lang=\\"ts\\" context=\\"module\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\n;\\r\\n;\\r\\nimport { API } from \\"$lib/Env\\";\\r\\nexport const load = ({ fetch, page: { query } }) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    // edit will be an optional query string parameter that\'ll contain the ID of the post that needs to be updated.\\r\\n    // If this is set, the post will be updated instead of being created.\\r\\n    const edit = query.get(\\"edit\\");\\r\\n    if (edit) {\\r\\n        const res = yield fetch(`${API}/posts/` + edit);\\r\\n        if (res.status === 404) {\\r\\n            const error = new Error(`The post with ID ${edit} was not found`);\\r\\n            return { status: 404, error };\\r\\n        }\\r\\n        else {\\r\\n            const data = yield res.json();\\r\\n            return {\\r\\n                props: {\\r\\n                    editId: edit,\\r\\n                    title: data.title,\\r\\n                    url: data.url,\\r\\n                    content: data.content,\\r\\n                    description: data.description,\\r\\n                },\\r\\n            };\\r\\n        }\\r\\n    }\\r\\n    return { props: {} };\\r\\n});\\r\\n<\/script>\\r\\n\\r\\n<script lang=\\"ts\\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\nimport { onMount } from \\"svelte\\";\\r\\nimport user from \\"$lib/user\\";\\r\\nimport { goto } from \\"$app/navigation\\";\\r\\nimport marked from \\"marked\\";\\r\\nexport let editId;\\r\\nexport let title = \\"\\";\\r\\nexport let description = \\"\\";\\r\\nexport let content = \\"\\";\\r\\nexport let url = \\"\\";\\r\\nonMount(() => {\\r\\n    if (!$user)\\r\\n        goto(\\"/login\\");\\r\\n});\\r\\n// To edit the post\\r\\nfunction editPost() {\\r\\n    var _a, _b, _c, _d;\\r\\n    return __awaiter(this, void 0, void 0, function* () {\\r\\n        if (!localStorage.getItem(\\"token\\")) {\\r\\n            goto(\\"/login\\");\\r\\n            return;\\r\\n        }\\r\\n        const res = yield fetch(`${API}/posts/` + editId, {\\r\\n            method: \\"PUT\\",\\r\\n            headers: {\\r\\n                \\"Content-Type\\": \\"application/json\\",\\r\\n                Accept: \\"application/json\\",\\r\\n                Authorization: \\"Bearer \\" + localStorage.getItem(\\"token\\"),\\r\\n            },\\r\\n            body: JSON.stringify({ title, description, content, url }),\\r\\n        });\\r\\n        if (!res.ok) {\\r\\n            const data = yield res.json();\\r\\n            if ((_d = (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data.message) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.messages) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.message) {\\r\\n                alert(data.message[0].messages[0].message);\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            const data = yield res.json();\\r\\n            goto(\\"/blog/\\" + data.id);\\r\\n        }\\r\\n    });\\r\\n}\\r\\nfunction createPost() {\\r\\n    var _a, _b, _c, _d;\\r\\n    return __awaiter(this, void 0, void 0, function* () {\\r\\n        if (!localStorage.getItem(\\"token\\")) {\\r\\n            goto(\\"/login\\");\\r\\n            return;\\r\\n        }\\r\\n        if (editId) {\\r\\n            // We\'re supposed to edit, not create\\r\\n            editPost();\\r\\n            return;\\r\\n        }\\r\\n        const res = yield fetch(`${API}/posts`, {\\r\\n            method: \\"POST\\",\\r\\n            headers: {\\r\\n                \\"Content-Type\\": \\"application/json\\",\\r\\n                Accept: \\"application/json\\",\\r\\n                Authorization: \\"Bearer \\" + localStorage.getItem(\\"token\\"),\\r\\n            },\\r\\n            body: JSON.stringify({ title, description, content, url }),\\r\\n        });\\r\\n        if (!res.ok) {\\r\\n            const data = yield res.json();\\r\\n            if ((_d = (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data.message) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.messages) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.message) {\\r\\n                alert(data.message[0].messages[0].message);\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            const data = yield res.json();\\r\\n            goto(\\"/blog/\\" + data.id);\\r\\n        }\\r\\n    });\\r\\n}\\r\\n$: mark = marked(content);\\r\\n<\/script>\\r\\n<svelte:head>\\r\\n  <title>{title}</title>\\r\\n</svelte:head>\\r\\n<div class=\\"md:flex\\">\\r\\n  <form\\r\\n    on:submit|preventDefault={createPost}\\r\\n    class=\\"my-4 mx-auto container p-4\\"\\r\\n  >\\r\\n    <div class=\\"my-1\\">\\r\\n      <label for=\\"title\\">Title</label>\\r\\n      <input\\r\\n        type=\\"text\\"\\r\\n        placeholder=\\"Enter title\\"\\r\\n        id=\\"title\\"\\r\\n        bind:value={title}\\r\\n      />\\r\\n    </div>\\r\\n    <div class=\\"my-1\\">\\r\\n      <label for=\\"url\\">Url</label>\\r\\n      <input type=\\"url\\" placeholder=\\"Enter Url\\" id=\\"url\\" bind:value={url} />\\r\\n    </div>\\r\\n    <div class=\\"my-1\\">\\r\\n      <label for=\\"description\\">Description</label>\\r\\n      <input\\r\\n        type=\\"text\\"\\r\\n        placeholder=\\"Enter description\\"\\r\\n        id=\\"description\\"\\r\\n        bind:value={description}\\r\\n      />\\r\\n    </div>\\r\\n    <div class=\\"my-1\\">\\r\\n      <label for=\\"title\\">Content</label>\\r\\n      <textarea\\r\\n        rows={5}\\r\\n        placeholder=\\"Enter content\\"\\r\\n        id=\\"content\\"\\r\\n        bind:value={content}\\r\\n      />\\r\\n    </div>\\r\\n    <div class=\\"my-2\\">\\r\\n      <button class=\\"submit\\" type=\\"submit\\">Submit</button>\\r\\n    </div>\\r\\n  </form>\\r\\n  <div class=\\"prose md:prose-md w-full\\">\\r\\n    {@html mark}\\r\\n  </div>\\r\\n</div>\\r\\n\\r\\n<style lang=\\"postcss\\">label{display:block;font-weight:700;margin-bottom:.25rem}input,textarea{--tw-border-opacity:1;--tw-bg-opacity:1;background-color:rgba(255,255,255,var(--tw-bg-opacity));border-color:rgba(107,114,128,var(--tw-border-opacity));border-radius:.25rem;border-width:1px;outline:2px solid transparent;outline-offset:2px;padding:.5rem 1rem;width:100%}textarea{resize:vertical}.submit{--tw-bg-opacity:1;--tw-text-opacity:1;background-color:rgba(59,130,246,var(--tw-bg-opacity));border-color:transparent;border-radius:.25rem;color:rgba(255,255,255,var(--tw-text-opacity));padding:.5rem 1rem}</style>\\r\\n"],"names":[],"mappings":"AA8KsB,oBAAK,CAAC,QAAQ,KAAK,CAAC,YAAY,GAAG,CAAC,cAAc,MAAM,CAAC,oBAAK,CAAC,uBAAQ,CAAC,oBAAoB,CAAC,CAAC,gBAAgB,CAAC,CAAC,iBAAiB,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC,aAAa,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,mBAAmB,CAAC,CAAC,CAAC,cAAc,MAAM,CAAC,aAAa,GAAG,CAAC,QAAQ,GAAG,CAAC,KAAK,CAAC,WAAW,CAAC,eAAe,GAAG,CAAC,QAAQ,KAAK,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,uBAAQ,CAAC,OAAO,QAAQ,CAAC,sBAAO,CAAC,gBAAgB,CAAC,CAAC,kBAAkB,CAAC,CAAC,iBAAiB,KAAK,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC,aAAa,WAAW,CAAC,cAAc,MAAM,CAAC,MAAM,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,iBAAiB,CAAC,CAAC,CAAC,QAAQ,KAAK,CAAC,IAAI,CAAC"}'
};
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var load$1 = ({ fetch: fetch2, page: { query } }) => __awaiter$1(void 0, void 0, void 0, function* () {
  const edit = query.get("edit");
  if (edit) {
    const res = yield fetch2(`${API}/posts/` + edit);
    if (res.status === 404) {
      const error2 = new Error(`The post with ID ${edit} was not found`);
      return { status: 404, error: error2 };
    } else {
      const data = yield res.json();
      return {
        props: {
          editId: edit,
          title: data.title,
          url: data.url,
          content: data.content,
          description: data.description
        }
      };
    }
  }
  return { props: {} };
});
var New = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let mark;
  let $$unsubscribe_user;
  $$unsubscribe_user = subscribe(user, (value) => value);
  (function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let { editId } = $$props;
  let { title = "" } = $$props;
  let { description = "" } = $$props;
  let { content = "" } = $$props;
  let { url = "" } = $$props;
  if ($$props.editId === void 0 && $$bindings.editId && editId !== void 0)
    $$bindings.editId(editId);
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.description === void 0 && $$bindings.description && description !== void 0)
    $$bindings.description(description);
  if ($$props.content === void 0 && $$bindings.content && content !== void 0)
    $$bindings.content(content);
  if ($$props.url === void 0 && $$bindings.url && url !== void 0)
    $$bindings.url(url);
  $$result.css.add(css);
  mark = (0, import_marked.default)(content);
  $$unsubscribe_user();
  return `



${$$result.head += `${$$result.title = `<title>${escape2(title)}</title>`, ""}`, ""}
<div class="${"md:flex"}"><form class="${"my-4 mx-auto container p-4"}"><div class="${"my-1"}"><label for="${"title"}" class="${"svelte-1gr50x2"}">Title</label>
      <input type="${"text"}" placeholder="${"Enter title"}" id="${"title"}" class="${"svelte-1gr50x2"}"${add_attribute("value", title, 0)}></div>
    <div class="${"my-1"}"><label for="${"url"}" class="${"svelte-1gr50x2"}">Url</label>
      <input type="${"url"}" placeholder="${"Enter Url"}" id="${"url"}" class="${"svelte-1gr50x2"}"${add_attribute("value", url, 0)}></div>
    <div class="${"my-1"}"><label for="${"description"}" class="${"svelte-1gr50x2"}">Description</label>
      <input type="${"text"}" placeholder="${"Enter description"}" id="${"description"}" class="${"svelte-1gr50x2"}"${add_attribute("value", description, 0)}></div>
    <div class="${"my-1"}"><label for="${"title"}" class="${"svelte-1gr50x2"}">Content</label>
      <textarea${add_attribute("rows", 5, 0)} placeholder="${"Enter content"}" id="${"content"}" class="${"svelte-1gr50x2"}">${content || ""}</textarea></div>
    <div class="${"my-2"}"><button class="${"submit svelte-1gr50x2"}" type="${"submit"}">Submit</button></div></form>
  <div class="${"prose md:prose-md w-full"}"><!-- HTML_TAG_START -->${mark}<!-- HTML_TAG_END --></div>
</div>`;
});
var _new = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": New,
  load: load$1
});
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var load = ({ page: { params }, fetch: fetch2 }) => __awaiter(void 0, void 0, void 0, function* () {
  const { slug } = params;
  const res = yield fetch2(`${API}/posts/` + slug);
  if (res.status === 404) {
    const error2 = new Error(`The post with ID ${slug} was not found`);
    return { status: 404, error: error2 };
  } else {
    const data = yield res.json();
    return { props: { post: data } };
  }
});
var U5Bslugu5D = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $user, $$unsubscribe_user;
  $$unsubscribe_user = subscribe(user, (value) => $user = value);
  (function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  let { post } = $$props;
  let content = post.content;
  if ($$props.post === void 0 && $$bindings.post && post !== void 0)
    $$bindings.post(post);
  $$unsubscribe_user();
  return `




${$$result.head += `<link rel="${"stylesheet"}" href="${"https://cdn.jsdelivr.net/npm/@tailwindcss/typography@0.4.x/dist/typography.min.css"}" data-svelte="svelte-1mlvvzv">`, ""}
<h1 class="${"text-center text-4xl mt-4"}">${escape2(post.title)}</h1>
<p class="${"text-center mt-2"}">By: ${escape2(post.author.username)}</p>

${$user && post.author.id === $user.id ? `<p class="${"my-2 flex justify-center items-center gap-3"}"><button class="${"bg-blue-500 text-white font-bold py-2 px-4 rounded border-transparent"}">Update post</button>
    <button class="${"bg-red-500 text-white font-bold py-2 px-4 rounded border-transparent"}">Delete post</button></p>` : ``}

<div class="${"border border-gray-500 my-4 mx-8 p-6 rounded "}"><div class="${"prose lg:prose-xl"}"><a${add_attribute("href", post.url, 0)}>${escape2(post.url)}</a>

    <!-- HTML_TAG_START -->${content}<!-- HTML_TAG_END --></div></div>`;
});
var _slug_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": U5Bslugu5D,
  load
});

// .svelte-kit/vercel/entry.js
init();
var entry_default = async (req, res) => {
  const { pathname, searchParams } = new URL(req.url || "", "http://localhost");
  let body;
  try {
    body = await getRawBody(req);
  } catch (err) {
    res.statusCode = err.status || 400;
    return res.end(err.reason || "Invalid request body");
  }
  const rendered = await render({
    method: req.method,
    headers: req.headers,
    path: pathname,
    query: searchParams,
    rawBody: body
  });
  if (rendered) {
    const { status, headers, body: body2 } = rendered;
    return res.writeHead(status, headers).end(body2);
  }
  return res.writeHead(404).end();
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
 * 1) Apply backwards compatible find/findOne behavior to sub documents
 *
 *    find logic:
 *      a) filter out non-documents
 *      b) remove _id from sub docs when user specified
 *
 *    findOne
 *      a) if no doc found, set to null
 *      b) remove _id from sub docs when user specified
 *
 * 2) Remove _ids when specified by users query.
 *
 * background:
 * _ids are left in the query even when user excludes them so
 * that population mapping can occur.
 */
/*!
 * @ignore
 */
/*!
 * @param {Schema} schema
 * @param {Object} doc POJO
 * @param {string} path
 */
/*!
 * @see exports.options
 */
/*!
 * A faster Array.prototype.slice.call(arguments) alternative
 * @api private
 */
/*!
 * A list of authentication mechanisms that don't require a password for authentication.
 * This is used by the authMechanismDoesNotRequirePassword method.
 *
 * @api private
 */
/*!
 * A query thunk is the function responsible for sending the query to MongoDB,
 * like `Query#_findOne()` or `Query#_execUpdate()`. The `Query#exec()` function
 * calls a thunk. The term "thunk" here is the traditional Node.js definition:
 * a function that takes exactly 1 parameter, a callback.
 *
 * This function defines common behavior for all query thunks.
 */
/*!
 * Adds the appropriate `$match` pipeline step to the top of an aggregate's
 * pipeline, should it's model is a non-root discriminator type. This is
 * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.
 *
 * @param {Aggregate} aggregate Aggregate to prepare
 */
/*!
 * Applies schema type transforms to `json`.
 *
 * @param {Document} self
 * @param {Object} json
 * @return {Object} `json`
 */
/*!
 * Applies setters without casting
 *
 * @api private
 */
/*!
 * Applies toObject recursively.
 *
 * @param {Document|Array|Object} obj
 * @return {Object}
 * @api private
 */
/*!
 * Applies virtuals properties to `json`.
 *
 * @param {Document} self
 * @param {Object} json
 * @return {Object} `json`
 */
/*!
 * Applies virtuals properties to `json`.
 */
/*!
 * Apply query middleware
 *
 * @param {Query} query constructor
 * @param {Model} model
 */
/*!
 * Apply the operation to the delta (update) clause as
 * well as track versioning for our where clause.
 *
 * @param {Document} self
 * @param {Object} where
 * @param {Object} delta
 * @param {Object} data
 * @param {Mixed} val
 * @param {String} [operation]
 */
/*!
 * Assign `vals` returned by mongo query to the `rawIds`
 * structure returned from utils.getVals() honoring
 * query sort order if specified by user.
 *
 * This can be optimized.
 *
 * Rules:
 *
 *   if the value of the path is not an array, use findOne rules, else find.
 *   for findOne the results are assigned directly to doc path (including null results).
 *   for find, if user specified sort order, results are assigned directly
 *   else documents are put back in original order of array if found in results
 *
 * @param {Array} rawIds
 * @param {Array} vals
 * @param {Boolean} sort
 * @api private
 */
/*!
 * Behaves like `Schema#path()`, except for it also digs into arrays without
 * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.
 */
/*!
 * Browser doc exposes the event emitter API
 */
/*!
 * Casts `val` according to `schema` and atomic `op`.
 *
 * @param {SchemaType} schema
 * @param {Object} val
 * @param {String} op - the atomic operator ($pull, $set, etc)
 * @param {String} $conditional
 * @param {Query} context
 * @api private
 */
/*!
 * Casts an update op based on the given schema
 *
 * @param {Schema} schema
 * @param {Object} obj
 * @param {Object} options
 * @param {Boolean} [options.overwrite] defaults to false
 * @param {Boolean|String} [options.strict] defaults to true
 * @param {Query} context passed to setters
 * @return {Boolean} true iff the update is non-empty
 */
/*!
 * Casts obj for an update command.
 *
 * @param {Object} obj
 * @return {Object} obj after casting its values
 * @api private
 */
/*!
 * Casts val to an object suitable for `$text`. Throws an error if the object
 * can't be casted.
 *
 * @param {Any} val value to cast
 * @param {String} [path] path to associate with any errors that occured
 * @return {Object} casted object
 * @see https://docs.mongodb.com/manual/reference/operator/query/text/
 * @api private
 */
/*!
 * Centralize this so we can more easily work around issues with people
 * stubbing out `process.nextTick()` in tests using sinon:
 * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time
 * See gh-6074
 */
/*!
 * Checks for indexes added to subdocs using Schema.index().
 * These indexes need their paths prefixed properly.
 *
 * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
 */
/*!
 * Checks to see if at least one path is in the states passed in via `arguments`
 * e.g., this.some('required', 'inited')
 *
 * @param {String} state that we want to check for.
 * @private
 */
/*!
 * Collection
 */
/*!
 * Collection the model uses.
 *
 * @property collection
 * @api public
 * @memberOf Model
 */
/*!
 * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`
 * because they need to do the same thing
 */
/*!
 * Compile other Buffer methods marking this buffer as modified.
 */
/*!
 * Compiled middleware for this model. Set in `applyHooks()`.
 *
 * @api private
 * @property _middleware
 * @memberOf Model
 * @static
 */
/*!
 * Compiler utility.
 *
 * @param {String|Function} name model name or class extending Model
 * @param {Schema} schema
 * @param {String} collectionName
 * @param {Connection} connection
 * @param {Mongoose} base mongoose instance
 */
/*!
 * Compiles an update and where clause for a `val` with _atomics.
 *
 * @param {Document} self
 * @param {Object} where
 * @param {Object} delta
 * @param {Object} data
 * @param {Array} value
 */
/*!
 * Compiles schemas.
 */
/*!
 * Connection
 */
/*!
 * Connection instance the model uses.
 *
 * @property db
 * @api public
 * @memberOf Model
 */
/*!
 * Connection states
 */
/*!
 * Convert a raw doc into a full mongoose doc.
 */
/*!
 * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
 *
 * @param {Object} object
 * @api private
 */
/*!
 * Converts arguments to ReadPrefs the driver
 * can understand.
 *
 * @param {String|Array} pref
 * @param {Array} [tags]
 */
/*!
 * Converts to POJO when you use the document for querying
 */
/*!
 * Copy the collection methods and make them subject to queues
 */
/*!
 * Create virtual properties with alias field
 */
/*!
 * Date Query casting.
 *
 * @api private
 */
/*!
 * Debug print helper
 */
/*!
 * Decorate buffers
 */
/*!
 * Decorate the update with a version key, if necessary
 */
/*!
 * Defines the accessor named prop on the incoming prototype.
 */
/*!
 * Dependencies
 */
/*!
 * Determine if `obj` is something we can set a populated path to. Can be a
 * document, a lean document, or an array/map that contains docs.
 */
/*!
 * Determine if `val` is null or undefined
 *
 * @return {Boolean}
 */
/*!
 * Determine if array was populated with some form of filter and is now
 * being updated in a manner which could overwrite data unintentionally.
 *
 * @see https://github.com/Automattic/mongoose/issues/1334
 * @param {Document} doc
 * @param {String} path
 * @return {String|undefined}
 */
/*!
 * Determines if `a` and `b` are deep equal.
 *
 * Modified from node/lib/assert.js
 *
 * @param {any} a a value to compare to `b`
 * @param {any} b a value to compare to `a`
 * @return {Boolean}
 * @api private
 */
/*!
 * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,
 * `arg` must be an object but not an instance of any special class, like String,
 * ObjectId, etc.
 *
 * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */
/*!
 * Determines if `arg` is an object.
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */
/*!
 * Determines if `obj` is a built-in object like an array, date, boolean,
 * etc.
 */
/*!
 * Determines if `path` is excluded by `projection`
 *
 * @param {Object} projection
 * @param {string} path
 * @return {Boolean}
 */
/*!
 * Determines if `val` is an object that has no own keys
 */
/*!
 * Determines if two buffers are equal.
 *
 * @param {Buffer} a
 * @param {Object} b
 */
/*!
 * Determines whether versioning should be skipped for the given path
 *
 * @param {Document} self
 * @param {String} path
 * @return {Boolean} true if versioning should be skipped for the given path
 */
/*!
 * Document exposes the NodeJS event emitter API, so you can use
 * `on`, `once`, etc.
 */
/*!
 * Export
 */
/*!
 * Exports
 */
/*!
 * Exports.
 */
/*!
 * Find the correct constructor, taking into account discriminators
 */
/*!
 * Flattens an array.
 *
 * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
 *
 * @param {Array} arr
 * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsy value, the item will not be included in the results.
 * @return {Array}
 * @private
 */
/*!
 * Format `mod.match` given that it may be an array that we need to $or if
 * the client has multiple docs with match functions
 */
/*!
 * Formats error messages
 */
/*!
 * Gather all indexes defined in the schema, including single nested,
 * document arrays, and embedded discriminators.
 */
/*!
 * Generates a random string
 *
 * @api private
 */
/*!
 * Get options from query opts, falling back to the base mongoose object.
 */
/*!
 * Get the bson type, if it exists
 */
/*!
 * Get the error to throw for `orFail()`
 */
/*!
 * Get the last element of an array
 */
/*!
 * Get the next doc from the underlying cursor and mongooseify it
 * (populate, etc.)
 */
/*!
 * Getter for convenience with populate, see gh-6115
 */
/*!
 * Give the constructor the ability to emit events.
 */
/*!
 * Given a model and a bulkWrite op, return a thunk that handles casting and
 * validating the individual op.
 */
/*!
 * Given a model and an array of docs, hydrates all the docs to be instances
 * of the model. Used to initialize docs returned from the db from `find()`
 *
 * @param {Model} model
 * @param {Array} docs
 * @param {Object} fields the projection used, including `select` from schemas
 * @param {Object} userProvidedFields the user-specified projection
 * @param {Object} opts
 * @param {Array} [opts.populated]
 * @param {ClientSession} [opts.session]
 * @param {Function} callback
 */
/*!
 * Given a value, cast it to a boolean, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {Boolean|null|undefined}
 * @throws {CastError} if `value` is not one of the allowed values
 * @api private
 */
/*!
 * Given a value, cast it to a number, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {Boolean|null|undefined}
 * @throws {Error} if `value` is not one of the allowed values
 * @api private
 */
/*!
 * Given a value, cast it to a string, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {string|null|undefined}
 * @throws {CastError}
 * @api private
 */
/*!
 * Handle async validators
 */
/*!
 * Handle the `WriteOpResult` from the server
 */
/*!
 * Helper for JSON.stringify
 * Ensure `name` and `message` show up in toJSON output re: gh-9847
 */
/*!
 * Helpers
 */
/*!
 * If populating a path within a document array, make sure each
 * subdoc within the array knows its subpaths are populated.
 *
 * ####Example:
 *     const doc = await Article.findOne().populate('comments.author');
 *     doc.comments[0].populated('author'); // Should be set
 */
/*!
 * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,
 * it returns an instance of the given model.
 *
 * @param {Model}  model
 * @param {Object} doc
 * @param {Object} fields
 *
 * @return {Document}
 */
/*!
 * If the model is a discriminator type and not root, then add the key & value to the criteria.
 */
/*!
 * If this is a document array, each element may contain single
 * populated paths, so we need to modify the top-level document's
 * populated cache. See gh-8247, gh-8265.
 */
/*!
 * Ignore
 */
/*!
 * Inherit from Buffer.
 */
/*!
 * Inherit from Document
 */
/*!
 * Inherit from EventEmitter
 */
/*!
 * Inherit from EventEmitter.
 */
/*!
 * Inherit from abstract Collection.
 */
/*!
 * Inherit from the NodeJS document
 */
/*!
 * Inherits from ArrayType.
 */
/*!
 * Inherits from Connection.
 */
/*!
 * Inherits from Document.
 *
 * All Model.prototype features are available on
 * top level (non-sub) documents.
 */
/*!
 * Inherits from SchemaType.
 */
/*!
 * Init helper.
 *
 * @param {Object} self document instance
 * @param {Object} obj raw mongodb doc
 * @param {Object} doc object we are initializing
 * @api private
 */
/*!
 * Internal helper for update, updateMany, updateOne
 */
/*!
 * Internal helper for update, updateMany, updateOne, replaceOne
 */
/*!
 * Internal switch for runSetters
 *
 * @api private
 */
/*!
 * Internal thunk around `deleteMany()`
 */
/*!
 * Internal thunk for .replaceOne()
 *
 * @param {Function} callback
 * @see Model.replaceOne #model_Model.replaceOne
 * @api private
 */
/*!
 * Internal thunk for .update()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
/*!
 * Internal thunk for .updateMany()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
/*!
 * Internal thunk for .updateOne()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
/*!
 * Internal thunk for `deleteOne()`
 */
/*!
 * Iterates over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @private
 */
/*!
 * Just like handleArray, except also allows `[]` because surprisingly
 * `$in: [1, []]` works fine
 */
/*!
 * Like `schema.path()`, except with a document, because impossible to
 * determine path type without knowing the embedded discriminator key.
 */
/*!
 * Make sure `this` is a model
 */
/*!
 * Maps over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @return {Array}
 * @private
 */
/*!
 * Marks this cursor as errored
 */
/*!
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param {Object} to
 * @param {Object} from
 * @api private
 */
/*!
 * Minimizes an object, removing undefined values and empty objects
 *
 * @param {Object} object to minimize
 * @return {Object}
 */
/*!
 * Module dependencies
 */
/*!
 * Module dependencies.
 */
/*!
 * Module exports
 */
/*!
 * Module exports.
 */
/*!
 * Module requirements
 */
/*!
 * Module requirements.
 */
/*!
 * Mongoose calls this function internally to validate the query if
 * `runValidators` is set
 *
 * @param {Object} castedDoc the update, after casting
 * @param {Object} options the options from `_optionsForExec()`
 * @param {Function} callback
 * @api private
 */
/*!
 * Necessary to satisfy the Readable API
 */
/*!
 * Object clone with Mongoose natives support.
 *
 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
 *
 * Functions are never cloned.
 *
 * @param {Object} obj the object to clone
 * @param {Object} options
 * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.
 * @return {Object} the cloned object
 * @api private
 */
/*!
 * Optionally filter out invalid ids that don't conform to foreign field's schema
 * to avoid cast errors (gh-7706)
 */
/*!
 * Override mquery.prototype._findAndModify to provide casting etc.
 *
 * @param {String} type - either "remove" or "update"
 * @param {Function} callback
 * @api private
 */
/*!
 * Override mquery.prototype._mergeUpdate to handle mongoose objects in
 * updates.
 *
 * @param {Object} doc
 * @api private
 */
/*!
 * Overwriting mquery is needed to support a couple different near() forms found in older
 * versions of mongoose
 * near([1,1])
 * near(1,1)
 * near(field, [1,2])
 * near(field, 1, 2)
 * In addition to all of the normal forms supported by mquery
 */
/*!
 * Permissions
 */
/*!
 * Pluralize function.
 *
 * @author TJ Holowaychuk (extracted from _ext.js_)
 * @param {String} string to pluralize
 * @api private
 */
/*!
 * Populate helper
 *
 * @param {Model} model the model to use
 * @param {Document|Array} docs Either a single document or array of documents to populate.
 * @param {Object} paths
 * @param {Function} [cb(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.
 * @return {Function}
 * @api private
 */
/*!
 * Populates `docs`
 */
/*!
 * Prepare a set of path options for query population.
 *
 * @param {Query} query
 * @param {Object} options
 * @return {Array}
 */
/*!
 * Prepare a set of path options for query population. This is the MongooseQuery
 * version
 *
 * @param {Query} query
 * @param {Object} options
 * @return {Array}
 */
/*!
 * Produces a collection name from model `name`. By default, just returns
 * the model name
 *
 * @param {String} name a model name
 * @param {Function} pluralize function that pluralizes the collection name
 * @return {String} a collection name
 * @api private
 */
/*!
 * Recursively set nested arrays
 */
/*!
 * Register custom query methods for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 */
/*!
 * Register hooks for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 */
/*!
 * Register listeners for important events and bubble appropriately.
 */
/*!
 * Register methods for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 */
/*!
 * Register statics for this model
 * @param {Model} model
 * @param {Schema} schema
 */
/*!
 * Registers remove event listeners for triggering
 * on subdocuments.
 *
 * @param {EmbeddedDocument} sub
 * @api private
 */
/*!
 * Registers remove event listeners for triggering
 * on subdocuments.
 *
 * @param {Subdocument} sub
 * @api private
 */
/*!
 * Remove _id from `subdoc` if user specified "lean" query option
 */
/*!
 * Removes duplicate values from an array
 *
 * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
 * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
 *    => [ObjectId("550988ba0c19d57f697dc45e")]
 *
 * @param {Array} arr
 * @return {Array}
 * @private
 */
/*!
 * Retrieve the _id of `val` if a Document or Array of Documents.
 *
 * @param {Array|Document|Any} val
 * @return {Array|Document|Any}
 */
/*!
 * Return the value of `obj` at the given `path`.
 *
 * @param {String} path
 * @param {Object} obj
 */
/*!
 * Returns an array of values from object `o`.
 *
 * @param {Object} o
 * @return {Array}
 * @private
 */
/*!
 * Returns if `v` is a mongoose object that has a `toObject()` method we can use.
 *
 * This is for compatibility with libs like Date.js which do foolish things to Natives.
 *
 * @param {any} v
 * @api private
 */
/*!
 * Returns the value passed to it.
 */
/*!
 * Returns this documents _id cast to a string.
 */
/*!
 * Returns true if `v` is an object that can be serialized as a primitive in
 * MongoDB
 */
/*!
 * Runs queued functions
 */
/*!
 * Safer helper for hasOwnProperty checks
 *
 * @param {Object} obj
 * @param {String} prop
 */
/*!
 * Scopes paths selected in a query to this array.
 * Necessary for proper default application of subdocument values.
 *
 * @param {DocumentArrayPath} array - the array to scope `fields` paths
 * @param {Object|undefined} fields - the root fields selected in the query
 * @param {Boolean|undefined} init - if we are being created part of a query result
 */
/*!
 * Search if `obj` or any POJOs nested underneath `obj` has a property named
 * `key`
 */
/*!
 * Set each path query option to lean
 *
 * @param {Object} option
 */
/*!
 * Sets the value of `obj` at the given `path`.
 *
 * @param {String} path
 * @param {Anything} val
 * @param {Object} obj
 */
/*!
 * Shallow copies defaults into options.
 *
 * @param {Object} defaults
 * @param {Object} options
 * @return {Object} the merged object
 * @api private
 */
/*!
 * Simplified lodash.get to work around the annoying null quirk. See:
 * https://github.com/lodash/lodash/issues/3659
 */
/*!
 * Since maps are stored as objects under the hood, keys must be strings
 * and can't contain any invalid characters
 */
/*!
 * Special case for when users use a common location schema to represent
 * locations for use with $geoWithin.
 * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/
 *
 * @param {Object} val
 * @api private
 */
/*!
 * StateMachine represents a minimal `interface` for the
 * constructors it builds via StateMachine.ctor(...).
 *
 * @api private
 */
/*!
 * StateMachine.ctor('state1', 'state2', ...)
 * A factory method for subclassing StateMachine.
 * The arguments are a list of states. For each state,
 * the constructor's prototype gets state transition
 * methods named after each state. These transition methods
 * place their path argument into the given state.
 *
 * @param {String} state
 * @param {String} [state]
 * @return {Function} subclass constructor
 * @private
 */
/*!
 * Subclass this model with `conn`, `schema`, and `collection` settings.
 *
 * @param {Connection} conn
 * @param {Schema} [schema]
 * @param {String} [collection]
 * @return {Model}
 */
/*!
 * Support the `new` option as an alternative to `returnOriginal` for backwards
 * compat.
 */
/*!
 * The class that Mongoose uses internally to instantiate this SchemaType's `options` property.
 */
/*!
 * The exports object is an instance of Mongoose.
 *
 * @api public
 */
/*!
 * The mongodb driver 1.3.23 only supports the nested array sort
 * syntax. We must convert it or sorting findAndModify will not work.
 */
/*!
 * The object used to define this validator. Not enumerable to hide
 * it from `require('util').inspect()` output re: gh-3925
 */
/*!
 * These operators require casting docs
 * to real Documents for Update operations.
 */
/*!
 * These operators should be cast to numbers instead
 * of their path schema type.
 */
/*!
 * These ops require no casting because the RHS doesn't do anything.
 */
/*!
 * This function builds the functions that get assigned to `forEach` and `map`,
 * since both of those methods share a lot of the same logic.
 *
 * @param {String} iterMethod is either 'forEach' or 'map'
 * @return {Function}
 * @api private
 */
/*!
 * This function is wrapped by the state change functions:
 *
 * - `require(path)`
 * - `modify(path)`
 * - `init(path)`
 *
 * @api private
 */
/*!
 * Thunk around findOneAndDelete()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */
/*!
 * Thunk around findOneAndRemove()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */
/*!
 * Thunk around findOneAndReplace()
 *
 * @param {Function} [callback]
 * @return {Query} this
 * @api private
 */
/*!
 * Thunk around findOneAndUpdate()
 *
 * @param {Function} [callback]
 * @api private
 */
/*!
 * Use native promises by default
 */
/*!
 * Valid mongoose options
 */
/*!
 * Walk each path of obj and cast its values
 * according to its schema.
 *
 * @param {Schema} schema
 * @param {Object} obj - part of a query
 * @param {String} op - the atomic operator ($pull, $set, etc)
 * @param {Object} options
 * @param {Boolean|String} [options.strict]
 * @param {Boolean} [options.omitUndefined]
 * @param {Query} context
 * @param {String} pref - path prefix (internal only)
 * @return {Bool} true if this path has keys to update
 * @api private
 */
/*!
 * Wraps `castForQuery` to handle context
 */
/*!
 * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
 * @constructor NodeMongoDbObjectId
 * @see ObjectId
 */
/*!
 * castDoc
 * @api private
 */
/*!
 * castQuery
 * @api private
 */
/*!
 * define methods
 */
/*!
 * exports
 */
/*!
 * gets discriminator model if discriminator key is present in object
 */
/*!
 * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
 *
 *     Thing.where('type').nin(array)
 */
/*!
 * hydrates a document
 *
 * @param {Model} model
 * @param {Document} doc
 * @param {Object} res 3rd parameter to callback
 * @param {Object} fields
 * @param {Query} self
 * @param {Array} [pop] array of paths used in population
 * @param {Function} callback
 */
/*!
 * ignore
 */
/*!
 * ignore. Deprecated re: #6405
 */
/*!
 * inherit mquery
 */
/*!
 * limit, skip, maxScan, batchSize, comment
 *
 * Sets these associated options.
 *
 *     query.comment('feed query');
 */
/*!
 * no-op for hooks
 */
/*!
 * populate helper
 */
/*!
 * process.nextTick helper.
 *
 * Wraps `callback` in a try/catch + nextTick.
 *
 * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
 *
 * @param {Function} callback
 * @api private
 */
/*!
 * this is needed to support the mongoose syntax of:
 * box(field, { ll : [x,y], ur : [x2,y2] })
 * box({ ll : [x,y], ur : [x2,y2] })
 */
/*!
* Avoid Node deprecation warning DEP0079
*/
/*!
* returns discriminator by discriminatorMapping.value
*
* @param {Model} model
* @param {string} value
*/
/*!
* returns discriminator by discriminatorMapping.value
*
* @param {Schema} schema
* @param {string} value
*/
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
